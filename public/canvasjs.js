/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 26);
/******/ })
/************************************************************************/
/******/ ({

/***/ 26:
/* all exports used */
/*!************************************!*\
  !*** ./src/client/app/CanvasJS.js ***!
  \************************************/
/***/ function(module, exports) {

"use strict";
eval("\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\r\n CanvasJS HTML5 & JavaScript Charts - v2.0.1 GA - https://canvasjs.com/ \r\n Copyright 2017 fenopix\r\n\r\n  --------------------- License Information --------------------\r\n CanvasJS is a commercial product which requires purchase of license. Without a commercial license you can use it for evaluation purposes for upto 30 days. Please refer to the following link for further details.\r\n     https://canvasjs.com/license-canvasjs/\r\n\r\n*/\n(function () {\n  function pa(m, s) {\n    m.prototype = $a(s.prototype);m.prototype.constructor = m;m.base = s.prototype;\n  }function $a(m) {\n    function s() {}s.prototype = m;return new s();\n  }function Ta(m, s, q) {\n    \"millisecond\" === q ? m.setMilliseconds(m.getMilliseconds() + 1 * s) : \"second\" === q ? m.setSeconds(m.getSeconds() + 1 * s) : \"minute\" === q ? m.setMinutes(m.getMinutes() + 1 * s) : \"hour\" === q ? m.setHours(m.getHours() + 1 * s) : \"day\" === q ? m.setDate(m.getDate() + 1 * s) : \"week\" === q ? m.setDate(m.getDate() + 7 * s) : \"month\" === q ? m.setMonth(m.getMonth() + 1 * s) : \"year\" === q && m.setFullYear(m.getFullYear() + 1 * s);return m;\n  }function ia(m, s) {\n    var q = !1;0 > m && (q = !0, m *= -1);m = \"\" + m;for (s = s ? s : 1; m.length < s;) {\n      m = \"0\" + m;\n    }return q ? \"-\" + m : m;\n  }function Ga(m) {\n    if (!m) return m;m = m.replace(/^\\s\\s*/, \"\");for (var s = /\\s/, q = m.length; s.test(m.charAt(--q));) {}return m.slice(0, q + 1);\n  }function Ca(m) {\n    m.roundRect = function (m, q, v, y, x, z, Q, C) {\n      Q && (this.fillStyle = Q);C && (this.strokeStyle = C);\"undefined\" === typeof x && (x = 5);this.lineWidth = z;this.beginPath();this.moveTo(m + x, q);this.lineTo(m + v - x, q);this.quadraticCurveTo(m + v, q, m + v, q + x);this.lineTo(m + v, q + y - x);this.quadraticCurveTo(m + v, q + y, m + v - x, q + y);this.lineTo(m + x, q + y);this.quadraticCurveTo(m, q + y, m, q + y - x);this.lineTo(m, q + x);this.quadraticCurveTo(m, q, m + x, q);this.closePath();Q && this.fill();C && 0 < z && this.stroke();\n    };\n  }function Pa(m, s) {\n    return m - s;\n  }function R(m) {\n    var s = ((m & 16711680) >> 16).toString(16),\n        q = ((m & 65280) >> 8).toString(16);m = ((m & 255) >> 0).toString(16);s = 2 > s.length ? \"0\" + s : s;q = 2 > q.length ? \"0\" + q : q;m = 2 > m.length ? \"0\" + m : m;return \"#\" + s + q + m;\n  }function ab(m, s) {\n    var q = this.length >>> 0,\n        v = Number(s) || 0,\n        v = 0 > v ? Math.ceil(v) : Math.floor(v);\n    for (0 > v && (v += q); v < q; v++) {\n      if (v in this && this[v] === m) return v;\n    }return -1;\n  }function y(m) {\n    return null === m || \"undefined\" === typeof m;\n  }function Da(m) {\n    m.indexOf || (m.indexOf = ab);return m;\n  }function bb(m) {\n    if (Z.fSDec) m[ka(\"`eeDwdouMhrudods\")](ka(\"e`u`@ohl`uhnoHuds`uhnoDoe\"), function () {\n      Z._fTWm && Z._fTWm(m);\n    });\n  }function Ua(m, s, q) {\n    q = q || \"normal\";var v = m + \"_\" + s + \"_\" + q,\n        y = Va[v];if (isNaN(y)) {\n      try {\n        m = \"position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;font-family:\" + m + \"; font-size:\" + s + \"px; font-weight:\" + q + \";\";if (!ra) {\n          var x = document.body;ra = document.createElement(\"span\");ra.innerHTML = \"\";var z = document.createTextNode(\"Mpgyi\");ra.appendChild(z);x.appendChild(ra);\n        }ra.style.display = \"\";ra.setAttribute(\"style\", m);y = Math.round(ra.offsetHeight);ra.style.display = \"none\";\n      } catch (Q) {\n        y = Math.ceil(1.1 * s);\n      }y = Math.max(y, s);Va[v] = y;\n    }return y;\n  }function G(m, s) {\n    var q = [];if (q = { solid: [], shortDash: [3, 1], shortDot: [1, 1], shortDashDot: [3, 1, 1, 1], shortDashDotDot: [3, 1, 1, 1, 1, 1], dot: [1, 2], dash: [4, 2], dashDot: [4, 2, 1, 2], longDash: [8, 2], longDashDot: [8, 2, 1, 2], longDashDotDot: [8, 2, 1, 2, 1, 2] }[m || \"solid\"]) for (var v = 0; v < q.length; v++) {\n      q[v] *= s;\n    } else q = [];return q;\n  }function N(m, s, q, v) {\n    return m.addEventListener ? (m.addEventListener(s, q, v || !1), q) : m.attachEvent ? (v = function v(s) {\n      s = s || window.event;s.preventDefault = s.preventDefault || function () {\n        s.returnValue = !1;\n      };s.stopPropagation = s.stopPropagation || function () {\n        s.cancelBubble = !0;\n      };q.call(m, s);\n    }, m.attachEvent(\"on\" + s, v), v) : !1;\n  }function Wa(m, s, q) {\n    m *= ha;s *= ha;m = q.getImageData(m, s, 2, 2).data;s = !0;for (q = 0; 4 > q; q++) {\n      if (m[q] !== m[q + 4] | m[q] !== m[q + 8] | m[q] !== m[q + 12]) {\n        s = !1;break;\n      }\n    }return s ? m[0] << 16 | m[1] << 8 | m[2] : 0;\n  }function na(m, s, q) {\n    return m in s ? s[m] : q[m];\n  }function Ha(m, s, q) {\n    if (v && Xa) {\n      var y = m.getContext(\"2d\");La = y.webkitBackingStorePixelRatio || y.mozBackingStorePixelRatio || y.msBackingStorePixelRatio || y.oBackingStorePixelRatio || y.backingStorePixelRatio || 1;ha = Qa / La;m.width = s * ha;m.height = q * ha;Qa !== La && (m.style.width = s + \"px\", m.style.height = q + \"px\", y.scale(ha, ha));\n    } else m.width = s, m.height = q;\n  }function cb(m) {\n    if (!Ya) {\n      var s = !1,\n          q = !1;\"undefined\" === typeof sa.Chart.creditHref ? (m.creditHref = ka(\"iuuqr;..b`ow`rkr/bnl.\"), m.creditText = ka(\"B`ow`rKR/bnl\")) : (s = m.updateOption(\"creditText\"), q = m.updateOption(\"creditHref\"));if (m.creditHref && m.creditText) {\n        m._creditLink || (m._creditLink = document.createElement(\"a\"), m._creditLink.setAttribute(\"class\", \"canvasjs-chart-credit\"), m._creditLink.setAttribute(\"style\", \"outline:none;margin:0px;position:absolute;right:2px;top:\" + (m.height - 14) + \"px;color:dimgrey;text-decoration:none;font-size:11px;font-family: Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif\"), m._creditLink.setAttribute(\"tabIndex\", -1), m._creditLink.setAttribute(\"target\", \"_blank\"));if (0 === m.renderCount || s || q) m._creditLink.setAttribute(\"href\", m.creditHref), m._creditLink.innerHTML = m.creditText;m._creditLink && m.creditHref && m.creditText ? (m._creditLink.parentElement || m._canvasJSContainer.appendChild(m._creditLink), m._creditLink.style.top = m.height - 14 + \"px\") : m._creditLink.parentElement && m._canvasJSContainer.removeChild(m._creditLink);\n      }\n    }\n  }function ua(m, s) {\n    var q = document.createElement(\"canvas\");q.setAttribute(\"class\", \"canvasjs-chart-canvas\");Ha(q, m, s);v || \"undefined\" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(q);return q;\n  }function qa(m, s, q) {\n    for (var v in q) {\n      s.style[v] = q[v];\n    }\n  }function va(m, s, q) {\n    s.getAttribute(\"state\") || (s.style.backgroundColor = m.toolbar.backgroundColor, s.style.color = m.toolbar.fontColor, s.style.border = \"none\", qa(m, s, { WebkitUserSelect: \"none\", MozUserSelect: \"none\", msUserSelect: \"none\", userSelect: \"none\" }));s.getAttribute(\"state\") !== q && (s.setAttribute(\"state\", q), s.setAttribute(\"type\", \"button\"), qa(m, s, { padding: \"5px 12px\", cursor: \"pointer\", \"float\": \"left\", width: \"40px\", height: \"25px\", outline: \"0px\", verticalAlign: \"baseline\", lineHeight: \"0\" }), s.setAttribute(\"title\", m._cultureInfo[q + \"Text\"]), s.innerHTML = \"<img style='height:95%;' src='\" + db[q].image + \"' alt='\" + m._cultureInfo[q + \"Text\"] + \"' />\");\n  }function Ma() {\n    for (var m = null, s = 0; s < arguments.length; s++) {\n      m = arguments[s], m.style && (m.style.display = \"inline\");\n    }\n  }function wa() {\n    for (var m = null, s = 0; s < arguments.length; s++) {\n      (m = arguments[s]) && m.style && (m.style.display = \"none\");\n    }\n  }\n  function X(m, s, q, v, x) {\n    this._defaultsKey = m;this._themeOptionsKey = s;this._index = v;this.parent = x;this._eventListeners = [];m = {};this.theme && y(s) && y(v) ? m = y(ya[this.theme]) ? ya.light1 : ya[this.theme] : this.parent && this.parent.themeOptions && this.parent.themeOptions[s] && (null === v ? m = this.parent.themeOptions[s] : 0 < this.parent.themeOptions[s].length && (v = Math.min(this.parent.themeOptions[s].length - 1, v), m = this.parent.themeOptions[s][v]));this.themeOptions = m;this.options = q ? q : { _isPlaceholder: !0 };this.setOptions(this.options, m);\n  }function Ea(m, s, q, v, y) {\n    \"undefined\" === typeof y && (y = 0);this._padding = y;this._x1 = m;this._y1 = s;this._x2 = q;this._y2 = v;this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;\n  }function la(m, s) {\n    la.base.constructor.call(this, \"TextBlock\", null, s, null, null);this.ctx = m;this._isDirty = !0;this._wrappedText = null;this._initialize();\n  }function Ra(m, s) {\n    Ra.base.constructor.call(this, \"Toolbar\", \"toolbar\", s, null, m);this.chart = m;this.canvas = m.canvas;this.ctx = this.chart.ctx;this.optionsName = \"toolbar\";\n  }function Ia(m, s) {\n    Ia.base.constructor.call(this, \"Title\", \"title\", s, null, m);this.chart = m;this.canvas = m.canvas;this.ctx = this.chart.ctx;this.optionsName = \"title\";if (y(this.options.margin) && m.options.subtitles) for (var q = m.options.subtitles, v = 0; v < q.length; v++) {\n      if ((y(q[v].horizontalAlign) && \"center\" === this.horizontalAlign || q[v].horizontalAlign === this.horizontalAlign) && (y(q[v].verticalAlign) && \"top\" === this.verticalAlign || q[v].verticalAlign === this.verticalAlign) && !q[v].dockInsidePlotArea === !this.dockInsidePlotArea) {\n        this.margin = 0;break;\n      }\n    }\"undefined\" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));this.height = this.width = null;this.bounds = { x1: null, y1: null, x2: null, y2: null };\n  }function Na(m, s, q) {\n    Na.base.constructor.call(this, \"Subtitle\", \"subtitles\", s, q, m);this.chart = m;this.canvas = m.canvas;this.ctx = this.chart.ctx;this.optionsName = \"subtitles\";this.isOptionsInArray = !0;\"undefined\" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));this.height = this.width = null;\n    this.bounds = { x1: null, y1: null, x2: null, y2: null };\n  }function Ja(m) {\n    var s;m && Ka[m] && (s = Ka[m]);Ja.base.constructor.call(this, \"CultureInfo\", null, s, null, null);\n  }var Z = {},\n      v = !!document.createElement(\"canvas\").getContext,\n      sa = { Chart: { width: 500, height: 400, zoomEnabled: !1, zoomType: \"x\", backgroundColor: \"white\", theme: \"light1\", animationEnabled: !1, animationDuration: 1200, dataPointWidth: null, dataPointMinWidth: null, dataPointMaxWidth: null, colorSet: \"colorSet1\", culture: \"en\", creditHref: \"\", creditText: \"CanvasJS\", interactivityEnabled: !0,\n      exportEnabled: !1, exportFileName: \"Chart\", rangeChanging: null, rangeChanged: null, publicProperties: { title: \"readWrite\", subtitles: \"readWrite\", toolbar: \"readWrite\", toolTip: \"readWrite\", legend: \"readWrite\", axisX: \"readWrite\", axisY: \"readWrite\", axisX2: \"readWrite\", axisY2: \"readWrite\", data: \"readWrite\", options: \"readWrite\", bounds: \"readOnly\", container: \"readOnly\" } }, Title: { padding: 0, text: null, verticalAlign: \"top\", horizontalAlign: \"center\", fontSize: 20, fontFamily: \"Calibri\", fontWeight: \"normal\", fontColor: \"black\", fontStyle: \"normal\",\n      borderThickness: 0, borderColor: \"black\", cornerRadius: 0, backgroundColor: v ? \"transparent\" : null, margin: 5, wrap: !0, maxWidth: null, dockInsidePlotArea: !1, publicProperties: { options: \"readWrite\", bounds: \"readOnly\", chart: \"readOnly\" } }, Subtitle: { padding: 0, text: null, verticalAlign: \"top\", horizontalAlign: \"center\", fontSize: 14, fontFamily: \"Calibri\", fontWeight: \"normal\", fontColor: \"black\", fontStyle: \"normal\", borderThickness: 0, borderColor: \"black\", cornerRadius: 0, backgroundColor: null, margin: 2, wrap: !0, maxWidth: null, dockInsidePlotArea: !1,\n      publicProperties: { options: \"readWrite\", bounds: \"readOnly\", chart: \"readOnly\" } }, Toolbar: { backgroundColor: \"white\", backgroundColorOnHover: \"#2196f3\", borderColor: \"#2196f3\", borderThickness: 1, fontColor: \"black\", fontColorOnHover: \"white\", publicProperties: { options: \"readWrite\", chart: \"readOnly\" } }, Legend: { name: null, verticalAlign: \"center\", horizontalAlign: \"right\", fontSize: 14, fontFamily: \"calibri\", fontWeight: \"normal\", fontColor: \"black\", fontStyle: \"normal\", cursor: null, itemmouseover: null, itemmouseout: null, itemmousemove: null,\n      itemclick: null, dockInsidePlotArea: !1, reversed: !1, backgroundColor: v ? \"transparent\" : null, borderColor: v ? \"transparent\" : null, borderThickness: 0, cornerRadius: 0, maxWidth: null, maxHeight: null, markerMargin: null, itemMaxWidth: null, itemWidth: null, itemWrap: !0, itemTextFormatter: null, publicProperties: { options: \"readWrite\", bounds: \"readOnly\", chart: \"readOnly\" } }, ToolTip: { enabled: !0, shared: !1, animationEnabled: !0, content: null, contentFormatter: null, reversed: !1, backgroundColor: v ? \"rgba(255,255,255,.9)\" : \"rgb(255,255,255)\", borderColor: null,\n      borderThickness: 2, cornerRadius: 5, fontSize: 14, fontColor: \"black\", fontFamily: \"Calibri, Arial, Georgia, serif;\", fontWeight: \"normal\", fontStyle: \"italic\", publicProperties: { options: \"readWrite\", chart: \"readOnly\" } }, Axis: { minimum: null, maximum: null, viewportMinimum: null, viewportMaximum: null, interval: null, intervalType: null, reversed: !1, logarithmic: !1, logarithmBase: 10, title: null, titleFontColor: \"black\", titleFontSize: 20, titleFontFamily: \"arial\", titleFontWeight: \"normal\", titleFontStyle: \"normal\", titleWrap: !0, titleMaxWidth: null,\n      titleBackgroundColor: v ? \"transparent\" : null, titleBorderColor: v ? \"transparent\" : null, titleBorderThickness: 0, titleCornerRadius: 0, labelAngle: 0, labelFontFamily: \"arial\", labelFontColor: \"black\", labelFontSize: 12, labelFontWeight: \"normal\", labelFontStyle: \"normal\", labelAutoFit: !0, labelWrap: !0, labelMaxWidth: null, labelFormatter: null, labelBackgroundColor: v ? \"transparent\" : null, labelBorderColor: v ? \"transparent\" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelPlacement: \"outside\", prefix: \"\", suffix: \"\", includeZero: !0, tickLength: 5,\n      tickColor: \"black\", tickThickness: 1, lineColor: \"black\", lineThickness: 1, lineDashType: \"solid\", gridColor: \"A0A0A0\", gridThickness: 0, gridDashType: \"solid\", interlacedColor: v ? \"transparent\" : null, valueFormatString: null, margin: 2, publicProperties: { options: \"readWrite\", stripLines: \"readWrite\", scaleBreaks: \"readWrite\", crosshair: \"readWrite\", bounds: \"readOnly\", chart: \"readOnly\" } }, StripLine: { value: null, startValue: null, endValue: null, color: \"orange\", opacity: null, thickness: 2, lineDashType: \"solid\", label: \"\", labelPlacement: \"inside\",\n      labelAlign: \"far\", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: null, labelBorderColor: v ? \"transparent\" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: \"arial\", labelFontColor: \"orange\", labelFontSize: 12, labelFontWeight: \"normal\", labelFontStyle: \"normal\", labelFormatter: null, showOnTop: !1, publicProperties: { options: \"readWrite\", axis: \"readOnly\", bounds: \"readOnly\", chart: \"readOnly\" } }, ScaleBreaks: { autoCalculate: !1, collapsibleThreshold: \"25%\", maxNumberOfAutoBreaks: 2, spacing: 8, type: \"straight\",\n      color: \"#FFFFFF\", fillOpacity: 0.9, lineThickness: 2, lineColor: \"#E16E6E\", lineDashType: \"solid\", publicProperties: { options: \"readWrite\", customBreaks: \"readWrite\", axis: \"readOnly\", autoBreaks: \"readOnly\", bounds: \"readOnly\", chart: \"readOnly\" } }, Break: { startValue: null, endValue: null, spacing: 8, type: \"straight\", color: \"#FFFFFF\", fillOpacity: 0.9, lineThickness: 2, lineColor: \"#E16E6E\", lineDashType: \"solid\", publicProperties: { options: \"readWrite\", scaleBreaks: \"readOnly\", bounds: \"readOnly\", chart: \"readOnly\" } }, Crosshair: { enabled: !1, snapToDataPoint: !1,\n      color: \"grey\", opacity: null, thickness: 2, lineDashType: \"solid\", label: \"\", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: v ? \"grey\" : null, labelBorderColor: v ? \"grey\" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: v ? \"Calibri, Optima, Candara, Verdana, Geneva, sans-serif\" : \"calibri\", labelFontSize: 12, labelFontColor: \"#fff\", labelFontWeight: \"normal\", labelFontStyle: \"normal\", labelFormatter: null, valueFormatString: null, publicProperties: { options: \"readWrite\", axis: \"readOnly\", bounds: \"readOnly\", chart: \"readOnly\" } },\n    DataSeries: { name: null, dataPoints: null, label: \"\", bevelEnabled: !1, highlightEnabled: !0, cursor: \"default\", indexLabel: \"\", indexLabelPlacement: \"auto\", indexLabelOrientation: \"horizontal\", indexLabelFontColor: \"black\", indexLabelFontSize: 12, indexLabelFontStyle: \"normal\", indexLabelFontFamily: \"Arial\", indexLabelFontWeight: \"normal\", indexLabelBackgroundColor: null, indexLabelLineColor: \"gray\", indexLabelLineThickness: 1, indexLabelLineDashType: \"solid\", indexLabelMaxWidth: null, indexLabelWrap: !0, indexLabelFormatter: null, lineThickness: 2,\n      lineDashType: \"solid\", connectNullData: !1, nullDataLineDashType: \"dash\", color: null, lineColor: null, risingColor: \"white\", fallingColor: \"red\", fillOpacity: null, startAngle: 0, radius: null, innerRadius: null, neckHeight: null, neckWidth: null, reversed: !1, valueRepresents: null, linkedDataSeriesIndex: null, whiskerThickness: 2, whiskerDashType: \"solid\", whiskerColor: null, whiskerLength: null, stemThickness: 2, stemColor: null, stemDashType: \"solid\", upperBoxColor: \"white\", lowerBoxColor: \"white\", type: \"column\", xValueType: \"number\", axisXType: \"primary\",\n      axisYType: \"primary\", axisXIndex: 0, axisYIndex: 0, xValueFormatString: null, yValueFormatString: null, zValueFormatString: null, percentFormatString: null, showInLegend: null, legendMarkerType: null, legendMarkerColor: null, legendText: null, legendMarkerBorderColor: v ? \"transparent\" : null, legendMarkerBorderThickness: 0, markerType: \"circle\", markerColor: null, markerSize: null, markerBorderColor: v ? \"transparent\" : null, markerBorderThickness: 0, mouseover: null, mouseout: null, mousemove: null, click: null, toolTipContent: null, visible: !0, publicProperties: { options: \"readWrite\",\n        axisX: \"readWrite\", axisY: \"readWrite\", chart: \"readOnly\" } }, TextBlock: { x: 0, y: 0, width: null, height: null, maxWidth: null, maxHeight: null, padding: 0, angle: 0, text: \"\", horizontalAlign: \"center\", fontSize: 12, fontFamily: \"calibri\", fontWeight: \"normal\", fontColor: \"black\", fontStyle: \"normal\", borderThickness: 0, borderColor: \"black\", cornerRadius: 0, backgroundColor: null, textBaseline: \"top\" }, CultureInfo: { decimalSeparator: \".\", digitGroupSeparator: \",\", zoomText: \"Zoom\", panText: \"Pan\", resetText: \"Reset\", menuText: \"More Options\", saveJPGText: \"Save as JPEG\",\n      savePNGText: \"Save as PNG\", printText: \"Print\", days: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), shortDays: \"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"), months: \"January February March April May June July August September October November December\".split(\" \"), shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \") } },\n      Ka = { en: {} },\n      x = v ? \"Trebuchet MS, Helvetica, sans-serif\" : \"Arial\",\n      Fa = v ? \"Impact, Charcoal, sans-serif\" : \"Arial\",\n      Aa = { colorSet1: \"#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566\".split(\" \"),\n    colorSet2: \"#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C\".split(\" \"), colorSet3: \"#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970\".split(\" \") },\n      O,\n      ga,\n      T,\n      Y,\n      fa;ga = \"#333333\";T = \"#000000\";O = \"#666666\";fa = Y = \"#000000\";var aa = 20,\n      z = 14,\n      Sa = { colorSet: \"colorSet1\", backgroundColor: \"#FFFFFF\", title: { fontFamily: Fa, fontSize: 32, fontColor: ga, fontWeight: \"normal\", verticalAlign: \"top\",\n      margin: 5 }, subtitles: [{ fontFamily: Fa, fontSize: z, fontColor: ga, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }], data: [{ indexLabelFontFamily: x, indexLabelFontSize: z, indexLabelFontColor: ga, indexLabelFontWeight: \"normal\", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: ga, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: T, labelFontWeight: \"normal\", lineThickness: 1, lineColor: O, tickThickness: 1, tickColor: O, gridThickness: 0, gridColor: O, stripLines: [{ labelFontFamily: x,\n        labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: fa, color: Y, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisX2: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: ga, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z,\n      labelFontColor: T, labelFontWeight: \"normal\", lineThickness: 1, lineColor: O, tickThickness: 1, tickColor: O, gridThickness: 0, gridColor: O, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: fa, color: Y, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1,\n        lineDashType: \"solid\" } }], axisY: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: ga, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: T, labelFontWeight: \"normal\", lineThickness: 1, lineColor: O, tickThickness: 1, tickColor: O, gridThickness: 1, gridColor: O, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\",\n        labelBackgroundColor: fa, color: Y, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisY2: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: ga, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: T, labelFontWeight: \"normal\", lineThickness: 1, lineColor: O, tickThickness: 1, tickColor: O, gridThickness: 1, gridColor: O, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\",\n        labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: fa, color: Y, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], legend: { fontFamily: x, fontSize: 14, fontColor: ga, fontWeight: \"bold\", verticalAlign: \"bottom\", horizontalAlign: \"center\" }, toolTip: { fontFamily: x, fontSize: 14, fontStyle: \"normal\", cornerRadius: 0, borderThickness: 1 } };\n  T = ga = \"#F5F5F5\";O = \"#FFFFFF\";Y = \"#40BAF1\";fa = \"#F5F5F5\";var aa = 20,\n      z = 14,\n      Za = { colorSet: \"colorSet2\", title: { fontFamily: x, fontSize: 33, fontColor: \"#3A3A3A\", fontWeight: \"bold\", verticalAlign: \"top\", margin: 5 }, subtitles: [{ fontFamily: x, fontSize: z, fontColor: \"#3A3A3A\", fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }], data: [{ indexLabelFontFamily: x, indexLabelFontSize: z, indexLabelFontColor: \"#666666\", indexLabelFontWeight: \"normal\", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: \"#666666\",\n      titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: \"#666666\", labelFontWeight: \"normal\", lineThickness: 1, lineColor: \"#BBBBBB\", tickThickness: 1, tickColor: \"#BBBBBB\", gridThickness: 1, gridColor: \"#BBBBBB\", stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FFA500\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FFA500\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: \"black\", color: \"black\",\n        thickness: 1, lineDashType: \"dot\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisX2: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: \"#666666\", titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: \"#666666\", labelFontWeight: \"normal\", lineThickness: 1, lineColor: \"#BBBBBB\", tickColor: \"#BBBBBB\", tickThickness: 1, gridThickness: 1, gridColor: \"#BBBBBB\", stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FFA500\", labelFontWeight: \"normal\",\n        labelBackgroundColor: null, color: \"#FFA500\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: \"black\", color: \"black\", thickness: 1, lineDashType: \"dot\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisY: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: \"#666666\", titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: \"#666666\", labelFontWeight: \"normal\",\n      lineThickness: 0, lineColor: \"#BBBBBB\", tickColor: \"#BBBBBB\", tickThickness: 1, gridThickness: 1, gridColor: \"#BBBBBB\", stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FFA500\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FFA500\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: \"black\", color: \"black\", thickness: 1, lineDashType: \"dot\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1,\n        lineDashType: \"solid\" } }], axisY2: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: \"#666666\", titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: \"#666666\", labelFontWeight: \"normal\", lineThickness: 0, lineColor: \"#BBBBBB\", tickColor: \"#BBBBBB\", tickThickness: 1, gridThickness: 1, gridColor: \"#BBBBBB\", stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FFA500\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FFA500\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z,\n        labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: \"black\", color: \"black\", thickness: 1, lineDashType: \"dot\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], legend: { fontFamily: x, fontSize: 14, fontColor: \"#3A3A3A\", fontWeight: \"bold\", verticalAlign: \"bottom\", horizontalAlign: \"center\" }, toolTip: { fontFamily: x, fontSize: 14, fontStyle: \"normal\", cornerRadius: 0, borderThickness: 1 } };T = ga = \"#F5F5F5\";O = \"#FFFFFF\";Y = \"#40BAF1\";fa = \"#F5F5F5\";aa = 20;z = 14;Fa = { colorSet: \"colorSet12\",\n    backgroundColor: \"#2A2A2A\", title: { fontFamily: Fa, fontSize: 32, fontColor: ga, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }, subtitles: [{ fontFamily: Fa, fontSize: z, fontColor: ga, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }], toolbar: { backgroundColor: \"#666666\", backgroundColorOnHover: \"#FF7372\", borderColor: \"#FF7372\", borderThickness: 1, fontColor: \"#F5F5F5\", fontColorOnHover: \"#F5F5F5\" }, data: [{ indexLabelFontFamily: x, indexLabelFontSize: z, indexLabelFontColor: T, indexLabelFontWeight: \"normal\", indexLabelLineThickness: 1 }],\n    axisX: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: T, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: T, labelFontWeight: \"normal\", lineThickness: 1, lineColor: O, tickThickness: 1, tickColor: O, gridThickness: 0, gridColor: O, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: fa,\n        color: Y, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisX2: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: T, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: T, labelFontWeight: \"normal\", lineThickness: 1, lineColor: O, tickThickness: 1, tickColor: O, gridThickness: 0, gridColor: O, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null,\n        color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: fa, color: Y, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisY: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: T, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: T, labelFontWeight: \"normal\", lineThickness: 1, lineColor: O, tickThickness: 1,\n      tickColor: O, gridThickness: 1, gridColor: O, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: fa, color: Y, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisY2: [{ titleFontFamily: x, titleFontSize: aa,\n      titleFontColor: T, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: T, labelFontWeight: \"normal\", lineThickness: 1, lineColor: O, tickThickness: 1, tickColor: O, gridThickness: 1, gridColor: O, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: fa, color: Y, thickness: 1, lineDashType: \"dash\" },\n      scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], legend: { fontFamily: x, fontSize: 14, fontColor: ga, fontWeight: \"bold\", verticalAlign: \"bottom\", horizontalAlign: \"center\" }, toolTip: { fontFamily: x, fontSize: 14, fontStyle: \"normal\", cornerRadius: 0, borderThickness: 1, fontColor: T, backgroundColor: \"rgba(0, 0, 0, .7)\" } };O = \"#FFFFFF\";T = ga = \"#FAFAFA\";Y = \"#40BAF1\";fa = \"#F5F5F5\";var aa = 20,\n      z = 14,\n      ya = { light1: Sa, light2: Za, dark1: Fa, dark2: { colorSet: \"colorSet2\", backgroundColor: \"#32373A\",\n      title: { fontFamily: x, fontSize: 32, fontColor: ga, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }, subtitles: [{ fontFamily: x, fontSize: z, fontColor: ga, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }], toolbar: { backgroundColor: \"#666666\", backgroundColorOnHover: \"#FF7372\", borderColor: \"#FF7372\", borderThickness: 1, fontColor: \"#F5F5F5\", fontColorOnHover: \"#F5F5F5\" }, data: [{ indexLabelFontFamily: x, indexLabelFontSize: z, indexLabelFontColor: T, indexLabelFontWeight: \"normal\", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: x,\n        titleFontSize: aa, titleFontColor: T, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: T, labelFontWeight: \"normal\", lineThickness: 1, lineColor: O, tickThickness: 1, tickColor: O, gridThickness: 0, gridColor: O, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: fa, color: Y, thickness: 1,\n          lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisX2: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: T, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: T, labelFontWeight: \"normal\", lineThickness: 1, lineColor: O, tickThickness: 1, tickColor: O, gridThickness: 0, gridColor: O, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null,\n          color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: fa, color: Y, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisY: [{ titleFontFamily: x, titleFontSize: aa, titleFontColor: T, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: T, labelFontWeight: \"normal\", lineThickness: 0, lineColor: O, tickThickness: 1,\n        tickColor: O, gridThickness: 1, gridColor: O, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: fa, color: Y, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisY2: [{ titleFontFamily: x, titleFontSize: aa,\n        titleFontColor: T, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: T, labelFontWeight: \"normal\", lineThickness: 0, lineColor: O, tickThickness: 1, tickColor: O, gridThickness: 1, gridColor: O, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: fa, color: Y, thickness: 1, lineDashType: \"dash\" },\n        scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], legend: { fontFamily: x, fontSize: 14, fontColor: ga, fontWeight: \"bold\", verticalAlign: \"bottom\", horizontalAlign: \"center\" }, toolTip: { fontFamily: x, fontSize: 14, fontStyle: \"normal\", cornerRadius: 0, borderThickness: 1, fontColor: T, backgroundColor: \"rgba(0, 0, 0, .7)\" } }, theme1: Sa, theme2: Za, theme3: Sa },\n      U = { numberDuration: 1, yearDuration: 314496E5, monthDuration: 2592E6, weekDuration: 6048E5, dayDuration: 864E5, hourDuration: 36E5,\n    minuteDuration: 6E4, secondDuration: 1E3, millisecondDuration: 1, dayOfWeekFromInt: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \") };(function () {\n    Z.fSDec = function (m) {\n      for (var s = \"\", q = 0; q < m.length; q++) {\n        s += String.fromCharCode(Math.ceil(m.length / 57 / 5) ^ m.charCodeAt(q));\n      }return s;\n    };Z.obj = { trVs: \"Ush`m!Wdsrhno\", fntStr: \"qy!B`mhcsh-!Mtbhe`!Fs`oed-!Mtbhe`!R`or!Tohbned-!@sh`m-!r`or,rdshg\", txtBl: \"udyuC`rdmhod\", fnt: \"gnou\", fSy: \"ghmmRuxmd\", fTx: \"ghmmUdyu\", grClr: \"fsdx\", cntx: \"buy\", tp: \"unq\" };delete sa[Z.fSDec(\"Bi`su\")][Z.fSDec(\"bsdehuIsdg\")];\n    Z.pro = { sCH: sa[Z.fSDec(\"Bi`su\")][Z.fSDec(\"bsdehuIsdg\")] };Z._fTWm = function (m) {\n      if (\"undefined\" === typeof Z.pro.sCH && !Ya) try {\n        var s = m[Z.fSDec(Z.obj.cntx)];s[Z.fSDec(Z.obj.txtBl)] = Z.fSDec(Z.obj.tp);s[Z.fSDec(Z.obj.fnt)] = 11 + Z.fSDec(Z.obj.fntStr);s[Z.fSDec(Z.obj.fSy)] = Z.fSDec(Z.obj.grClr);s[Z.fSDec(Z.obj.fTx)](Z.fSDec(Z.obj.trVs), 2, m.height - 11 - 2);\n      } catch (q) {}\n    };\n  })();var Va = {},\n      ra = null,\n      Ba = function () {\n    var m = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|\"[^\"]*\"|'[^']*'/g,\n        s = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        q = \"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"),\n        v = \"January February March April May June July August September October November December\".split(\" \"),\n        y = \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        x = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g,\n        z = /[^-+\\dA-Z]/g;return function (Q, C, P) {\n      var G = P ? P.days : s,\n          O = P ? P.months : v,\n          R = P ? P.shortDays : q,\n          N = P ? P.shortMonths : y;P = \"\";var U = !1;Q = Q && Q.getTime ? Q : Q ? new Date(Q) : new Date();\n      if (isNaN(Q)) throw SyntaxError(\"invalid date\");\"UTC:\" === C.slice(0, 4) && (C = C.slice(4), U = !0);P = U ? \"getUTC\" : \"get\";var Z = Q[P + \"Date\"](),\n          V = Q[P + \"Day\"](),\n          X = Q[P + \"Month\"](),\n          T = Q[P + \"FullYear\"](),\n          H = Q[P + \"Hours\"](),\n          W = Q[P + \"Minutes\"](),\n          a = Q[P + \"Seconds\"](),\n          f = Q[P + \"Milliseconds\"](),\n          b = U ? 0 : Q.getTimezoneOffset();return P = C.replace(m, function (c) {\n        switch (c) {case \"D\":\n            return Z;case \"DD\":\n            return ia(Z, 2);case \"DDD\":\n            return R[V];case \"DDDD\":\n            return G[V];case \"M\":\n            return X + 1;case \"MM\":\n            return ia(X + 1, 2);case \"MMM\":\n            return N[X];case \"MMMM\":\n            return O[X];\n          case \"Y\":\n            return parseInt(String(T).slice(-2));case \"YY\":\n            return ia(String(T).slice(-2), 2);case \"YYY\":\n            return ia(String(T).slice(-3), 3);case \"YYYY\":\n            return ia(T, 4);case \"h\":\n            return H % 12 || 12;case \"hh\":\n            return ia(H % 12 || 12, 2);case \"H\":\n            return H;case \"HH\":\n            return ia(H, 2);case \"m\":\n            return W;case \"mm\":\n            return ia(W, 2);case \"s\":\n            return a;case \"ss\":\n            return ia(a, 2);case \"f\":\n            return String(f).slice(0, 1);case \"ff\":\n            return ia(String(f).slice(0, 2), 2);case \"fff\":\n            return ia(String(f).slice(0, 3), 3);case \"t\":\n            return 12 > H ? \"a\" : \"p\";\n          case \"tt\":\n            return 12 > H ? \"am\" : \"pm\";case \"T\":\n            return 12 > H ? \"A\" : \"P\";case \"TT\":\n            return 12 > H ? \"AM\" : \"PM\";case \"K\":\n            return U ? \"UTC\" : (String(Q).match(x) || [\"\"]).pop().replace(z, \"\");case \"z\":\n            return (0 < b ? \"-\" : \"+\") + Math.floor(Math.abs(b) / 60);case \"zz\":\n            return (0 < b ? \"-\" : \"+\") + ia(Math.floor(Math.abs(b) / 60), 2);case \"zzz\":\n            return (0 < b ? \"-\" : \"+\") + ia(Math.floor(Math.abs(b) / 60), 2) + ia(Math.abs(b) % 60, 2);default:\n            return c.slice(1, c.length - 1);}\n      });\n    };\n  }(),\n      W = function W(m, s, q) {\n    if (null === m) return \"\";if (!isFinite(m)) return m;m = Number(m);var v = 0 > m ? !0 : !1;v && (m *= -1);var y = q ? q.decimalSeparator : \".\",\n        x = q ? q.digitGroupSeparator : \",\",\n        z = \"\";s = String(s);var z = 1,\n        Q = q = \"\",\n        C = -1,\n        P = [],\n        G = [],\n        O = 0,\n        R = 0,\n        U = 0,\n        N = !1,\n        Z = 0,\n        Q = s.match(/\"[^\"]*\"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\\u2030|./g);s = null;for (var V = 0; Q && V < Q.length; V++) {\n      if (s = Q[V], \".\" === s && 0 > C) C = V;else {\n        if (\"%\" === s) z *= 100;else if (\"\\u2030\" === s) {\n          z *= 1E3;continue;\n        } else if (\",\" === s[0] && \".\" === s[s.length - 1]) {\n          z /= Math.pow(1E3, s.length - 1);C = V + s.length - 1;continue;\n        } else \"E\" !== s[0] && \"e\" !== s[0] || \"0\" !== s[s.length - 1] || (N = !0);0 > C ? (P.push(s), \"#\" === s || \"0\" === s ? O++ : \",\" === s && U++) : (G.push(s), \"#\" !== s && \"0\" !== s || R++);\n      }\n    }N && (s = Math.floor(m), Q = -Math.floor(Math.log(m) / Math.LN10 + 1), Z = 0 === m ? 0 : 0 === s ? -(O + Q) : String(s).length - O, z /= Math.pow(10, Z));0 > C && (C = V);z = (m * z).toFixed(R);s = z.split(\".\");z = (s[0] + \"\").split(\"\");m = (s[1] + \"\").split(\"\");z && \"0\" === z[0] && z.shift();for (N = Q = V = R = C = 0; 0 < P.length;) {\n      if (s = P.pop(), \"#\" === s || \"0\" === s) {\n        if (C++, C === O) {\n          var X = z,\n              z = [];if (\"0\" === s) for (s = O - R - (X ? X.length : 0); 0 < s;) {\n            X.unshift(\"0\"), s--;\n          }for (; 0 < X.length;) {\n            q = X.pop() + q, N++, 0 === N % Q && V === U && 0 < X.length && (q = x + q);\n          }\n        } else 0 < z.length ? (q = z.pop() + q, R++, N++) : \"0\" === s && (q = \"0\" + q, R++, N++), 0 === N % Q && V === U && 0 < z.length && (q = x + q);\n      } else \"E\" !== s[0] && \"e\" !== s[0] || \"0\" !== s[s.length - 1] || !/[eE][+-]*[0]+/.test(s) ? \",\" === s ? (V++, Q = N, N = 0, 0 < z.length && (q = x + q)) : q = 1 < s.length && ('\"' === s[0] && '\"' === s[s.length - 1] || \"'\" === s[0] && \"'\" === s[s.length - 1]) ? s.slice(1, s.length - 1) + q : s + q : (s = 0 > Z ? s.replace(\"+\", \"\").replace(\"-\", \"\") : s.replace(\"-\", \"\"), q += s.replace(/[0]+/, function (m) {\n        return ia(Z, m.length);\n      }));\n    }x = \"\";for (P = !1; 0 < G.length;) {\n      s = G.shift(), \"#\" === s || \"0\" === s ? 0 < m.length && 0 !== Number(m.join(\"\")) ? (x += m.shift(), P = !0) : \"0\" === s && (x += \"0\", P = !0) : 1 < s.length && ('\"' === s[0] && '\"' === s[s.length - 1] || \"'\" === s[0] && \"'\" === s[s.length - 1]) ? x += s.slice(1, s.length - 1) : \"E\" !== s[0] && \"e\" !== s[0] || \"0\" !== s[s.length - 1] || !/[eE][+-]*[0]+/.test(s) ? x += s : (s = 0 > Z ? s.replace(\"+\", \"\").replace(\"-\", \"\") : s.replace(\"-\", \"\"), x += s.replace(/[0]+/, function (m) {\n        return ia(Z, m.length);\n      }));\n    }q += (P ? y : \"\") + x;return v ? \"-\" + q : q;\n  },\n      Oa = function Oa(m) {\n    var s = 0,\n        q = 0;m = m || window.event;m.offsetX || 0 === m.offsetX ? (s = m.offsetX, q = m.offsetY) : m.layerX || 0 == m.layerX ? (s = m.layerX, q = m.layerY) : (s = m.pageX - m.target.offsetLeft, q = m.pageY - m.target.offsetTop);return { x: s, y: q };\n  },\n      Xa = !0,\n      Qa = window.devicePixelRatio || 1,\n      La = 1,\n      ha = Xa ? Qa / La : 1,\n      ka = function ka(m) {\n    for (var s = \"\", q = 0; q < m.length; q++) {\n      s += String.fromCharCode(Math.ceil(m.length / 57 / 5) ^ m.charCodeAt(q));\n    }return s;\n  },\n      Ya = window && window[ka(\"mnb`uhno\")] && window[ka(\"mnb`uhno\")].href && window[ka(\"mnb`uhno\")].href.indexOf && (-1 !== window[ka(\"mnb`uhno\")].href.indexOf(ka(\"b`ow`rkr/bnl\")) || -1 !== window[ka(\"mnb`uhno\")].href.indexOf(ka(\"gdonqhy/bnl\")) || -1 !== window[ka(\"mnb`uhno\")].href.indexOf(ka(\"gheemd\"))),\n      db = { reset: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg==\" },\n    pan: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC\" },\n    zoom: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII=\" },\n    menu: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC\" } };\n  X.prototype.setOptions = function (m, s) {\n    if (sa[this._defaultsKey]) {\n      var q = sa[this._defaultsKey],\n          v;for (v in q) {\n        \"publicProperties\" !== v && q.hasOwnProperty(v) && (this[v] = m && v in m ? m[v] : s && v in s ? s[v] : q[v]);\n      }\n    }\n  };X.prototype.get = function (m) {\n    var s = sa[this._defaultsKey];if (\"options\" === m) return this.options && this.options._isPlaceholder ? null : this.options;if (s.hasOwnProperty(m) || s.publicProperties && s.publicProperties.hasOwnProperty(m)) return this[m];window.console && window.console.log('Property \"' + m + \"\\\" doesn't exist. Please check for typo.\");\n  };\n  X.prototype.set = function (m, s, q) {\n    q = \"undefined\" === typeof q ? !0 : q;var v = sa[this._defaultsKey];if (\"options\" === m) this.createUserOptions(s);else if (v.hasOwnProperty(m) || v.publicProperties && v.publicProperties.hasOwnProperty(m) && \"readWrite\" === v.publicProperties[m]) this.options._isPlaceholder && this.createUserOptions(), this.options[m] = s;else {\n      window.console && (v.publicProperties && v.publicProperties.hasOwnProperty(m) && \"readOnly\" === v.publicProperties[m] ? window.console.log('Property \"' + m + '\" is read-only.') : window.console.log('Property \"' + m + \"\\\" doesn't exist. Please check for typo.\"));return;\n    }q && (this.chart || this).render();\n  };X.prototype.addTo = function (m, s, q, v) {\n    v = \"undefined\" === typeof v ? !0 : v;var y = sa[this._defaultsKey];y.hasOwnProperty(m) || y.publicProperties && y.publicProperties.hasOwnProperty(m) && \"readWrite\" === y.publicProperties[m] ? (this.options._isPlaceholder && this.createUserOptions(), \"undefined\" === typeof this.options[m] && (this.options[m] = []), m = this.options[m], q = \"undefined\" === typeof q || null === q ? m.length : q, m.splice(q, 0, s), v && (this.chart || this).render()) : window.console && (y.publicProperties && y.publicProperties.hasOwnProperty(m) && \"readOnly\" === y.publicProperties[m] ? window.console.log('Property \"' + m + '\" is read-only.') : window.console.log('Property \"' + m + \"\\\" doesn't exist. Please check for typo.\"));\n  };X.prototype.createUserOptions = function (m) {\n    if (\"undefined\" !== typeof m || this.options._isPlaceholder) if (this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.isOptionsInArray) {\n      this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []);var s = this.parent.options[this.optionsName],\n          q = s.length;this.options._isPlaceholder || (Da(s), q = s.indexOf(this.options));this.options = \"undefined\" === typeof m ? {} : m;s[q] = this.options;\n    } else this.options = \"undefined\" === typeof m ? {} : m, m = this.parent.options, this.optionsName ? s = this.optionsName : (s = this._defaultsKey) && 0 !== s.length ? (q = s.charAt(0).toLowerCase(), 1 < s.length && (q = q.concat(s.slice(1))), s = q) : s = void 0, m[s] = this.options;\n  };X.prototype.remove = function (m) {\n    m = \"undefined\" === typeof m ? !0 : m;if (this.isOptionsInArray) {\n      var s = this.parent.options[this.optionsName];Da(s);var q = s.indexOf(this.options);0 <= q && s.splice(q, 1);\n    } else delete this.parent.options[this.optionsName];m && (this.chart || this).render();\n  };X.prototype.updateOption = function (m) {\n    var s = sa[this._defaultsKey],\n        q = {},\n        v = this[m],\n        x = this._themeOptionsKey,\n        z = this._index;this.theme && y(x) && y(z) ? q = y(ya[this.theme]) ? ya.light1 : ya[this.theme] : this.parent && this.parent.themeOptions && this.parent.themeOptions[x] && (null === z ? q = this.parent.themeOptions[x] : 0 < this.parent.themeOptions[x].length && (q = Math.min(this.parent.themeOptions[x].length - 1, z), q = this.parent.themeOptions[x][q]));this.themeOptions = q;m in s && (v = m in this.options ? this.options[m] : q && m in q ? q[m] : s[m]);if (v === this[m]) return !1;this[m] = v;return !0;\n  };X.prototype.trackChanges = function (m) {\n    if (!this.sessionVariables) throw \"Session Variable Store not set\";this.sessionVariables[m] = this.options[m];\n  };X.prototype.isBeingTracked = function (m) {\n    this.options._oldOptions || (this.options._oldOptions = {});return this.options._oldOptions[m] ? !0 : !1;\n  };X.prototype.hasOptionChanged = function (m) {\n    if (!this.sessionVariables) throw \"Session Variable Store not set\";return this.sessionVariables[m] !== this.options[m];\n  };X.prototype.addEventListener = function (m, s, v) {\n    m && s && (this._eventListeners[m] = this._eventListeners[m] || [], this._eventListeners[m].push({ context: v || this, eventHandler: s }));\n  };X.prototype.removeEventListener = function (m, s) {\n    if (m && s && this._eventListeners[m]) for (var v = this._eventListeners[m], y = 0; y < v.length; y++) {\n      if (v[y].eventHandler === s) {\n        v[y].splice(y, 1);break;\n      }\n    }\n  };X.prototype.removeAllEventListeners = function () {\n    this._eventListeners = [];\n  };X.prototype.dispatchEvent = function (m, s, v) {\n    if (m && this._eventListeners[m]) {\n      s = s || {};for (var y = this._eventListeners[m], x = 0; x < y.length; x++) {\n        y[x].eventHandler.call(y[x].context, s);\n      }\n    }\"function\" === typeof this[m] && this[m].call(v || this.chart, s);\n  };Ea.prototype.registerSpace = function (m, s) {\n    \"top\" === m ? this._topOccupied += s.height : \"bottom\" === m ? this._bottomOccupied += s.height : \"left\" === m ? this._leftOccupied += s.width : \"right\" === m && (this._rightOccupied += s.width);\n  };Ea.prototype.unRegisterSpace = function (m, s) {\n    \"top\" === m ? this._topOccupied -= s.height : \"bottom\" === m ? this._bottomOccupied -= s.height : \"left\" === m ? this._leftOccupied -= s.width : \"right\" === m && (this._rightOccupied -= s.width);\n  };Ea.prototype.getFreeSpace = function () {\n    return { x1: this._x1 + this._leftOccupied, y1: this._y1 + this._topOccupied, x2: this._x2 - this._rightOccupied, y2: this._y2 - this._bottomOccupied, width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied, height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied };\n  };Ea.prototype.reset = function () {\n    this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;\n  };pa(la, X);la.prototype._initialize = function () {\n    y(this.padding) || \"object\" !== _typeof(this.padding) ? this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = Number(this.padding) | 0 : (this.topPadding = y(this.padding.top) ? 0 : Number(this.padding.top) | 0, this.rightPadding = y(this.padding.right) ? 0 : Number(this.padding.right) | 0, this.bottomPadding = y(this.padding.bottom) ? 0 : Number(this.padding.bottom) | 0, this.leftPadding = y(this.padding.left) ? 0 : Number(this.padding.left) | 0);\n  };la.prototype.render = function (m) {\n    if (0 !== this.fontSize) {\n      m && this.ctx.save();var s = this.ctx.font;this.ctx.textBaseline = this.textBaseline;var v = 0;this._isDirty && this.measureText(this.ctx);this.ctx.translate(this.x, this.y + v);\"middle\" === this.textBaseline && (v = -this._lineHeight / 2);this.ctx.font = this._getFontString();this.ctx.rotate(Math.PI / 180 * this.angle);var y = 0,\n          x = this.topPadding,\n          z = null;this.ctx.roundRect || Ca(this.ctx);(0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(0, v, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);this.ctx.fillStyle = this.fontColor;for (v = 0; v < this._wrappedText.lines.length; v++) {\n        z = this._wrappedText.lines[v], \"right\" === this.horizontalAlign ? y = (this.width - (this.leftPadding + this.rightPadding)) / 2 - z.width / 2 + this.leftPadding : \"left\" === this.horizontalAlign ? y = this.leftPadding : \"center\" === this.horizontalAlign && (y = (this.width - (this.leftPadding + this.rightPadding)) / 2 - z.width / 2 + this.leftPadding), this.ctx.fillText(z.text, y, x), x += z.height;\n      }this.ctx.font = s;m && this.ctx.restore();\n    }\n  };la.prototype.setText = function (m) {\n    this.text = m;this._isDirty = !0;this._wrappedText = null;\n  };la.prototype.measureText = function () {\n    this._lineHeight = Ua(this.fontFamily, this.fontSize, this.fontWeight);if (null === this.maxWidth) throw \"Please set maxWidth and height for TextBlock\";this._wrapText(this.ctx);this._isDirty = !1;return { width: this.width, height: this.height };\n  };la.prototype._getLineWithWidth = function (m, s, v) {\n    m = String(m);if (!m) return { text: \"\",\n      width: 0 };var y = v = 0,\n        x = m.length - 1,\n        z = Infinity;for (this.ctx.font = this._getFontString(); y <= x;) {\n      var z = Math.floor((y + x) / 2),\n          G = m.substr(0, z + 1);v = this.ctx.measureText(G).width;if (v < s) y = z + 1;else if (v > s) x = z - 1;else break;\n    }v > s && 1 < G.length && (G = G.substr(0, G.length - 1), v = this.ctx.measureText(G).width);s = !0;if (G.length === m.length || \" \" === m[G.length]) s = !1;s && (m = G.split(\" \"), 1 < m.length && m.pop(), G = m.join(\" \"), v = this.ctx.measureText(G).width);return { text: G, width: v };\n  };la.prototype._wrapText = function () {\n    var m = new String(Ga(String(this.text))),\n        v = [],\n        q = this.ctx.font,\n        y = 0,\n        x = 0;this.ctx.font = this._getFontString();if (0 === this.frontSize) x = y = 0;else for (; 0 < m.length;) {\n      var z = this.maxHeight - (this.topPadding + this.bottomPadding),\n          G = this._getLineWithWidth(m, this.maxWidth - (this.leftPadding + this.rightPadding), !1);G.height = this._lineHeight;v.push(G);var Q = x,\n          x = Math.max(x, G.width),\n          y = y + G.height,\n          m = Ga(m.slice(G.text.length, m.length));z && y > z && (G = v.pop(), y -= G.height, x = Q);\n    }this._wrappedText = { lines: v, width: x, height: y };this.width = x + (this.leftPadding + this.rightPadding);\n    this.height = y + (this.topPadding + this.bottomPadding);this.ctx.font = q;\n  };la.prototype._getFontString = function () {\n    var m;m = \"\" + (this.fontStyle ? this.fontStyle + \" \" : \"\");m += this.fontWeight ? this.fontWeight + \" \" : \"\";m += this.fontSize ? this.fontSize + \"px \" : \"\";var s = this.fontFamily ? this.fontFamily + \"\" : \"\";!v && s && (s = s.split(\",\")[0], \"'\" !== s[0] && '\"' !== s[0] && (s = \"'\" + s + \"'\"));return m += s;\n  };pa(Ra, X);pa(Ia, X);Ia.prototype.render = function () {\n    if (this.text) {\n      var m = this.dockInsidePlotArea ? this.chart.plotArea : this.chart,\n          v = m.layoutManager.getFreeSpace(),\n          q = v.x1,\n          x = v.y1,\n          z = 0,\n          G = 0,\n          R = this.chart._menuButton && this.chart.exportEnabled && \"top\" === this.verticalAlign ? 22 : 0,\n          Q,\n          C;\"top\" === this.verticalAlign || \"bottom\" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = v.width - 4 - R * (\"center\" === this.horizontalAlign ? 2 : 1)), G = 0.5 * v.height - this.margin - 2, z = 0) : \"center\" === this.verticalAlign && (\"left\" === this.horizontalAlign || \"right\" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = v.height - 4), G = 0.5 * v.width - this.margin - 2) : \"center\" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = v.width - 4), G = 0.5 * v.height - 4));var P;y(this.padding) || \"number\" !== typeof this.padding ? y(this.padding) || \"object\" !== _typeof(this.padding) || (P = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, P += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0, P *= 1.25) : P = 2.5 * this.padding;this.wrap || (G = Math.min(G, Math.max(1.5 * this.fontSize, this.fontSize + P)));G = new la(this.ctx, { fontSize: this.fontSize, fontFamily: this.fontFamily, fontColor: this.fontColor,\n        fontStyle: this.fontStyle, fontWeight: this.fontWeight, horizontalAlign: this.horizontalAlign, verticalAlign: this.verticalAlign, borderColor: this.borderColor, borderThickness: this.borderThickness, backgroundColor: this.backgroundColor, maxWidth: this.maxWidth, maxHeight: G, cornerRadius: this.cornerRadius, text: this.text, padding: this.padding, textBaseline: \"top\" });P = G.measureText();\"top\" === this.verticalAlign || \"bottom\" === this.verticalAlign ? (\"top\" === this.verticalAlign ? (x = v.y1 + 2, C = \"top\") : \"bottom\" === this.verticalAlign && (x = v.y2 - 2 - P.height, C = \"bottom\"), \"left\" === this.horizontalAlign ? q = v.x1 + 2 : \"center\" === this.horizontalAlign ? q = v.x1 + v.width / 2 - P.width / 2 : \"right\" === this.horizontalAlign && (q = v.x2 - 2 - P.width - R), Q = this.horizontalAlign, this.width = P.width, this.height = P.height) : \"center\" === this.verticalAlign && (\"left\" === this.horizontalAlign ? (q = v.x1 + 2, x = v.y2 - 2 - (this.maxWidth / 2 - P.width / 2), z = -90, C = \"left\", this.width = P.height, this.height = P.width) : \"right\" === this.horizontalAlign ? (q = v.x2 - 2, x = v.y1 + 2 + (this.maxWidth / 2 - P.width / 2), z = 90, C = \"right\", this.width = P.height, this.height = P.width) : \"center\" === this.horizontalAlign && (x = m.y1 + (m.height / 2 - P.height / 2), q = m.x1 + (m.width / 2 - P.width / 2), C = \"center\", this.width = P.width, this.height = P.height), Q = \"center\");G.x = q;G.y = x;G.angle = z;G.horizontalAlign = Q;G.render(!0);m.layoutManager.registerSpace(C, { width: this.width + (\"left\" === C || \"right\" === C ? this.margin + 2 : 0), height: this.height + (\"top\" === C || \"bottom\" === C ? this.margin + 2 : 0) });this.bounds = { x1: q, y1: x, x2: q + this.width, y2: x + this.height };this.ctx.textBaseline = \"top\";\n    }\n  };pa(Na, X);Na.prototype.render = Ia.prototype.render;pa(Ja, X);x = { addTheme: function addTheme(m, v) {\n      ya[m] = v;\n    }, addColorSet: function addColorSet(m, v) {\n      Aa[m] = v;\n    }, addCultureInfo: function addCultureInfo(m, v) {\n      Ka[m] = v;\n    }, formatNumber: function formatNumber(m, v, q) {\n      q = q || \"en\";if (Ka[q]) return W(m, v || \"#,##0.##\", new Ja(q));throw \"Unknown Culture Name\";\n    }, formatDate: function formatDate(m, v, q) {\n      q = q || \"en\";if (Ka[q]) return Ba(m, v || \"DD MMM YYYY\", new Ja(q));throw \"Unknown Culture Name\";\n    } };window.CanvasJS = x;x.Chart = function () {\n    function m(a, f) {\n      return a.x - f.x;\n    }function s(a, f, b) {\n      if (a && f && b) {\n        b = b + \".\" + f;var c = \"image/\" + f;a = a.toDataURL(c);var e = !1,\n            g = document.createElement(\"a\");g.download = b;g.href = a;if (\"undefined\" !== typeof Blob && new Blob()) {\n          for (var h = a.replace(/^data:[a-z\\/]*;base64,/, \"\"), h = atob(h), l = new ArrayBuffer(h.length), l = new Uint8Array(l), t = 0; t < h.length; t++) {\n            l[t] = h.charCodeAt(t);\n          }f = new Blob([l.buffer], { type: \"image/\" + f });try {\n            window.navigator.msSaveBlob(f, b), e = !0;\n          } catch (k) {\n            g.dataset.downloadurl = [c, g.download, g.href].join(\":\"), g.href = window.URL.createObjectURL(f);\n          }\n        }if (!e) try {\n          event = document.createEvent(\"MouseEvents\"), event.initMouseEvent(\"click\", !0, !1, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), g.dispatchEvent ? g.dispatchEvent(event) : g.fireEvent && g.fireEvent(\"onclick\");\n        } catch (r) {\n          f = window.open(), f.document.write(\"<img src='\" + a + \"'></img><div>Please right click on the image and save it to your device</div>\"), f.document.close();\n        }\n      }\n    }function q(a, f) {\n      f = f || {};this.theme = y(f.theme) || y(ya[f.theme]) ? \"light1\" : f.theme;q.base.constructor.call(this, \"Chart\", null, f, null, null);var b = this;this._containerId = a;this._objectsInitialized = !1;this.overlaidCanvasCtx = this.ctx = null;this._indexLabels = [];this._panTimerId = 0;this._lastTouchEventType = \"\";this._lastTouchData = null;this.isAnimating = !1;this.renderCount = 0;this.panEnabled = this.disableToolTip = this.animatedRender = !1;this._defaultCursor = \"default\";this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 };this._dataInRenderedOrder = [];if (this.container = \"string\" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) {\n        this.container.innerHTML = \"\";var c = 0,\n            e = 0,\n            c = this.options.width ? this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width,\n            e = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height;this.width = c;this.height = e;this.x1 = this.y1 = 0;this.x2 = this.width;this.y2 = this.height;this._selectedColorSet = \"undefined\" !== typeof Aa[this.colorSet] ? Aa[this.colorSet] : Aa.colorSet1;this._canvasJSContainer = document.createElement(\"div\");this._canvasJSContainer.setAttribute(\"class\", \"canvasjs-chart-container\");this._canvasJSContainer.style.position = \"relative\";this._canvasJSContainer.style.textAlign = \"left\";this._canvasJSContainer.style.cursor = \"auto\";v || (this._canvasJSContainer.style.height = \"0px\");this.container.appendChild(this._canvasJSContainer);this.canvas = ua(c, e);this._preRenderCanvas = ua(c, e);this.canvas.style.position = \"absolute\";this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext(\"2d\"), this.ctx.textBaseline = \"top\", Ca(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext(\"2d\"), this._preRenderCtx.textBaseline = \"top\", Ca(this._preRenderCtx), v ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = ua(c, e), this.plotArea.canvas.style.position = \"absolute\", this.plotArea.canvas.setAttribute(\"class\", \"plotAreaCanvas\"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext(\"2d\")), this.overlaidCanvas = ua(c, e), this.overlaidCanvas.style.position = \"absolute\", this.overlaidCanvas.style.webkitTapHighlightColor = \"transparent\", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext(\"2d\"), this.overlaidCanvasCtx.textBaseline = \"top\", Ca(this.overlaidCanvasCtx)), this._eventManager = new fa(this), this.windowResizeHandler = N(window, \"resize\", function () {\n          b._updateSize() && b.render();\n        }), this._toolBar = document.createElement(\"div\"), this._toolBar.setAttribute(\"class\", \"canvasjs-chart-toolbar\"), this._toolBar.style.cssText = \"position: absolute; right: 1px; top: 1px;\", this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, N(this.overlaidCanvas, \"click\", function (a) {\n          b._mouseEventHandler(a);\n        }), N(this.overlaidCanvas, \"mousemove\", function (a) {\n          b._mouseEventHandler(a);\n        }), N(this.overlaidCanvas, \"mouseup\", function (a) {\n          b._mouseEventHandler(a);\n        }), N(this.overlaidCanvas, \"mousedown\", function (a) {\n          b._mouseEventHandler(a);wa(b._dropdownMenu);\n        }), N(this.overlaidCanvas, \"mouseout\", function (a) {\n          b._mouseEventHandler(a);\n        }), N(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerDown\" : \"touchstart\", function (a) {\n          b._touchEventHandler(a);\n        }), N(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerMove\" : \"touchmove\", function (a) {\n          b._touchEventHandler(a);\n        }), N(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerUp\" : \"touchend\", function (a) {\n          b._touchEventHandler(a);\n        }), N(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerCancel\" : \"touchcancel\", function (a) {\n          b._touchEventHandler(a);\n        }), this.toolTip = new Y(this, this.options.toolTip), this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = { axisX: [], axisX2: [], axisY: [], axisY2: [] });\n      } else window.console && window.console.log('CanvasJS Error: Chart Container with id \"' + this._containerId + '\" was not found');\n    }function x(a, f) {\n      for (var b = [], c, e = 0; e < a.length; e++) {\n        if (0 == e) b.push(a[0]);else {\n          var g, h, l;l = e - 1;g = 0 === l ? 0 : l - 1;h = l === a.length - 1 ? l : l + 1;c = Math.abs((a[h].x - a[g].x) / (0 === a[h].x - a[l].x ? 0.01 : a[h].x - a[l].x)) * (f - 1) / 2 + 1;var t = (a[h].x - a[g].x) / c;c = (a[h].y - a[g].y) / c;b[b.length] = a[l].x > a[g].x && 0 < t || a[l].x < a[g].x && 0 > t ? { x: a[l].x + t / 3, y: a[l].y + c / 3 } : { x: a[l].x, y: a[l].y + c / 9 };l = e;g = 0 === l ? 0 : l - 1;h = l === a.length - 1 ? l : l + 1;c = Math.abs((a[h].x - a[g].x) / (0 === a[l].x - a[g].x ? 0.01 : a[l].x - a[g].x)) * (f - 1) / 2 + 1;t = (a[h].x - a[g].x) / c;c = (a[h].y - a[g].y) / c;b[b.length] = a[l].x > a[g].x && 0 < t || a[l].x < a[g].x && 0 > t ? { x: a[l].x - t / 3, y: a[l].y - c / 3 } : { x: a[l].x, y: a[l].y - c / 9 };b[b.length] = a[e];\n        }\n      }return b;\n    }function z(a, f, b, c, e, g, h, l, t, k) {\n      var r = 0;k ? (h.color = g, l.color = g) : k = 1;r = t ? Math.abs(e - b) : Math.abs(c - f);r = 0 < h.trimLength ? Math.abs(r * h.trimLength / 100) : Math.abs(r - h.length);\n      t ? (b += r / 2, e -= r / 2) : (f += r / 2, c -= r / 2);var r = 1 === Math.round(h.thickness) % 2 ? 0.5 : 0,\n          p = 1 === Math.round(l.thickness) % 2 ? 0.5 : 0;a.save();a.globalAlpha = k;a.strokeStyle = l.color || g;a.lineWidth = l.thickness || 2;a.setLineDash && a.setLineDash(G(l.dashType, l.thickness));a.beginPath();t && 0 < l.thickness ? (a.moveTo(c - h.thickness / 2, Math.round((b + e) / 2) - p), a.lineTo(f + h.thickness / 2, Math.round((b + e) / 2) - p)) : 0 < l.thickness && (a.moveTo(Math.round((f + c) / 2) - p, b + h.thickness / 2), a.lineTo(Math.round((f + c) / 2) - p, e - h.thickness / 2));a.stroke();a.strokeStyle = h.color || g;a.lineWidth = h.thickness || 2;a.setLineDash && a.setLineDash(G(h.dashType, h.thickness));a.beginPath();t && 0 < h.thickness ? (a.moveTo(c - r, b), a.lineTo(c - r, e), a.moveTo(f + r, b), a.lineTo(f + r, e)) : 0 < h.thickness && (a.moveTo(f, b + r), a.lineTo(c, b + r), a.moveTo(f, e - r), a.lineTo(c, e - r));a.stroke();a.restore();\n    }function O(a, f, b, c, e) {\n      if (null === a || \"undefined\" === typeof a) return \"undefined\" === typeof b ? f : b;a = parseFloat(a.toString()) * (0 <= a.toString().indexOf(\"%\") ? f / 100 : 1);\"undefined\" !== typeof c && (a = Math.min(c, a), \"undefined\" !== typeof e && (a = Math.max(e, a)));return !isNaN(a) && a <= f && 0 <= a ? a : \"undefined\" === typeof b ? f : b;\n    }function T(a, f) {\n      T.base.constructor.call(this, \"Legend\", \"legend\", f, null, a);this.chart = a;this.canvas = a.canvas;this.ctx = this.chart.ctx;this.ghostCtx = this.chart._eventManager.ghostCtx;this.items = [];this.optionsName = \"legend\";this.height = this.width = 0;this.orientation = null;this.dataSeries = [];this.bounds = { x1: null, y1: null, x2: null, y2: null };\"undefined\" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));\n      this.lineHeight = Ua(this.fontFamily, this.fontSize, this.fontWeight);this.horizontalSpacing = this.fontSize;\n    }function Q(a, f, b, c) {\n      Q.base.constructor.call(this, \"DataSeries\", \"data\", f, b, a);this.chart = a;this.canvas = a.canvas;this._ctx = a.canvas.ctx;this.index = b;this.noDataPointsInPlotArea = 0;this.id = c;this.chart._eventManager.objectMap[c] = { id: c, objectType: \"dataSeries\", dataSeriesIndex: b };a = f.dataPoints ? f.dataPoints.length : 0;this.dataPointEOs = [];for (f = 0; f < a; f++) {\n        this.dataPointEOs[f] = {};\n      }this.dataPointIds = [];this.plotUnit = [];this.axisY = this.axisX = null;this.optionsName = \"data\";this.isOptionsInArray = !0;null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = 0.7 : this.fillOpacity = 1);this.axisPlacement = this.getDefaultAxisPlacement();\"undefined\" === typeof this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize));\n    }function C(a, f, b, c, e, g) {\n      C.base.constructor.call(this, \"Axis\", f, b, c, a);this.chart = a;this.canvas = a.canvas;this.ctx = a.ctx;this.intervalStartPosition = this.maxHeight = this.maxWidth = 0;this.labels = [];this.dataSeries = [];this._stripLineLabels = this._ticks = this._labels = null;this.dataInfo = { min: Infinity, max: -Infinity, viewPortMin: Infinity, viewPortMax: -Infinity, minDiff: Infinity };this.isOptionsInArray = !0;\"axisX\" === e ? (\"left\" === g || \"bottom\" === g ? (this.optionsName = \"axisX\", y(this.chart.sessionVariables.axisX[c]) && (this.chart.sessionVariables.axisX[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisX[c]) : (this.optionsName = \"axisX2\", y(this.chart.sessionVariables.axisX2[c]) && (this.chart.sessionVariables.axisX2[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[c]), this.options.interval || (this.intervalType = null)) : \"left\" === g || \"bottom\" === g ? (this.optionsName = \"axisY\", y(this.chart.sessionVariables.axisY[c]) && (this.chart.sessionVariables.axisY[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisY[c]) : (this.optionsName = \"axisY2\", y(this.chart.sessionVariables.axisY2[c]) && (this.chart.sessionVariables.axisY2[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[c]);\n      \"undefined\" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize));\"undefined\" === typeof this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize));this.type = e;\"axisX\" !== e || b && \"undefined\" !== typeof b.gridThickness || (this.gridThickness = 0);this._position = g;this.lineCoordinates = { x1: null, y1: null, x2: null, y2: null, width: null };this.labelAngle = (this.labelAngle % 360 + 360) % 360;90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360);this.options.scaleBreaks && (this.scaleBreaks = new P(this.chart, this.options.scaleBreaks, ++this.chart._eventManager.lastObjectId, this));this.stripLines = [];if (this.options.stripLines && 0 < this.options.stripLines.length) for (a = 0; a < this.options.stripLines.length; a++) {\n        this.stripLines.push(new ga(this.chart, this.options.stripLines[a], a, ++this.chart._eventManager.lastObjectId, this));\n      }this.options.crosshair && (this.crosshair = new ia(this.chart, this.options.crosshair, this));this._titleTextBlock = null;this.hasOptionChanged(\"viewportMinimum\") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null);this.hasOptionChanged(\"viewportMinimum\") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum;this.hasOptionChanged(\"viewportMaximum\") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null);this.hasOptionChanged(\"viewportMaximum\") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum;null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));this.trackChanges(\"viewportMinimum\");this.trackChanges(\"viewportMaximum\");\n    }function P(a, f, b, c) {\n      P.base.constructor.call(this, \"ScaleBreaks\", \"scaleBreaks\", f, null, c);this.id = b;this.chart = a;this.ctx = this.chart.ctx;this.axis = c;this.optionsName = \"scaleBreaks\";this.isOptionsInArray = !1;this._appliedBreaks = [];this.customBreaks = [];this.autoBreaks = [];\"string\" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + \"%\") : \"number\" !== typeof this.spacing && (this.spacing = 8);this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5));if (this.options.customBreaks && 0 < this.options.customBreaks.length) {\n        for (a = 0; a < this.options.customBreaks.length; a++) {\n          this.customBreaks.push(new aa(this.chart, \"customBreaks\", this.options.customBreaks[a], a, ++this.chart._eventManager.lastObjectId, this)), \"number\" === typeof this.customBreaks[a].startValue && \"number\" === typeof this.customBreaks[a].endValue && this.customBreaks[a].endValue !== this.customBreaks[a].startValue && this._appliedBreaks.push(this.customBreaks[a]);\n        }this._appliedBreaks.sort(function (a, c) {\n          return a.startValue - c.startValue;\n        });for (a = 0; a < this._appliedBreaks.length - 1; a++) {\n          this._appliedBreaks[a].endValue >= this._appliedBreaks[a + 1].startValue && (this._appliedBreaks[a].endValue = Math.max(this._appliedBreaks[a].endValue, this._appliedBreaks[a + 1].endValue), window.console && window.console.log(\"CanvasJS Error: Breaks \" + a + \" and \" + (a + 1) + \" are overlapping.\"), this._appliedBreaks.splice(a, 2), a--);\n        }\n      }\n    }function aa(a, f, b, c, e, g) {\n      aa.base.constructor.call(this, \"Break\", f, b, c, g);this.id = e;this.chart = a;this.ctx = this.chart.ctx;this.scaleBreaks = g;this.optionsName = f;this.isOptionsInArray = !0;this.type = b.type ? this.type : g.type;this.fillOpacity = y(b.fillOpacity) ? g.fillOpacity : this.fillOpacity;this.lineThickness = y(b.lineThickness) ? g.lineThickness : this.lineThickness;this.color = b.color ? this.color : g.color;this.lineColor = b.lineColor ? this.lineColor : g.lineColor;this.lineDashType = b.lineDashType ? this.lineDashType : g.lineDashType;!y(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime());!y(this.endValue) && this.endValue.getTime && (this.endValue = this.endValue.getTime());\"number\" === typeof this.startValue && \"number\" === typeof this.endValue && this.endValue < this.startValue && (a = this.startValue, this.startValue = this.endValue, this.endValue = a);this.spacing = \"undefined\" === typeof b.spacing ? g.spacing : b.spacing;\"string\" === typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + \"%\") : \"number\" !== typeof this.options.spacing && (this.spacing = g.spacing);this.size = g.parent.logarithmic ? 1 : 0;\n    }function ga(a, f, b, c, e) {\n      ga.base.constructor.call(this, \"StripLine\", \"stripLines\", f, b, e);this.id = c;this.chart = a;this.ctx = this.chart.ctx;this.label = this.label;this.axis = e;this.optionsName = \"stripLines\";this.isOptionsInArray = !0;this._thicknessType = \"pixel\";null !== this.startValue && null !== this.endValue && (this.value = e.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null);\n    }function ia(a, f, b) {\n      ia.base.constructor.call(this, \"Crosshair\", \"crosshair\", f, null, b);this.chart = a;this.ctx = this.chart.ctx;this.axis = b;this.optionsName = \"crosshair\";this._thicknessType = \"pixel\";\n    }\n    function Y(a, f) {\n      Y.base.constructor.call(this, \"ToolTip\", \"toolTip\", f, null, a);this.chart = a;this.canvas = a.canvas;this.ctx = this.chart.ctx;this.currentDataPointIndex = this.currentSeriesIndex = -1;this._timerId = 0;this._prevY = this._prevX = NaN;this.containerTransitionDuration = 0.1;this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration);this.optionsName = \"toolTip\";this._initialize();\n    }function fa(a) {\n      this.chart = a;this.lastObjectId = 0;this.objectMap = [];this.rectangularRegionEventSubscriptions = [];this.previousDataPointEventObject = null;this.ghostCanvas = ua(this.chart.width, this.chart.height);this.ghostCtx = this.ghostCanvas.getContext(\"2d\");this.mouseoveredObjectMaps = [];\n    }function ka(a) {\n      this.chart = a;this.ctx = this.chart.plotArea.ctx;this.animations = [];this.animationRequestId = null;\n    }pa(q, X);q.prototype.destroy = function () {\n      var a = window,\n          f = this.windowResizeHandler;a.removeEventListener ? a.removeEventListener(\"resize\", f) : a.detachEvent && a.detachEvent(\"onresize\", f);\n    };q.prototype._updateOptions = function () {\n      var a = this;this.updateOption(\"width\");this.updateOption(\"height\");this.updateOption(\"dataPointWidth\");this.updateOption(\"dataPointMinWidth\");this.updateOption(\"dataPointMaxWidth\");this.updateOption(\"interactivityEnabled\");this.updateOption(\"theme\");this.updateOption(\"colorSet\") && (this._selectedColorSet = \"undefined\" !== typeof Aa[this.colorSet] ? Aa[this.colorSet] : Aa.colorSet1);this.updateOption(\"backgroundColor\");this.backgroundColor || (this.backgroundColor = \"rgba(0,0,0,0)\");this.updateOption(\"culture\");this._cultureInfo = new Ja(this.options.culture);this.updateOption(\"animationEnabled\");this.animationEnabled = this.animationEnabled && v;this.updateOption(\"animationDuration\");this.updateOption(\"rangeChanging\");this.updateOption(\"rangeChanged\");this.updateOption(\"exportEnabled\");this.updateOption(\"exportFileName\");this.updateOption(\"zoomType\");if (this.options.zoomEnabled) {\n        if (!this._zoomButton) {\n          var f = !1;wa(this._zoomButton = document.createElement(\"button\"));va(this, this._zoomButton, \"pan\");this._toolBar.appendChild(this._zoomButton);\n          this._zoomButton.style.borderRight = this.toolbar.borderThickness + \"px solid \" + this.toolbar.borderColor;N(this._zoomButton, \"touchstart\", function (a) {\n            f = !0;\n          });N(this._zoomButton, \"click\", function () {\n            a.zoomEnabled ? (a.zoomEnabled = !1, a.panEnabled = !0, va(a, a._zoomButton, \"zoom\")) : (a.zoomEnabled = !0, a.panEnabled = !1, va(a, a._zoomButton, \"pan\"));a.render();\n          });N(this._zoomButton, \"mouseover\", function () {\n            f ? f = !1 : (qa(a, a._zoomButton, { backgroundColor: a.toolbar.backgroundColorOnHover, color: a.toolbar.fontColorOnHover, transition: \"0.4s\",\n              WebkitTransition: \"0.4s\" }), 0 >= navigator.userAgent.search(\"MSIE\") && qa(a, a._zoomButton.childNodes[0], { WebkitFilter: \"invert(100%)\", filter: \"invert(100%)\" }));\n          });N(this._zoomButton, \"mouseout\", function () {\n            f || (qa(a, a._zoomButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor, transition: \"0.4s\", WebkitTransition: \"0.4s\" }), 0 >= navigator.userAgent.search(\"MSIE\") && qa(a, a._zoomButton.childNodes[0], { WebkitFilter: \"invert(0%)\", filter: \"invert(0%)\" }));\n          });\n        }this._resetButton || (f = !1, wa(this._resetButton = document.createElement(\"button\")), va(this, this._resetButton, \"reset\"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + \"px solid \" + this.toolbar.borderColor, this._toolBar.appendChild(this._resetButton), N(this._resetButton, \"touchstart\", function (a) {\n          f = !0;\n        }), N(this._resetButton, \"click\", function () {\n          a.toolTip.hide();a.zoomEnabled || a.panEnabled ? (a.zoomEnabled = !0, a.panEnabled = !1, va(a, a._zoomButton, \"pan\"), a._defaultCursor = \"default\", a.overlaidCanvas.style.cursor = a._defaultCursor) : (a.zoomEnabled = !1, a.panEnabled = !1);if (a.sessionVariables.axisX) for (var c = 0; c < a.sessionVariables.axisX.length; c++) {\n            a.sessionVariables.axisX[c].newViewportMinimum = null, a.sessionVariables.axisX[c].newViewportMaximum = null;\n          }if (a.sessionVariables.axisX2) for (c = 0; c < a.sessionVariables.axisX2.length; c++) {\n            a.sessionVariables.axisX2[c].newViewportMinimum = null, a.sessionVariables.axisX2[c].newViewportMaximum = null;\n          }if (a.sessionVariables.axisY) for (c = 0; c < a.sessionVariables.axisY.length; c++) {\n            a.sessionVariables.axisY[c].newViewportMinimum = null, a.sessionVariables.axisY[c].newViewportMaximum = null;\n          }if (a.sessionVariables.axisY2) for (c = 0; c < a.sessionVariables.axisY2.length; c++) {\n            a.sessionVariables.axisY2[c].newViewportMinimum = null, a.sessionVariables.axisY2[c].newViewportMaximum = null;\n          }a.resetOverlayedCanvas();wa(a._zoomButton, a._resetButton);a._dispatchRangeEvent(\"rangeChanging\", \"reset\");a.render();a._dispatchRangeEvent(\"rangeChanged\", \"reset\");\n        }), N(this._resetButton, \"mouseover\", function () {\n          f || (qa(a, a._resetButton, { backgroundColor: a.toolbar.backgroundColorOnHover,\n            color: a.toolbar.hoverFfontColorOnHoverontColor, transition: \"0.4s\", WebkitTransition: \"0.4s\" }), 0 >= navigator.userAgent.search(\"MSIE\") && qa(a, a._resetButton.childNodes[0], { WebkitFilter: \"invert(100%)\", filter: \"invert(100%)\" }));\n        }), N(this._resetButton, \"mouseout\", function () {\n          f || (qa(a, a._resetButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor, transition: \"0.4s\", WebkitTransition: \"0.4s\" }), 0 >= navigator.userAgent.search(\"MSIE\") && qa(a, a._resetButton.childNodes[0], { WebkitFilter: \"invert(0%)\", filter: \"invert(0%)\" }));\n        }), this.overlaidCanvas.style.cursor = a._defaultCursor);this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute(\"state\") === a._cultureInfo.zoomText ? (this.panEnabled = !0, this.zoomEnabled = !1) : (this.zoomEnabled = !0, this.panEnabled = !1), Ma(a._zoomButton, a._resetButton)) : (this.zoomEnabled = !0, this.panEnabled = !1));\n      } else this.panEnabled = this.zoomEnabled = !1;this._menuButton ? this.exportEnabled ? Ma(this._menuButton) : wa(this._menuButton) : this.exportEnabled && v && (f = !1, this._menuButton = document.createElement(\"button\"), va(this, this._menuButton, \"menu\"), this._toolBar.appendChild(this._menuButton), N(this._menuButton, \"touchstart\", function (a) {\n        f = !0;\n      }), N(this._menuButton, \"click\", function () {\n        \"none\" !== a._dropdownMenu.style.display || a._dropDownCloseTime && 500 >= new Date().getTime() - a._dropDownCloseTime.getTime() || (a._dropdownMenu.style.display = \"block\", a._menuButton.blur(), a._dropdownMenu.focus());\n      }, !0), N(this._menuButton, \"mouseover\", function () {\n        f || (qa(a, a._menuButton, { backgroundColor: a.toolbar.backgroundColorOnHover, color: a.toolbar.fontColorOnHover }), 0 >= navigator.userAgent.search(\"MSIE\") && qa(a, a._menuButton.childNodes[0], { WebkitFilter: \"invert(100%)\", filter: \"invert(100%)\" }));\n      }, !0), N(this._menuButton, \"mouseout\", function () {\n        f || (qa(a, a._menuButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor }), 0 >= navigator.userAgent.search(\"MSIE\") && qa(a, a._menuButton.childNodes[0], { WebkitFilter: \"invert(0%)\", filter: \"invert(0%)\" }));\n      }, !0));if (!this._dropdownMenu && this.exportEnabled && v) {\n        f = !1;this._dropdownMenu = document.createElement(\"div\");this._dropdownMenu.setAttribute(\"tabindex\", -1);var b = -1 !== this.theme.indexOf(\"dark\") ? \"black\" : \"#888888\";this._dropdownMenu.style.cssText = \"position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 0px;top: 25px;min-width: 120px;outline: 0;font-size: 14px; font-family: Arial, Helvetica, sans-serif;padding: 5px 0px 5px 0px;text-align: left;line-height: 10px;background-color:\" + this.toolbar.backgroundColor + \";box-shadow: 2px 2px 10px \" + b;a._dropdownMenu.style.display = \"none\";\n        this._toolBar.appendChild(this._dropdownMenu);N(this._dropdownMenu, \"blur\", function () {\n          wa(a._dropdownMenu);a._dropDownCloseTime = new Date();\n        }, !0);b = document.createElement(\"div\");b.style.cssText = \"padding: 12px 8px 12px 8px\";b.innerHTML = this._cultureInfo.printText;b.style.backgroundColor = this.toolbar.backgroundColor;b.style.color = this.toolbar.fontColor;this._dropdownMenu.appendChild(b);N(b, \"touchstart\", function (a) {\n          f = !0;\n        });N(b, \"mouseover\", function () {\n          f || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover);\n        }, !0);N(b, \"mouseout\", function () {\n          f || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor);\n        }, !0);N(b, \"click\", function () {\n          a.print();wa(a._dropdownMenu);\n        }, !0);b = document.createElement(\"div\");b.style.cssText = \"padding: 12px 8px 12px 8px\";b.innerHTML = this._cultureInfo.saveJPGText;b.style.backgroundColor = this.toolbar.backgroundColor;b.style.color = this.toolbar.fontColor;this._dropdownMenu.appendChild(b);N(b, \"touchstart\", function (a) {\n          f = !0;\n        });N(b, \"mouseover\", function () {\n          f || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover);\n        }, !0);N(b, \"mouseout\", function () {\n          f || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor);\n        }, !0);N(b, \"click\", function () {\n          s(a.canvas, \"jpeg\", a.exportFileName);wa(a._dropdownMenu);\n        }, !0);b = document.createElement(\"div\");b.style.cssText = \"padding: 12px 8px 12px 8px\";b.innerHTML = this._cultureInfo.savePNGText;b.style.backgroundColor = this.toolbar.backgroundColor;\n        b.style.color = this.toolbar.fontColor;this._dropdownMenu.appendChild(b);N(b, \"touchstart\", function (a) {\n          f = !0;\n        });N(b, \"mouseover\", function () {\n          f || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover);\n        }, !0);N(b, \"mouseout\", function () {\n          f || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor);\n        }, !0);N(b, \"click\", function () {\n          s(a.canvas, \"png\", a.exportFileName);wa(a._dropdownMenu);\n        }, !0);\n      }\"none\" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? va(a, a._zoomButton, \"zoom\") : va(a, a._zoomButton, \"pan\"), a._resetButton.getAttribute(\"state\") !== a._cultureInfo.resetText && va(a, a._resetButton, \"reset\"));this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip);for (var c in this.toolTip.options) {\n        this.toolTip.options.hasOwnProperty(c) && this.toolTip.updateOption(c);\n      }\n    };q.prototype._updateSize = function () {\n      var a = 0,\n          f = 0;this.options.width ? a = this.width : this.width = a = 0 < this.container.clientWidth ? this.container.clientWidth : this.width;this.options.height ? f = this.height : this.height = f = 0 < this.container.clientHeight ? this.container.clientHeight : this.height;return this.canvas.width !== a * ha || this.canvas.height !== f * ha ? (Ha(this.canvas, a, f), Ha(this._preRenderCanvas, a, f), Ha(this.overlaidCanvas, a, f), Ha(this._eventManager.ghostCanvas, a, f), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, !0) : !1;\n    };q.prototype._initialize = function () {\n      this.toolbar = new Ra(this, this.options.toolbar);this._animator ? this._animator.cancelAllAnimations() : this._animator = new ka(this);this.removeAllEventListeners();this.disableToolTip = !1;this._axes = [];this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null;this.animationRequestId && this.cancelRequestAnimFrame.call(window, this.animationRequestId);this._updateOptions();this.animatedRender = v && this.animationEnabled && 0 === this.renderCount;this._updateSize();this.clearCanvas();this.ctx.beginPath();this.axisX = [];this.axisX2 = [];this.axisY = [];this.axisY2 = [];this._indexLabels = [];this._dataInRenderedOrder = [];this._events = [];this._eventManager && this._eventManager.reset();this.plotInfo = { axisPlacement: null, plotTypes: [] };this.layoutManager = new Ea(0, 0, this.width, this.height, 2);this.plotArea.layoutManager && this.plotArea.layoutManager.reset();this.data = [];var a = 0,\n          f = null;if (this.options.data) {\n        for (var b = 0; b < this.options.data.length; b++) {\n          if (a++, !this.options.data[b].type || 0 <= q._supportedChartTypes.indexOf(this.options.data[b].type)) {\n            var c = new Q(this, this.options.data[b], a - 1, ++this._eventManager.lastObjectId);\n            \"error\" === c.type && (c.linkedDataSeriesIndex = y(this.options.data[b].linkedDataSeriesIndex) ? b - 1 : this.options.data[b].linkedDataSeriesIndex, 0 > c.linkedDataSeriesIndex || c.linkedDataSeriesIndex >= this.options.data.length || \"number\" !== typeof c.linkedDataSeriesIndex || \"error\" === this.options.data[c.linkedDataSeriesIndex].type) && (c.linkedDataSeriesIndex = null);null === c.name && (c.name = \"DataSeries \" + a);null === c.color ? 1 < this.options.data.length ? (c._colorSet = [this._selectedColorSet[c.index % this._selectedColorSet.length]], c.color = this._selectedColorSet[c.index % this._selectedColorSet.length]) : c._colorSet = \"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"stackedArea\" === c.type || \"stackedArea100\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type || \"candlestick\" === c.type || \"ohlc\" === c.type || \"waterfall\" === c.type || \"boxAndWhisker\" === c.type ? [this._selectedColorSet[0]] : this._selectedColorSet : c._colorSet = [c.color];null === c.markerSize && ((\"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || 0 <= c.type.toLowerCase().indexOf(\"area\")) && c.dataPoints && c.dataPoints.length < this.width / 16 || \"scatter\" === c.type) && (c.markerSize = 8);\"bubble\" !== c.type && \"scatter\" !== c.type || !c.dataPoints || (c.dataPoints.some ? c.dataPoints.some(function (a) {\n              return a.x;\n            }) && c.dataPoints.sort(m) : c.dataPoints.sort(m));this.data.push(c);var e = c.axisPlacement,\n                f = f || e,\n                g;\"normal\" === e ? \"xySwapped\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with bar chart' : \"none\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = \"normal\") : \"xySwapped\" === e ? \"normal\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with line, area, column or pie chart' : \"none\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = \"xySwapped\") : \"none\" === e ? \"normal\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with line, area, column or bar chart' : \"xySwapped\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = \"none\") : null === e && \"none\" === this.plotInfo.axisPlacement && (g = 'You cannot combine \"' + c.type + '\" with pie chart');if (g && window.console) {\n              window.console.log(g);return;\n            }\n          }\n        }for (b = 0; b < this.data.length; b++) {\n          if (\"none\" == f && \"error\" === this.data[b].type && window.console) {\n            window.console.log('You cannot combine \"' + c.type + '\" with error chart');\n            return;\n          }\"error\" === this.data[b].type && (this.data[b].axisPlacement = this.plotInfo.axisPlacement = f || \"normal\", this.data[b]._linkedSeries = null === this.data[b].linkedDataSeriesIndex ? null : this.data[this.data[b].linkedDataSeriesIndex]);\n        }\n      }this._objectsInitialized = !0;\n    };q._supportedChartTypes = Da(\"line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall\".split(\" \"));\n    q.prototype.render = function (a) {\n      a && (this.options = a);this._initialize();bb(this);cb(this);var f = [];for (a = 0; a < this.data.length; a++) {\n        if (\"normal\" === this.plotInfo.axisPlacement || \"xySwapped\" === this.plotInfo.axisPlacement) {\n          if (!this.data[a].axisYType || \"primary\" === this.data[a].axisYType) if (this.options.axisY && 0 < this.options.axisY.length) {\n            if (!this.axisY.length) for (var b = 0; b < this.options.axisY.length; b++) {\n              \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[b] = new C(this, \"axisY\", this.options.axisY[b], b, \"axisY\", \"left\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[b] = new C(this, \"axisY\", this.options.axisY[b], b, \"axisY\", \"bottom\"));\n            }this.data[a].axisY = this.axisY[0 <= this.data[a].axisYIndex && this.data[a].axisYIndex < this.axisY.length ? this.data[a].axisYIndex : 0];this.axisY[0 <= this.data[a].axisYIndex && this.data[a].axisYIndex < this.axisY.length ? this.data[a].axisYIndex : 0].dataSeries.push(this.data[a]);\n          } else this.axisY.length || (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new C(this, \"axisY\", this.options.axisY, 0, \"axisY\", \"left\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new C(this, \"axisY\", this.options.axisY, 0, \"axisY\", \"bottom\"))), this.data[a].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[a]);if (\"secondary\" === this.data[a].axisYType) if (this.options.axisY2 && 0 < this.options.axisY2.length) {\n            if (!this.axisY2.length) for (b = 0; b < this.options.axisY2.length; b++) {\n              \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[b] = new C(this, \"axisY2\", this.options.axisY2[b], b, \"axisY\", \"right\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[b] = new C(this, \"axisY2\", this.options.axisY2[b], b, \"axisY\", \"top\"));\n            }this.data[a].axisY = this.axisY2[0 <= this.data[a].axisYIndex && this.data[a].axisYIndex < this.axisY2.length ? this.data[a].axisYIndex : 0];this.axisY2[0 <= this.data[a].axisYIndex && this.data[a].axisYIndex < this.axisY2.length ? this.data[a].axisYIndex : 0].dataSeries.push(this.data[a]);\n          } else this.axisY2.length || (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[0] = new C(this, \"axisY2\", this.options.axisY2, 0, \"axisY\", \"right\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new C(this, \"axisY2\", this.options.axisY2, 0, \"axisY\", \"top\"))), this.data[a].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[a]);if (!this.data[a].axisXType || \"primary\" === this.data[a].axisXType) if (this.options.axisX && 0 < this.options.axisX.length) {\n            if (!this.axisX.length) for (b = 0; b < this.options.axisX.length; b++) {\n              \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[b] = new C(this, \"axisX\", this.options.axisX[b], b, \"axisX\", \"bottom\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[b] = new C(this, \"axisX\", this.options.axisX[b], b, \"axisX\", \"left\"));\n            }this.data[a].axisX = this.axisX[0 <= this.data[a].axisXIndex && this.data[a].axisXIndex < this.axisX.length ? this.data[a].axisXIndex : 0];this.axisX[0 <= this.data[a].axisXIndex && this.data[a].axisXIndex < this.axisX.length ? this.data[a].axisXIndex : 0].dataSeries.push(this.data[a]);\n          } else this.axisX.length || (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[0] = new C(this, \"axisX\", this.options.axisX, 0, \"axisX\", \"bottom\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new C(this, \"axisX\", this.options.axisX, 0, \"axisX\", \"left\"))), this.data[a].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[a]);if (\"secondary\" === this.data[a].axisXType) if (this.options.axisX2 && 0 < this.options.axisX2.length) {\n            if (!this.axisX2.length) for (b = 0; b < this.options.axisX2.length; b++) {\n              \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[b] = new C(this, \"axisX2\", this.options.axisX2[b], b, \"axisX\", \"top\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[b] = new C(this, \"axisX2\", this.options.axisX2[b], b, \"axisX\", \"right\"));\n            }this.data[a].axisX = this.axisX2[0 <= this.data[a].axisXIndex && this.data[a].axisXIndex < this.axisX2.length ? this.data[a].axisXIndex : 0];this.axisX2[0 <= this.data[a].axisXIndex && this.data[a].axisXIndex < this.axisX2.length ? this.data[a].axisXIndex : 0].dataSeries.push(this.data[a]);\n          } else this.axisX2.length || (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new C(this, \"axisX2\", this.options.axisX2, 0, \"axisX\", \"top\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new C(this, \"axisX2\", this.options.axisX2, 0, \"axisX\", \"right\"))), this.data[a].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[a]);\n        }\n      }if (this.axisY) {\n        for (b = 1; b < this.axisY.length; b++) {\n          \"undefined\" === typeof this.axisY[b].options.gridThickness && (this.axisY[b].gridThickness = 0);\n        }for (b = 0; b < this.axisY.length - 1; b++) {\n          \"undefined\" === typeof this.axisY[b].options.margin && (this.axisY[b].margin = 10);\n        }\n      }if (this.axisY2) {\n        for (b = 1; b < this.axisY2.length; b++) {\n          \"undefined\" === typeof this.axisY2[b].options.gridThickness && (this.axisY2[b].gridThickness = 0);\n        }for (b = 0; b < this.axisY2.length - 1; b++) {\n          \"undefined\" === typeof this.axisY2[b].options.margin && (this.axisY2[b].margin = 10);\n        }\n      }this.axisY && 0 < this.axisY.length && this.axisY2 && 0 < this.axisY2.length && (0 < this.axisY[0].gridThickness && \"undefined\" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness = 0 : 0 < this.axisY2[0].gridThickness && \"undefined\" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0));if (this.axisX) for (b = 0; b < this.axisX.length; b++) {\n        \"undefined\" === typeof this.axisX[b].options.gridThickness && (this.axisX[b].gridThickness = 0);\n      }if (this.axisX2) for (b = 0; b < this.axisX2.length; b++) {\n        \"undefined\" === typeof this.axisX2[b].options.gridThickness && (this.axisX2[b].gridThickness = 0);\n      }this.axisX && 0 < this.axisX.length && this.axisX2 && 0 < this.axisX2.length && (0 < this.axisX[0].gridThickness && \"undefined\" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && \"undefined\" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0));b = !1;if (0 < this._axes.length && (this.zoomEnabled || this.panEnabled)) for (a = 0; a < this._axes.length; a++) {\n        if (null !== this._axes[a].viewportMinimum || null !== this._axes[a].viewportMaximum) {\n          b = !0;break;\n        }\n      }b ? (Ma(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + \"px solid \" + this.toolbar.borderColor, this._zoomButton.style.borderRight = this.toolbar.borderThickness + \"px solid \" + this.toolbar.borderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + \"px solid \" + this.toolbar.borderColor) : (wa(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + \"px solid transparent\", this.options.zoomEnabled && (this.zoomEnabled = !0, this.panEnabled = !1));this._processData();this.options.title && (this.title = new Ia(this, this.options.title), this.title.dockInsidePlotArea ? f.push(this.title) : this.title.render());if (this.options.subtitles) for (this.subtitles = [], a = 0; a < this.options.subtitles.length; a++) {\n        b = new Na(this, this.options.subtitles[a], a), this.subtitles.push(b), b.dockInsidePlotArea ? f.push(b) : b.render();\n      }this.legend = new T(this, this.options.legend);for (a = 0; a < this.data.length; a++) {\n        (this.data[a].showInLegend || \"pie\" === this.data[a].type || \"doughnut\" === this.data[a].type || \"funnel\" === this.data[a].type || \"pyramid\" === this.data[a].type) && this.legend.dataSeries.push(this.data[a]);\n      }this.legend.dockInsidePlotArea ? f.push(this.legend) : this.legend.render();for (a = 0; a < this._axes.length; a++) {\n        if (this._axes[a].scaleBreaks && this._axes[a].scaleBreaks._appliedBreaks.length) {\n          v ? (this._breaksCanvas = ua(this.width, this.height, !0), this._breaksCanvasCtx = this._breaksCanvas.getContext(\"2d\")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx);break;\n        }\n      }this._preRenderCanvas = ua(this.width, this.height);this._preRenderCtx = this._preRenderCanvas.getContext(\"2d\");\n      if (\"normal\" === this.plotInfo.axisPlacement || \"xySwapped\" === this.plotInfo.axisPlacement) C.setLayoutAndRender(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());else if (\"none\" === this.plotInfo.axisPlacement) this.preparePlotArea();else return;for (a = 0; a < f.length; a++) {\n        f[a].render();\n      }var c = [];if (this.animatedRender) {\n        var e = ua(this.width, this.height);e.getContext(\"2d\").drawImage(this.canvas, 0, 0, this.width, this.height);\n      }var f = this.ctx.miterLimit,\n          g;this.ctx.miterLimit = 3;v && this._breaksCanvas && (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = \"source-atop\", this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), this._preRenderCtx.clearRect(0, 0, this.width, this.height));for (a = 0; a < this.plotInfo.plotTypes.length; a++) {\n        for (var h = this.plotInfo.plotTypes[a], l = 0; l < h.plotUnits.length; l++) {\n          var t = h.plotUnits[l],\n              k = null;t.targetCanvas = null;this.animatedRender && (t.targetCanvas = ua(this.width, this.height), t.targetCanvasCtx = t.targetCanvas.getContext(\"2d\"), g = t.targetCanvasCtx.miterLimit, t.targetCanvasCtx.miterLimit = 3);\"line\" === t.type ? k = this.renderLine(t) : \"stepLine\" === t.type ? k = this.renderStepLine(t) : \"spline\" === t.type ? k = this.renderSpline(t) : \"column\" === t.type ? k = this.renderColumn(t) : \"bar\" === t.type ? k = this.renderBar(t) : \"area\" === t.type ? k = this.renderArea(t) : \"stepArea\" === t.type ? k = this.renderStepArea(t) : \"splineArea\" === t.type ? k = this.renderSplineArea(t) : \"stackedColumn\" === t.type ? k = this.renderStackedColumn(t) : \"stackedColumn100\" === t.type ? k = this.renderStackedColumn100(t) : \"stackedBar\" === t.type ? k = this.renderStackedBar(t) : \"stackedBar100\" === t.type ? k = this.renderStackedBar100(t) : \"stackedArea\" === t.type ? k = this.renderStackedArea(t) : \"stackedArea100\" === t.type ? k = this.renderStackedArea100(t) : \"bubble\" === t.type ? k = k = this.renderBubble(t) : \"scatter\" === t.type ? k = this.renderScatter(t) : \"pie\" === t.type ? this.renderPie(t) : \"doughnut\" === t.type ? this.renderPie(t) : \"funnel\" === t.type ? k = this.renderFunnel(t) : \"pyramid\" === t.type ? k = this.renderFunnel(t) : \"candlestick\" === t.type ? k = this.renderCandlestick(t) : \"ohlc\" === t.type ? k = this.renderCandlestick(t) : \"rangeColumn\" === t.type ? k = this.renderRangeColumn(t) : \"error\" === t.type ? k = this.renderError(t) : \"rangeBar\" === t.type ? k = this.renderRangeBar(t) : \"rangeArea\" === t.type ? k = this.renderRangeArea(t) : \"rangeSplineArea\" === t.type ? k = this.renderRangeSplineArea(t) : \"waterfall\" === t.type ? k = this.renderWaterfall(t) : \"boxAndWhisker\" === t.type && (k = this.renderBoxAndWhisker(t));\n          for (b = 0; b < t.dataSeriesIndexes.length; b++) {\n            this._dataInRenderedOrder.push(this.data[t.dataSeriesIndexes[b]]);\n          }this.animatedRender && (t.targetCanvasCtx.miterLimit = g, k && c.push(k));\n        }\n      }this.ctx.miterLimit = f;this.animatedRender && this._breaksCanvasCtx && c.push({ source: this._breaksCanvasCtx, dest: this.plotArea.ctx, animationCallback: H.fadeInAnimation, easingFunction: H.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 });this.animatedRender && 0 < this._indexLabels.length && (g = ua(this.width, this.height).getContext(\"2d\"), c.push(this.renderIndexLabels(g)));var r = this;if (0 < c.length) r.disableToolTip = !0, r._animator.animate(200, r.animationDuration, function (a) {\n        r.ctx.clearRect(0, 0, r.width, r.height);r.ctx.drawImage(e, 0, 0, Math.floor(r.width * ha), Math.floor(r.height * ha), 0, 0, r.width, r.height);for (var b = 0; b < c.length; b++) {\n          k = c[b], 1 > a && \"undefined\" !== typeof k.startTimePercent ? a >= k.startTimePercent && k.animationCallback(k.easingFunction(a - k.startTimePercent, 0, 1, 1 - k.startTimePercent), k) : k.animationCallback(k.easingFunction(a, 0, 1, 1), k);\n        }r.dispatchEvent(\"dataAnimationIterationEnd\", { chart: r });\n      }, function () {\n        c = [];for (var a = 0; a < r.plotInfo.plotTypes.length; a++) {\n          for (var b = r.plotInfo.plotTypes[a], d = 0; d < b.plotUnits.length; d++) {\n            b.plotUnits[d].targetCanvas = null;\n          }\n        }e = null;r.disableToolTip = !1;\n      });else {\n        if (r._breaksCanvas) if (v) r.plotArea.ctx.drawImage(r._breaksCanvas, 0, 0, this.width, this.height);else for (b = 0; b < r._axes.length; b++) {\n          r._axes[b].createMask();\n        }0 < r._indexLabels.length && r.renderIndexLabels();r.dispatchEvent(\"dataAnimationIterationEnd\", { chart: r });\n      }this.attachPlotAreaEventHandlers();\n      this.zoomEnabled || this.panEnabled || !this._zoomButton || \"none\" === this._zoomButton.style.display || wa(this._zoomButton, this._resetButton);this.toolTip._updateToolTip();this.renderCount++;this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx);for (b = 0; b < this._axes.length; b++) {\n        this._axes[b].maskCanvas && (delete this._axes[b].maskCanvas, delete this._axes[b].maskCtx);\n      }\n    };q.prototype.attachPlotAreaEventHandlers = function () {\n      this.attachEvent({ context: this, chart: this, mousedown: this._plotAreaMouseDown,\n        mouseup: this._plotAreaMouseUp, mousemove: this._plotAreaMouseMove, cursor: this.panEnabled ? \"move\" : \"default\", capture: !0, bounds: this.plotArea });\n    };q.prototype.categoriseDataSeries = function () {\n      for (var a = \"\", f = 0; f < this.data.length; f++) {\n        if (a = this.data[f], a.dataPoints && 0 !== a.dataPoints.length && a.visible && 0 <= q._supportedChartTypes.indexOf(a.type)) {\n          for (var b = null, c = !1, e = null, g = !1, h = 0; h < this.plotInfo.plotTypes.length; h++) {\n            if (this.plotInfo.plotTypes[h].type === a.type) {\n              c = !0;b = this.plotInfo.plotTypes[h];break;\n            }\n          }c || (b = { type: a.type,\n            totalDataSeries: 0, plotUnits: [] }, this.plotInfo.plotTypes.push(b));for (h = 0; h < b.plotUnits.length; h++) {\n            if (b.plotUnits[h].axisYType === a.axisYType && b.plotUnits[h].axisXType === a.axisXType && b.plotUnits[h].axisYIndex === a.axisYIndex && b.plotUnits[h].axisXIndex === a.axisXIndex) {\n              g = !0;e = b.plotUnits[h];break;\n            }\n          }g || (e = { type: a.type, previousDataSeriesCount: 0, index: b.plotUnits.length, plotType: b, axisXType: a.axisXType, axisYType: a.axisYType, axisYIndex: a.axisYIndex, axisXIndex: a.axisXIndex, axisY: \"primary\" === a.axisYType ? this.axisY[0 <= a.axisYIndex && a.axisYIndex < this.axisY.length ? a.axisYIndex : 0] : this.axisY2[0 <= a.axisYIndex && a.axisYIndex < this.axisY2.length ? a.axisYIndex : 0], axisX: \"primary\" === a.axisXType ? this.axisX[0 <= a.axisXIndex && a.axisXIndex < this.axisX.length ? a.axisXIndex : 0] : this.axisX2[0 <= a.axisXIndex && a.axisXIndex < this.axisX2.length ? a.axisXIndex : 0], dataSeriesIndexes: [], yTotals: [] }, b.plotUnits.push(e));b.totalDataSeries++;e.dataSeriesIndexes.push(f);a.plotUnit = e;\n        }\n      }for (f = 0; f < this.plotInfo.plotTypes.length; f++) {\n        for (b = this.plotInfo.plotTypes[f], h = a = 0; h < b.plotUnits.length; h++) {\n          b.plotUnits[h].previousDataSeriesCount = a, a += b.plotUnits[h].dataSeriesIndexes.length;\n        }\n      }\n    };q.prototype.assignIdToDataPoints = function () {\n      for (var a = 0; a < this.data.length; a++) {\n        var f = this.data[a];if (f.dataPoints) for (var b = f.dataPoints.length, c = 0; c < b; c++) {\n          f.dataPointIds[c] = ++this._eventManager.lastObjectId;\n        }\n      }\n    };q.prototype._processData = function () {\n      this.assignIdToDataPoints();this.categoriseDataSeries();for (var a = 0; a < this.plotInfo.plotTypes.length; a++) {\n        for (var f = this.plotInfo.plotTypes[a], b = 0; b < f.plotUnits.length; b++) {\n          var c = f.plotUnits[b];\"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"column\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"bar\" === c.type || \"bubble\" === c.type || \"scatter\" === c.type ? this._processMultiseriesPlotUnit(c) : \"stackedColumn\" === c.type || \"stackedBar\" === c.type || \"stackedArea\" === c.type ? this._processStackedPlotUnit(c) : \"stackedColumn100\" === c.type || \"stackedBar100\" === c.type || \"stackedArea100\" === c.type ? this._processStacked100PlotUnit(c) : \"candlestick\" === c.type || \"ohlc\" === c.type || \"rangeColumn\" === c.type || \"rangeBar\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type || \"error\" === c.type || \"boxAndWhisker\" === c.type ? this._processMultiYPlotUnit(c) : \"waterfall\" === c.type && this._processSpecificPlotUnit(c);\n        }\n      }this.calculateAutoBreaks();\n    };q.prototype._processMultiseriesPlotUnit = function (a) {\n      if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, h = 0; h < a.dataSeriesIndexes.length; h++) {\n        var l = this.data[a.dataSeriesIndexes[h]],\n            t = 0,\n            k = !1,\n            r = !1,\n            p;if (\"normal\" === l.axisPlacement || \"xySwapped\" === l.axisPlacement) var n = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity,\n            d = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;if (l.dataPoints[t].x && l.dataPoints[t].x.getTime || \"dateTime\" === l.xValueType) g = !0;for (t = 0; t < l.dataPoints.length; t++) {\n          \"undefined\" === typeof l.dataPoints[t].x && (l.dataPoints[t].x = t + (a.axisX.logarithmic ? 1 : 0));l.dataPoints[t].x.getTime ? (g = !0, c = l.dataPoints[t].x.getTime()) : c = l.dataPoints[t].x;e = l.dataPoints[t].y;c < b.min && (b.min = c);c > b.max && (b.max = c);e < f.min && \"number\" === typeof e && (f.min = e);\n          e > f.max && \"number\" === typeof e && (f.max = e);if (0 < t) {\n            if (a.axisX.logarithmic) {\n              var w = c / l.dataPoints[t - 1].x;1 > w && (w = 1 / w);b.minDiff > w && 1 !== w && (b.minDiff = w);\n            } else w = c - l.dataPoints[t - 1].x, 0 > w && (w *= -1), b.minDiff > w && 0 !== w && (b.minDiff = w);null !== e && null !== l.dataPoints[t - 1].y && (a.axisY.logarithmic ? (w = e / l.dataPoints[t - 1].y, 1 > w && (w = 1 / w), f.minDiff > w && 1 !== w && (f.minDiff = w)) : (w = e - l.dataPoints[t - 1].y, 0 > w && (w *= -1), f.minDiff > w && 0 !== w && (f.minDiff = w)));\n          }if (c < n && !k) null !== e && (p = c);else {\n            if (!k && (k = !0, 0 < t)) {\n              t -= 2;continue;\n            }if (c > d && !r) r = !0;else if (c > d && r) continue;l.dataPoints[t].label && (a.axisX.labels[c] = l.dataPoints[t].label);c < b.viewPortMin && (b.viewPortMin = c);c > b.viewPortMax && (b.viewPortMax = c);null === e ? b.viewPortMin === c && p < c && (b.viewPortMin = p) : (e < f.viewPortMin && \"number\" === typeof e && (f.viewPortMin = e), e > f.viewPortMax && \"number\" === typeof e && (f.viewPortMax = e));\n          }\n        }l.axisX.valueType = l.xValueType = g ? \"dateTime\" : \"number\";\n      }\n    };q.prototype._processStackedPlotUnit = function (a) {\n      if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {\n        for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, h = [], l = [], t = Infinity, k = -Infinity, r = 0; r < a.dataSeriesIndexes.length; r++) {\n          var p = this.data[a.dataSeriesIndexes[r]],\n              n = 0,\n              d = !1,\n              w = !1,\n              za;if (\"normal\" === p.axisPlacement || \"xySwapped\" === p.axisPlacement) var D = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity,\n              u = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;if (p.dataPoints[n].x && p.dataPoints[n].x.getTime || \"dateTime\" === p.xValueType) g = !0;for (n = 0; n < p.dataPoints.length; n++) {\n            \"undefined\" === typeof p.dataPoints[n].x && (p.dataPoints[n].x = n + (a.axisX.logarithmic ? 1 : 0));p.dataPoints[n].x.getTime ? (g = !0, c = p.dataPoints[n].x.getTime()) : c = p.dataPoints[n].x;e = y(p.dataPoints[n].y) ? 0 : p.dataPoints[n].y;c < b.min && (b.min = c);c > b.max && (b.max = c);if (0 < n) {\n              if (a.axisX.logarithmic) {\n                var m = c / p.dataPoints[n - 1].x;1 > m && (m = 1 / m);b.minDiff > m && 1 !== m && (b.minDiff = m);\n              } else m = c - p.dataPoints[n - 1].x, 0 > m && (m *= -1), b.minDiff > m && 0 !== m && (b.minDiff = m);null !== e && null !== p.dataPoints[n - 1].y && (a.axisY.logarithmic ? 0 < e && (m = e / p.dataPoints[n - 1].y, 1 > m && (m = 1 / m), f.minDiff > m && 1 !== m && (f.minDiff = m)) : (m = e - p.dataPoints[n - 1].y, 0 > m && (m *= -1), f.minDiff > m && 0 !== m && (f.minDiff = m)));\n            }if (c < D && !d) null !== p.dataPoints[n].y && (za = c);else {\n              if (!d && (d = !0, 0 < n)) {\n                n -= 2;continue;\n              }if (c > u && !w) w = !0;else if (c > u && w) continue;p.dataPoints[n].label && (a.axisX.labels[c] = p.dataPoints[n].label);c < b.viewPortMin && (b.viewPortMin = c);c > b.viewPortMax && (b.viewPortMax = c);null === p.dataPoints[n].y ? b.viewPortMin === c && za < c && (b.viewPortMin = za) : (a.yTotals[c] = (a.yTotals[c] ? a.yTotals[c] : 0) + e, 0 <= e ? h[c] ? h[c] += e : (h[c] = e, t = Math.min(e, t)) : l[c] ? l[c] += e : (l[c] = e, k = Math.max(e, k)));\n            }\n          }a.axisY.scaleBreaks && a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks && (f.dataPointYPositiveSums ? (f.dataPointYPositiveSums.push.apply(f.dataPointYPositiveSums, h), f.dataPointYNegativeSums.push.apply(f.dataPointYPositiveSums, l)) : (f.dataPointYPositiveSums = h, f.dataPointYNegativeSums = l));p.axisX.valueType = p.xValueType = g ? \"dateTime\" : \"number\";\n        }for (n in h) {\n          h.hasOwnProperty(n) && !isNaN(n) && (a = h[n], a < f.min && (f.min = Math.min(a, t)), a > f.max && (f.max = a), n < b.viewPortMin || n > b.viewPortMax || (a < f.viewPortMin && (f.viewPortMin = Math.min(a, t)), a > f.viewPortMax && (f.viewPortMax = a)));\n        }for (n in l) {\n          l.hasOwnProperty(n) && !isNaN(n) && (a = l[n], a < f.min && (f.min = a), a > f.max && (f.max = Math.max(a, k)), n < b.viewPortMin || n > b.viewPortMax || (a < f.viewPortMin && (f.viewPortMin = a), a > f.viewPortMax && (f.viewPortMax = Math.max(a, k))));\n        }\n      }\n    };q.prototype._processStacked100PlotUnit = function (a) {\n      if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {\n        for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, h = !1, l = !1, t = [], k = 0; k < a.dataSeriesIndexes.length; k++) {\n          var r = this.data[a.dataSeriesIndexes[k]],\n              p = 0,\n              n = !1,\n              d = !1,\n              w;if (\"normal\" === r.axisPlacement || \"xySwapped\" === r.axisPlacement) var m = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity,\n              D = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;if (r.dataPoints[p].x && r.dataPoints[p].x.getTime || \"dateTime\" === r.xValueType) g = !0;for (p = 0; p < r.dataPoints.length; p++) {\n            \"undefined\" === typeof r.dataPoints[p].x && (r.dataPoints[p].x = p + (a.axisX.logarithmic ? 1 : 0));r.dataPoints[p].x.getTime ? (g = !0, c = r.dataPoints[p].x.getTime()) : c = r.dataPoints[p].x;e = y(r.dataPoints[p].y) ? null : r.dataPoints[p].y;c < b.min && (b.min = c);c > b.max && (b.max = c);if (0 < p) {\n              if (a.axisX.logarithmic) {\n                var u = c / r.dataPoints[p - 1].x;1 > u && (u = 1 / u);b.minDiff > u && 1 !== u && (b.minDiff = u);\n              } else u = c - r.dataPoints[p - 1].x, 0 > u && (u *= -1), b.minDiff > u && 0 !== u && (b.minDiff = u);y(e) || null === r.dataPoints[p - 1].y || (a.axisY.logarithmic ? 0 < e && (u = e / r.dataPoints[p - 1].y, 1 > u && (u = 1 / u), f.minDiff > u && 1 !== u && (f.minDiff = u)) : (u = e - r.dataPoints[p - 1].y, 0 > u && (u *= -1), f.minDiff > u && 0 !== u && (f.minDiff = u)));\n            }if (c < m && !n) null !== e && (w = c);else {\n              if (!n && (n = !0, 0 < p)) {\n                p -= 2;continue;\n              }if (c > D && !d) d = !0;else if (c > D && d) continue;r.dataPoints[p].label && (a.axisX.labels[c] = r.dataPoints[p].label);c < b.viewPortMin && (b.viewPortMin = c);c > b.viewPortMax && (b.viewPortMax = c);null === e ? b.viewPortMin === c && w < c && (b.viewPortMin = w) : (a.yTotals[c] = (a.yTotals[c] ? a.yTotals[c] : 0) + e, 0 <= e ? h = !0 : 0 > e && (l = !0), t[c] = t[c] ? t[c] + Math.abs(e) : Math.abs(e));\n            }\n          }r.axisX.valueType = r.xValueType = g ? \"dateTime\" : \"number\";\n        }a.axisY.logarithmic ? (f.max = y(f.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -0.05) : Math.max(f.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -0.05)), f.min = y(f.viewPortMin) ? 1 : Math.min(f.viewPortMin, 1)) : h && !l ? (f.max = y(f.viewPortMax) ? 99 : Math.max(f.viewPortMax, 99), f.min = y(f.viewPortMin) ? 1 : Math.min(f.viewPortMin, 1)) : h && l ? (f.max = y(f.viewPortMax) ? 99 : Math.max(f.viewPortMax, 99), f.min = y(f.viewPortMin) ? -99 : Math.min(f.viewPortMin, -99)) : !h && l && (f.max = y(f.viewPortMax) ? -1 : Math.max(f.viewPortMax, -1), f.min = y(f.viewPortMin) ? -99 : Math.min(f.viewPortMin, -99));f.viewPortMin = f.min;f.viewPortMax = f.max;a.dataPointYSums = t;\n      }\n    };q.prototype._processMultiYPlotUnit = function (a) {\n      if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g, h, l = !1, t = 0; t < a.dataSeriesIndexes.length; t++) {\n        var k = this.data[a.dataSeriesIndexes[t]],\n            r = 0,\n            p = !1,\n            n = !1,\n            d,\n            w,\n            m;if (\"normal\" === k.axisPlacement || \"xySwapped\" === k.axisPlacement) var D = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity,\n            u = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;if (k.dataPoints[r].x && k.dataPoints[r].x.getTime || \"dateTime\" === k.xValueType) l = !0;for (r = 0; r < k.dataPoints.length; r++) {\n          \"undefined\" === typeof k.dataPoints[r].x && (k.dataPoints[r].x = r + (a.axisX.logarithmic ? 1 : 0));k.dataPoints[r].x.getTime ? (l = !0, c = k.dataPoints[r].x.getTime()) : c = k.dataPoints[r].x;if ((e = k.dataPoints[r].y) && e.length) {\n            g = Math.min.apply(null, e);h = Math.max.apply(null, e);w = !0;for (var v = 0; v < e.length; v++) {\n              null === e.k && (w = !1);\n            }w && (p || (m = d), d = c);\n          }c < b.min && (b.min = c);c > b.max && (b.max = c);g < f.min && (f.min = g);h > f.max && (f.max = h);0 < r && (a.axisX.logarithmic ? (w = c / k.dataPoints[r - 1].x, 1 > w && (w = 1 / w), b.minDiff > w && 1 !== w && (b.minDiff = w)) : (w = c - k.dataPoints[r - 1].x, 0 > w && (w *= -1), b.minDiff > w && 0 !== w && (b.minDiff = w)), e && null !== e[0] && k.dataPoints[r - 1].y && null !== k.dataPoints[r - 1].y[0] && (a.axisY.logarithmic ? (w = e[0] / k.dataPoints[r - 1].y[0], 1 > w && (w = 1 / w), f.minDiff > w && 1 !== w && (f.minDiff = w)) : (w = e[0] - k.dataPoints[r - 1].y[0], 0 > w && (w *= -1), f.minDiff > w && 0 !== w && (f.minDiff = w))));if (!(c < D) || p) {\n            if (!p && (p = !0, 0 < r)) {\n              r -= 2;d = m;continue;\n            }if (c > u && !n) n = !0;else if (c > u && n) continue;k.dataPoints[r].label && (a.axisX.labels[c] = k.dataPoints[r].label);c < b.viewPortMin && (b.viewPortMin = c);c > b.viewPortMax && (b.viewPortMax = c);if (b.viewPortMin === c && e) for (v = 0; v < e.length; v++) {\n              if (null === e[v] && d < c) {\n                b.viewPortMin = d;break;\n              }\n            }null === e ? b.viewPortMin === c && d < c && (b.viewPortMin = d) : (g < f.viewPortMin && (f.viewPortMin = g), h > f.viewPortMax && (f.viewPortMax = h));\n          }\n        }k.axisX.valueType = k.xValueType = l ? \"dateTime\" : \"number\";\n      }\n    };q.prototype._processSpecificPlotUnit = function (a) {\n      if (\"waterfall\" === a.type && a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, h = 0; h < a.dataSeriesIndexes.length; h++) {\n        var l = this.data[a.dataSeriesIndexes[h]],\n            t = 0,\n            k = !1,\n            r = !1,\n            p = c = 0;if (\"normal\" === l.axisPlacement || \"xySwapped\" === l.axisPlacement) var n = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity,\n            d = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;if (l.dataPoints[t].x && l.dataPoints[t].x.getTime || \"dateTime\" === l.xValueType) g = !0;for (t = 0; t < l.dataPoints.length; t++) {\n          \"undefined\" !== typeof l.dataPoints[t].isCumulativeSum && !0 === l.dataPoints[t].isCumulativeSum ? (l.dataPointEOs[t].cumulativeSumYStartValue = 0, l.dataPointEOs[t].cumulativeSum = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum, l.dataPoints[t].y = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum) : \"undefined\" !== typeof l.dataPoints[t].isIntermediateSum && !0 === l.dataPoints[t].isIntermediateSum ? (l.dataPointEOs[t].cumulativeSumYStartValue = p, l.dataPointEOs[t].cumulativeSum = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum, l.dataPoints[t].y = 0 === t ? 0 : c, p = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum, c = 0) : (e = \"number\" !== typeof l.dataPoints[t].y ? 0 : l.dataPoints[t].y, l.dataPointEOs[t].cumulativeSumYStartValue = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum, l.dataPointEOs[t].cumulativeSum = 0 === t ? e : l.dataPointEOs[t - 1].cumulativeSum + e, c += e);\n        }for (t = 0; t < l.dataPoints.length; t++) {\n          if (\"undefined\" === typeof l.dataPoints[t].x && (l.dataPoints[t].x = t + (a.axisX.logarithmic ? 1 : 0)), l.dataPoints[t].x.getTime ? (g = !0, c = l.dataPoints[t].x.getTime()) : c = l.dataPoints[t].x, e = l.dataPoints[t].y, c < b.min && (b.min = c), c > b.max && (b.max = c), l.dataPointEOs[t].cumulativeSum < f.min && (f.min = l.dataPointEOs[t].cumulativeSum), l.dataPointEOs[t].cumulativeSum > f.max && (f.max = l.dataPointEOs[t].cumulativeSum), 0 < t && (a.axisX.logarithmic ? (p = c / l.dataPoints[t - 1].x, 1 > p && (p = 1 / p), b.minDiff > p && 1 !== p && (b.minDiff = p)) : (p = c - l.dataPoints[t - 1].x, 0 > p && (p *= -1), b.minDiff > p && 0 !== p && (b.minDiff = p)), null !== e && null !== l.dataPoints[t - 1].y && (a.axisY.logarithmic ? (e = l.dataPointEOs[t].cumulativeSum / l.dataPointEOs[t - 1].cumulativeSum, 1 > e && (e = 1 / e), f.minDiff > e && 1 !== e && (f.minDiff = e)) : (e = l.dataPointEOs[t].cumulativeSum - l.dataPointEOs[t - 1].cumulativeSum, 0 > e && (e *= -1), f.minDiff > e && 0 !== e && (f.minDiff = e)))), !(c < n) || k) {\n            if (!k && (k = !0, 0 < t)) {\n              t -= 2;continue;\n            }if (c > d && !r) r = !0;else if (c > d && r) continue;l.dataPoints[t].label && (a.axisX.labels[c] = l.dataPoints[t].label);c < b.viewPortMin && (b.viewPortMin = c);c > b.viewPortMax && (b.viewPortMax = c);0 < t && (l.dataPointEOs[t - 1].cumulativeSum < f.viewPortMin && (f.viewPortMin = l.dataPointEOs[t - 1].cumulativeSum), l.dataPointEOs[t - 1].cumulativeSum > f.viewPortMax && (f.viewPortMax = l.dataPointEOs[t - 1].cumulativeSum));l.dataPointEOs[t].cumulativeSum < f.viewPortMin && (f.viewPortMin = l.dataPointEOs[t].cumulativeSum);l.dataPointEOs[t].cumulativeSum > f.viewPortMax && (f.viewPortMax = l.dataPointEOs[t].cumulativeSum);\n          }\n        }l.axisX.valueType = l.xValueType = g ? \"dateTime\" : \"number\";\n      }\n    };\n    q.prototype.calculateAutoBreaks = function () {\n      function a(a, c, b, e) {\n        if (e) return b = Math.pow(Math.min(b * a / c, c / a), 0.2), 1 >= b && (b = Math.pow(1 > a ? 1 / a : Math.min(c / a, a), 0.25)), { startValue: a * b, endValue: c / b };b = 0.2 * Math.min(b - c + a, c - a);0 >= b && (b = 0.25 * Math.min(c - a, Math.abs(a)));return { startValue: a + b, endValue: c - b };\n      }function f(a) {\n        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {\n          var c = a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks,\n              b = a.axisY.scaleBreaks && a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks;if (c || b) for (var f = a.axisY.dataInfo, g = a.axisX.dataInfo, k, h = g.min, n = g.max, l = f.min, t = f.max, g = g._dataRanges, f = f._dataRanges, p, r = 0, m = 0; m < a.dataSeriesIndexes.length; m++) {\n            var v = e.data[a.dataSeriesIndexes[m]];if (!(4 > v.dataPoints.length)) for (r = 0; r < v.dataPoints.length; r++) {\n              if (c && (p = (n + 1 - h) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, k = v.dataPoints[r].x.getTime ? v.dataPoints[r].x.getTime() : v.dataPoints[r].x, p = Math.floor((k - h) / p), k < g[p].min && (g[p].min = k), k > g[p].max && (g[p].max = k)), b) {\n                var s = (t + 1 - l) * Math.max(parseFloat(a.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100;if ((k = \"waterfall\" === a.type ? v.dataPointEOs[r].cumulativeSum : v.dataPoints[r].y) && k.length) for (var q = 0; q < k.length; q++) {\n                  p = Math.floor((k[q] - l) / s), k[q] < f[p].min && (f[p].min = k[q]), k[q] > f[p].max && (f[p].max = k[q]);\n                } else y(k) || (p = Math.floor((k - l) / s), k < f[p].min && (f[p].min = k), k > f[p].max && (f[p].max = k));\n              }\n            }\n          }\n        }\n      }function b(a) {\n        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length) && a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks) for (var c = a.axisX.dataInfo, b = c.min, f = c.max, g = c._dataRanges, k, h = 0, n = 0; n < a.dataSeriesIndexes.length; n++) {\n          var l = e.data[a.dataSeriesIndexes[n]];if (!(4 > l.dataPoints.length)) for (h = 0; h < l.dataPoints.length; h++) {\n            k = (f + 1 - b) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, c = l.dataPoints[h].x.getTime ? l.dataPoints[h].x.getTime() : l.dataPoints[h].x, k = Math.floor((c - b) / k), c < g[k].min && (g[k].min = c), c > g[k].max && (g[k].max = c);\n          }\n        }\n      }for (var c, e = this, g = !1, h = 0; h < this._axes.length; h++) {\n        if (this._axes[h].scaleBreaks && this._axes[h].scaleBreaks.autoCalculate && 1 <= this._axes[h].scaleBreaks.maxNumberOfAutoBreaks) {\n          g = !0;this._axes[h].dataInfo._dataRanges = [];for (var l = 0; l < 100 / Math.max(parseFloat(this._axes[h].scaleBreaks.collapsibleThreshold) || 10, 10); l++) {\n            this._axes[h].dataInfo._dataRanges.push({ min: Infinity, max: -Infinity });\n          }\n        }\n      }if (g) {\n        for (h = 0; h < this.plotInfo.plotTypes.length; h++) {\n          for (g = this.plotInfo.plotTypes[h], l = 0; l < g.plotUnits.length; l++) {\n            c = g.plotUnits[l], \"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"column\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"bar\" === c.type || \"bubble\" === c.type || \"scatter\" === c.type || \"candlestick\" === c.type || \"ohlc\" === c.type || \"rangeColumn\" === c.type || \"rangeBar\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type || \"waterfall\" === c.type || \"error\" === c.type || \"boxAndWhisker\" === c.type ? f(c) : 0 <= c.type.indexOf(\"stacked\") && b(c);\n          }\n        }for (h = 0; h < this._axes.length; h++) {\n          if (this._axes[h].dataInfo._dataRanges) {\n            var t = this._axes[h].dataInfo.min;c = (this._axes[h].dataInfo.max + 1 - t) * Math.max(parseFloat(this._axes[h].scaleBreaks.collapsibleThreshold) || 10, 10) / 100;var k = this._axes[h].dataInfo._dataRanges,\n                r,\n                p,\n                g = [];if (this._axes[h].dataInfo.dataPointYPositiveSums) {\n              var n = this._axes[h].dataInfo.dataPointYPositiveSums;r = k;for (l in n) {\n                n.hasOwnProperty(l) && !isNaN(l) && (p = n[l], y(p) || (index = Math.floor((p - t) / c), p < r[index].min && (r[index].min = p), p > r[index].max && (r[index].max = p)));\n              }delete this._axes[h].dataInfo.dataPointYPositiveSums;\n            }if (this._axes[h].dataInfo.dataPointYNegativeSums) {\n              n = this._axes[h].dataInfo.dataPointYNegativeSums;r = k;for (l in n) {\n                n.hasOwnProperty(l) && !isNaN(l) && (p = -1 * n[l], y(p) || (index = Math.floor((p - t) / c), p < r[index].min && (r[index].min = p), p > r[index].max && (r[index].max = p)));\n              }delete this._axes[h].dataInfo.dataPointYNegativeSums;\n            }for (l = 0; l < k.length - 1; l++) {\n              if (r = k[l].max, isFinite(r)) for (; l < k.length - 1;) {\n                if (t = k[l + 1].min, isFinite(t)) {\n                  p = t - r;p > c && g.push({ diff: p, start: r, end: t });break;\n                } else l++;\n              }\n            }if (this._axes[h].scaleBreaks.customBreaks) for (l = 0; l < this._axes[h].scaleBreaks.customBreaks.length; l++) {\n              for (c = 0; c < g.length; c++) {\n                if (this._axes[h].scaleBreaks.customBreaks[l].startValue <= g[c].start && g[c].start <= this._axes[h].scaleBreaks.customBreaks[l].endValue || this._axes[h].scaleBreaks.customBreaks[l].startValue <= g[c].start && g[c].start <= this._axes[h].scaleBreaks.customBreaks[l].endValue || g[c].start <= this._axes[h].scaleBreaks.customBreaks[l].startValue && this._axes[h].scaleBreaks.customBreaks[l].startValue <= g[c].end || g[c].start <= this._axes[h].scaleBreaks.customBreaks[l].endValue && this._axes[h].scaleBreaks.customBreaks[l].endValue <= g[c].end) g.splice(c, 1), c--;\n              }\n            }g.sort(function (a, c) {\n              return c.diff - a.diff;\n            });for (l = 0; l < Math.min(g.length, this._axes[h].scaleBreaks.maxNumberOfAutoBreaks); l++) {\n              c = a(g[l].start, g[l].end, this._axes[h].logarithmic ? this._axes[h].dataInfo.max / this._axes[h].dataInfo.min : this._axes[h].dataInfo.max - this._axes[h].dataInfo.min, this._axes[h].logarithmic), this._axes[h].scaleBreaks.autoBreaks.push(new aa(this, \"autoBreaks\", c, l, ++this._eventManager.lastObjectId, this._axes[h].scaleBreaks)), this._axes[h].scaleBreaks._appliedBreaks.push(this._axes[h].scaleBreaks.autoBreaks[this._axes[h].scaleBreaks.autoBreaks.length - 1]);\n            }this._axes[h].scaleBreaks._appliedBreaks.sort(function (a, c) {\n              return a.startValue - c.startValue;\n            });\n          }\n        }\n      }\n    };q.prototype.getDataPointAtXY = function (a, f, b) {\n      b = b || !1;for (var c = [], e = this._dataInRenderedOrder.length - 1; 0 <= e; e--) {\n        var g = null;(g = this._dataInRenderedOrder[e].getDataPointAtXY(a, f, b)) && c.push(g);\n      }a = null;f = !1;for (b = 0; b < c.length; b++) {\n        if (\"line\" === c[b].dataSeries.type || \"stepLine\" === c[b].dataSeries.type || \"area\" === c[b].dataSeries.type || \"stepArea\" === c[b].dataSeries.type) if (e = na(\"markerSize\", c[b].dataPoint, c[b].dataSeries) || 8, c[b].distance <= e / 2) {\n          f = !0;break;\n        }\n      }for (b = 0; b < c.length; b++) {\n        f && \"line\" !== c[b].dataSeries.type && \"stepLine\" !== c[b].dataSeries.type && \"area\" !== c[b].dataSeries.type && \"stepArea\" !== c[b].dataSeries.type || (a ? c[b].distance <= a.distance && (a = c[b]) : a = c[b]);\n      }return a;\n    };q.prototype.getObjectAtXY = function (a, f, b) {\n      var c = null;if (b = this.getDataPointAtXY(a, f, b || !1)) c = b.dataSeries.dataPointIds[b.dataPointIndex];else if (v) c = Wa(a, f, this._eventManager.ghostCtx);else for (b = 0; b < this.legend.items.length; b++) {\n        var e = this.legend.items[b];\n        a >= e.x1 && a <= e.x2 && f >= e.y1 && f <= e.y2 && (c = e.id);\n      }return c;\n    };q.prototype.getAutoFontSize = function (a, f, b) {\n      f = Math.min(this.width, this.height);return Math.max(\"theme4\" === this.theme ? 0 : 300 <= f ? 12 : 10, Math.round(f * (a / 400)));\n    };q.prototype.resetOverlayedCanvas = function () {\n      this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height);\n    };q.prototype.clearCanvas = function () {\n      this.ctx.clearRect(0, 0, this.width, this.height);this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height));\n    };\n    q.prototype.attachEvent = function (a) {\n      this._events.push(a);\n    };q.prototype._touchEventHandler = function (a) {\n      if (a.changedTouches && this.interactivityEnabled) {\n        var f = [],\n            b = a.changedTouches,\n            c = b ? b[0] : a,\n            e = null;switch (a.type) {case \"touchstart\":case \"MSPointerDown\":\n            f = [\"mousemove\", \"mousedown\"];this._lastTouchData = Oa(c);this._lastTouchData.time = new Date();break;case \"touchmove\":case \"MSPointerMove\":\n            f = [\"mousemove\"];break;case \"touchend\":case \"MSPointerUp\":\n            var g = this._lastTouchData && this._lastTouchData.time ? new Date() - this._lastTouchData.time : 0,\n                f = \"touchstart\" === this._lastTouchEventType || \"MSPointerDown\" === this._lastTouchEventType || 300 > g ? [\"mouseup\", \"click\"] : [\"mouseup\"];break;default:\n            return;}if (!(b && 1 < b.length)) {\n          e = Oa(c);e.time = new Date();try {\n            var h = e.y - this._lastTouchData.y,\n                g = e.time - this._lastTouchData.time;if (15 < Math.abs(h) && (this._lastTouchData.scroll || 300 > g)) {\n              this._lastTouchData.scroll = !0;var l = window.parent || window;l && l.scrollBy && l.scrollBy(0, -h);\n            }\n          } catch (t) {}this._lastTouchEventType = a.type;if (this._lastTouchData.scroll && this.zoomEnabled) this.isDrag && this.resetOverlayedCanvas(), this.isDrag = !1;else for (b = 0; b < f.length; b++) {\n            e = f[b], g = document.createEvent(\"MouseEvent\"), g.initMouseEvent(e, !0, !0, window, 1, c.screenX, c.screenY, c.clientX, c.clientY, !1, !1, !1, !1, 0, null), c.target.dispatchEvent(g), a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault();\n          }\n        }\n      }\n    };q.prototype._dispatchRangeEvent = function (a, f) {\n      var b = { chart: this };b.type = a;b.trigger = f;var c = [];this.axisX && 0 < this.axisX.length && c.push(\"axisX\");this.axisX2 && 0 < this.axisX2.length && c.push(\"axisX2\");this.axisY && 0 < this.axisY.length && c.push(\"axisY\");this.axisY2 && 0 < this.axisY2.length && c.push(\"axisY2\");for (var e = 0; e < c.length; e++) {\n        if (y(b[c[e]]) && (b[c[e]] = []), \"axisY\" === c[e]) for (var g = 0; g < this.axisY.length; g++) {\n          b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });\n        } else if (\"axisY2\" === c[e]) for (g = 0; g < this.axisY2.length; g++) {\n          b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum,\n            viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });\n        } else if (\"axisX\" === c[e]) for (g = 0; g < this.axisX.length; g++) {\n          b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });\n        } else if (\"axisX2\" === c[e]) for (g = 0; g < this.axisX2.length; g++) {\n          b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });\n        }\n      }this.dispatchEvent(a, b, this);\n    };\n    q.prototype._mouseEventHandler = function (a) {\n      \"undefined\" === typeof a.target && a.srcElement && (a.target = a.srcElement);var f = Oa(a),\n          b = a.type,\n          c,\n          e;a.which ? e = 3 == a.which : a.button && (e = 2 == a.button);q.capturedEventParam && (c = q.capturedEventParam, \"mouseup\" === b && (q.capturedEventParam = null, c.chart.overlaidCanvas.releaseCapture ? c.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener(\"mouseup\", c.chart._mouseEventHandler, !1)), c.hasOwnProperty(b) && (\"mouseup\" !== b || c.chart.overlaidCanvas.releaseCapture ? a.target !== c.chart.overlaidCanvas && v || c[b].call(c.context, f.x, f.y) : a.target !== c.chart.overlaidCanvas && (c.chart.isDrag = !1)));if (this.interactivityEnabled) if (this._ignoreNextEvent) this._ignoreNextEvent = !1;else if (a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault(), !e) {\n        if (!q.capturedEventParam && this._events) {\n          for (var g = 0; g < this._events.length; g++) {\n            if (this._events[g].hasOwnProperty(b)) if (c = this._events[g], e = c.bounds, f.x >= e.x1 && f.x <= e.x2 && f.y >= e.y1 && f.y <= e.y2) {\n              c[b].call(c.context, f.x, f.y);\"mousedown\" === b && !0 === c.capture ? (q.capturedEventParam = c, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener(\"mouseup\", this._mouseEventHandler, !1)) : \"mouseup\" === b && (c.chart.overlaidCanvas.releaseCapture ? c.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener(\"mouseup\", this._mouseEventHandler, !1));break;\n            } else c = null;\n          }a.target.style.cursor = c && c.cursor ? c.cursor : this._defaultCursor;\n        }b = this.plotArea;if (f.x < b.x1 || f.x > b.x2 || f.y < b.y1 || f.y > b.y2) this.toolTip && this.toolTip.enabled ? this.toolTip.hide() : this.resetOverlayedCanvas();this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a);\n      }\n    };q.prototype._plotAreaMouseDown = function (a, f) {\n      this.isDrag = !0;this.dragStartPoint = { x: a, y: f };\n    };q.prototype._plotAreaMouseUp = function (a, f) {\n      if ((\"normal\" === this.plotInfo.axisPlacement || \"xySwapped\" === this.plotInfo.axisPlacement) && this.isDrag) {\n        var b = f - this.dragStartPoint.y,\n            c = a - this.dragStartPoint.x,\n            e = 0 <= this.zoomType.indexOf(\"x\"),\n            g = 0 <= this.zoomType.indexOf(\"y\"),\n            h = !1;this.resetOverlayedCanvas();if (\"xySwapped\" === this.plotInfo.axisPlacement) var l = g,\n            g = e,\n            e = l;if (this.panEnabled || this.zoomEnabled) {\n          if (this.panEnabled) for (e = g = 0; e < this._axes.length; e++) {\n            b = this._axes[e], b.logarithmic ? b.viewportMinimum < b.minimum ? (g = b.minimum / b.viewportMinimum, b.sessionVariables.newViewportMinimum = b.viewportMinimum * g, b.sessionVariables.newViewportMaximum = b.viewportMaximum * g, h = !0) : b.viewportMaximum > b.maximum && (g = b.viewportMaximum / b.maximum, b.sessionVariables.newViewportMinimum = b.viewportMinimum / g, b.sessionVariables.newViewportMaximum = b.viewportMaximum / g, h = !0) : b.viewportMinimum < b.minimum ? (g = b.minimum - b.viewportMinimum, b.sessionVariables.newViewportMinimum = b.viewportMinimum + g, b.sessionVariables.newViewportMaximum = b.viewportMaximum + g, h = !0) : b.viewportMaximum > b.maximum && (g = b.viewportMaximum - b.maximum, b.sessionVariables.newViewportMinimum = b.viewportMinimum - g, b.sessionVariables.newViewportMaximum = b.viewportMaximum - g, h = !0);\n          } else if ((!e || 2 < Math.abs(c)) && (!g || 2 < Math.abs(b)) && this.zoomEnabled) {\n            if (!this.dragStartPoint) return;\n            b = e ? this.dragStartPoint.x : this.plotArea.x1;c = g ? this.dragStartPoint.y : this.plotArea.y1;e = e ? a : this.plotArea.x2;g = g ? f : this.plotArea.y2;2 < Math.abs(b - e) && 2 < Math.abs(c - g) && this._zoomPanToSelectedRegion(b, c, e, g) && (h = !0);\n          }h && (this._ignoreNextEvent = !0, this._dispatchRangeEvent(\"rangeChanging\", \"zoom\"), this.render(), this._dispatchRangeEvent(\"rangeChanged\", \"zoom\"), h && this.zoomEnabled && \"none\" === this._zoomButton.style.display && (Ma(this._zoomButton, this._resetButton), va(this, this._zoomButton, \"pan\"), va(this, this._resetButton, \"reset\")));\n        }\n      }this.isDrag = !1;if (\"none\" !== this.plotInfo.axisPlacement) {\n        this.resetOverlayedCanvas();if (this.axisX && 0 < this.axisX.length) for (h = 0; h < this.axisX.length; h++) {\n          this.axisX[h].crosshair && this.axisX[h].crosshair.enabled && this.axisX[h].renderCrosshair(a, f);\n        }if (this.axisX2 && 0 < this.axisX2.length) for (h = 0; h < this.axisX2.length; h++) {\n          this.axisX2[h].crosshair && this.axisX2[h].crosshair.enabled && this.axisX2[h].renderCrosshair(a, f);\n        }if (this.axisY && 0 < this.axisY.length) for (h = 0; h < this.axisY.length; h++) {\n          this.axisY[h].crosshair && this.axisY[h].crosshair.enabled && this.axisY[h].renderCrosshair(a, f);\n        }if (this.axisY2 && 0 < this.axisY2.length) for (h = 0; h < this.axisY2.length; h++) {\n          this.axisY2[h].crosshair && this.axisY2[h].crosshair.enabled && this.axisY2[h].renderCrosshair(a, f);\n        }\n      }\n    };q.prototype._plotAreaMouseMove = function (a, f) {\n      if (this.isDrag && \"none\" !== this.plotInfo.axisPlacement) {\n        var b = 0,\n            c = 0,\n            e = b = null,\n            e = 0 <= this.zoomType.indexOf(\"x\"),\n            g = 0 <= this.zoomType.indexOf(\"y\"),\n            h = this;\"xySwapped\" === this.plotInfo.axisPlacement && (b = g, g = e, e = b);b = this.dragStartPoint.x - a;c = this.dragStartPoint.y - f;2 < Math.abs(b) && 8 > Math.abs(b) && (this.panEnabled || this.zoomEnabled) ? this.toolTip.hide() : this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(a, f);if ((!e || 2 < Math.abs(b) || !g || 2 < Math.abs(c)) && (this.panEnabled || this.zoomEnabled)) if (this.panEnabled) e = { x1: e ? this.plotArea.x1 + b : this.plotArea.x1, y1: g ? this.plotArea.y1 + c : this.plotArea.y1, x2: e ? this.plotArea.x2 + b : this.plotArea.x2, y2: g ? this.plotArea.y2 + c : this.plotArea.y2 }, clearTimeout(h._panTimerId), h._panTimerId = setTimeout(function (c, b, e, d) {\n          return function () {\n            h._zoomPanToSelectedRegion(c, b, e, d, !0) && (h._dispatchRangeEvent(\"rangeChanging\", \"pan\"), h.render(), h._dispatchRangeEvent(\"rangeChanged\", \"pan\"), h.dragStartPoint.x = a, h.dragStartPoint.y = f);\n          };\n        }(e.x1, e.y1, e.x2, e.y2), 0);else if (this.zoomEnabled) {\n          this.resetOverlayedCanvas();b = this.overlaidCanvasCtx.globalAlpha;this.overlaidCanvasCtx.fillStyle = \"#A89896\";var c = e ? this.dragStartPoint.x : this.plotArea.x1,\n              l = g ? this.dragStartPoint.y : this.plotArea.y1,\n              t = e ? a - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1,\n              k = g ? f - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1;this.validateRegion(c, l, e ? a : this.plotArea.x2 - this.plotArea.x1, g ? f : this.plotArea.y2 - this.plotArea.y1, \"xy\" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = \"#99B2B5\");this.overlaidCanvasCtx.globalAlpha = 0.7;this.overlaidCanvasCtx.fillRect(c, l, t, k);this.overlaidCanvasCtx.globalAlpha = b;\n        }\n      } else if (this.toolTip.mouseMoveHandler(a, f), \"none\" !== this.plotInfo.axisPlacement) {\n        if (this.axisX && 0 < this.axisX.length) for (e = 0; e < this.axisX.length; e++) {\n          this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && this.axisX[e].renderCrosshair(a, f);\n        }if (this.axisX2 && 0 < this.axisX2.length) for (e = 0; e < this.axisX2.length; e++) {\n          this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled && this.axisX2[e].renderCrosshair(a, f);\n        }if (this.axisY && 0 < this.axisY.length) for (e = 0; e < this.axisY.length; e++) {\n          this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && this.axisY[e].renderCrosshair(a, f);\n        }if (this.axisY2 && 0 < this.axisY2.length) for (e = 0; e < this.axisY2.length; e++) {\n          this.axisY2[e].crosshair && this.axisY2[e].crosshair.enabled && this.axisY2[e].renderCrosshair(a, f);\n        }\n      }\n    };q.prototype._zoomPanToSelectedRegion = function (a, f, b, c, e) {\n      a = this.validateRegion(a, f, b, c, e);f = a.axesWithValidRange;b = a.axesRanges;if (a.isValid) for (c = 0; c < f.length; c++) {\n        e = b[c], f[c].setViewPortRange(e.val1, e.val2);\n      }return a.isValid;\n    };q.prototype.validateRegion = function (a, f, b, c, e) {\n      e = e || !1;for (var g = 0 <= this.zoomType.indexOf(\"x\"), h = 0 <= this.zoomType.indexOf(\"y\"), l = !1, t = [], k = [], r = [], p = 0; p < this._axes.length; p++) {\n        (\"axisX\" === this._axes[p].type && g || \"axisY\" === this._axes[p].type && h) && k.push(this._axes[p]);\n      }for (h = 0; h < k.length; h++) {\n        var p = k[h],\n            g = !1,\n            n = p.convertPixelToValue({ x: a, y: f }),\n            d = p.convertPixelToValue({ x: b, y: c });if (n > d) var w = d,\n            d = n,\n            n = w;if (p.scaleBreaks) for (w = 0; !g && w < p.scaleBreaks._appliedBreaks.length; w++) {\n          g = p.scaleBreaks._appliedBreaks[w].startValue <= n && p.scaleBreaks._appliedBreaks[w].endValue >= d;\n        }if (isFinite(p.dataInfo.minDiff)) if (w = p.getApparentDifference(n, d, null, !0), !(g || !(this.panEnabled && p.scaleBreaks && p.scaleBreaks._appliedBreaks.length) && (p.logarithmic && w < Math.pow(p.dataInfo.minDiff, 3) || !p.logarithmic && w < 3 * Math.abs(p.dataInfo.minDiff)) || n < p.minimum || d > p.maximum)) t.push(p), r.push({ val1: n, val2: d }), l = !0;else if (!e) {\n          l = !1;break;\n        }\n      }return { isValid: l, axesWithValidRange: t, axesRanges: r };\n    };q.prototype.preparePlotArea = function () {\n      var a = this.plotArea;!v && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1);if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {\n        var f = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates;\n        if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {\n          var b = this.axisY[0];a.x1 = f.x1 < f.x2 ? f.x1 : b.lineCoordinates.x1;a.y1 = f.y1 < b.lineCoordinates.y1 ? f.y1 : b.lineCoordinates.y1;a.x2 = f.x2 > b.lineCoordinates.x2 ? f.x2 : b.lineCoordinates.x2;a.y2 = f.y2 > f.y1 ? f.y2 : b.lineCoordinates.y2;a.width = a.x2 - a.x1;a.height = a.y2 - a.y1;\n        }this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (b = this.axisY2[0], a.x1 = f.x1 < f.x2 ? f.x1 : b.lineCoordinates.x1, a.y1 = f.y1 < b.lineCoordinates.y1 ? f.y1 : b.lineCoordinates.y1, a.x2 = f.x2 > b.lineCoordinates.x2 ? f.x2 : b.lineCoordinates.x2, a.y2 = f.y2 > f.y1 ? f.y2 : b.lineCoordinates.y2, a.width = a.x2 - a.x1, a.height = a.y2 - a.y1);\n      } else f = this.layoutManager.getFreeSpace(), a.x1 = f.x1, a.x2 = f.x2, a.y1 = f.y1, a.y2 = f.y2, a.width = f.width, a.height = f.height;v || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left = a.x1 + \"px\", a.canvas.style.top = a.y1 + \"px\", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(-a.x1, -a.y1));a.layoutManager = new Ea(a.x1, a.y1, a.x2, a.y2, 2);\n    };q.prototype.renderIndexLabels = function (a) {\n      var f = a || this.plotArea.ctx,\n          b = this.plotArea,\n          c = 0,\n          e = 0,\n          g = 0,\n          h = 0,\n          l = c = h = e = g = 0,\n          t = 0;for (a = 0; a < this._indexLabels.length; a++) {\n        var k = this._indexLabels[a],\n            r = k.chartType.toLowerCase(),\n            p,\n            n,\n            l = na(\"indexLabelFontColor\", k.dataPoint, k.dataSeries),\n            t = na(\"indexLabelFontSize\", k.dataPoint, k.dataSeries);p = na(\"indexLabelFontFamily\", k.dataPoint, k.dataSeries);n = na(\"indexLabelFontStyle\", k.dataPoint, k.dataSeries);var h = na(\"indexLabelFontWeight\", k.dataPoint, k.dataSeries),\n            d = na(\"indexLabelBackgroundColor\", k.dataPoint, k.dataSeries),\n            e = na(\"indexLabelMaxWidth\", k.dataPoint, k.dataSeries),\n            g = na(\"indexLabelWrap\", k.dataPoint, k.dataSeries),\n            w = na(\"indexLabelLineDashType\", k.dataPoint, k.dataSeries),\n            m = na(\"indexLabelLineColor\", k.dataPoint, k.dataSeries),\n            D = y(k.dataPoint.indexLabelLineThickness) ? y(k.dataSeries.options.indexLabelLineThickness) ? 0 : k.dataSeries.options.indexLabelLineThickness : k.dataPoint.indexLabelLineThickness,\n            c = 0 < D ? Math.min(10, (\"normal\" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0,\n            u = { percent: null, total: null },\n            S = null;if (0 <= k.dataSeries.type.indexOf(\"stacked\") || \"pie\" === k.dataSeries.type || \"doughnut\" === k.dataSeries.type) u = this.getPercentAndTotal(k.dataSeries, k.dataPoint);if (k.dataSeries.indexLabelFormatter || k.dataPoint.indexLabelFormatter) S = { chart: this, dataSeries: k.dataSeries, dataPoint: k.dataPoint, index: k.indexKeyword, total: u.total, percent: u.percent };var ca = k.dataPoint.indexLabelFormatter ? k.dataPoint.indexLabelFormatter(S) : k.dataPoint.indexLabel ? this.replaceKeywordsWithValue(k.dataPoint.indexLabel, k.dataPoint, k.dataSeries, null, k.indexKeyword) : k.dataSeries.indexLabelFormatter ? k.dataSeries.indexLabelFormatter(S) : k.dataSeries.indexLabel ? this.replaceKeywordsWithValue(k.dataSeries.indexLabel, k.dataPoint, k.dataSeries, null, k.indexKeyword) : null;if (null !== ca && \"\" !== ca) {\n          var u = na(\"indexLabelPlacement\", k.dataPoint, k.dataSeries),\n              S = na(\"indexLabelOrientation\", k.dataPoint, k.dataSeries),\n              s = k.direction,\n              q = k.dataSeries.axisX,\n              A = k.dataSeries.axisY,\n              x = !1,\n              d = new la(f, { x: 0, y: 0, maxWidth: e ? e : 0.5 * this.width, maxHeight: g ? 5 * t : 1.5 * t, angle: \"horizontal\" === S ? 0 : -90, text: ca, padding: 0, backgroundColor: d, horizontalAlign: \"left\",\n            fontSize: t, fontFamily: p, fontWeight: h, fontColor: l, fontStyle: n, textBaseline: \"top\" });d.measureText();k.dataSeries.indexLabelMaxWidth = d.maxWidth;if (\"stackedarea100\" === r) {\n            if (k.point.x < b.x1 || k.point.x > b.x2 || k.point.y < b.y1 - 1 || k.point.y > b.y2 + 1) continue;\n          } else if (\"rangearea\" === r || \"rangesplinearea\" === r) {\n            if (k.dataPoint.x < q.viewportMinimum || k.dataPoint.x > q.viewportMaximum || Math.max.apply(null, k.dataPoint.y) < A.viewportMinimum || Math.min.apply(null, k.dataPoint.y) > A.viewportMaximum) continue;\n          } else if (0 <= r.indexOf(\"line\") || 0 <= r.indexOf(\"area\") || 0 <= r.indexOf(\"bubble\") || 0 <= r.indexOf(\"scatter\")) {\n            if (k.dataPoint.x < q.viewportMinimum || k.dataPoint.x > q.viewportMaximum || k.dataPoint.y < A.viewportMinimum || k.dataPoint.y > A.viewportMaximum) continue;\n          } else if (0 <= r.indexOf(\"column\") || \"waterfall\" === r || \"error\" === r && !k.axisSwapped) {\n            if (k.dataPoint.x < q.viewportMinimum || k.dataPoint.x > q.viewportMaximum || k.bounds.y1 > b.y2 || k.bounds.y2 < b.y1) continue;\n          } else if (0 <= r.indexOf(\"bar\") || \"error\" === r) {\n            if (k.dataPoint.x < q.viewportMinimum || k.dataPoint.x > q.viewportMaximum || k.bounds.x1 > b.x2 || k.bounds.x2 < b.x1) continue;\n          } else if (\"candlestick\" === r || \"ohlc\" === r) {\n            if (k.dataPoint.x < q.viewportMinimum || k.dataPoint.x > q.viewportMaximum || Math.max.apply(null, k.dataPoint.y) < A.viewportMinimum || Math.min.apply(null, k.dataPoint.y) > A.viewportMaximum) continue;\n          } else if (k.dataPoint.x < q.viewportMinimum || k.dataPoint.x > q.viewportMaximum) continue;e = h = 2;\"horizontal\" === S ? (l = d.width, t = d.height) : (t = d.width, l = d.height);if (\"normal\" === this.plotInfo.axisPlacement) {\n            if (0 <= r.indexOf(\"line\") || 0 <= r.indexOf(\"area\")) u = \"auto\", h = 4;else if (0 <= r.indexOf(\"stacked\")) \"auto\" === u && (u = \"inside\");else if (\"bubble\" === r || \"scatter\" === r) u = \"inside\";p = k.point.x - l / 2;\"inside\" !== u ? (e = b.y1, g = b.y2, 0 < s ? (n = k.point.y - t - h - c, n < e && (n = \"auto\" === u ? Math.max(k.point.y, e) + h + c : e + h + c, x = n + t > k.point.y)) : (n = k.point.y + h + c, n > g - t - h - c && (n = \"auto\" === u ? Math.min(k.point.y, g) - t - h - c : g - t - h - c, x = n < k.point.y))) : (e = Math.max(k.bounds.y1, b.y1), g = Math.min(k.bounds.y2, b.y2), c = 0 <= r.indexOf(\"range\") || \"error\" === r ? 0 < s ? Math.max(k.bounds.y1, b.y1) + t / 2 + h : Math.min(k.bounds.y2, b.y2) - t / 2 - h : (Math.max(k.bounds.y1, b.y1) + Math.min(k.bounds.y2, b.y2)) / 2, 0 < s ? (n = Math.max(k.point.y, c) - t / 2, n < e && (\"bubble\" === r || \"scatter\" === r) && (n = Math.max(k.point.y - t - h, b.y1 + h))) : (n = Math.min(k.point.y, c) - t / 2, n > g - t - h && (\"bubble\" === r || \"scatter\" === r) && (n = Math.min(k.point.y + h, b.y2 - t - h))), n = Math.min(n, g - t));\n          } else 0 <= r.indexOf(\"line\") || 0 <= r.indexOf(\"area\") || 0 <= r.indexOf(\"scatter\") ? (u = \"auto\", e = 4) : 0 <= r.indexOf(\"stacked\") ? \"auto\" === u && (u = \"inside\") : \"bubble\" === r && (u = \"inside\"), n = k.point.y - t / 2, \"inside\" !== u ? (h = b.x1, g = b.x2, 0 > s ? (p = k.point.x - l - e - c, p < h && (p = \"auto\" === u ? Math.max(k.point.x, h) + e + c : h + e + c, x = p + l > k.point.x)) : (p = k.point.x + e + c, p > g - l - e - c && (p = \"auto\" === u ? Math.min(k.point.x, g) - l - e - c : g - l - e - c, x = p < k.point.x))) : (h = Math.max(k.bounds.x1, b.x1), Math.min(k.bounds.x2, b.x2), c = 0 <= r.indexOf(\"range\") || \"error\" === r ? 0 > s ? Math.max(k.bounds.x1, b.x1) + l / 2 + e : Math.min(k.bounds.x2, b.x2) - l / 2 - e : (Math.max(k.bounds.x1, b.x1) + Math.min(k.bounds.x2, b.x2)) / 2, p = 0 > s ? Math.max(k.point.x, c) - l / 2 : Math.min(k.point.x, c) - l / 2, p = Math.max(p, h));\"vertical\" === S && (n += t);d.x = p;d.y = n;d.render(!0);D && \"inside\" !== u && (0 > r.indexOf(\"bar\") && (\"error\" !== r || !k.axisSwapped) && k.point.x > b.x1 && k.point.x < b.x2 || !x) && (0 > r.indexOf(\"column\") && (\"error\" !== r || k.axisSwapped) && k.point.y > b.y1 && k.point.y < b.y2 || !x) && (f.lineWidth = D, f.strokeStyle = m ? m : \"gray\", f.setLineDash && f.setLineDash(G(w, D)), f.beginPath(), f.moveTo(k.point.x, k.point.y), 0 <= r.indexOf(\"bar\") || \"error\" === r && k.axisSwapped ? f.lineTo(p + (0 < k.direction ? 0 : l), n + (\"horizontal\" === S ? t : -t) / 2) : 0 <= r.indexOf(\"column\") || \"error\" === r && !k.axisSwapped ? f.lineTo(p + l / 2, n + ((0 < k.direction ? t : -t) + (\"horizontal\" === S ? t : -t)) / 2) : f.lineTo(p + l / 2, n + ((n < k.point.y ? t : -t) + (\"horizontal\" === S ? t : -t)) / 2), f.stroke());\n        }\n      }f = { source: f, dest: this.plotArea.ctx, animationCallback: H.fadeInAnimation, easingFunction: H.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 };for (a = 0; a < this._indexLabels.length; a++) {\n        k = this._indexLabels[a], d = na(\"indexLabelBackgroundColor\", k.dataPoint, k.dataSeries), k.dataSeries.indexLabelBackgroundColor = y(d) ? v ? \"transparent\" : null : d;\n      }return f;\n    };q.prototype.renderLine = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = this._eventManager.ghostCtx;b.save();var e = this.plotArea;b.beginPath();b.rect(e.x1, e.y1, e.width, e.height);b.clip();for (var g = [], h, l = 0; l < a.dataSeriesIndexes.length; l++) {\n          var t = a.dataSeriesIndexes[l],\n              k = this.data[t];b.lineWidth = k.lineThickness;var r = k.dataPoints,\n              p = \"solid\";if (b.setLineDash) {\n            var n = G(k.nullDataLineDashType, k.lineThickness),\n                p = k.lineDashType,\n                d = G(p, k.lineThickness);b.setLineDash(d);\n          }var w = k.id;this._eventManager.objectMap[w] = { objectType: \"dataSeries\", dataSeriesIndex: t };w = R(w);c.strokeStyle = w;c.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;var w = k._colorSet,\n              m = w = k.lineColor = k.options.lineColor ? k.options.lineColor : w[0];b.strokeStyle = w;var D = !0,\n              u = 0,\n              S,\n              ca;b.beginPath();if (0 < r.length) {\n            for (var s = !1, u = 0; u < r.length; u++) {\n              if (S = r[u].x.getTime ? r[u].x.getTime() : r[u].x, !(S < a.axisX.dataInfo.viewPortMin || S > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !s))) if (\"number\" !== typeof r[u].y) 0 < u && !(k.connectNullData || s || D) && (b.stroke(), v && c.stroke()), s = !0;else {\n                S = a.axisX.convertValueToPixel(S);ca = a.axisY.convertValueToPixel(r[u].y);var q = k.dataPointIds[u];this._eventManager.objectMap[q] = { id: q, objectType: \"dataPoint\", dataSeriesIndex: t, dataPointIndex: u, x1: S, y1: ca };D || s ? (!D && k.connectNullData ? (b.setLineDash && (k.options.nullDataLineDashType || p === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (b.stroke(), b.beginPath(), b.moveTo(h.x, h.y), p = k.nullDataLineDashType, b.setLineDash(n)), b.lineTo(S, ca), v && c.lineTo(S, ca)) : (b.beginPath(), b.moveTo(S, ca), v && (c.beginPath(), c.moveTo(S, ca))), s = D = !1) : (b.lineTo(S, ca), v && c.lineTo(S, ca), 0 == u % 500 && (b.stroke(), b.beginPath(), b.moveTo(S, ca), v && (c.stroke(), c.beginPath(), c.moveTo(S, ca))));h = { x: S, y: ca };u < r.length - 1 && (m !== (r[u].lineColor || w) || p !== (r[u].lineDashType || k.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(S, ca), m = r[u].lineColor || w, b.strokeStyle = m, b.setLineDash && (r[u].lineDashType ? (p = r[u].lineDashType, b.setLineDash(G(p, k.lineThickness))) : (p = k.lineDashType, b.setLineDash(d))));if (0 < r[u].markerSize || 0 < k.markerSize) {\n                  var A = k.getMarkerProperties(u, S, ca, b);g.push(A);q = R(q);v && g.push({ x: S, y: ca, ctx: c, type: A.type, size: A.size, color: q, borderColor: q, borderThickness: A.borderThickness });\n                }(r[u].indexLabel || k.indexLabel || r[u].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: \"line\", dataPoint: r[u], dataSeries: k, point: { x: S, y: ca }, direction: 0 > r[u].y === a.axisY.reversed ? 1 : -1, color: w });\n              }\n            }b.stroke();v && c.stroke();\n          }\n        }ja.drawMarkers(g);v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), c.beginPath());b.restore();b.beginPath();return { source: f, dest: this.plotArea.ctx, animationCallback: H.xClipAnimation, easingFunction: H.easing.linear,\n          animationBase: 0 };\n      }\n    };q.prototype.renderStepLine = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = this._eventManager.ghostCtx;b.save();var e = this.plotArea;b.beginPath();b.rect(e.x1, e.y1, e.width, e.height);b.clip();for (var g = [], h, l = 0; l < a.dataSeriesIndexes.length; l++) {\n          var t = a.dataSeriesIndexes[l],\n              k = this.data[t];b.lineWidth = k.lineThickness;var r = k.dataPoints,\n              p = \"solid\";if (b.setLineDash) {\n            var n = G(k.nullDataLineDashType, k.lineThickness),\n                p = k.lineDashType,\n                d = G(p, k.lineThickness);b.setLineDash(d);\n          }var w = k.id;this._eventManager.objectMap[w] = { objectType: \"dataSeries\", dataSeriesIndex: t };w = R(w);c.strokeStyle = w;c.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;var w = k._colorSet,\n              m = w = k.lineColor = k.options.lineColor ? k.options.lineColor : w[0];b.strokeStyle = w;var D = !0,\n              u = 0,\n              S,\n              ca;b.beginPath();if (0 < r.length) {\n            for (var s = !1, u = 0; u < r.length; u++) {\n              if (S = r[u].getTime ? r[u].x.getTime() : r[u].x, !(S < a.axisX.dataInfo.viewPortMin || S > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !s))) if (\"number\" !== typeof r[u].y) 0 < u && !(k.connectNullData || s || D) && (b.stroke(), v && c.stroke()), s = !0;else {\n                var q = ca;S = a.axisX.convertValueToPixel(S);ca = a.axisY.convertValueToPixel(r[u].y);var A = k.dataPointIds[u];this._eventManager.objectMap[A] = { id: A, objectType: \"dataPoint\", dataSeriesIndex: t, dataPointIndex: u, x1: S, y1: ca };D || s ? (!D && k.connectNullData ? (b.setLineDash && (k.options.nullDataLineDashType || p === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (b.stroke(), b.beginPath(), b.moveTo(h.x, h.y), p = k.nullDataLineDashType, b.setLineDash(n)), b.lineTo(S, q), b.lineTo(S, ca), v && (c.lineTo(S, q), c.lineTo(S, ca))) : (b.beginPath(), b.moveTo(S, ca), v && (c.beginPath(), c.moveTo(S, ca))), s = D = !1) : (b.lineTo(S, q), v && c.lineTo(S, q), b.lineTo(S, ca), v && c.lineTo(S, ca), 0 == u % 500 && (b.stroke(), b.beginPath(), b.moveTo(S, ca), v && (c.stroke(), c.beginPath(), c.moveTo(S, ca))));h = { x: S, y: ca };u < r.length - 1 && (m !== (r[u].lineColor || w) || p !== (r[u].lineDashType || k.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(S, ca), m = r[u].lineColor || w, b.strokeStyle = m, b.setLineDash && (r[u].lineDashType ? (p = r[u].lineDashType, b.setLineDash(G(p, k.lineThickness))) : (p = k.lineDashType, b.setLineDash(d))));if (0 < r[u].markerSize || 0 < k.markerSize) q = k.getMarkerProperties(u, S, ca, b), g.push(q), A = R(A), v && g.push({ x: S, y: ca, ctx: c, type: q.type, size: q.size, color: A, borderColor: A, borderThickness: q.borderThickness });(r[u].indexLabel || k.indexLabel || r[u].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stepLine\", dataPoint: r[u], dataSeries: k, point: { x: S,\n                    y: ca }, direction: 0 > r[u].y === a.axisY.reversed ? 1 : -1, color: w });\n              }\n            }b.stroke();v && c.stroke();\n          }\n        }ja.drawMarkers(g);v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), c.beginPath());b.restore();b.beginPath();return { source: f, dest: this.plotArea.ctx, animationCallback: H.xClipAnimation, easingFunction: H.easing.linear, animationBase: 0 };\n      }\n    };q.prototype.renderSpline = function (a) {\n      function f(a) {\n        a = x(a, 2);if (0 < a.length) {\n          c.beginPath();v && e.beginPath();c.moveTo(a[0].x, a[0].y);a[0].newStrokeStyle && (c.strokeStyle = a[0].newStrokeStyle);a[0].newLineDashArray && c.setLineDash(a[0].newLineDashArray);v && e.moveTo(a[0].x, a[0].y);for (var b = 0; b < a.length - 3; b += 3) {\n            if (c.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y), v && e.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y), 0 < b && 0 === b % 3E3 || a[b + 3].newStrokeStyle || a[b + 3].newLineDashArray) c.stroke(), c.beginPath(), c.moveTo(a[b + 3].x, a[b + 3].y), a[b + 3].newStrokeStyle && (c.strokeStyle = a[b + 3].newStrokeStyle), a[b + 3].newLineDashArray && c.setLineDash(a[b + 3].newLineDashArray), v && (e.stroke(), e.beginPath(), e.moveTo(a[b + 3].x, a[b + 3].y));\n          }c.stroke();v && e.stroke();\n        }\n      }var b = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : b;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var e = this._eventManager.ghostCtx;c.save();var g = this.plotArea;c.beginPath();c.rect(g.x1, g.y1, g.width, g.height);c.clip();for (var h = [], l = 0; l < a.dataSeriesIndexes.length; l++) {\n          var t = a.dataSeriesIndexes[l],\n              k = this.data[t];c.lineWidth = k.lineThickness;var r = k.dataPoints,\n              p = \"solid\";if (c.setLineDash) {\n            var n = G(k.nullDataLineDashType, k.lineThickness),\n                p = k.lineDashType,\n                d = G(p, k.lineThickness);c.setLineDash(d);\n          }var w = k.id;this._eventManager.objectMap[w] = { objectType: \"dataSeries\",\n            dataSeriesIndex: t };w = R(w);e.strokeStyle = w;e.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;var w = k._colorSet,\n              m = w = k.lineColor = k.options.lineColor ? k.options.lineColor : w[0];c.strokeStyle = w;var D = 0,\n              u,\n              S,\n              q = [];c.beginPath();if (0 < r.length) for (S = !1, D = 0; D < r.length; D++) {\n            if (u = r[D].getTime ? r[D].x.getTime() : r[D].x, !(u < a.axisX.dataInfo.viewPortMin || u > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !S))) if (\"number\" !== typeof r[D].y) 0 < D && !S && (k.connectNullData ? c.setLineDash && 0 < q.length && (k.options.nullDataLineDashType || !r[D - 1].lineDashType) && (q[q.length - 1].newLineDashArray = n, p = k.nullDataLineDashType) : (f(q), q = [])), S = !0;else {\n              u = a.axisX.convertValueToPixel(u);S = a.axisY.convertValueToPixel(r[D].y);var s = k.dataPointIds[D];this._eventManager.objectMap[s] = { id: s, objectType: \"dataPoint\", dataSeriesIndex: t, dataPointIndex: D, x1: u, y1: S };q[q.length] = { x: u, y: S };D < r.length - 1 && (m !== (r[D].lineColor || w) || p !== (r[D].lineDashType || k.lineDashType)) && (m = r[D].lineColor || w, q[q.length - 1].newStrokeStyle = m, c.setLineDash && (r[D].lineDashType ? (p = r[D].lineDashType, q[q.length - 1].newLineDashArray = G(p, k.lineThickness)) : (p = k.lineDashType, q[q.length - 1].newLineDashArray = d)));if (0 < r[D].markerSize || 0 < k.markerSize) {\n                var y = k.getMarkerProperties(D, u, S, c);h.push(y);s = R(s);v && h.push({ x: u, y: S, ctx: e, type: y.type, size: y.size, color: s, borderColor: s, borderThickness: y.borderThickness });\n              }(r[D].indexLabel || k.indexLabel || r[D].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: \"spline\", dataPoint: r[D], dataSeries: k, point: { x: u, y: S }, direction: 0 > r[D].y === a.axisY.reversed ? 1 : -1, color: w });S = !1;\n            }\n          }f(q);\n        }ja.drawMarkers(h);v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(g.x1, g.y1, g.width, g.height), e.beginPath());c.restore();\n        c.beginPath();return { source: b, dest: this.plotArea.ctx, animationCallback: H.xClipAnimation, easingFunction: H.easing.linear, animationBase: 0 };\n      }\n    };var V = function V(a, f, b, c, e, g, h, l, t, k, r, p, n) {\n      \"undefined\" === typeof n && (n = 1);h = h || 0;l = l || \"black\";var d = 15 < c - f && 15 < e - b ? 8 : 0.35 * Math.min(c - f, e - b);a.beginPath();a.moveTo(f, b);a.save();a.fillStyle = g;a.globalAlpha = n;a.fillRect(f, b, c - f, e - b);a.globalAlpha = 1;0 < h && (n = 0 === h % 2 ? 0 : 0.5, a.beginPath(), a.lineWidth = h, a.strokeStyle = l, a.moveTo(f, b), a.rect(f - n, b - n, c - f + 2 * n, e - b + 2 * n), a.stroke());\n      a.restore();!0 === t && (a.save(), a.beginPath(), a.moveTo(f, b), a.lineTo(f + d, b + d), a.lineTo(c - d, b + d), a.lineTo(c, b), a.closePath(), h = a.createLinearGradient((c + f) / 2, b + d, (c + f) / 2, b), h.addColorStop(0, g), h.addColorStop(1, \"rgba(255, 255, 255, .4)\"), a.fillStyle = h, a.fill(), a.restore());!0 === k && (a.save(), a.beginPath(), a.moveTo(f, e), a.lineTo(f + d, e - d), a.lineTo(c - d, e - d), a.lineTo(c, e), a.closePath(), h = a.createLinearGradient((c + f) / 2, e - d, (c + f) / 2, e), h.addColorStop(0, g), h.addColorStop(1, \"rgba(255, 255, 255, .4)\"), a.fillStyle = h, a.fill(), a.restore());!0 === r && (a.save(), a.beginPath(), a.moveTo(f, b), a.lineTo(f + d, b + d), a.lineTo(f + d, e - d), a.lineTo(f, e), a.closePath(), h = a.createLinearGradient(f + d, (e + b) / 2, f, (e + b) / 2), h.addColorStop(0, g), h.addColorStop(1, \"rgba(255, 255, 255, 0.1)\"), a.fillStyle = h, a.fill(), a.restore());!0 === p && (a.save(), a.beginPath(), a.moveTo(c, b), a.lineTo(c - d, b + d), a.lineTo(c - d, e - d), a.lineTo(c, e), h = a.createLinearGradient(c - d, (e + b) / 2, c, (e + b) / 2), h.addColorStop(0, g), h.addColorStop(1, \"rgba(255, 255, 255, 0.1)\"), a.fillStyle = h, h.addColorStop(0, g), h.addColorStop(1, \"rgba(255, 255, 255, 0.1)\"), a.fillStyle = h, a.fill(), a.closePath(), a.restore());\n    };q.prototype.renderColumn = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = null,\n            e = this.plotArea,\n            g = 0,\n            h,\n            l,\n            t,\n            k = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            g = this.dataPointMinWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1,\n            r = this.dataPointMaxWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0,\n            p = a.axisX.dataInfo.minDiff;isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));p = this.dataPointWidth = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;this.dataPointMaxWidth && g > r && (g = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, r));!this.dataPointMaxWidth && this.dataPointMinWidth && r < g && (r = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, g));p < g && (p = g);p > r && (p = r);b.save();v && this._eventManager.ghostCtx.save();b.beginPath();b.rect(e.x1, e.y1, e.width, e.height);b.clip();v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());for (r = 0; r < a.dataSeriesIndexes.length; r++) {\n          var n = a.dataSeriesIndexes[r],\n              d = this.data[n],\n              w = d.dataPoints;if (0 < w.length) for (var m = 5 < p && d.bevelEnabled ? !0 : !1, g = 0; g < w.length; g++) {\n            if (w[g].getTime ? t = w[g].x.getTime() : t = w[g].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof w[g].y) {\n              h = a.axisX.convertValueToPixel(t);l = a.axisY.convertValueToPixel(w[g].y);h = a.axisX.reversed ? h + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + r) * p << 0 : h - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + r) * p << 0;var D = a.axisX.reversed ? h - p << 0 : h + p << 0,\n                  u;0 <= w[g].y ? u = k : (u = l, l = k);l > u && (c = l, l = u, u = c);c = w[g].color ? w[g].color : d._colorSet[g % d._colorSet.length];V(b, h, l, D, u, c, 0, null, m && 0 <= w[g].y, 0 > w[g].y && m, !1, !1, d.fillOpacity);c = d.dataPointIds[g];this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: n, dataPointIndex: g, x1: h, y1: l, x2: D, y2: u };c = R(c);v && V(this._eventManager.ghostCtx, h, l, D, u, c, 0, null, !1, !1, !1, !1);(w[g].indexLabel || d.indexLabel || w[g].indexLabelFormatter || d.indexLabelFormatter) && this._indexLabels.push({ chartType: \"column\", dataPoint: w[g], dataSeries: d,\n                point: { x: h + (D - h) / 2, y: 0 > w[g].y === a.axisY.reversed ? l : u }, direction: 0 > w[g].y === a.axisY.reversed ? 1 : -1, bounds: { x1: h, y1: Math.min(l, u), x2: D, y2: Math.max(l, u) }, color: c });\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.yScaleAnimation, easingFunction: H.easing.easeOutQuart, animationBase: k < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : k > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : k };\n      }\n    };q.prototype.renderStackedColumn = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = null,\n            e = this.plotArea,\n            g = [],\n            h = [],\n            l = [],\n            t = [],\n            k = 0,\n            r,\n            p,\n            n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            k = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;r = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0;var d = a.axisX.dataInfo.minDiff;isFinite(d) || (d = 0.3 * Math.abs(a.axisX.range));d = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(d) / Math.log(a.axisX.range) : Math.abs(d) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;this.dataPointMaxWidth && k > r && (k = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, r));!this.dataPointMaxWidth && this.dataPointMinWidth && r < k && (r = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, k));d < k && (d = k);d > r && (d = r);b.save();v && this._eventManager.ghostCtx.save();b.beginPath();b.rect(e.x1, e.y1, e.width, e.height);b.clip();v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());for (var w = 0; w < a.dataSeriesIndexes.length; w++) {\n          var m = a.dataSeriesIndexes[w],\n              D = this.data[m],\n              u = D.dataPoints;if (0 < u.length) {\n            var q = 5 < d && D.bevelEnabled ? !0 : !1;b.strokeStyle = \"#4572A7 \";for (k = 0; k < u.length; k++) {\n              if (c = u[k].x.getTime ? u[k].x.getTime() : u[k].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof u[k].y) {\n                r = a.axisX.convertValueToPixel(c);var s = r - a.plotType.plotUnits.length * d / 2 + a.index * d << 0,\n                    y = s + d << 0,\n                    B;if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < u[k].y) l[c] = u[k].y + (l[c] ? l[c] : 0), 0 < l[c] && (p = a.axisY.convertValueToPixel(l[c]), B = \"undefined\" !== typeof g[c] ? g[c] : n, g[c] = p);else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= u[k].y) t[c] = u[k].y + (t[c] ? t[c] : 0), B = a.axisY.convertValueToPixel(t[c]), p = \"undefined\" !== typeof h[c] ? h[c] : n, h[c] = B;else if (p = a.axisY.convertValueToPixel(u[k].y), 0 <= u[k].y) {\n                  var A = \"undefined\" !== typeof g[c] ? g[c] : 0;p -= A;B = n - A;g[c] = A + (B - p);\n                } else A = h[c] ? h[c] : 0, B = p + A, p = n + A, h[c] = A + (B - p);c = u[k].color ? u[k].color : D._colorSet[k % D._colorSet.length];V(b, s, p, y, B, c, 0, null, q && 0 <= u[k].y, 0 > u[k].y && q, !1, !1, D.fillOpacity);c = D.dataPointIds[k];this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: m, dataPointIndex: k, x1: s, y1: p, x2: y, y2: B };c = R(c);v && V(this._eventManager.ghostCtx, s, p, y, B, c, 0, null, !1, !1, !1, !1);(u[k].indexLabel || D.indexLabel || u[k].indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedColumn\", dataPoint: u[k], dataSeries: D,\n                  point: { x: r, y: 0 <= u[k].y ? p : B }, direction: 0 > u[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: s, y1: Math.min(p, B), x2: y, y2: Math.max(p, B) }, color: c });\n              }\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.yScaleAnimation, easingFunction: H.easing.easeOutQuart, animationBase: n < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : n > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : n };\n      }\n    };q.prototype.renderStackedColumn100 = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = null,\n            e = this.plotArea,\n            g = [],\n            h = [],\n            l = [],\n            t = [],\n            k = 0,\n            r,\n            p,\n            n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            k = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;r = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0;var d = a.axisX.dataInfo.minDiff;isFinite(d) || (d = 0.3 * Math.abs(a.axisX.range));d = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(d) / Math.log(a.axisX.range) : Math.abs(d) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;this.dataPointMaxWidth && k > r && (k = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, r));!this.dataPointMaxWidth && this.dataPointMinWidth && r < k && (r = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, k));d < k && (d = k);d > r && (d = r);b.save();v && this._eventManager.ghostCtx.save();b.beginPath();b.rect(e.x1, e.y1, e.width, e.height);b.clip();v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\n        for (var w = 0; w < a.dataSeriesIndexes.length; w++) {\n          var m = a.dataSeriesIndexes[w],\n              D = this.data[m],\n              u = D.dataPoints;if (0 < u.length) for (var q = 5 < d && D.bevelEnabled ? !0 : !1, k = 0; k < u.length; k++) {\n            if (c = u[k].x.getTime ? u[k].x.getTime() : u[k].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof u[k].y) {\n              r = a.axisX.convertValueToPixel(c);p = 0 !== a.dataPointYSums[c] ? 100 * (u[k].y / a.dataPointYSums[c]) : 0;var s = r - a.plotType.plotUnits.length * d / 2 + a.index * d << 0,\n                  y = s + d << 0,\n                  B;if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < u[k].y) {\n                l[c] = p + (\"undefined\" !== typeof l[c] ? l[c] : 0);if (0 >= l[c]) continue;p = a.axisY.convertValueToPixel(l[c]);B = g[c] ? g[c] : n;g[c] = p;\n              } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= u[k].y) t[c] = p + (\"undefined\" !== typeof t[c] ? t[c] : 0), B = a.axisY.convertValueToPixel(t[c]), p = h[c] ? h[c] : n, h[c] = B;else if (p = a.axisY.convertValueToPixel(p), 0 <= u[k].y) {\n                var A = \"undefined\" !== typeof g[c] ? g[c] : 0;p -= A;B = n - A;g[c] = A + (B - p);\n              } else A = \"undefined\" !== typeof h[c] ? h[c] : 0, B = p + A, p = n + A, h[c] = A + (B - p);c = u[k].color ? u[k].color : D._colorSet[k % D._colorSet.length];V(b, s, p, y, B, c, 0, null, q && 0 <= u[k].y, 0 > u[k].y && q, !1, !1, D.fillOpacity);c = D.dataPointIds[k];this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: m, dataPointIndex: k, x1: s, y1: p, x2: y, y2: B };c = R(c);v && V(this._eventManager.ghostCtx, s, p, y, B, c, 0, null, !1, !1, !1, !1);(u[k].indexLabel || D.indexLabel || u[k].indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedColumn100\", dataPoint: u[k],\n                dataSeries: D, point: { x: r, y: 0 <= u[k].y ? p : B }, direction: 0 > u[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: s, y1: Math.min(p, B), x2: y, y2: Math.max(p, B) }, color: c });\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.yScaleAnimation, easingFunction: H.easing.easeOutQuart, animationBase: n < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : n > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : n };\n      }\n    };q.prototype.renderBar = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = null,\n            e = this.plotArea,\n            g = 0,\n            h,\n            l,\n            t,\n            k = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            g = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1,\n            r = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0,\n            p = a.axisX.dataInfo.minDiff;isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));p = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;this.dataPointMaxWidth && g > r && (g = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, r));!this.dataPointMaxWidth && this.dataPointMinWidth && r < g && (r = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, g));p < g && (p = g);p > r && (p = r);b.save();v && this._eventManager.ghostCtx.save();b.beginPath();b.rect(e.x1, e.y1, e.width, e.height);b.clip();v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\n        for (r = 0; r < a.dataSeriesIndexes.length; r++) {\n          var n = a.dataSeriesIndexes[r],\n              d = this.data[n],\n              w = d.dataPoints;if (0 < w.length) {\n            var m = 5 < p && d.bevelEnabled ? !0 : !1;b.strokeStyle = \"#4572A7 \";for (g = 0; g < w.length; g++) {\n              if (w[g].getTime ? t = w[g].x.getTime() : t = w[g].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof w[g].y) {\n                l = a.axisX.convertValueToPixel(t);h = a.axisY.convertValueToPixel(w[g].y);l = a.axisX.reversed ? l + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + r) * p << 0 : l - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + r) * p << 0;var D = a.axisX.reversed ? l - p << 0 : l + p << 0,\n                    u;0 <= w[g].y ? u = k : (u = h, h = k);c = w[g].color ? w[g].color : d._colorSet[g % d._colorSet.length];V(b, u, l, h, D, c, 0, null, m, !1, !1, !1, d.fillOpacity);c = d.dataPointIds[g];this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: n, dataPointIndex: g, x1: u, y1: l, x2: h, y2: D };c = R(c);v && V(this._eventManager.ghostCtx, u, l, h, D, c, 0, null, !1, !1, !1, !1);(w[g].indexLabel || d.indexLabel || w[g].indexLabelFormatter || d.indexLabelFormatter) && this._indexLabels.push({ chartType: \"bar\",\n                  dataPoint: w[g], dataSeries: d, point: { x: 0 <= w[g].y ? h : u, y: l + (D - l) / 2 }, direction: 0 > w[g].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(u, h), y1: l, x2: Math.max(u, h), y2: D }, color: c });\n              }\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.xScaleAnimation, easingFunction: H.easing.easeOutQuart, animationBase: k < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : k > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : k };\n      }\n    };q.prototype.renderStackedBar = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = null,\n            e = this.plotArea,\n            g = [],\n            h = [],\n            l = [],\n            t = [],\n            k = 0,\n            r,\n            p,\n            n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            k = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;p = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0;var d = a.axisX.dataInfo.minDiff;isFinite(d) || (d = 0.3 * Math.abs(a.axisX.range));d = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(d) / Math.log(a.axisX.range) : Math.abs(d) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;this.dataPointMaxWidth && k > p && (k = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, p));!this.dataPointMaxWidth && this.dataPointMinWidth && p < k && (p = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, k));d < k && (d = k);d > p && (d = p);b.save();v && this._eventManager.ghostCtx.save();b.beginPath();b.rect(e.x1, e.y1, e.width, e.height);b.clip();v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());for (var w = 0; w < a.dataSeriesIndexes.length; w++) {\n          var m = a.dataSeriesIndexes[w],\n              D = this.data[m],\n              u = D.dataPoints;if (0 < u.length) {\n            var q = 5 < d && D.bevelEnabled ? !0 : !1;b.strokeStyle = \"#4572A7 \";for (k = 0; k < u.length; k++) {\n              if (c = u[k].x.getTime ? u[k].x.getTime() : u[k].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof u[k].y) {\n                p = a.axisX.convertValueToPixel(c);var s = p - a.plotType.plotUnits.length * d / 2 + a.index * d << 0,\n                    y = s + d << 0,\n                    B;if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < u[k].y) l[c] = u[k].y + (l[c] ? l[c] : 0), 0 < l[c] && (B = g[c] ? g[c] : n, g[c] = r = a.axisY.convertValueToPixel(l[c]));else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= u[k].y) t[c] = u[k].y + (t[c] ? t[c] : 0), r = h[c] ? h[c] : n, h[c] = B = a.axisY.convertValueToPixel(t[c]);else if (r = a.axisY.convertValueToPixel(u[k].y), 0 <= u[k].y) {\n                  var A = g[c] ? g[c] : 0;B = n + A;r += A;g[c] = A + (r - B);\n                } else A = h[c] ? h[c] : 0, B = r - A, r = n - A, h[c] = A + (r - B);c = u[k].color ? u[k].color : D._colorSet[k % D._colorSet.length];\n                V(b, B, s, r, y, c, 0, null, q, !1, !1, !1, D.fillOpacity);c = D.dataPointIds[k];this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: m, dataPointIndex: k, x1: B, y1: s, x2: r, y2: y };c = R(c);v && V(this._eventManager.ghostCtx, B, s, r, y, c, 0, null, !1, !1, !1, !1);(u[k].indexLabel || D.indexLabel || u[k].indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedBar\", dataPoint: u[k], dataSeries: D, point: { x: 0 <= u[k].y ? r : B, y: p }, direction: 0 > u[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(B, r), y1: s, x2: Math.max(B, r), y2: y }, color: c });\n              }\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());b.restore();\n        return { source: f, dest: this.plotArea.ctx, animationCallback: H.xScaleAnimation, easingFunction: H.easing.easeOutQuart, animationBase: n < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : n > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : n };\n      }\n    };q.prototype.renderStackedBar100 = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = null,\n            e = this.plotArea,\n            g = [],\n            h = [],\n            l = [],\n            t = [],\n            k = 0,\n            r,\n            p,\n            n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            k = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;p = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0;var d = a.axisX.dataInfo.minDiff;isFinite(d) || (d = 0.3 * Math.abs(a.axisX.range));d = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(d) / Math.log(a.axisX.range) : Math.abs(d) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;this.dataPointMaxWidth && k > p && (k = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, p));!this.dataPointMaxWidth && this.dataPointMinWidth && p < k && (p = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, k));d < k && (d = k);d > p && (d = p);b.save();v && this._eventManager.ghostCtx.save();b.beginPath();b.rect(e.x1, e.y1, e.width, e.height);b.clip();v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());for (var w = 0; w < a.dataSeriesIndexes.length; w++) {\n          var m = a.dataSeriesIndexes[w],\n              D = this.data[m],\n              u = D.dataPoints;\n          if (0 < u.length) {\n            var q = 5 < d && D.bevelEnabled ? !0 : !1;b.strokeStyle = \"#4572A7 \";for (k = 0; k < u.length; k++) {\n              if (c = u[k].x.getTime ? u[k].x.getTime() : u[k].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof u[k].y) {\n                p = a.axisX.convertValueToPixel(c);var s;s = 0 !== a.dataPointYSums[c] ? 100 * (u[k].y / a.dataPointYSums[c]) : 0;var y = p - a.plotType.plotUnits.length * d / 2 + a.index * d << 0,\n                    B = y + d << 0;if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < u[k].y) {\n                  l[c] = s + (l[c] ? l[c] : 0);if (0 >= l[c]) continue;s = g[c] ? g[c] : n;g[c] = r = a.axisY.convertValueToPixel(l[c]);\n                } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= u[k].y) t[c] = s + (t[c] ? t[c] : 0), r = h[c] ? h[c] : n, h[c] = s = a.axisY.convertValueToPixel(t[c]);else if (r = a.axisY.convertValueToPixel(s), 0 <= u[k].y) {\n                  var A = g[c] ? g[c] : 0;s = n + A;r += A;g[c] = A + (r - s);\n                } else A = h[c] ? h[c] : 0, s = r - A, r = n - A, h[c] = A + (r - s);c = u[k].color ? u[k].color : D._colorSet[k % D._colorSet.length];V(b, s, y, r, B, c, 0, null, q, !1, !1, !1, D.fillOpacity);c = D.dataPointIds[k];\n                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: m, dataPointIndex: k, x1: s, y1: y, x2: r, y2: B };c = R(c);v && V(this._eventManager.ghostCtx, s, y, r, B, c, 0, null, !1, !1, !1, !1);(u[k].indexLabel || D.indexLabel || u[k].indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedBar100\", dataPoint: u[k], dataSeries: D, point: { x: 0 <= u[k].y ? r : s, y: p }, direction: 0 > u[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(s, r), y1: y, x2: Math.max(s, r), y2: B }, color: c });\n              }\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.xScaleAnimation, easingFunction: H.easing.easeOutQuart,\n          animationBase: n < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : n > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : n };\n      }\n    };q.prototype.renderArea = function (a) {\n      var f, b;function c() {\n        A && (0 < w.lineThickness && g.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? B = y : 0 > a.axisY.viewportMaximum ? B = t.y1 : 0 < a.axisY.viewportMinimum && (B = l.y2), g.lineTo(u, B), g.lineTo(A.x, B), g.closePath(), g.globalAlpha = w.fillOpacity, g.fill(), g.globalAlpha = 1, v && (h.lineTo(u, B), h.lineTo(A.x, B), h.closePath(), h.fill()), g.beginPath(), g.moveTo(u, s), h.beginPath(), h.moveTo(u, s), A = { x: u, y: s });\n      }var e = a.targetCanvasCtx || this.plotArea.ctx,\n          g = v ? this._preRenderCtx : e;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var h = this._eventManager.ghostCtx,\n            l = a.axisX.lineCoordinates,\n            t = a.axisY.lineCoordinates,\n            k = [],\n            r = this.plotArea,\n            p;g.save();v && h.save();g.beginPath();g.rect(r.x1, r.y1, r.width, r.height);g.clip();v && (h.beginPath(), h.rect(r.x1, r.y1, r.width, r.height), h.clip());for (var n = 0; n < a.dataSeriesIndexes.length; n++) {\n          var d = a.dataSeriesIndexes[n],\n              w = this.data[d],\n              m = w.dataPoints,\n              k = w.id;this._eventManager.objectMap[k] = { objectType: \"dataSeries\", dataSeriesIndex: d };k = R(k);h.fillStyle = k;k = [];f = !0;var D = 0,\n              u,\n              s,\n              q,\n              y = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n              B,\n              A = null;if (0 < m.length) {\n            var x = w._colorSet[D % w._colorSet.length],\n                z = w.lineColor = w.options.lineColor || x,\n                J = z;g.fillStyle = x;g.strokeStyle = z;g.lineWidth = w.lineThickness;b = \"solid\";if (g.setLineDash) {\n              var I = G(w.nullDataLineDashType, w.lineThickness);b = w.lineDashType;var da = G(b, w.lineThickness);\n              g.setLineDash(da);\n            }for (var ea = !0; D < m.length; D++) {\n              if (q = m[D].x.getTime ? m[D].x.getTime() : m[D].x, !(q < a.axisX.dataInfo.viewPortMin || q > a.axisX.dataInfo.viewPortMax && (!w.connectNullData || !ea))) if (\"number\" !== typeof m[D].y) w.connectNullData || ea || f || c(), ea = !0;else {\n                u = a.axisX.convertValueToPixel(q);s = a.axisY.convertValueToPixel(m[D].y);f || ea ? (!f && w.connectNullData ? (g.setLineDash && (w.options.nullDataLineDashType || b === w.lineDashType && w.lineDashType !== w.nullDataLineDashType) && (f = u, b = s, u = p.x, s = p.y, c(), g.moveTo(p.x, p.y), u = f, s = b, A = p, b = w.nullDataLineDashType, g.setLineDash(I)), g.lineTo(u, s), v && h.lineTo(u, s)) : (g.beginPath(), g.moveTo(u, s), v && (h.beginPath(), h.moveTo(u, s)), A = { x: u, y: s }), ea = f = !1) : (g.lineTo(u, s), v && h.lineTo(u, s), 0 == D % 250 && c());p = { x: u, y: s };D < m.length - 1 && (J !== (m[D].lineColor || z) || b !== (m[D].lineDashType || w.lineDashType)) && (c(), J = m[D].lineColor || z, g.strokeStyle = J, g.setLineDash && (m[D].lineDashType ? (b = m[D].lineDashType, g.setLineDash(G(b, w.lineThickness))) : (b = w.lineDashType, g.setLineDash(da))));var $ = w.dataPointIds[D];\n                this._eventManager.objectMap[$] = { id: $, objectType: \"dataPoint\", dataSeriesIndex: d, dataPointIndex: D, x1: u, y1: s };0 !== m[D].markerSize && (0 < m[D].markerSize || 0 < w.markerSize) && (q = w.getMarkerProperties(D, u, s, g), k.push(q), $ = R($), v && k.push({ x: u, y: s, ctx: h, type: q.type, size: q.size, color: $, borderColor: $, borderThickness: q.borderThickness }));(m[D].indexLabel || w.indexLabel || m[D].indexLabelFormatter || w.indexLabelFormatter) && this._indexLabels.push({ chartType: \"area\", dataPoint: m[D], dataSeries: w, point: { x: u, y: s }, direction: 0 > m[D].y === a.axisY.reversed ? 1 : -1, color: x });\n              }\n            }c();ja.drawMarkers(k);\n          }\n        }v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && g.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && g.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore());\n        g.restore();return { source: e, dest: this.plotArea.ctx, animationCallback: H.xClipAnimation, easingFunction: H.easing.linear, animationBase: 0 };\n      }\n    };q.prototype.renderSplineArea = function (a) {\n      function f() {\n        var b = x(q, 2);if (0 < b.length) {\n          if (0 < p.lineThickness) {\n            c.beginPath();c.moveTo(b[0].x, b[0].y);b[0].newStrokeStyle && (c.strokeStyle = b[0].newStrokeStyle);b[0].newLineDashArray && c.setLineDash(b[0].newLineDashArray);for (var d = 0; d < b.length - 3; d += 3) {\n              if (c.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), v && e.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), b[d + 3].newStrokeStyle || b[d + 3].newLineDashArray) c.stroke(), c.beginPath(), c.moveTo(b[d + 3].x, b[d + 3].y), b[d + 3].newStrokeStyle && (c.strokeStyle = b[d + 3].newStrokeStyle), b[d + 3].newLineDashArray && c.setLineDash(b[d + 3].newLineDashArray);\n            }c.stroke();\n          }c.beginPath();c.moveTo(b[0].x, b[0].y);v && (e.beginPath(), e.moveTo(b[0].x, b[0].y));for (d = 0; d < b.length - 3; d += 3) {\n            c.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), v && e.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y);\n          }a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? u = D : 0 > a.axisY.viewportMaximum ? u = h.y1 : 0 < a.axisY.viewportMinimum && (u = g.y2);s = { x: b[0].x, y: b[0].y };c.lineTo(b[b.length - 1].x, u);c.lineTo(s.x, u);c.closePath();c.globalAlpha = p.fillOpacity;c.fill();c.globalAlpha = 1;v && (e.lineTo(b[b.length - 1].x, u), e.lineTo(s.x, u), e.closePath(), e.fill());\n        }\n      }var b = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : b;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var e = this._eventManager.ghostCtx,\n            g = a.axisX.lineCoordinates,\n            h = a.axisY.lineCoordinates,\n            l = [],\n            t = this.plotArea;c.save();v && e.save();c.beginPath();c.rect(t.x1, t.y1, t.width, t.height);c.clip();v && (e.beginPath(), e.rect(t.x1, t.y1, t.width, t.height), e.clip());for (var k = 0; k < a.dataSeriesIndexes.length; k++) {\n          var r = a.dataSeriesIndexes[k],\n              p = this.data[r],\n              n = p.dataPoints,\n              l = p.id;this._eventManager.objectMap[l] = { objectType: \"dataSeries\", dataSeriesIndex: r };l = R(l);e.fillStyle = l;var l = [],\n              d = 0,\n              w,\n              m,\n              D = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n              u,\n              s = null,\n              q = [];if (0 < n.length) {\n            var y = p._colorSet[d % p._colorSet.length],\n                B = p.lineColor = p.options.lineColor || y,\n                A = B;c.fillStyle = y;c.strokeStyle = B;c.lineWidth = p.lineThickness;var z = \"solid\";if (c.setLineDash) {\n              var L = G(p.nullDataLineDashType, p.lineThickness),\n                  z = p.lineDashType,\n                  J = G(z, p.lineThickness);c.setLineDash(J);\n            }for (m = !1; d < n.length; d++) {\n              if (w = n[d].x.getTime ? n[d].x.getTime() : n[d].x, !(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax && (!p.connectNullData || !m))) if (\"number\" !== typeof n[d].y) 0 < d && !m && (p.connectNullData ? c.setLineDash && 0 < q.length && (p.options.nullDataLineDashType || !n[d - 1].lineDashType) && (q[q.length - 1].newLineDashArray = L, z = p.nullDataLineDashType) : (f(), q = [])), m = !0;else {\n                w = a.axisX.convertValueToPixel(w);m = a.axisY.convertValueToPixel(n[d].y);var I = p.dataPointIds[d];this._eventManager.objectMap[I] = { id: I, objectType: \"dataPoint\", dataSeriesIndex: r, dataPointIndex: d, x1: w, y1: m };q[q.length] = { x: w, y: m };d < n.length - 1 && (A !== (n[d].lineColor || B) || z !== (n[d].lineDashType || p.lineDashType)) && (A = n[d].lineColor || B, q[q.length - 1].newStrokeStyle = A, c.setLineDash && (n[d].lineDashType ? (z = n[d].lineDashType, q[q.length - 1].newLineDashArray = G(z, p.lineThickness)) : (z = p.lineDashType, q[q.length - 1].newLineDashArray = J)));if (0 !== n[d].markerSize && (0 < n[d].markerSize || 0 < p.markerSize)) {\n                  var da = p.getMarkerProperties(d, w, m, c);l.push(da);I = R(I);v && l.push({ x: w, y: m, ctx: e, type: da.type, size: da.size, color: I, borderColor: I, borderThickness: da.borderThickness });\n                }(n[d].indexLabel || p.indexLabel || n[d].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({ chartType: \"splineArea\", dataPoint: n[d], dataSeries: p, point: { x: w, y: m }, direction: 0 > n[d].y === a.axisY.reversed ? 1 : -1, color: y });m = !1;\n              }\n            }f();ja.drawMarkers(l);\n          }\n        }v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(t.x1, t.y1, t.width, t.height), this._eventManager.ghostCtx.restore());c.restore();return { source: b, dest: this.plotArea.ctx, animationCallback: H.xClipAnimation, easingFunction: H.easing.linear, animationBase: 0 };\n      }\n    };q.prototype.renderStepArea = function (a) {\n      var f, b;function c() {\n        A && (0 < w.lineThickness && g.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? B = y : 0 > a.axisY.viewportMaximum ? B = t.y1 : 0 < a.axisY.viewportMinimum && (B = l.y2), g.lineTo(u, B), g.lineTo(A.x, B), g.closePath(), g.globalAlpha = w.fillOpacity, g.fill(), g.globalAlpha = 1, v && (h.lineTo(u, B), h.lineTo(A.x, B), h.closePath(), h.fill()), g.beginPath(), g.moveTo(u, s), h.beginPath(), h.moveTo(u, s), A = { x: u, y: s });\n      }var e = a.targetCanvasCtx || this.plotArea.ctx,\n          g = v ? this._preRenderCtx : e;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var h = this._eventManager.ghostCtx,\n            l = a.axisX.lineCoordinates,\n            t = a.axisY.lineCoordinates,\n            k = [],\n            r = this.plotArea,\n            p;g.save();v && h.save();g.beginPath();g.rect(r.x1, r.y1, r.width, r.height);g.clip();v && (h.beginPath(), h.rect(r.x1, r.y1, r.width, r.height), h.clip());for (var n = 0; n < a.dataSeriesIndexes.length; n++) {\n          var d = a.dataSeriesIndexes[n],\n              w = this.data[d],\n              m = w.dataPoints,\n              k = w.id;this._eventManager.objectMap[k] = { objectType: \"dataSeries\", dataSeriesIndex: d };k = R(k);h.fillStyle = k;k = [];f = !0;var D = 0,\n              u,\n              s,\n              q,\n              y = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n              B,\n              A = null;b = !1;if (0 < m.length) {\n            var x = w._colorSet[D % w._colorSet.length],\n                z = w.lineColor = w.options.lineColor || x,\n                J = z;g.fillStyle = x;g.strokeStyle = z;g.lineWidth = w.lineThickness;var I = \"solid\";if (g.setLineDash) {\n              var da = G(w.nullDataLineDashType, w.lineThickness),\n                  I = w.lineDashType,\n                  ea = G(I, w.lineThickness);g.setLineDash(ea);\n            }for (; D < m.length; D++) {\n              if (q = m[D].x.getTime ? m[D].x.getTime() : m[D].x, !(q < a.axisX.dataInfo.viewPortMin || q > a.axisX.dataInfo.viewPortMax && (!w.connectNullData || !b))) {\n                var $ = s;\"number\" !== typeof m[D].y ? (w.connectNullData || b || f || c(), b = !0) : (u = a.axisX.convertValueToPixel(q), s = a.axisY.convertValueToPixel(m[D].y), f || b ? (!f && w.connectNullData ? (g.setLineDash && (w.options.nullDataLineDashType || I === w.lineDashType && w.lineDashType !== w.nullDataLineDashType) && (f = u, b = s, u = p.x, s = p.y, c(), g.moveTo(p.x, p.y), u = f, s = b, A = p, I = w.nullDataLineDashType, g.setLineDash(da)), g.lineTo(u, $), g.lineTo(u, s), v && (h.lineTo(u, $), h.lineTo(u, s))) : (g.beginPath(), g.moveTo(u, s), v && (h.beginPath(), h.moveTo(u, s)), A = { x: u, y: s }), b = f = !1) : (g.lineTo(u, $), v && h.lineTo(u, $), g.lineTo(u, s), v && h.lineTo(u, s), 0 == D % 250 && c()), p = { x: u, y: s }, D < m.length - 1 && (J !== (m[D].lineColor || z) || I !== (m[D].lineDashType || w.lineDashType)) && (c(), J = m[D].lineColor || z, g.strokeStyle = J, g.setLineDash && (m[D].lineDashType ? (I = m[D].lineDashType, g.setLineDash(G(I, w.lineThickness))) : (I = w.lineDashType, g.setLineDash(ea)))), q = w.dataPointIds[D], this._eventManager.objectMap[q] = { id: q, objectType: \"dataPoint\", dataSeriesIndex: d, dataPointIndex: D, x1: u, y1: s }, 0 !== m[D].markerSize && (0 < m[D].markerSize || 0 < w.markerSize) && ($ = w.getMarkerProperties(D, u, s, g), k.push($), q = R(q), v && k.push({ x: u, y: s, ctx: h, type: $.type, size: $.size, color: q, borderColor: q, borderThickness: $.borderThickness })), (m[D].indexLabel || w.indexLabel || m[D].indexLabelFormatter || w.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stepArea\", dataPoint: m[D], dataSeries: w, point: { x: u, y: s }, direction: 0 > m[D].y === a.axisY.reversed ? 1 : -1, color: x }));\n              }\n            }c();ja.drawMarkers(k);\n          }\n        }v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && g.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && g.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore());g.restore();return { source: e, dest: this.plotArea.ctx, animationCallback: H.xClipAnimation, easingFunction: H.easing.linear, animationBase: 0 };\n      }\n    };q.prototype.renderStackedArea = function (a) {\n      function f() {\n        if (!(1 > t.length)) {\n          for (0 < A.lineThickness && c.stroke(); 0 < t.length;) {\n            var a = t.pop();c.lineTo(a.x, a.y);v && s.lineTo(a.x, a.y);\n          }c.closePath();c.globalAlpha = A.fillOpacity;\n          c.fill();c.globalAlpha = 1;c.beginPath();v && (s.closePath(), s.fill(), s.beginPath());t = [];\n        }\n      }var b = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : b;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var e = null,\n            g = [],\n            h = this.plotArea,\n            l = [],\n            t = [],\n            k = [],\n            r = [],\n            p = 0,\n            n,\n            d,\n            w,\n            m = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            s = this._eventManager.ghostCtx,\n            u,\n            q,\n            y;v && s.beginPath();c.save();v && s.save();c.beginPath();c.rect(h.x1, h.y1, h.width, h.height);c.clip();v && (s.beginPath(), s.rect(h.x1, h.y1, h.width, h.height), s.clip());for (var e = [], x = 0; x < a.dataSeriesIndexes.length; x++) {\n          var B = a.dataSeriesIndexes[x],\n              A = this.data[B],\n              z = A.dataPoints;A.dataPointIndexes = [];for (p = 0; p < z.length; p++) {\n            B = z[p].x.getTime ? z[p].x.getTime() : z[p].x, A.dataPointIndexes[B] = p, e[B] || (k.push(B), e[B] = !0);\n          }k.sort(Pa);\n        }for (x = 0; x < a.dataSeriesIndexes.length; x++) {\n          B = a.dataSeriesIndexes[x];A = this.data[B];z = A.dataPoints;q = !0;t = [];p = A.id;this._eventManager.objectMap[p] = { objectType: \"dataSeries\", dataSeriesIndex: B };p = R(p);s.fillStyle = p;if (0 < k.length) {\n            var e = A._colorSet[0],\n                L = A.lineColor = A.options.lineColor || e,\n                J = L;c.fillStyle = e;c.strokeStyle = L;c.lineWidth = A.lineThickness;y = \"solid\";if (c.setLineDash) {\n              var I = G(A.nullDataLineDashType, A.lineThickness);y = A.lineDashType;var da = G(y, A.lineThickness);c.setLineDash(da);\n            }for (var ea = !0, p = 0; p < k.length; p++) {\n              w = k[p];var $ = null,\n                  $ = 0 <= A.dataPointIndexes[w] ? z[A.dataPointIndexes[w]] : { x: w, y: null };if (!(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax && (!A.connectNullData || !ea))) if (\"number\" !== typeof $.y) A.connectNullData || ea || q || f(), ea = !0;else {\n                n = a.axisX.convertValueToPixel(w);var xa = l[w] ? l[w] : 0;if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {\n                  r[w] = $.y + (r[w] ? r[w] : 0);if (0 >= r[w] && a.axisY.logarithmic) continue;d = a.axisY.convertValueToPixel(r[w]);\n                } else d = a.axisY.convertValueToPixel($.y), d -= xa;t.push({ x: n, y: m - xa });l[w] = m - d;q || ea ? (!q && A.connectNullData ? (c.setLineDash && (A.options.nullDataLineDashType || y === A.lineDashType && A.lineDashType !== A.nullDataLineDashType) && (q = t.pop(), y = t[t.length - 1], f(), c.moveTo(u.x, u.y), t.push(y), t.push(q), y = A.nullDataLineDashType, c.setLineDash(I)), c.lineTo(n, d), v && s.lineTo(n, d)) : (c.beginPath(), c.moveTo(n, d), v && (s.beginPath(), s.moveTo(n, d))), ea = q = !1) : (c.lineTo(n, d), v && s.lineTo(n, d), 0 == p % 250 && (f(), c.moveTo(n, d), v && s.moveTo(n, d), t.push({ x: n, y: m - xa })));u = { x: n, y: d };p < z.length - 1 && (J !== (z[p].lineColor || L) || y !== (z[p].lineDashType || A.lineDashType)) && (f(), c.beginPath(), c.moveTo(n, d), t.push({ x: n, y: m - xa }), J = z[p].lineColor || L, c.strokeStyle = J, c.setLineDash && (z[p].lineDashType ? (y = z[p].lineDashType, c.setLineDash(G(y, A.lineThickness))) : (y = A.lineDashType, c.setLineDash(da))));if (0 <= A.dataPointIndexes[w]) {\n                  var oa = A.dataPointIds[A.dataPointIndexes[w]];this._eventManager.objectMap[oa] = { id: oa, objectType: \"dataPoint\", dataSeriesIndex: B, dataPointIndex: A.dataPointIndexes[w], x1: n, y1: d };\n                }0 <= A.dataPointIndexes[w] && 0 !== $.markerSize && (0 < $.markerSize || 0 < A.markerSize) && (w = A.getMarkerProperties(A.dataPointIndexes[w], n, d, c), g.push(w), markerColor = R(oa), v && g.push({ x: n, y: d, ctx: s, type: w.type, size: w.size,\n                  color: markerColor, borderColor: markerColor, borderThickness: w.borderThickness }));($.indexLabel || A.indexLabel || $.indexLabelFormatter || A.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedArea\", dataPoint: $, dataSeries: A, point: { x: n, y: d }, direction: 0 > z[p].y === a.axisY.reversed ? 1 : -1, color: e });\n              }\n            }f();c.moveTo(n, d);v && s.moveTo(n, d);\n          }delete A.dataPointIndexes;\n        }ja.drawMarkers(g);v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(h.x1, h.y1, h.width, h.height), s.restore());c.restore();return { source: b, dest: this.plotArea.ctx, animationCallback: H.xClipAnimation, easingFunction: H.easing.linear, animationBase: 0 };\n      }\n    };q.prototype.renderStackedArea100 = function (a) {\n      function f() {\n        for (0 < A.lineThickness && c.stroke(); 0 < t.length;) {\n          var a = t.pop();c.lineTo(a.x, a.y);v && y.lineTo(a.x, a.y);\n        }c.closePath();c.globalAlpha = A.fillOpacity;c.fill();c.globalAlpha = 1;c.beginPath();v && (y.closePath(), y.fill(), y.beginPath());t = [];\n      }var b = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : b;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var e = null,\n            g = this.plotArea,\n            h = [],\n            l = [],\n            t = [],\n            k = [],\n            r = [],\n            p = 0,\n            n,\n            d,\n            w,\n            m,\n            s,\n            u,\n            q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            y = this._eventManager.ghostCtx;c.save();v && y.save();\n        c.beginPath();c.rect(g.x1, g.y1, g.width, g.height);c.clip();v && (y.beginPath(), y.rect(g.x1, g.y1, g.width, g.height), y.clip());for (var e = [], x = 0; x < a.dataSeriesIndexes.length; x++) {\n          var B = a.dataSeriesIndexes[x],\n              A = this.data[B],\n              z = A.dataPoints;A.dataPointIndexes = [];for (p = 0; p < z.length; p++) {\n            B = z[p].x.getTime ? z[p].x.getTime() : z[p].x, A.dataPointIndexes[B] = p, e[B] || (k.push(B), e[B] = !0);\n          }k.sort(Pa);\n        }for (x = 0; x < a.dataSeriesIndexes.length; x++) {\n          B = a.dataSeriesIndexes[x];A = this.data[B];z = A.dataPoints;s = !0;e = A.id;this._eventManager.objectMap[e] = { objectType: \"dataSeries\", dataSeriesIndex: B };e = R(e);y.fillStyle = e;t = [];if (0 < k.length) {\n            var e = A._colorSet[p % A._colorSet.length],\n                L = A.lineColor = A.options.lineColor || e,\n                J = L;c.fillStyle = e;c.strokeStyle = L;c.lineWidth = A.lineThickness;u = \"solid\";if (c.setLineDash) {\n              var I = G(A.nullDataLineDashType, A.lineThickness);u = A.lineDashType;var da = G(u, A.lineThickness);c.setLineDash(da);\n            }for (var ea = !0, p = 0; p < k.length; p++) {\n              w = k[p];var $ = null,\n                  $ = 0 <= A.dataPointIndexes[w] ? z[A.dataPointIndexes[w]] : { x: w, y: null };if (!(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax && (!A.connectNullData || !ea))) if (\"number\" !== typeof $.y) A.connectNullData || ea || s || f(), ea = !0;else {\n                var xa;xa = 0 !== a.dataPointYSums[w] ? 100 * ($.y / a.dataPointYSums[w]) : 0;n = a.axisX.convertValueToPixel(w);var oa = l[w] ? l[w] : 0;if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {\n                  r[w] = xa + (r[w] ? r[w] : 0);if (0 >= r[w] && a.axisY.logarithmic) continue;d = a.axisY.convertValueToPixel(r[w]);\n                } else d = a.axisY.convertValueToPixel(xa), d -= oa;t.push({ x: n, y: q - oa });l[w] = q - d;s || ea ? (!s && A.connectNullData ? (c.setLineDash && (A.options.nullDataLineDashType || u === A.lineDashType && A.lineDashType !== A.nullDataLineDashType) && (s = t.pop(), u = t[t.length - 1], f(), c.moveTo(m.x, m.y), t.push(u), t.push(s), u = A.nullDataLineDashType, c.setLineDash(I)), c.lineTo(n, d), v && y.lineTo(n, d)) : (c.beginPath(), c.moveTo(n, d), v && (y.beginPath(), y.moveTo(n, d))), ea = s = !1) : (c.lineTo(n, d), v && y.lineTo(n, d), 0 == p % 250 && (f(), c.moveTo(n, d), v && y.moveTo(n, d), t.push({ x: n, y: q - oa })));m = { x: n, y: d };p < z.length - 1 && (J !== (z[p].lineColor || L) || u !== (z[p].lineDashType || A.lineDashType)) && (f(), c.beginPath(), c.moveTo(n, d), t.push({ x: n, y: q - oa }), J = z[p].lineColor || L, c.strokeStyle = J, c.setLineDash && (z[p].lineDashType ? (u = z[p].lineDashType, c.setLineDash(G(u, A.lineThickness))) : (u = A.lineDashType, c.setLineDash(da))));if (0 <= A.dataPointIndexes[w]) {\n                  var E = A.dataPointIds[A.dataPointIndexes[w]];this._eventManager.objectMap[E] = { id: E, objectType: \"dataPoint\", dataSeriesIndex: B, dataPointIndex: A.dataPointIndexes[w], x1: n, y1: d };\n                }0 <= A.dataPointIndexes[w] && 0 !== $.markerSize && (0 < $.markerSize || 0 < A.markerSize) && (w = A.getMarkerProperties(p, n, d, c), h.push(w), markerColor = R(E), v && h.push({ x: n, y: d, ctx: y, type: w.type, size: w.size, color: markerColor, borderColor: markerColor, borderThickness: w.borderThickness }));($.indexLabel || A.indexLabel || $.indexLabelFormatter || A.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedArea100\", dataPoint: $, dataSeries: A, point: { x: n, y: d }, direction: 0 > z[p].y === a.axisY.reversed ? 1 : -1, color: e });\n              }\n            }f();c.moveTo(n, d);v && y.moveTo(n, d);\n          }delete A.dataPointIndexes;\n        }ja.drawMarkers(h);\n        v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(g.x1, g.y1, g.width, g.height), y.restore());c.restore();return { source: b, dest: this.plotArea.ctx, animationCallback: H.xClipAnimation,\n          easingFunction: H.easing.linear, animationBase: 0 };\n      }\n    };q.prototype.renderBubble = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = this.plotArea,\n            e = 0,\n            g,\n            h;b.save();v && this._eventManager.ghostCtx.save();b.beginPath();b.rect(c.x1, c.y1, c.width, c.height);b.clip();v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip());for (var l = -Infinity, t = Infinity, k = 0; k < a.dataSeriesIndexes.length; k++) {\n          for (var r = a.dataSeriesIndexes[k], p = this.data[r], n = p.dataPoints, d = 0, e = 0; e < n.length; e++) {\n            g = n[e].getTime ? g = n[e].x.getTime() : g = n[e].x, g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax || \"undefined\" === typeof n[e].z || (d = n[e].z, d > l && (l = d), d < t && (t = d));\n          }\n        }for (var w = 25 * Math.PI, m = Math.max(Math.pow(0.25 * Math.min(c.height, c.width) / 2, 2) * Math.PI, w), k = 0; k < a.dataSeriesIndexes.length; k++) {\n          if (r = a.dataSeriesIndexes[k], p = this.data[r], n = p.dataPoints, 0 < n.length) for (b.strokeStyle = \"#4572A7 \", e = 0; e < n.length; e++) {\n            if (g = n[e].getTime ? g = n[e].x.getTime() : g = n[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof n[e].y) {\n              g = a.axisX.convertValueToPixel(g);h = a.axisY.convertValueToPixel(n[e].y);var d = n[e].z,\n                  s = 2 * Math.max(Math.sqrt((l === t ? m / 2 : w + (m - w) / (l - t) * (d - t)) / Math.PI) << 0, 1),\n                  d = p.getMarkerProperties(e, b);d.size = s;b.globalAlpha = p.fillOpacity;ja.drawMarker(g, h, b, d.type, d.size, d.color, d.borderColor, d.borderThickness);b.globalAlpha = 1;var u = p.dataPointIds[e];this._eventManager.objectMap[u] = { id: u, objectType: \"dataPoint\", dataSeriesIndex: r, dataPointIndex: e, x1: g, y1: h, size: s };s = R(u);v && ja.drawMarker(g, h, this._eventManager.ghostCtx, d.type, d.size, s, s, d.borderThickness);(n[e].indexLabel || p.indexLabel || n[e].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({ chartType: \"bubble\", dataPoint: n[e], dataSeries: p, point: { x: g, y: h }, direction: 1, bounds: { x1: g - d.size / 2, y1: h - d.size / 2, x2: g + d.size / 2, y2: h + d.size / 2 }, color: null });\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore());b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.fadeInAnimation, easingFunction: H.easing.easeInQuad, animationBase: 0 };\n      }\n    };q.prototype.renderScatter = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = this.plotArea,\n            e = 0,\n            g,\n            h;b.save();v && this._eventManager.ghostCtx.save();b.beginPath();b.rect(c.x1, c.y1, c.width, c.height);b.clip();v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip());for (var l = 0; l < a.dataSeriesIndexes.length; l++) {\n          var t = a.dataSeriesIndexes[l],\n              k = this.data[t],\n              r = k.dataPoints;if (0 < r.length) {\n            b.strokeStyle = \"#4572A7 \";Math.pow(0.3 * Math.min(c.height, c.width) / 2, 2);for (var p = 0, n = 0, e = 0; e < r.length; e++) {\n              if (g = r[e].getTime ? g = r[e].x.getTime() : g = r[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof r[e].y) {\n                g = a.axisX.convertValueToPixel(g);h = a.axisY.convertValueToPixel(r[e].y);var d = k.getMarkerProperties(e, g, h, b);b.globalAlpha = k.fillOpacity;ja.drawMarker(d.x, d.y, d.ctx, d.type, d.size, d.color, d.borderColor, d.borderThickness);b.globalAlpha = 1;Math.sqrt((p - g) * (p - g) + (n - h) * (n - h)) < Math.min(d.size, 5) && r.length > Math.min(this.plotArea.width, this.plotArea.height) || (p = k.dataPointIds[e], this._eventManager.objectMap[p] = { id: p, objectType: \"dataPoint\", dataSeriesIndex: t, dataPointIndex: e, x1: g, y1: h }, p = R(p), v && ja.drawMarker(d.x, d.y, this._eventManager.ghostCtx, d.type, d.size, p, p, d.borderThickness), (r[e].indexLabel || k.indexLabel || r[e].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: \"scatter\", dataPoint: r[e], dataSeries: k, point: { x: g, y: h }, direction: 1,\n                  bounds: { x1: g - d.size / 2, y1: h - d.size / 2, x2: g + d.size / 2, y2: h + d.size / 2 }, color: null }), p = g, n = h);\n              }\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore());\n        b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.fadeInAnimation, easingFunction: H.easing.easeInQuad, animationBase: 0 };\n      }\n    };q.prototype.renderCandlestick = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f,\n          c = this._eventManager.ghostCtx;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var e = null,\n            g = null,\n            h = this.plotArea,\n            l = 0,\n            t,\n            k,\n            r,\n            p,\n            n,\n            d,\n            e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1,\n            g = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.015 * this.width,\n            w = a.axisX.dataInfo.minDiff;isFinite(w) || (w = 0.3 * Math.abs(a.axisX.range));w = this.dataPointWidth ? this.dataPointWidth : 0.7 * h.width * (a.axisX.logarithmic ? Math.log(w) / Math.log(a.axisX.range) : Math.abs(w) / Math.abs(a.axisX.range)) << 0;this.dataPointMaxWidth && e > g && (e = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, g));!this.dataPointMaxWidth && this.dataPointMinWidth && g < e && (g = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, e));w < e && (w = e);w > g && (w = g);b.save();v && c.save();b.beginPath();b.rect(h.x1, h.y1, h.width, h.height);b.clip();v && (c.beginPath(), c.rect(h.x1, h.y1, h.width, h.height), c.clip());for (var m = 0; m < a.dataSeriesIndexes.length; m++) {\n          var s = a.dataSeriesIndexes[m],\n              u = this.data[s],\n              q = u.dataPoints;if (0 < q.length) for (var ca = 5 < w && u.bevelEnabled ? !0 : !1, l = 0; l < q.length; l++) {\n            if (q[l].getTime ? d = q[l].x.getTime() : d = q[l].x, !(d < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && !y(q[l].y) && q[l].y.length && \"number\" === typeof q[l].y[0] && \"number\" === typeof q[l].y[1] && \"number\" === typeof q[l].y[2] && \"number\" === typeof q[l].y[3]) {\n              t = a.axisX.convertValueToPixel(d);k = a.axisY.convertValueToPixel(q[l].y[0]);r = a.axisY.convertValueToPixel(q[l].y[1]);p = a.axisY.convertValueToPixel(q[l].y[2]);n = a.axisY.convertValueToPixel(q[l].y[3]);var x = t - w / 2 << 0,\n                  B = x + w << 0,\n                  g = u.options.fallingColor ? u.fallingColor : u._colorSet[0],\n                  e = q[l].color ? q[l].color : u._colorSet[0],\n                  A = Math.round(Math.max(1, 0.15 * w)),\n                  z = 0 === A % 2 ? 0 : 0.5,\n                  L = u.dataPointIds[l];this._eventManager.objectMap[L] = { id: L, objectType: \"dataPoint\", dataSeriesIndex: s, dataPointIndex: l, x1: x, y1: k, x2: B, y2: r, x3: t, y3: p, x4: t, y4: n, borderThickness: A, color: e };b.strokeStyle = e;b.beginPath();b.lineWidth = A;c.lineWidth = Math.max(A, 4);\"candlestick\" === u.type ? (b.moveTo(t - z, r), b.lineTo(t - z, Math.min(k, n)), b.stroke(), b.moveTo(t - z, Math.max(k, n)), b.lineTo(t - z, p), b.stroke(), V(b, x, Math.min(k, n), B, Math.max(k, n), q[l].y[0] <= q[l].y[3] ? u.risingColor : g, A, e, ca, ca, !1, !1, u.fillOpacity), v && (e = R(L), c.strokeStyle = e, c.moveTo(t - z, r), c.lineTo(t - z, Math.min(k, n)), c.stroke(), c.moveTo(t - z, Math.max(k, n)), c.lineTo(t - z, p), c.stroke(), V(c, x, Math.min(k, n), B, Math.max(k, n), e, 0, null, !1, !1, !1, !1))) : \"ohlc\" === u.type && (b.moveTo(t - z, r), b.lineTo(t - z, p), b.stroke(), b.beginPath(), b.moveTo(t, k), b.lineTo(x, k), b.stroke(), b.beginPath(), b.moveTo(t, n), b.lineTo(B, n), b.stroke(), v && (e = R(L), c.strokeStyle = e, c.moveTo(t - z, r), c.lineTo(t - z, p), c.stroke(), c.beginPath(), c.moveTo(t, k), c.lineTo(x, k), c.stroke(), c.beginPath(), c.moveTo(t, n), c.lineTo(B, n), c.stroke()));(q[l].indexLabel || u.indexLabel || q[l].indexLabelFormatter || u.indexLabelFormatter) && this._indexLabels.push({ chartType: u.type, dataPoint: q[l], dataSeries: u, point: { x: x + (B - x) / 2, y: a.axisY.reversed ? p : r }, direction: 1, bounds: { x1: x, y1: Math.min(r, p), x2: B, y2: Math.max(r, p) }, color: e });\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(h.x1, h.y1, h.width, h.height), c.restore());b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.fadeInAnimation, easingFunction: H.easing.easeInQuad, animationBase: 0 };\n      }\n    };q.prototype.renderBoxAndWhisker = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f,\n          c = this._eventManager.ghostCtx;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var e = null,\n            g = this.plotArea,\n            h = 0,\n            l,\n            t,\n            k,\n            r,\n            p,\n            n,\n            d,\n            e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1,\n            h = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.015 * this.width,\n            w = a.axisX.dataInfo.minDiff;isFinite(w) || (w = 0.3 * Math.abs(a.axisX.range));w = this.dataPointWidth ? this.dataPointWidth : 0.7 * g.width * (a.axisX.logarithmic ? Math.log(w) / Math.log(a.axisX.range) : Math.abs(w) / Math.abs(a.axisX.range)) << 0;this.dataPointMaxWidth && e > h && (e = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, h));!this.dataPointMaxWidth && this.dataPointMinWidth && h < e && (h = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, e));w < e && (w = e);w > h && (w = h);b.save();v && c.save();b.beginPath();b.rect(g.x1, g.y1, g.width, g.height);b.clip();v && (c.beginPath(), c.rect(g.x1, g.y1, g.width, g.height), c.clip());for (var m = !1, m = !!a.axisY.reversed, s = 0; s < a.dataSeriesIndexes.length; s++) {\n          var u = a.dataSeriesIndexes[s],\n              q = this.data[u],\n              x = q.dataPoints;if (0 < x.length) for (var z = 5 < w && q.bevelEnabled ? !0 : !1, h = 0; h < x.length; h++) {\n            if (x[h].getTime ? d = x[h].x.getTime() : d = x[h].x, !(d < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && !y(x[h].y) && x[h].y.length && \"number\" === typeof x[h].y[0] && \"number\" === typeof x[h].y[1] && \"number\" === typeof x[h].y[2] && \"number\" === typeof x[h].y[3] && \"number\" === typeof x[h].y[4] && 5 === x[h].y.length) {\n              l = a.axisX.convertValueToPixel(d);t = a.axisY.convertValueToPixel(x[h].y[0]);k = a.axisY.convertValueToPixel(x[h].y[1]);r = a.axisY.convertValueToPixel(x[h].y[2]);p = a.axisY.convertValueToPixel(x[h].y[3]);n = a.axisY.convertValueToPixel(x[h].y[4]);\n              var B = l - w / 2 << 0,\n                  A = l + w / 2 << 0,\n                  e = x[h].color ? x[h].color : q._colorSet[0],\n                  C = Math.round(Math.max(1, 0.15 * w)),\n                  L = 0 === C % 2 ? 0 : 0.5,\n                  J = x[h].whiskerColor ? x[h].whiskerColor : x[h].color ? q.whiskerColor ? q.whiskerColor : x[h].color : q.whiskerColor ? q.whiskerColor : e,\n                  I = \"number\" === typeof x[h].whiskerThickness ? x[h].whiskerThickness : \"number\" === typeof q.options.whiskerThickness ? q.whiskerThickness : C,\n                  da = x[h].whiskerDashType ? x[h].whiskerDashType : q.whiskerDashType,\n                  ea = y(x[h].whiskerLength) ? y(q.options.whiskerLength) ? w : q.whiskerLength : x[h].whiskerLength,\n                  ea = \"number\" === typeof ea ? 0 >= ea ? 0 : ea >= w ? w : ea : \"string\" === typeof ea ? parseInt(ea) * w / 100 > w ? w : parseInt(ea) * w / 100 : w,\n                  $ = 1 === Math.round(I) % 2 ? 0.5 : 0,\n                  xa = x[h].stemColor ? x[h].stemColor : x[h].color ? q.stemColor ? q.stemColor : x[h].color : q.stemColor ? q.stemColor : e,\n                  oa = \"number\" === typeof x[h].stemThickness ? x[h].stemThickness : \"number\" === typeof q.options.stemThickness ? q.stemThickness : C,\n                  E = 1 === Math.round(oa) % 2 ? 0.5 : 0,\n                  eb = x[h].stemDashType ? x[h].stemDashType : q.stemDashType,\n                  P = x[h].lineColor ? x[h].lineColor : x[h].color ? q.lineColor ? q.lineColor : x[h].color : q.lineColor ? q.lineColor : e,\n                  O = \"number\" === typeof x[h].lineThickness ? x[h].lineThickness : \"number\" === typeof q.options.lineThickness ? q.lineThickness : C,\n                  Q = x[h].lineDashType ? x[h].lineDashType : q.lineDashType,\n                  K = 1 === Math.round(O) % 2 ? 0.5 : 0,\n                  N = q.upperBoxColor,\n                  U = q.lowerBoxColor,\n                  ta = y(q.options.fillOpacity) ? 1 : q.fillOpacity,\n                  M = q.dataPointIds[h];this._eventManager.objectMap[M] = { id: M, objectType: \"dataPoint\", dataSeriesIndex: u, dataPointIndex: h, x1: B, y1: t, x2: A, y2: k, x3: l, y3: r, x4: l, y4: p, y5: n, borderThickness: C, color: e,\n                stemThickness: oa, stemColor: xa, whiskerThickness: I, whiskerLength: ea, whiskerColor: J, lineThickness: O, lineColor: P };b.save();0 < oa && (b.beginPath(), b.strokeStyle = xa, b.lineWidth = oa, b.setLineDash && b.setLineDash(G(eb, oa)), b.moveTo(l - E, k), b.lineTo(l - E, t), b.stroke(), b.moveTo(l - E, p), b.lineTo(l - E, r), b.stroke());b.restore();c.lineWidth = Math.max(C, 4);b.beginPath();V(b, B, Math.min(n, k), A, Math.max(k, n), U, 0, e, m ? z : !1, m ? !1 : z, !1, !1, ta);b.beginPath();V(b, B, Math.min(r, n), A, Math.max(n, r), N, 0, e, m ? !1 : z, m ? z : !1, !1, !1, ta);b.beginPath();\n              b.lineWidth = C;b.strokeStyle = e;b.rect(B - L, Math.min(k, r) - L, A - B + 2 * L, Math.max(k, r) - Math.min(k, r) + 2 * L);b.stroke();b.save();0 < O && (b.beginPath(), b.globalAlpha = 1, b.setLineDash && b.setLineDash(G(Q, O)), b.strokeStyle = P, b.lineWidth = O, b.moveTo(B, n - K), b.lineTo(A, n - K), b.stroke());b.restore();b.save();0 < I && (b.beginPath(), b.setLineDash && b.setLineDash(G(da, I)), b.strokeStyle = J, b.lineWidth = I, b.moveTo(l - ea / 2 << 0, p - $), b.lineTo(l + ea / 2 << 0, p - $), b.stroke(), b.moveTo(l - ea / 2 << 0, t + $), b.lineTo(l + ea / 2 << 0, t + $), b.stroke());b.restore();\n              v && (e = R(M), c.strokeStyle = e, c.lineWidth = oa, 0 < oa && (c.moveTo(l - L - E, k), c.lineTo(l - L - E, Math.max(t, p)), c.stroke(), c.moveTo(l - L - E, Math.min(t, p)), c.lineTo(l - L - E, r), c.stroke()), V(c, B, Math.max(k, r), A, Math.min(k, r), e, 0, null, !1, !1, !1, !1), 0 < I && (c.beginPath(), c.lineWidth = I, c.moveTo(l + ea / 2, p - $), c.lineTo(l - ea / 2, p - $), c.stroke(), c.moveTo(l + ea / 2, t + $), c.lineTo(l - ea / 2, t + $), c.stroke()));(x[h].indexLabel || q.indexLabel || x[h].indexLabelFormatter || q.indexLabelFormatter) && this._indexLabels.push({ chartType: q.type, dataPoint: x[h],\n                dataSeries: q, point: { x: B + (A - B) / 2, y: a.axisY.reversed ? t : p }, direction: 1, bounds: { x1: B, y1: Math.min(t, p), x2: A, y2: Math.max(t, p) }, color: e });\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(g.x1, g.y1, g.width, g.height), c.restore());b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.fadeInAnimation, easingFunction: H.easing.easeInQuad, animationBase: 0 };\n      }\n    };q.prototype.renderRangeColumn = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = null,\n            e = this.plotArea,\n            g = 0,\n            h,\n            l,\n            t,\n            g = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;h = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.03 * this.width;var k = a.axisX.dataInfo.minDiff;isFinite(k) || (k = 0.3 * Math.abs(a.axisX.range));k = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(k) / Math.log(a.axisX.range) : Math.abs(k) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;this.dataPointMaxWidth && g > h && (g = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, h));!this.dataPointMaxWidth && this.dataPointMinWidth && h < g && (h = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, g));k < g && (k = g);k > h && (k = h);b.save();v && this._eventManager.ghostCtx.save();b.beginPath();b.rect(e.x1, e.y1, e.width, e.height);b.clip();v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());for (var r = 0; r < a.dataSeriesIndexes.length; r++) {\n          var p = a.dataSeriesIndexes[r],\n              n = this.data[p],\n              d = n.dataPoints;if (0 < d.length) for (var w = 5 < k && n.bevelEnabled ? !0 : !1, g = 0; g < d.length; g++) {\n            if (d[g].getTime ? t = d[g].x.getTime() : t = d[g].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax) && !y(d[g].y) && d[g].y.length && \"number\" === typeof d[g].y[0] && \"number\" === typeof d[g].y[1]) {\n              c = a.axisX.convertValueToPixel(t);h = a.axisY.convertValueToPixel(d[g].y[0]);l = a.axisY.convertValueToPixel(d[g].y[1]);var m = a.axisX.reversed ? c + a.plotType.totalDataSeries * k / 2 - (a.previousDataSeriesCount + r) * k << 0 : c - a.plotType.totalDataSeries * k / 2 + (a.previousDataSeriesCount + r) * k << 0,\n                  q = a.axisX.reversed ? m - k << 0 : m + k << 0,\n                  c = d[g].color ? d[g].color : n._colorSet[g % n._colorSet.length];\n              if (h > l) {\n                var u = h;h = l;l = u;\n              }u = n.dataPointIds[g];this._eventManager.objectMap[u] = { id: u, objectType: \"dataPoint\", dataSeriesIndex: p, dataPointIndex: g, x1: m, y1: h, x2: q, y2: l };V(b, m, h, q, l, c, 0, c, w, w, !1, !1, n.fillOpacity);c = R(u);v && V(this._eventManager.ghostCtx, m, h, q, l, c, 0, null, !1, !1, !1, !1);if (d[g].indexLabel || n.indexLabel || d[g].indexLabelFormatter || n.indexLabelFormatter) this._indexLabels.push({ chartType: \"rangeColumn\", dataPoint: d[g], dataSeries: n, indexKeyword: 0, point: { x: m + (q - m) / 2, y: d[g].y[1] >= d[g].y[0] ? l : h }, direction: d[g].y[1] >= d[g].y[0] ? -1 : 1, bounds: { x1: m, y1: Math.min(h, l), x2: q, y2: Math.max(h, l) }, color: c }), this._indexLabels.push({ chartType: \"rangeColumn\", dataPoint: d[g], dataSeries: n, indexKeyword: 1, point: { x: m + (q - m) / 2, y: d[g].y[1] >= d[g].y[0] ? h : l }, direction: d[g].y[1] >= d[g].y[0] ? 1 : -1, bounds: { x1: m, y1: Math.min(h, l), x2: q, y2: Math.max(h, l) }, color: c });\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.fadeInAnimation, easingFunction: H.easing.easeInQuad, animationBase: 0 };\n      }\n    };q.prototype.renderError = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f,\n          c = a.axisY._position ? \"left\" === a.axisY._position || \"right\" === a.axisY._position ? !1 : !0 : !1;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var e = null,\n            g = !1,\n            h = this.plotArea,\n            l = 0,\n            t,\n            k,\n            r,\n            p,\n            n,\n            d,\n            w,\n            m = a.axisX.dataInfo.minDiff;isFinite(m) || (m = 0.3 * Math.abs(a.axisX.range));b.save();v && this._eventManager.ghostCtx.save();b.beginPath();b.rect(h.x1, h.y1, h.width, h.height);b.clip();v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.clip());for (var q = 0, u = 0; u < this.data.length; u++) {\n          !this.data[u].type.match(/(bar|column)/ig) || !this.data[u].visible || this.data[u].type.match(/(stacked)/ig) && q || q++;\n        }for (var s = 0; s < a.dataSeriesIndexes.length; s++) {\n          var x = a.dataSeriesIndexes[s],\n              ba = this.data[x],\n              B = ba.dataPoints,\n              A = y(ba._linkedSeries) ? !1 : ba._linkedSeries.type.match(/(bar|column)/ig) && ba._linkedSeries.visible ? !0 : !1,\n              C = 0;if (A) for (e = ba._linkedSeries.id, u = 0; u < e; u++) {\n            !this.data[u].type.match(/(bar|column)/ig) || !this.data[u].visible || this.data[u].type.match(/(stacked)/ig) && C || (this.data[u].type.match(/(range)/ig) && (g = !0), C++);\n          }e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;l = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : c ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (A ? q : 1))) << 0 : 0.3 * this.width;g && (l = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : c ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (A ? q : 1))) << 0 : 0.03 * this.width);u = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * ((c ? h.height : h.width) * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / (A ? q : 1)) << 0;this.dataPointMaxWidth && e > l && (e = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, l));!this.dataPointMaxWidth && this.dataPointMinWidth && l < e && (l = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, e));u < e && (u = e);u > l && (u = l);if (0 < B.length) for (var L = ba._colorSet, l = 0; l < B.length; l++) {\n            var e = ba.lineColor = ba.options.color ? ba.options.color : L[0],\n                J = { color: B[l].whiskerColor ? B[l].whiskerColor : B[l].color ? ba.whiskerColor ? ba.whiskerColor : B[l].color : ba.whiskerColor ? ba.whiskerColor : e, thickness: y(B[l].whiskerThickness) ? ba.whiskerThickness : B[l].whiskerThickness, dashType: B[l].whiskerDashType ? B[l].whiskerDashType : ba.whiskerDashType, length: y(B[l].whiskerLength) ? y(ba.options.whiskerLength) ? u : ba.options.whiskerLength : B[l].whiskerLength, trimLength: y(B[l].whiskerLength) ? y(ba.options.whiskerLength) ? 50 : 0 : 0 };J.length = \"number\" === typeof J.length ? 0 >= J.length ? 0 : J.length >= u ? u : J.length : \"string\" === typeof J.length ? parseInt(J.length) * u / 100 > u ? u : parseInt(J.length) * u / 100 > u : u;J.thickness = \"number\" === typeof J.thickness ? 0 > J.thickness ? 0 : Math.round(J.thickness) : 2;var I = { color: B[l].stemColor ? B[l].stemColor : B[l].color ? ba.stemColor ? ba.stemColor : B[l].color : ba.stemColor ? ba.stemColor : e, thickness: B[l].stemThickness ? B[l].stemThickness : ba.stemThickness, dashType: B[l].stemDashType ? B[l].stemDashType : ba.stemDashType };I.thickness = \"number\" === typeof I.thickness ? 0 > I.thickness ? 0 : Math.round(I.thickness) : 2;B[l].getTime ? w = B[l].x.getTime() : w = B[l].x;if (!(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax) && !y(B[l].y) && B[l].y.length && \"number\" === typeof B[l].y[0] && \"number\" === typeof B[l].y[1]) {\n              var da = a.axisX.convertValueToPixel(w);c ? k = da : t = da;da = a.axisY.convertValueToPixel(B[l].y[0]);c ? r = da : n = da;da = a.axisY.convertValueToPixel(B[l].y[1]);c ? p = da : d = da;c ? (n = a.axisX.reversed ? k + (A ? q : 1) * u / 2 - (A ? C - 1 : 0) * u << 0 : k - (A ? q : 1) * u / 2 + (A ? C - 1 : 0) * u << 0, d = a.axisX.reversed ? n - u << 0 : n + u << 0) : (r = a.axisX.reversed ? t + (A ? q : 1) * u / 2 - (A ? C - 1 : 0) * u << 0 : t - (A ? q : 1) * u / 2 + (A ? C - 1 : 0) * u << 0, p = a.axisX.reversed ? r - u << 0 : r + u << 0);!c && n > d && (da = n, n = d, d = da);c && r > p && (da = r, r = p, p = da);da = ba.dataPointIds[l];this._eventManager.objectMap[da] = { id: da, objectType: \"dataPoint\", dataSeriesIndex: x, dataPointIndex: l, x1: Math.min(r, p), y1: Math.min(n, d), x2: Math.max(p, r), y2: Math.max(d, n), isXYSwapped: c, stemProperties: I, whiskerProperties: J };z(b, Math.min(r, p), Math.min(n, d), Math.max(p, r), Math.max(d, n), e, J, I, c);v && z(this._eventManager.ghostCtx, r, n, p, d, e, J, I, c);if (B[l].indexLabel || ba.indexLabel || B[l].indexLabelFormatter || ba.indexLabelFormatter) this._indexLabels.push({ chartType: \"error\", dataPoint: B[l], dataSeries: ba, indexKeyword: 0, point: { x: c ? B[l].y[1] >= B[l].y[0] ? r : p : r + (p - r) / 2, y: c ? n + (d - n) / 2 : B[l].y[1] >= B[l].y[0] ? d : n }, direction: B[l].y[1] >= B[l].y[0] ? -1 : 1, bounds: { x1: c ? Math.min(r, p) : r, y1: c ? n : Math.min(n, d), x2: c ? Math.max(r, p) : p, y2: c ? d : Math.max(n, d) }, color: e, axisSwapped: c }), this._indexLabels.push({ chartType: \"error\", dataPoint: B[l], dataSeries: ba, indexKeyword: 1, point: { x: c ? B[l].y[1] >= B[l].y[0] ? p : r : r + (p - r) / 2, y: c ? n + (d - n) / 2 : B[l].y[1] >= B[l].y[0] ? n : d }, direction: B[l].y[1] >= B[l].y[0] ? 1 : -1, bounds: { x1: c ? Math.min(r, p) : r, y1: c ? n : Math.min(n, d), x2: c ? Math.max(r, p) : p, y2: c ? d : Math.max(n, d) }, color: e, axisSwapped: c });\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore());b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.fadeInAnimation, easingFunction: H.easing.easeInQuad, animationBase: 0 };\n      }\n    };q.prototype.renderRangeBar = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = null,\n            e = this.plotArea,\n            g = 0,\n            h,\n            l,\n            t,\n            k,\n            g = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;h = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0;var r = a.axisX.dataInfo.minDiff;isFinite(r) || (r = 0.3 * Math.abs(a.axisX.range));r = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(r) / Math.log(a.axisX.range) : Math.abs(r) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;this.dataPointMaxWidth && g > h && (g = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, h));!this.dataPointMaxWidth && this.dataPointMinWidth && h < g && (h = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, g));r < g && (r = g);r > h && (r = h);b.save();v && this._eventManager.ghostCtx.save();b.beginPath();b.rect(e.x1, e.y1, e.width, e.height);b.clip();v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());for (var p = 0; p < a.dataSeriesIndexes.length; p++) {\n          var n = a.dataSeriesIndexes[p],\n              d = this.data[n],\n              w = d.dataPoints;\n          if (0 < w.length) {\n            var m = 5 < r && d.bevelEnabled ? !0 : !1;b.strokeStyle = \"#4572A7 \";for (g = 0; g < w.length; g++) {\n              if (w[g].getTime ? k = w[g].x.getTime() : k = w[g].x, !(k < a.axisX.dataInfo.viewPortMin || k > a.axisX.dataInfo.viewPortMax) && !y(w[g].y) && w[g].y.length && \"number\" === typeof w[g].y[0] && \"number\" === typeof w[g].y[1]) {\n                h = a.axisY.convertValueToPixel(w[g].y[0]);l = a.axisY.convertValueToPixel(w[g].y[1]);t = a.axisX.convertValueToPixel(k);t = a.axisX.reversed ? t + a.plotType.totalDataSeries * r / 2 - (a.previousDataSeriesCount + p) * r << 0 : t - a.plotType.totalDataSeries * r / 2 + (a.previousDataSeriesCount + p) * r << 0;var q = a.axisX.reversed ? t - r << 0 : t + r << 0;h > l && (c = h, h = l, l = c);c = w[g].color ? w[g].color : d._colorSet[g % d._colorSet.length];V(b, h, t, l, q, c, 0, null, m, !1, !1, !1, d.fillOpacity);c = d.dataPointIds[g];this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: n, dataPointIndex: g, x1: h, y1: t, x2: l, y2: q };c = R(c);v && V(this._eventManager.ghostCtx, h, t, l, q, c, 0, null, !1, !1, !1, !1);if (w[g].indexLabel || d.indexLabel || w[g].indexLabelFormatter || d.indexLabelFormatter) this._indexLabels.push({ chartType: \"rangeBar\",\n                  dataPoint: w[g], dataSeries: d, indexKeyword: 0, point: { x: w[g].y[1] >= w[g].y[0] ? h : l, y: t + (q - t) / 2 }, direction: w[g].y[1] >= w[g].y[0] ? -1 : 1, bounds: { x1: Math.min(h, l), y1: t, x2: Math.max(h, l), y2: q }, color: c }), this._indexLabels.push({ chartType: \"rangeBar\", dataPoint: w[g], dataSeries: d, indexKeyword: 1, point: { x: w[g].y[1] >= w[g].y[0] ? l : h, y: t + (q - t) / 2 }, direction: w[g].y[1] >= w[g].y[0] ? 1 : -1, bounds: { x1: Math.min(h, l), y1: t, x2: Math.max(h, l), y2: q }, color: c });\n              }\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.fadeInAnimation, easingFunction: H.easing.easeInQuad, animationBase: 0 };\n      }\n    };q.prototype.renderRangeArea = function (a) {\n      function f() {\n        if (s) {\n          var a = null;0 < r.lineThickness && c.stroke();for (var b = t.length - 1; 0 <= b; b--) {\n            a = t[b], c.lineTo(a.x, a.y), e.lineTo(a.x, a.y);\n          }c.closePath();c.globalAlpha = r.fillOpacity;c.fill();c.globalAlpha = 1;e.fill();if (0 < r.lineThickness) {\n            c.beginPath();c.moveTo(a.x, a.y);for (b = 0; b < t.length; b++) {\n              a = t[b], c.lineTo(a.x, a.y);\n            }c.stroke();\n          }c.beginPath();c.moveTo(w, m);e.beginPath();e.moveTo(w, m);s = { x: w, y: m };t = [];t.push({ x: w, y: q });\n        }\n      }var b = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : b;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var e = this._eventManager.ghostCtx,\n            g = [],\n            h = this.plotArea;c.save();v && e.save();c.beginPath();c.rect(h.x1, h.y1, h.width, h.height);c.clip();v && (e.beginPath(), e.rect(h.x1, h.y1, h.width, h.height), e.clip());for (var l = 0; l < a.dataSeriesIndexes.length; l++) {\n          var t = [],\n              k = a.dataSeriesIndexes[l],\n              r = this.data[k],\n              p = r.dataPoints,\n              g = r.id;this._eventManager.objectMap[g] = { objectType: \"dataSeries\", dataSeriesIndex: k };g = R(g);e.fillStyle = g;var g = [],\n              n = !0,\n              d = 0,\n              w,\n              m,\n              q,\n              u,\n              s = null;if (0 < p.length) {\n            var y = r._colorSet[d % r._colorSet.length],\n                x = r.lineColor = r.options.lineColor || y,\n                B = x;c.fillStyle = y;c.strokeStyle = x;c.lineWidth = r.lineThickness;var A = \"solid\";if (c.setLineDash) {\n              var z = G(r.nullDataLineDashType, r.lineThickness),\n                  A = r.lineDashType,\n                  C = G(A, r.lineThickness);c.setLineDash(C);\n            }for (var J = !0; d < p.length; d++) {\n              if (u = p[d].x.getTime ? p[d].x.getTime() : p[d].x, !(u < a.axisX.dataInfo.viewPortMin || u > a.axisX.dataInfo.viewPortMax && (!r.connectNullData || !J))) if (null !== p[d].y && p[d].y.length && \"number\" === typeof p[d].y[0] && \"number\" === typeof p[d].y[1]) {\n                w = a.axisX.convertValueToPixel(u);m = a.axisY.convertValueToPixel(p[d].y[0]);q = a.axisY.convertValueToPixel(p[d].y[1]);n || J ? (r.connectNullData && !n ? (c.setLineDash && (r.options.nullDataLineDashType || A === r.lineDashType && r.lineDashType !== r.nullDataLineDashType) && (t[t.length - 1].newLineDashArray = C, A = r.nullDataLineDashType, c.setLineDash(z)), c.lineTo(w, m), v && e.lineTo(w, m), t.push({ x: w, y: q })) : (c.beginPath(), c.moveTo(w, m), s = { x: w, y: m }, t = [], t.push({ x: w, y: q }), v && (e.beginPath(), e.moveTo(w, m))), J = n = !1) : (c.lineTo(w, m), t.push({ x: w,\n                  y: q }), v && e.lineTo(w, m), 0 == d % 250 && f());u = r.dataPointIds[d];this._eventManager.objectMap[u] = { id: u, objectType: \"dataPoint\", dataSeriesIndex: k, dataPointIndex: d, x1: w, y1: m, y2: q };d < p.length - 1 && (B !== (p[d].lineColor || x) || A !== (p[d].lineDashType || r.lineDashType)) && (f(), B = p[d].lineColor || x, t[t.length - 1].newStrokeStyle = B, c.strokeStyle = B, c.setLineDash && (p[d].lineDashType ? (A = p[d].lineDashType, t[t.length - 1].newLineDashArray = G(A, r.lineThickness), c.setLineDash(t[t.length - 1].newLineDashArray)) : (A = r.lineDashType, t[t.length - 1].newLineDashArray = C, c.setLineDash(C))));if (0 !== p[d].markerSize && (0 < p[d].markerSize || 0 < r.markerSize)) {\n                  var I = r.getMarkerProperties(d, w, q, c);g.push(I);var da = R(u);v && g.push({ x: w, y: q, ctx: e, type: I.type, size: I.size, color: da, borderColor: da, borderThickness: I.borderThickness });I = r.getMarkerProperties(d, w, m, c);g.push(I);da = R(u);v && g.push({ x: w, y: m, ctx: e, type: I.type, size: I.size, color: da, borderColor: da, borderThickness: I.borderThickness });\n                }if (p[d].indexLabel || r.indexLabel || p[d].indexLabelFormatter || r.indexLabelFormatter) this._indexLabels.push({ chartType: \"rangeArea\",\n                  dataPoint: p[d], dataSeries: r, indexKeyword: 0, point: { x: w, y: m }, direction: p[d].y[0] > p[d].y[1] === a.axisY.reversed ? -1 : 1, color: y }), this._indexLabels.push({ chartType: \"rangeArea\", dataPoint: p[d], dataSeries: r, indexKeyword: 1, point: { x: w, y: q }, direction: p[d].y[0] > p[d].y[1] === a.axisY.reversed ? 1 : -1, color: y });\n              } else J || n || f(), J = !0;\n            }f();ja.drawMarkers(g);\n          }\n        }v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore());c.restore();return { source: b, dest: this.plotArea.ctx, animationCallback: H.xClipAnimation, easingFunction: H.easing.linear, animationBase: 0 };\n      }\n    };q.prototype.renderRangeSplineArea = function (a) {\n      function f(a, b) {\n        var d = x(m, 2);if (0 < d.length) {\n          if (0 < k.lineThickness) {\n            c.strokeStyle = b;c.setLineDash && c.setLineDash(a);c.beginPath();c.moveTo(d[0].x, d[0].y);for (var f = 0; f < d.length - 3; f += 3) {\n              if (d[f].newStrokeStyle || d[f].newLineDashArray) c.stroke(), c.beginPath(), c.moveTo(d[f].x, d[f].y), d[f].newStrokeStyle && (c.strokeStyle = d[f].newStrokeStyle), d[f].newLineDashArray && c.setLineDash(d[f].newLineDashArray);c.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y);\n            }c.stroke();\n          }c.beginPath();c.moveTo(d[0].x, d[0].y);v && (e.beginPath(), e.moveTo(d[0].x, d[0].y));\n          for (f = 0; f < d.length - 3; f += 3) {\n            c.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y), v && e.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y);\n          }d = x(q, 2);c.lineTo(q[q.length - 1].x, q[q.length - 1].y);for (f = d.length - 1; 2 < f; f -= 3) {\n            c.bezierCurveTo(d[f - 1].x, d[f - 1].y, d[f - 2].x, d[f - 2].y, d[f - 3].x, d[f - 3].y), v && e.bezierCurveTo(d[f - 1].x, d[f - 1].y, d[f - 2].x, d[f - 2].y, d[f - 3].x, d[f - 3].y);\n          }c.closePath();c.globalAlpha = k.fillOpacity;c.fill();v && (e.closePath(), e.fill());c.globalAlpha = 1;if (0 < k.lineThickness) {\n            c.strokeStyle = b;c.setLineDash && c.setLineDash(a);c.beginPath();c.moveTo(d[0].x, d[0].y);for (var g = f = 0; f < d.length - 3; f += 3, g++) {\n              if (m[g].newStrokeStyle || m[g].newLineDashArray) c.stroke(), c.beginPath(), c.moveTo(d[f].x, d[f].y), m[g].newStrokeStyle && (c.strokeStyle = m[g].newStrokeStyle), m[g].newLineDashArray && c.setLineDash(m[g].newLineDashArray);c.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y);\n            }c.stroke();\n          }c.beginPath();\n        }\n      }var b = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : b;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var e = this._eventManager.ghostCtx,\n            g = [],\n            h = this.plotArea;c.save();v && e.save();c.beginPath();c.rect(h.x1, h.y1, h.width, h.height);c.clip();v && (e.beginPath(), e.rect(h.x1, h.y1, h.width, h.height), e.clip());for (var l = 0; l < a.dataSeriesIndexes.length; l++) {\n          var t = a.dataSeriesIndexes[l],\n              k = this.data[t],\n              r = k.dataPoints,\n              g = k.id;this._eventManager.objectMap[g] = { objectType: \"dataSeries\", dataSeriesIndex: t };g = R(g);e.fillStyle = g;var g = [],\n              p = 0,\n              n,\n              d,\n              w,\n              m = [],\n              q = [];if (0 < r.length) {\n            var u = k._colorSet[p % k._colorSet.length],\n                s = k.lineColor = k.options.lineColor || u,\n                y = s;c.fillStyle = u;c.lineWidth = k.lineThickness;var z = \"solid\",\n                B;if (c.setLineDash) {\n              var A = G(k.nullDataLineDashType, k.lineThickness),\n                  z = k.lineDashType;B = G(z, k.lineThickness);\n            }for (d = !1; p < r.length; p++) {\n              if (n = r[p].x.getTime ? r[p].x.getTime() : r[p].x, !(n < a.axisX.dataInfo.viewPortMin || n > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !d))) if (null !== r[p].y && r[p].y.length && \"number\" === typeof r[p].y[0] && \"number\" === typeof r[p].y[1]) {\n                n = a.axisX.convertValueToPixel(n);d = a.axisY.convertValueToPixel(r[p].y[0]);w = a.axisY.convertValueToPixel(r[p].y[1]);\n                var C = k.dataPointIds[p];this._eventManager.objectMap[C] = { id: C, objectType: \"dataPoint\", dataSeriesIndex: t, dataPointIndex: p, x1: n, y1: d, y2: w };m[m.length] = { x: n, y: d };q[q.length] = { x: n, y: w };p < r.length - 1 && (y !== (r[p].lineColor || s) || z !== (r[p].lineDashType || k.lineDashType)) && (y = r[p].lineColor || s, m[m.length - 1].newStrokeStyle = y, c.setLineDash && (r[p].lineDashType ? (z = r[p].lineDashType, m[m.length - 1].newLineDashArray = G(z, k.lineThickness)) : (z = k.lineDashType, m[m.length - 1].newLineDashArray = B)));if (0 !== r[p].markerSize && (0 < r[p].markerSize || 0 < k.markerSize)) {\n                  var L = k.getMarkerProperties(p, n, d, c);g.push(L);var J = R(C);v && g.push({ x: n, y: d, ctx: e, type: L.type, size: L.size, color: J, borderColor: J, borderThickness: L.borderThickness });L = k.getMarkerProperties(p, n, w, c);g.push(L);J = R(C);v && g.push({ x: n, y: w, ctx: e, type: L.type, size: L.size, color: J, borderColor: J, borderThickness: L.borderThickness });\n                }if (r[p].indexLabel || k.indexLabel || r[p].indexLabelFormatter || k.indexLabelFormatter) this._indexLabels.push({ chartType: \"rangeSplineArea\", dataPoint: r[p],\n                  dataSeries: k, indexKeyword: 0, point: { x: n, y: d }, direction: r[p].y[0] <= r[p].y[1] ? -1 : 1, color: u }), this._indexLabels.push({ chartType: \"rangeSplineArea\", dataPoint: r[p], dataSeries: k, indexKeyword: 1, point: { x: n, y: w }, direction: r[p].y[0] <= r[p].y[1] ? 1 : -1, color: u });d = !1;\n              } else 0 < p && !d && (k.connectNullData ? c.setLineDash && 0 < m.length && (k.options.nullDataLineDashType || !r[p - 1].lineDashType) && (m[m.length - 1].newLineDashArray = A, z = k.nullDataLineDashType) : (f(B, s), m = [], q = [])), d = !0;\n            }f(B, s);ja.drawMarkers(g);\n          }\n        }v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore());c.restore();return { source: b, dest: this.plotArea.ctx, animationCallback: H.xClipAnimation, easingFunction: H.easing.linear,\n          animationBase: 0 };\n      }\n    };q.prototype.renderWaterfall = function (a) {\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : f;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var c = this._eventManager.ghostCtx,\n            e = null,\n            g = this.plotArea,\n            h = 0,\n            l,\n            t,\n            k,\n            r,\n            p = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            h = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;t = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0;var n = a.axisX.dataInfo.minDiff;isFinite(n) || (n = 0.3 * Math.abs(a.axisX.range));n = this.dataPointWidth ? this.dataPointWidth : 0.6 * (g.width * (a.axisX.logarithmic ? Math.log(n) / Math.log(a.axisX.range) : Math.abs(n) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;this.dataPointMaxWidth && h > t && (h = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, t));!this.dataPointMaxWidth && this.dataPointMinWidth && t < h && (t = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, h));n < h && (n = h);n > t && (n = t);b.save();v && this._eventManager.ghostCtx.save();b.beginPath();b.rect(g.x1, g.y1, g.width, g.height);b.clip();v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.clip());for (var d = 0; d < a.dataSeriesIndexes.length; d++) {\n          var w = a.dataSeriesIndexes[d],\n              m = this.data[w],\n              q = m.dataPoints,\n              e = m._colorSet[0];m.risingColor = m.options.risingColor ? m.options.risingColor : e;m.fallingColor = m.options.fallingColor ? m.options.fallingColor : \"#e40a0a\";var u = \"number\" === typeof m.options.lineThickness ? Math.round(m.lineThickness) : 1,\n              s = 1 === Math.round(u) % 2 ? -0.5 : 0;if (0 < q.length) for (var y = 5 < n && m.bevelEnabled ? !0 : !1, x = !1, B = null, A = null, h = 0; h < q.length; h++) {\n            if (q[h].getTime ? r = q[h].x.getTime() : r = q[h].x, \"number\" !== typeof q[h].y) {\n              if (0 < h && !x && m.connectNullData) var z = m.options.nullDataLineDashType || !q[h - 1].lineDashType ? m.nullDataLineDashType : q[h - 1].lineDashType;x = !0;\n            } else {\n              l = a.axisX.convertValueToPixel(r);t = 0 === m.dataPointEOs[h].cumulativeSum ? p : a.axisY.convertValueToPixel(m.dataPointEOs[h].cumulativeSum);k = 0 === m.dataPointEOs[h].cumulativeSumYStartValue ? p : a.axisY.convertValueToPixel(m.dataPointEOs[h].cumulativeSumYStartValue);l = a.axisX.reversed ? l + a.plotType.totalDataSeries * n / 2 - (a.previousDataSeriesCount + d) * n << 0 : l - a.plotType.totalDataSeries * n / 2 + (a.previousDataSeriesCount + d) * n << 0;var C = a.axisX.reversed ? l - n << 0 : l + n << 0;t > k && (e = t, t = k, k = e);a.axisY.reversed && (e = t, t = k, k = e);e = m.dataPointIds[h];this._eventManager.objectMap[e] = { id: e, objectType: \"dataPoint\",\n                dataSeriesIndex: w, dataPointIndex: h, x1: l, y1: t, x2: C, y2: k };var J = q[h].color ? q[h].color : -1 < q[h].y ? m.risingColor : m.fallingColor;V(b, l, t, C, k, J, 0, J, y, y, !1, !1, m.fillOpacity);e = R(e);v && V(this._eventManager.ghostCtx, l, t, C, k, e, 0, null, !1, !1, !1, !1);var I,\n                  J = l;I = \"undefined\" !== typeof q[h].isIntermediateSum && !0 === q[h].isIntermediateSum || \"undefined\" !== typeof q[h].isCumulativeSum && !0 === q[h].isCumulativeSum ? -1 < q[h].y ? t : k : -1 < q[h].y ? k : t;0 < h && B && (!x || m.connectNullData) && (x && b.setLineDash && b.setLineDash(G(z, u)), b.beginPath(), b.moveTo(B, A - s), b.lineTo(J, I - s), 0 < u && b.stroke(), v && (c.beginPath(), c.moveTo(B, A - s), c.lineTo(J, I - s), 0 < u && c.stroke()));x = !1;B = C;A = -1 < q[h].y ? t : k;J = q[h].lineDashType ? q[h].lineDashType : m.options.lineDashType ? m.options.lineDashType : \"shortDash\";b.strokeStyle = q[h].lineColor ? q[h].lineColor : m.options.lineColor ? m.options.lineColor : \"#9e9e9e\";b.lineWidth = u;b.setLineDash && (J = G(J, u), b.setLineDash(J));(q[h].indexLabel || m.indexLabel || q[h].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: \"waterfall\",\n                dataPoint: q[h], dataSeries: m, point: { x: l + (C - l) / 2, y: 0 <= q[h].y ? t : k }, direction: 0 > q[h].y === a.axisY.reversed ? 1 : -1, bounds: { x1: l, y1: Math.min(t, k), x2: C, y2: Math.max(t, k) }, color: e });\n            }\n          }\n        }v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.restore());b.restore();return { source: f, dest: this.plotArea.ctx, animationCallback: H.fadeInAnimation, easingFunction: H.easing.easeInQuad, animationBase: 0 };\n      }\n    };var ra = function ra(a, f, b, c, e, g, h, l, t) {\n      if (!(0 > b)) {\n        \"undefined\" === typeof l && (l = 1);if (!v) {\n          var k = Number((h % (2 * Math.PI)).toFixed(8));Number((g % (2 * Math.PI)).toFixed(8)) === k && (h -= 1E-4);\n        }a.save();a.globalAlpha = l;\"pie\" === e ? (a.beginPath(), a.moveTo(f.x, f.y), a.arc(f.x, f.y, b, g, h, !1), a.fillStyle = c, a.strokeStyle = \"white\", a.lineWidth = 2, a.closePath(), a.fill()) : \"doughnut\" === e && (a.beginPath(), a.arc(f.x, f.y, b, g, h, !1), 0 <= t && a.arc(f.x, f.y, t * b, h, g, !0), a.closePath(), a.fillStyle = c, a.strokeStyle = \"white\", a.lineWidth = 2, a.fill());a.globalAlpha = 1;a.restore();\n      }\n    };q.prototype.renderPie = function (a) {\n      function f() {\n        if (k && r) {\n          for (var a = 0, b = 0, c = 0, e = 0, f = 0; f < r.length; f++) {\n            var g = r[f],\n                h = k.dataPointIds[f];d[f].id = h;d[f].objectType = \"dataPoint\";d[f].dataPointIndex = f;d[f].dataSeriesIndex = 0;var l = d[f],\n                p = { percent: null, total: null },\n                m = null,\n                p = t.getPercentAndTotal(k, g);if (k.indexLabelFormatter || g.indexLabelFormatter) m = { chart: t.options, dataSeries: k, dataPoint: g, total: p.total, percent: p.percent };p = g.indexLabelFormatter ? g.indexLabelFormatter(m) : g.indexLabel ? t.replaceKeywordsWithValue(g.indexLabel, g, k, f) : k.indexLabelFormatter ? k.indexLabelFormatter(m) : k.indexLabel ? t.replaceKeywordsWithValue(k.indexLabel, g, k, f) : g.label ? g.label : \"\";t._eventManager.objectMap[h] = l;l.center = { x: x.x, y: x.y };l.y = g.y;l.radius = A;l.percentInnerRadius = L;l.indexLabelText = p;l.indexLabelPlacement = k.indexLabelPlacement;l.indexLabelLineColor = g.indexLabelLineColor ? g.indexLabelLineColor : k.options.indexLabelLineColor ? k.options.indexLabelLineColor : g.color ? g.color : k._colorSet[f % k._colorSet.length];l.indexLabelLineThickness = y(g.indexLabelLineThickness) ? k.indexLabelLineThickness : g.indexLabelLineThickness;l.indexLabelLineDashType = g.indexLabelLineDashType ? g.indexLabelLineDashType : k.indexLabelLineDashType;l.indexLabelFontColor = g.indexLabelFontColor ? g.indexLabelFontColor : k.indexLabelFontColor;l.indexLabelFontStyle = g.indexLabelFontStyle ? g.indexLabelFontStyle : k.indexLabelFontStyle;l.indexLabelFontWeight = g.indexLabelFontWeight ? g.indexLabelFontWeight : k.indexLabelFontWeight;l.indexLabelFontSize = y(g.indexLabelFontSize) ? k.indexLabelFontSize : g.indexLabelFontSize;l.indexLabelFontFamily = g.indexLabelFontFamily ? g.indexLabelFontFamily : k.indexLabelFontFamily;l.indexLabelBackgroundColor = g.indexLabelBackgroundColor ? g.indexLabelBackgroundColor : k.options.indexLabelBackgroundColor ? k.options.indexLabelBackgroundColor : k.indexLabelBackgroundColor;l.indexLabelMaxWidth = g.indexLabelMaxWidth ? g.indexLabelMaxWidth : k.indexLabelMaxWidth ? k.indexLabelMaxWidth : 0.33 * n.width;l.indexLabelWrap = \"undefined\" !== typeof g.indexLabelWrap ? g.indexLabelWrap : k.indexLabelWrap;l.startAngle = 0 === f ? k.startAngle ? k.startAngle / 180 * Math.PI : 0 : d[f - 1].endAngle;l.startAngle = (l.startAngle + 2 * Math.PI) % (2 * Math.PI);l.endAngle = l.startAngle + 2 * Math.PI / z * Math.abs(g.y);g = (l.endAngle + l.startAngle) / 2;g = (g + 2 * Math.PI) % (2 * Math.PI);\n            l.midAngle = g;if (l.midAngle > Math.PI / 2 - u && l.midAngle < Math.PI / 2 + u) {\n              if (0 === a || d[c].midAngle > l.midAngle) c = f;a++;\n            } else if (l.midAngle > 3 * Math.PI / 2 - u && l.midAngle < 3 * Math.PI / 2 + u) {\n              if (0 === b || d[e].midAngle > l.midAngle) e = f;b++;\n            }l.hemisphere = g > Math.PI / 2 && g <= 3 * Math.PI / 2 ? \"left\" : \"right\";l.indexLabelTextBlock = new la(t.plotArea.ctx, { fontSize: l.indexLabelFontSize, fontFamily: l.indexLabelFontFamily, fontColor: l.indexLabelFontColor, fontStyle: l.indexLabelFontStyle, fontWeight: l.indexLabelFontWeight, horizontalAlign: \"left\", backgroundColor: l.indexLabelBackgroundColor,\n              maxWidth: l.indexLabelMaxWidth, maxHeight: l.indexLabelWrap ? 5 * l.indexLabelFontSize : 1.5 * l.indexLabelFontSize, text: l.indexLabelText, padding: 0, textBaseline: \"top\" });l.indexLabelTextBlock.measureText();\n          }h = g = 0;p = !1;for (f = 0; f < r.length; f++) {\n            l = d[(c + f) % r.length], 1 < a && l.midAngle > Math.PI / 2 - u && l.midAngle < Math.PI / 2 + u && (g <= a / 2 && !p ? (l.hemisphere = \"right\", g++) : (l.hemisphere = \"left\", p = !0));\n          }p = !1;for (f = 0; f < r.length; f++) {\n            l = d[(e + f) % r.length], 1 < b && l.midAngle > 3 * Math.PI / 2 - u && l.midAngle < 3 * Math.PI / 2 + u && (h <= b / 2 && !p ? (l.hemisphere = \"left\", h++) : (l.hemisphere = \"right\", p = !0));\n          }\n        }\n      }function b(a) {\n        var b = t.plotArea.ctx;b.clearRect(n.x1, n.y1, n.width, n.height);b.fillStyle = t.backgroundColor;b.fillRect(n.x1, n.y1, n.width, n.height);for (b = 0; b < r.length; b++) {\n          var c = d[b].startAngle,\n              e = d[b].endAngle;if (e > c) {\n            var f = 0.07 * A * Math.cos(d[b].midAngle),\n                g = 0.07 * A * Math.sin(d[b].midAngle),\n                h = !1;if (r[b].exploded) {\n              if (1E-9 < Math.abs(d[b].center.x - (x.x + f)) || 1E-9 < Math.abs(d[b].center.y - (x.y + g))) d[b].center.x = x.x + f * a, d[b].center.y = x.y + g * a, h = !0;\n            } else if (0 < Math.abs(d[b].center.x - x.x) || 0 < Math.abs(d[b].center.y - x.y)) d[b].center.x = x.x + f * (1 - a), d[b].center.y = x.y + g * (1 - a), h = !0;h && (f = {}, f.dataSeries = k, f.dataPoint = k.dataPoints[b], f.index = b, t.toolTip.highlightObjects([f]));ra(t.plotArea.ctx, d[b].center, d[b].radius, r[b].color ? r[b].color : k._colorSet[b % k._colorSet.length], k.type, c, e, k.fillOpacity, d[b].percentInnerRadius);\n          }\n        }a = t.plotArea.ctx;a.save();a.fillStyle = \"black\";a.strokeStyle = \"grey\";a.textBaseline = \"middle\";a.lineJoin = \"round\";for (b = b = 0; b < r.length; b++) {\n          c = d[b], c.indexLabelText && (c.indexLabelTextBlock.y -= c.indexLabelTextBlock.height / 2, e = 0, e = \"left\" === c.hemisphere ? \"inside\" !== k.indexLabelPlacement ? -(c.indexLabelTextBlock.width + p) : -c.indexLabelTextBlock.width / 2 : \"inside\" !== k.indexLabelPlacement ? p : -c.indexLabelTextBlock.width / 2, c.indexLabelTextBlock.x += e, c.indexLabelTextBlock.render(!0), c.indexLabelTextBlock.x -= e, c.indexLabelTextBlock.y += c.indexLabelTextBlock.height / 2, \"inside\" !== c.indexLabelPlacement && 0 < c.indexLabelLineThickness && (e = c.center.x + A * Math.cos(c.midAngle), f = c.center.y + A * Math.sin(c.midAngle), a.strokeStyle = c.indexLabelLineColor, a.lineWidth = c.indexLabelLineThickness, a.setLineDash && a.setLineDash(G(c.indexLabelLineDashType, c.indexLabelLineThickness)), a.beginPath(), a.moveTo(e, f), a.lineTo(c.indexLabelTextBlock.x, c.indexLabelTextBlock.y), a.lineTo(c.indexLabelTextBlock.x + (\"left\" === c.hemisphere ? -p : p), c.indexLabelTextBlock.y), a.stroke()), a.lineJoin = \"miter\");\n        }a.save();\n      }function c(a, b) {\n        var c = 0,\n            c = a.indexLabelTextBlock.y - a.indexLabelTextBlock.height / 2,\n            d = a.indexLabelTextBlock.y + a.indexLabelTextBlock.height / 2,\n            e = b.indexLabelTextBlock.y - b.indexLabelTextBlock.height / 2,\n            f = b.indexLabelTextBlock.y + b.indexLabelTextBlock.height / 2;return c = b.indexLabelTextBlock.y > a.indexLabelTextBlock.y ? e - d : c - f;\n      }function e(a) {\n        for (var b = null, e = 1; e < r.length; e++) {\n          if (b = (a + e + d.length) % d.length, d[b].hemisphere !== d[a].hemisphere) {\n            b = null;break;\n          } else if (d[b].indexLabelText && b !== a && (0 > c(d[b], d[a]) || (\"right\" === d[a].hemisphere ? d[b].indexLabelTextBlock.y >= d[a].indexLabelTextBlock.y : d[b].indexLabelTextBlock.y <= d[a].indexLabelTextBlock.y))) break;else b = null;\n        }return b;\n      }function g(a, b, f) {\n        f = (f || 0) + 1;if (1E3 < f) return 0;b = b || 0;var k = 0,\n            h = x.y - 1 * q,\n            n = x.y + 1 * q;if (0 <= a && a < r.length) {\n          var l = d[a];if (0 > b && l.indexLabelTextBlock.y < h || 0 < b && l.indexLabelTextBlock.y > n) return 0;var t = 0,\n              p = 0,\n              p = t = t = 0;0 > b ? l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 > h && l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 + b < h && (b = -(h - (l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 + b))) : l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 < h && l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 + b > n && (b = l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 + b - n);b = l.indexLabelTextBlock.y + b;h = 0;h = \"right\" === l.hemisphere ? x.x + Math.sqrt(Math.pow(q, 2) - Math.pow(b - x.y, 2)) : x.x - Math.sqrt(Math.pow(q, 2) - Math.pow(b - x.y, 2));p = x.x + A * Math.cos(l.midAngle);t = x.y + A * Math.sin(l.midAngle);t = Math.sqrt(Math.pow(h - p, 2) + Math.pow(b - t, 2));p = Math.acos(A / q);t = Math.acos((q * q + A * A - t * t) / (2 * A * q));b = t < p ? b - l.indexLabelTextBlock.y : 0;h = null;for (n = 1; n < r.length; n++) {\n            if (h = (a - n + d.length) % d.length, d[h].hemisphere !== d[a].hemisphere) {\n              h = null;break;\n            } else if (d[h].indexLabelText && d[h].hemisphere === d[a].hemisphere && h !== a && (0 > c(d[h], d[a]) || (\"right\" === d[a].hemisphere ? d[h].indexLabelTextBlock.y <= d[a].indexLabelTextBlock.y : d[h].indexLabelTextBlock.y >= d[a].indexLabelTextBlock.y))) break;else h = null;\n          }p = h;t = e(a);n = h = 0;0 > b ? (n = \"right\" === l.hemisphere ? p : t, k = b, null !== n && (p = -b, b = l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 - (d[n].indexLabelTextBlock.y + d[n].indexLabelTextBlock.height / 2), b - p < m && (h = -p, n = g(n, h, f + 1), +n.toFixed(v) > +h.toFixed(v) && (k = b > m ? -(b - m) : -(p - (n - h)))))) : 0 < b && (n = \"right\" === l.hemisphere ? t : p, k = b, null !== n && (p = b, b = d[n].indexLabelTextBlock.y - d[n].indexLabelTextBlock.height / 2 - (l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2), b - p < m && (h = p, n = g(n, h, f + 1), +n.toFixed(v) < +h.toFixed(v) && (k = b > m ? b - m : p - (h - n)))));k && (f = l.indexLabelTextBlock.y + k, b = 0, b = \"right\" === l.hemisphere ? x.x + Math.sqrt(Math.pow(q, 2) - Math.pow(f - x.y, 2)) : x.x - Math.sqrt(Math.pow(q, 2) - Math.pow(f - x.y, 2)), l.midAngle > Math.PI / 2 - u && l.midAngle < Math.PI / 2 + u ? (h = (a - 1 + d.length) % d.length, h = d[h], a = d[(a + 1 + d.length) % d.length], \"left\" === l.hemisphere && \"right\" === h.hemisphere && b > h.indexLabelTextBlock.x ? b = h.indexLabelTextBlock.x - 15 : \"right\" === l.hemisphere && \"left\" === a.hemisphere && b < a.indexLabelTextBlock.x && (b = a.indexLabelTextBlock.x + 15)) : l.midAngle > 3 * Math.PI / 2 - u && l.midAngle < 3 * Math.PI / 2 + u && (h = (a - 1 + d.length) % d.length, h = d[h], a = d[(a + 1 + d.length) % d.length], \"right\" === l.hemisphere && \"left\" === h.hemisphere && b < h.indexLabelTextBlock.x ? b = h.indexLabelTextBlock.x + 15 : \"left\" === l.hemisphere && \"right\" === a.hemisphere && b > a.indexLabelTextBlock.x && (b = a.indexLabelTextBlock.x - 15)), l.indexLabelTextBlock.y = f, l.indexLabelTextBlock.x = b, l.indexLabelAngle = Math.atan2(l.indexLabelTextBlock.y - x.y, l.indexLabelTextBlock.x - x.x));\n        }return k;\n      }function h() {\n        var a = t.plotArea.ctx;a.fillStyle = \"grey\";a.strokeStyle = \"grey\";a.font = \"16px Arial\";a.textBaseline = \"middle\";for (var b = a = 0, f = 0, h = !0, b = 0; 10 > b && (1 > b || 0 < f); b++) {\n          if (k.radius || !k.radius && \"undefined\" !== typeof k.innerRadius && null !== k.innerRadius && A - f <= C) h = !1;h && (A -= f);f = 0;if (\"inside\" !== k.indexLabelPlacement) {\n            q = A * s;for (a = 0; a < r.length; a++) {\n              var l = d[a];l.indexLabelTextBlock.x = x.x + q * Math.cos(l.midAngle);l.indexLabelTextBlock.y = x.y + q * Math.sin(l.midAngle);l.indexLabelAngle = l.midAngle;l.radius = A;l.percentInnerRadius = L;\n            }for (var u, y, a = 0; a < r.length; a++) {\n              var l = d[a],\n                  B = e(a);if (null !== B) {\n                u = d[a];y = d[B];var z = 0,\n                    z = c(u, y) - m;if (0 > z) {\n                  for (var ba = y = 0, G = 0; G < r.length; G++) {\n                    G !== a && d[G].hemisphere === l.hemisphere && (d[G].indexLabelTextBlock.y < l.indexLabelTextBlock.y ? y++ : ba++);\n                  }y = z / (y + ba || 1) * ba;var ba = -1 * (z - y),\n                      H = G = 0;\"right\" === l.hemisphere ? (G = g(a, y), ba = -1 * (z - G), H = g(B, ba), +H.toFixed(v) < +ba.toFixed(v) && +G.toFixed(v) <= +y.toFixed(v) && g(a, -(ba - H))) : (G = g(B, y), ba = -1 * (z - G), H = g(a, ba), +H.toFixed(v) < +ba.toFixed(v) && +G.toFixed(v) <= +y.toFixed(v) && g(B, -(ba - H)));\n                }\n              }\n            }\n          } else for (a = 0; a < r.length; a++) {\n            l = d[a], q = \"pie\" === k.type ? 0.7 * A : 0.8 * A, B = x.x + q * Math.cos(l.midAngle), y = x.y + q * Math.sin(l.midAngle), l.indexLabelTextBlock.x = B, l.indexLabelTextBlock.y = y;\n          }for (a = 0; a < r.length; a++) {\n            if (l = d[a], B = l.indexLabelTextBlock.measureText(), 0 !== B.height && 0 !== B.width) B = B = 0, \"right\" === l.hemisphere ? (B = n.x2 - (l.indexLabelTextBlock.x + l.indexLabelTextBlock.width + p), B *= -1) : B = n.x1 - (l.indexLabelTextBlock.x - l.indexLabelTextBlock.width - p), 0 < B && (!h && l.indexLabelText && (y = \"right\" === l.hemisphere ? n.x2 - l.indexLabelTextBlock.x : l.indexLabelTextBlock.x - n.x1, 0.3 * l.indexLabelTextBlock.maxWidth > y ? l.indexLabelText = \"\" : l.indexLabelTextBlock.maxWidth = 0.85 * y, 0.3 * l.indexLabelTextBlock.maxWidth < y && (l.indexLabelTextBlock.x -= \"right\" === l.hemisphere ? 2 : -2)), Math.abs(l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 - x.y) < A || Math.abs(l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 - x.y) < A) && (B /= Math.abs(Math.cos(l.indexLabelAngle)), 9 < B && (B *= 0.3), B > f && (f = B)), B = B = 0, 0 < l.indexLabelAngle && l.indexLabelAngle < Math.PI ? (B = n.y2 - (l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 + 5), B *= -1) : B = n.y1 - (l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 - 5), 0 < B && (!h && l.indexLabelText && (y = 0 < l.indexLabelAngle && l.indexLabelAngle < Math.PI ? -1 : 1, 0 === g(a, B * y) && g(a, 2 * y)), Math.abs(l.indexLabelTextBlock.x - x.x) < A && (B /= Math.abs(Math.sin(l.indexLabelAngle)), 9 < B && (B *= 0.3), B > f && (f = B)));\n          }var K = function K(a, b, c) {\n            for (var e = [], f = 0; e.push(d[b]), b !== c; b = (b + 1 + r.length) % r.length) {}e.sort(function (a, b) {\n              return a.y - b.y;\n            });for (b = 0; b < e.length; b++) {\n              if (c = e[b], f < 0.7 * a) f += c.indexLabelTextBlock.height, c.indexLabelTextBlock.text = \"\", c.indexLabelText = \"\", c.indexLabelTextBlock.measureText();else break;\n            }\n          };(function () {\n            for (var a = -1, b = -1, f = 0, g = !1, h = 0; h < r.length; h++) {\n              if (g = !1, u = d[h], u.indexLabelText) {\n                var k = e(h);if (null !== k) {\n                  var l = d[k];z = 0;\n                  z = c(u, l);var n;if (n = 0 > z) {\n                    n = u.indexLabelTextBlock.x;var t = u.indexLabelTextBlock.y - u.indexLabelTextBlock.height / 2,\n                        m = u.indexLabelTextBlock.y + u.indexLabelTextBlock.height / 2,\n                        w = l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2,\n                        q = l.indexLabelTextBlock.x + l.indexLabelTextBlock.width,\n                        s = l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2;n = u.indexLabelTextBlock.x + u.indexLabelTextBlock.width < l.indexLabelTextBlock.x - p || n > q + p || t > s + p || m < w - p ? !1 : !0;\n                  }n ? (0 > a && (a = h), k !== a && (b = k, f += -z), 0 === h % Math.max(r.length / 10, 3) && (g = !0)) : g = !0;g && 0 < f && 0 <= a && 0 <= b && (K(f, a, b), b = a = -1, f = 0);\n                }\n              }\n            }0 < f && K(f, a, b);\n          })();\n        }\n      }function l() {\n        t.plotArea.layoutManager.reset();t.title && (t.title.dockInsidePlotArea || \"center\" === t.title.horizontalAlign && \"center\" === t.title.verticalAlign) && t.title.render();if (t.subtitles) for (var a = 0; a < t.subtitles.length; a++) {\n          var b = t.subtitles[a];(b.dockInsidePlotArea || \"center\" === b.horizontalAlign && \"center\" === b.verticalAlign) && b.render();\n        }t.legend && (t.legend.dockInsidePlotArea || \"center\" === t.legend.horizontalAlign && \"center\" === t.legend.verticalAlign) && t.legend.render();\n      }var t = this;if (!(0 >= a.dataSeriesIndexes.length)) {\n        var k = this.data[a.dataSeriesIndexes[0]],\n            r = k.dataPoints,\n            p = 10,\n            n = this.plotArea,\n            d = k.dataPointEOs,\n            m = 2,\n            q,\n            s = 1.3,\n            u = 20 / 180 * Math.PI,\n            v = 6,\n            x = { x: (n.x2 + n.x1) / 2, y: (n.y2 + n.y1) / 2 },\n            z = 0;a = !1;for (var B = 0; B < r.length; B++) {\n          z += Math.abs(r[B].y), !a && \"undefined\" !== typeof r[B].indexLabel && null !== r[B].indexLabel && 0 < r[B].indexLabel.toString().length && (a = !0), !a && \"undefined\" !== typeof r[B].label && null !== r[B].label && 0 < r[B].label.toString().length && (a = !0);\n        }if (0 !== z) {\n          a = a || \"undefined\" !== typeof k.indexLabel && null !== k.indexLabel && 0 < k.indexLabel.toString().length;var A = \"inside\" !== k.indexLabelPlacement && a ? 0.75 * Math.min(n.width, n.height) / 2 : 0.92 * Math.min(n.width, n.height) / 2;k.radius && (A = O(k.radius, A));var C = \"undefined\" !== typeof k.innerRadius && null !== k.innerRadius ? O(k.innerRadius, A) : 0.7 * A;k.radius = A;\"doughnut\" === k.type && (k.innerRadius = C);var L = Math.min(C / A, (A - 1) / A);this.pieDoughnutClickHandler = function (a) {\n            t.isAnimating || !y(a.dataSeries.explodeOnClick) && !a.dataSeries.explodeOnClick || (a = a.dataPoint, a.exploded = a.exploded ? !1 : !0, 1 < this.dataPoints.length && t._animator.animate(0, 500, function (a) {\n              b(a);l();\n            }));\n          };f();h();h();h();h();this.disableToolTip = !0;this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function (a) {\n            var b = t.plotArea.ctx;b.clearRect(n.x1, n.y1, n.width, n.height);b.fillStyle = t.backgroundColor;b.fillRect(n.x1, n.y1, n.width, n.height);a = d[0].startAngle + 2 * Math.PI * a;for (b = 0; b < r.length; b++) {\n              var c = 0 === b ? d[b].startAngle : e,\n                  e = c + (d[b].endAngle - d[b].startAngle),\n                  f = !1;e > a && (e = a, f = !0);var g = r[b].color ? r[b].color : k._colorSet[b % k._colorSet.length];e > c && ra(t.plotArea.ctx, d[b].center, d[b].radius, g, k.type, c, e, k.fillOpacity, d[b].percentInnerRadius);if (f) break;\n            }l();\n          }, function () {\n            t.disableToolTip = !1;t._animator.animate(0, t.animatedRender ? 500 : 0, function (a) {\n              b(a);l();\n            });\n          });\n        }\n      }\n    };var sa = function sa(a, f, b, c) {\n      \"undefined\" === typeof b && (b = 1);0 >= Math.round(f.y4 - f.y1) || (a.save(), a.globalAlpha = b, a.beginPath(), a.moveTo(Math.round(f.x1), Math.round(f.y1)), a.lineTo(Math.round(f.x2), Math.round(f.y2)), a.lineTo(Math.round(f.x3), Math.round(f.y3)), a.lineTo(Math.round(f.x4), Math.round(f.y4)), \"undefined\" !== f.x5 && (a.lineTo(Math.round(f.x5), Math.round(f.y5)), a.lineTo(Math.round(f.x6), Math.round(f.y6))), a.closePath(), a.fillStyle = c ? c : f.color, a.fill(), a.globalAplha = 1, a.restore());\n    };q.prototype.renderFunnel = function (a) {\n      function f() {\n        for (var a = 0, b = [], c = 0; c < x.length; c++) {\n          if (\"undefined\" === typeof x[c].y) return -1;x[c].y = \"number\" === typeof x[c].y ? x[c].y : 0;a += Math.abs(x[c].y);\n        }if (0 === a) return -1;for (c = b[0] = 0; c < x.length; c++) {\n          b.push(Math.abs(x[c].y) * O / a);\n        }return b;\n      }function b() {\n        var a = X,\n            b = V,\n            c = K,\n            d = Y,\n            e,\n            f;e = Q;f = $ - N;headArea = (f - e) * (b - a + (d - c)) / 2;headArea = Math.abs(headArea);c = Y - K;e = f - e;f = c * (f - $);f = Math.abs(f);f = headArea + f;for (var d = [], g = 0, h = 0; h < x.length; h++) {\n          if (\"undefined\" === typeof x[h].y) return -1;x[h].y = \"number\" === typeof x[h].y ? x[h].y : 0;g += Math.abs(x[h].y);\n        }if (0 === g) return -1;for (var k = d[0] = 0, l = 0, n, b = b - a, t = !1, h = 0; h < x.length; h++) {\n          a = Math.abs(x[h].y) * f / g, t ? k = 0 == Number(c.toFixed(3)) ? 0 : a / c : (sqrt = fa * fa * b * b - 4 * Math.abs(fa) * a, 0 > sqrt ? (n = c, k = (b + n) * (e - l) / 2, a -= k, k = e - l, l += e - l, k += 0 == n ? 0 : a / n, l += a / n, t = !0) : (k = (Math.abs(fa) * b - Math.sqrt(sqrt)) / 2, n = b - 2 * k / Math.abs(fa), l += k, l > e && (l -= k, n = c, k = (b + n) * (e - l) / 2, a -= k, k = e - l, l += e - l, k += a / n, l += a / n, t = !0), b = n)), d.push(k);\n        }return d;\n      }function c() {\n        if (u && x) {\n          for (var a, b, c, e, f, g, h, k, l, n, t, p, r, m, w = [], q = [], A = { percent: null, total: null }, B = null, z = 0; z < x.length; z++) {\n            m = M[z], m = \"undefined\" !== typeof m.x5 ? (m.y2 + m.y4) / 2 : (m.y2 + m.y3) / 2, m = d(m).x2 + 1, w[z] = P - m - U;\n          }m = 0.5 * U;for (var z = 0, za = x.length - 1; z < x.length || 0 <= za; z++, za--) {\n            b = u.reversed ? x[za] : x[z];a = b.color ? b.color : u.reversed ? u._colorSet[(x.length - 1 - z) % u._colorSet.length] : u._colorSet[z % u._colorSet.length];c = b.indexLabelPlacement || u.indexLabelPlacement || \"outside\";e = b.indexLabelBackgroundColor || u.indexLabelBackgroundColor || (v ? \"transparent\" : null);f = b.indexLabelFontColor || u.indexLabelFontColor || \"#979797\";g = y(b.indexLabelFontSize) ? u.indexLabelFontSize : b.indexLabelFontSize;h = b.indexLabelFontStyle || u.indexLabelFontStyle || \"normal\";k = b.indexLabelFontFamily || u.indexLabelFontFamily || \"arial\";l = b.indexLabelFontWeight || u.indexLabelFontWeight || \"normal\";a = b.indexLabelLineColor || u.options.indexLabelLineColor || a;n = \"number\" === typeof b.indexLabelLineThickness ? b.indexLabelLineThickness : \"number\" === typeof u.indexLabelLineThickness ? u.indexLabelLineThickness : 2;t = b.indexLabelLineDashType || u.indexLabelLineDashType || \"solid\";p = \"undefined\" !== typeof b.indexLabelWrap ? b.indexLabelWrap : \"undefined\" !== typeof u.indexLabelWrap ? u.indexLabelWrap : !0;r = u.dataPointIds[z];s._eventManager.objectMap[r] = { id: r,\n              objectType: \"dataPoint\", dataPointIndex: z, dataSeriesIndex: 0, funnelSection: M[u.reversed ? x.length - 1 - z : z] };\"inside\" === u.indexLabelPlacement && (w[z] = z !== ga ? u.reversed ? M[z].x2 - M[z].x1 : M[z].x3 - M[z].x4 : M[z].x3 - M[z].x6, 20 > w[z] && (w[z] = z !== ga ? u.reversed ? M[z].x3 - M[z].x4 : M[z].x2 - M[z].x1 : M[z].x2 - M[z].x1, w[z] /= 2));r = b.indexLabelMaxWidth ? b.indexLabelMaxWidth : u.options.indexLabelMaxWidth ? u.indexLabelMaxWidth : w[z];if (r > w[z] || 0 > r) r = w[z];q[z] = \"inside\" === u.indexLabelPlacement ? M[z].height : !1;A = s.getPercentAndTotal(u, b);\n            if (u.indexLabelFormatter || b.indexLabelFormatter) B = { chart: s.options, dataSeries: u, dataPoint: b, total: A.total, percent: A.percent };b = b.indexLabelFormatter ? b.indexLabelFormatter(B) : b.indexLabel ? s.replaceKeywordsWithValue(b.indexLabel, b, u, z) : u.indexLabelFormatter ? u.indexLabelFormatter(B) : u.indexLabel ? s.replaceKeywordsWithValue(u.indexLabel, b, u, z) : b.label ? b.label : \"\";0 >= n && (n = 0);1E3 > r && 1E3 - r < m && (r += 1E3 - r);R.roundRect || Ca(R);c = new la(R, { fontSize: g, fontFamily: k, fontColor: f, fontStyle: h, fontWeight: l, horizontalAlign: c,\n              backgroundColor: e, maxWidth: r, maxHeight: !1 === q[z] ? p ? 4.28571429 * g : 1.5 * g : q[z], text: b, padding: ha });c.measureText();F.push({ textBlock: c, id: u.reversed ? za : z, isDirty: !1, lineColor: a, lineThickness: n, lineDashType: t, height: c.height < c.maxHeight ? c.height : c.maxHeight, width: c.width < c.maxWidth ? c.width : c.maxWidth });\n          }\n        }\n      }function e() {\n        var a,\n            b,\n            c,\n            d,\n            e,\n            f = [];e = !1;c = 0;for (var g = P - V - U / 2, g = u.options.indexLabelMaxWidth ? u.indexLabelMaxWidth > g ? g : u.indexLabelMaxWidth : g, h = F.length - 1; 0 <= h; h--) {\n          dataPoint = x[F[h].id];c = F[h];d = c.textBlock;\n          b = (a = n(h) < M.length ? F[n(h)] : null) ? a.textBlock : null;c = c.height;a && d.y + c + ha > b.y && (e = !0);c = dataPoint.indexLabelMaxWidth || g;if (c > g || 0 > c) c = g;f.push(c);\n        }if (e) for (h = F.length - 1; 0 <= h; h--) {\n          a = M[h], F[h].textBlock.maxWidth = f[f.length - (h + 1)], F[h].textBlock.measureText(), F[h].textBlock.x = P - g, c = F[h].textBlock.height < F[h].textBlock.maxHeight ? F[h].textBlock.height : F[h].textBlock.maxHeight, e = F[h].textBlock.width < F[h].textBlock.maxWidth ? F[h].textBlock.width : F[h].textBlock.maxWidth, F[h].height = c, F[h].width = e, c = \"undefined\" !== typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, F[h].textBlock.y = c - F[h].height / 2, u.reversed ? (F[h].textBlock.y + F[h].height > T + C && (F[h].textBlock.y = T + C - F[h].height), F[h].textBlock.y < ta - C && (F[h].textBlock.y = ta - C)) : (F[h].textBlock.y < T - C && (F[h].textBlock.y = T - C), F[h].textBlock.y + F[h].height > ta + C && (F[h].textBlock.y = ta + C - F[h].height));\n        }\n      }function g() {\n        var a, b, c, e;if (\"inside\" !== u.indexLabelPlacement) for (var f = 0; f < M.length; f++) {\n          0 == F[f].textBlock.text.length ? F[f].isDirty = !0 : (a = M[f], c = \"undefined\" !== typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, b = u.reversed ? \"undefined\" !== typeof a.x5 ? c > aa ? d(c).x2 + 1 : (a.x2 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1 : \"undefined\" !== typeof a.x5 ? c < aa ? d(c).x2 + 1 : (a.x4 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1, F[f].textBlock.x = b + U, F[f].textBlock.y = c - F[f].height / 2, u.reversed ? (F[f].textBlock.y + F[f].height > T + C && (F[f].textBlock.y = T + C - F[f].height), F[f].textBlock.y < ta - C && (F[f].textBlock.y = ta - C)) : (F[f].textBlock.y < T - C && (F[f].textBlock.y = T - C), F[f].textBlock.y + F[f].height > ta + C && (F[f].textBlock.y = ta + C - F[f].height)));\n        } else for (f = 0; f < M.length; f++) {\n          0 == F[f].textBlock.text.length ? F[f].isDirty = !0 : (a = M[f], b = a.height, c = F[f].height, e = F[f].width, b >= c ? (b = f != ga ? (a.x4 + a.x3) / 2 - e / 2 : (a.x5 + a.x4) / 2 - e / 2, c = f != ga ? (a.y1 + a.y3) / 2 - c / 2 : (a.y1 + a.y4) / 2 - c / 2, F[f].textBlock.x = b, F[f].textBlock.y = c) : F[f].isDirty = !0);\n        }\n      }function h() {\n        function a(b, c) {\n          var d;if (0 > b || b >= F.length) return 0;var e,\n              f = F[b].textBlock;if (0 > c) {\n            c *= -1;e = p(b);d = l(e, b);if (d >= c) return f.y -= c, c;if (0 == b) return 0 < d && (f.y -= d), d;d += a(e, -(c - d));0 < d && (f.y -= d);return d;\n          }e = n(b);d = l(b, e);if (d >= c) return f.y += c, c;if (b == M.length - 1) return 0 < d && (f.y += d), d;d += a(e, c - d);0 < d && (f.y += d);return d;\n        }function b() {\n          var a,\n              d,\n              e,\n              f,\n              g = 0,\n              h;f = ($ - Q + 2 * C) / t;h = t;for (var k, l = 1; l < h; l++) {\n            e = l * f;for (var r = F.length - 1; 0 <= r; r--) {\n              !F[r].isDirty && F[r].textBlock.y < e && F[r].textBlock.y + F[r].height > e && (k = n(r), !(k >= F.length - 1) && F[r].textBlock.y + F[r].height + ha > F[k].textBlock.y && (F[r].textBlock.y = F[r].textBlock.y + F[r].height - e > e - F[r].textBlock.y ? e + 1 : e - F[r].height - 1));\n            }\n          }for (k = M.length - 1; 0 < k; k--) {\n            if (!F[k].isDirty) {\n              e = p(k);if (0 > e && (e = 0, F[e].isDirty)) break;if (F[k].textBlock.y < F[e].textBlock.y + F[e].height) {\n                d = d || k;f = k;for (h = 0; F[f].textBlock.y < F[e].textBlock.y + F[e].height + ha;) {\n                  a = a || F[f].textBlock.y + F[f].height;h += F[f].height;h += ha;f = e;if (0 >= f) {\n                    f = 0;h += F[f].height;break;\n                  }e = p(f);if (0 > e) {\n                    f = 0;h += F[f].height;break;\n                  }\n                }if (f != k) {\n                  g = F[f].textBlock.y;a -= g;a = h - a;g = c(a, d, f);break;\n                }\n              }\n            }\n          }return g;\n        }function c(a, b, d) {\n          var e = [],\n              f = 0,\n              g = 0;for (a = Math.abs(a); d <= b; d++) {\n            e.push(M[d]);\n          }e.sort(function (a, b) {\n            return a.height - b.height;\n          });for (d = 0; d < e.length; d++) {\n            if (b = e[d], f < a) g++, f += F[b.id].height + ha, F[b.id].textBlock.text = \"\", F[b.id].indexLabelText = \"\", F[b.id].isDirty = !0, F[b.id].textBlock.measureText();else break;\n          }return g;\n        }for (var d, e, f, g, h, k, t = 1, r = 0; r < 2 * t; r++) {\n          for (var m = F.length - 1; 0 <= m && !(previousTextBlock = (previousLabel = 0 <= p(m) ? F[p(m)] : null) ? previousLabel.textBlock : null, f = F[m], g = f.textBlock, k = (h = n(m) < M.length ? F[n(m)] : null) ? h.textBlock : null, d = +f.height.toFixed(6), e = +g.y.toFixed(6), !f.isDirty && h && e + d + ha > +k.y.toFixed(6) && (d = g.y + d + ha - k.y, e = a(m, -d), e < d && (0 < e && (d -= e), e = a(n(m), d), e != d))); m--) {}b();\n        }\n      }function l(a, b) {\n        return (b < M.length ? F[b].textBlock.y : u.reversed ? T + C : ta + C) - (0 > a ? u.reversed ? ta - C : T - C : F[a].textBlock.y + F[a].height + ha);\n      }function t(a, b, c) {\n        var d,\n            e,\n            f,\n            h = [],\n            l = C,\n            n = [];-1 !== b && (0 <= ma.indexOf(b) ? (e = ma.indexOf(b), ma.splice(e, 1)) : (ma.push(b), ma = ma.sort(function (a, b) {\n          return a - b;\n        })));if (0 === ma.length) h = ka;else {\n          e = C * (1 != ma.length || 0 != ma[0] && ma[0] != M.length - 1 ? 2 : 1) / k();for (var t = 0; t < M.length; t++) {\n            if (1 == ma.length && 0 == ma[0]) {\n              if (0 === t) {\n                h.push(ka[t]);d = l;continue;\n              }\n            } else 0 === t && (d = -1 * l);h.push(ka[t] + d);if (0 <= ma.indexOf(t) || t < M.length && 0 <= ma.indexOf(t + 1)) d += e;\n          }\n        }f = function () {\n          for (var a = [], b = 0; b < M.length; b++) {\n            a.push(h[b] - M[b].y1);\n          }return a;\n        }();var p = { startTime: new Date().getTime(), duration: c || 500, easingFunction: function easingFunction(a, b, c, d) {\n            return H.easing.easeOutQuart(a, b, c, d);\n          }, changeSection: function changeSection(a) {\n            for (var b, c, d = 0; d < M.length; d++) {\n              b = f[d], c = M[d], newY = b * a, \"undefined\" === typeof n[d] && (n[d] = 0), 0 > n && (n *= -1), c.y1 += newY - n[d], c.y2 += newY - n[d], c.y3 += newY - n[d], c.y4 += newY - n[d], c.y5 && (c.y5 += newY - n[d], c.y6 += newY - n[d]), n[d] = newY;\n            }\n          } };a._animator.animate(0, c, function (c) {\n          var d = a.plotArea.ctx || a.ctx;ja = !0;d.clearRect(z.x1, z.y1, z.x2 - z.x1, z.y2 - z.y1);d.fillStyle = a.backgroundColor;d.fillRect(z.x1, z.y1, z.width, z.height);p.changeSection(c, b);var e = {};e.dataSeries = u;e.dataPoint = u.reversed ? u.dataPoints[x.length - 1 - b] : u.dataPoints[b];e.index = u.reversed ? x.length - 1 - b : b;a.toolTip.highlightObjects([e]);for (e = 0; e < M.length; e++) {\n            sa(d, M[e], u.fillOpacity);\n          }q(d);J && (\"inside\" !== u.indexLabelPlacement ? r(d) : g(), m(d));1 <= c && (ja = !1);\n        }, null, H.easing.easeOutQuart);\n      }function k() {\n        for (var a = 0, b = 0; b < M.length - 1; b++) {\n          (0 <= ma.indexOf(b) || 0 <= ma.indexOf(b + 1)) && a++;\n        }return a;\n      }function r(a) {\n        for (var b, c, e, f, g = 0; g < M.length; g++) {\n          f = 1 === F[g].lineThickness % 2 ? 0.5 : 0, c = ((M[g].y2 + M[g].y4) / 2 << 0) + f, b = d(c).x2 - 1, e = F[g].textBlock.x, f = (F[g].textBlock.y + F[g].height / 2 << 0) + f, F[g].isDirty || 0 == F[g].lineThickness || (a.strokeStyle = F[g].lineColor, a.lineWidth = F[g].lineThickness, a.setLineDash && a.setLineDash(G(F[g].lineDashType, F[g].lineThickness)), a.beginPath(), a.moveTo(b, c), a.lineTo(e, f), a.stroke());\n        }\n      }function p(a) {\n        for (a -= 1; -1 <= a && -1 != a && F[a].isDirty; a--) {}\n        return a;\n      }function n(a) {\n        for (a += 1; a <= M.length && a != M.length && F[a].isDirty; a++) {}return a;\n      }function d(a) {\n        for (var b, c = 0; c < x.length; c++) {\n          if (M[c].y1 < a && M[c].y4 > a) {\n            b = M[c];break;\n          }\n        }return b ? (a = b.y6 ? a > b.y6 ? b.x3 + (b.x4 - b.x3) / (b.y4 - b.y3) * (a - b.y3) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2), { x1: a, x2: a }) : -1;\n      }function m(a) {\n        for (var b = 0; b < M.length; b++) {\n          F[b].isDirty || (a && (F[b].textBlock.ctx = a), F[b].textBlock.render(!0));\n        }\n      }function q(a) {\n        s.plotArea.layoutManager.reset();a.roundRect || Ca(a);s.title && (s.title.dockInsidePlotArea || \"center\" === s.title.horizontalAlign && \"center\" === s.title.verticalAlign) && (s.title.ctx = a, s.title.render());if (s.subtitles) for (var b = 0; b < s.subtitles.length; b++) {\n          var c = s.subtitles[b];if (c.dockInsidePlotArea || \"center\" === c.horizontalAlign && \"center\" === c.verticalAlign) s.subtitles.ctx = a, c.render();\n        }s.legend && (s.legend.dockInsidePlotArea || \"center\" === s.legend.horizontalAlign && \"center\" === s.legend.verticalAlign) && (s.legend.ctx = a, s.legend.render());Z.fNg && Z.fNg(s);\n      }var s = this;if (!(0 >= a.dataSeriesIndexes.length)) {\n        for (var u = this.data[a.dataSeriesIndexes[0]], x = u.dataPoints, z = this.plotArea, C = 0.025 * z.width, B = 0.01 * z.width, A = 0, O = z.height - 2 * C, L = Math.min(z.width - 2 * B, 2.8 * z.height), J = !1, I = 0; I < x.length; I++) {\n          if (!J && \"undefined\" !== typeof x[I].indexLabel && null !== x[I].indexLabel && 0 < x[I].indexLabel.toString().length && (J = !0), !J && \"undefined\" !== typeof x[I].label && null !== x[I].label && 0 < x[I].label.toString().length && (J = !0), !J && \"function\" === typeof u.indexLabelFormatter || \"function\" === typeof x[I].indexLabelFormatter) J = !0;\n        }J = J || \"undefined\" !== typeof u.indexLabel && null !== u.indexLabel && 0 < u.indexLabel.toString().length;\"inside\" !== u.indexLabelPlacement && J || (B = (z.width - 0.75 * L) / 2);var I = z.x1 + B,\n            P = z.x2 - B,\n            Q = z.y1 + C,\n            $ = z.y2 - C,\n            R = a.targetCanvasCtx || this.plotArea.ctx || this.ctx;if (0 != u.length && u.dataPoints && u.visible && 0 !== x.length) {\n          var N, E;a = 75 * L / 100;var U = 30 * (P - a) / 100;\"funnel\" === u.type ? (N = y(u.options.neckHeight) ? 0.35 * O : u.neckHeight, E = y(u.options.neckWidth) ? 0.25 * a : u.neckWidth, \"string\" === typeof N && N.match(/%$/) ? (N = parseInt(N), N = N * O / 100) : N = parseInt(N), \"string\" === typeof E && E.match(/%$/) ? (E = parseInt(E), E = E * a / 100) : E = parseInt(E), N > O ? N = O : 0 >= N && (N = 0), E > a ? E = a - 0.5 : 0 >= E && (E = 0)) : \"pyramid\" === u.type && (E = N = 0, u.reversed = u.reversed ? !1 : !0);var B = I + a / 2,\n              X = I,\n              V = I + a,\n              T = u.reversed ? $ : Q,\n              K = B - E / 2,\n              Y = B + E / 2,\n              aa = u.reversed ? Q + N : $ - N,\n              ta = u.reversed ? Q : $;a = [];var B = [],\n              M = [],\n              L = [],\n              W = Q,\n              ga,\n              fa = (aa - T) / (K - X),\n              ia = -fa,\n              I = \"area\" === (u.valueRepresents ? u.valueRepresents : \"height\") ? b() : f();if (-1 !== I) {\n            if (u.reversed) for (L.push(W), E = I.length - 1; 0 < E; E--) {\n              W += I[E], L.push(W);\n            } else for (E = 0; E < I.length; E++) {\n              W += I[E], L.push(W);\n            }if (u.reversed) for (E = 0; E < I.length; E++) {\n              L[E] < aa ? (a.push(K), B.push(Y), ga = E) : (a.push((L[E] - T + fa * X) / fa), B.push((L[E] - T + ia * V) / ia));\n            } else for (E = 0; E < I.length; E++) {\n              L[E] < aa ? (a.push((L[E] - T + fa * X) / fa), B.push((L[E] - T + ia * V) / ia), ga = E) : (a.push(K), B.push(Y));\n            }for (E = 0; E < I.length - 1; E++) {\n              W = u.reversed ? x[x.length - 1 - E].color ? x[x.length - 1 - E].color : u._colorSet[(x.length - 1 - E) % u._colorSet.length] : x[E].color ? x[E].color : u._colorSet[E % u._colorSet.length], E === ga ? M.push({ x1: a[E], y1: L[E], x2: B[E], y2: L[E],\n                x3: Y, y3: aa, x4: B[E + 1], y4: L[E + 1], x5: a[E + 1], y5: L[E + 1], x6: K, y6: aa, id: E, height: L[E + 1] - L[E], color: W }) : M.push({ x1: a[E], y1: L[E], x2: B[E], y2: L[E], x3: B[E + 1], y3: L[E + 1], x4: a[E + 1], y4: L[E + 1], id: E, height: L[E + 1] - L[E], color: W });\n            }var ha = 2,\n                F = [],\n                ja = !1,\n                ma = [],\n                ka = [],\n                I = !1;a = a = 0;Da(ma);for (E = 0; E < x.length; E++) {\n              x[E].exploded && (I = !0, u.reversed ? ma.push(x.length - 1 - E) : ma.push(E));\n            }R.clearRect(z.x1, z.y1, z.width, z.height);R.fillStyle = s.backgroundColor;R.fillRect(z.x1, z.y1, z.width, z.height);if (J && u.visible && (c(), g(), e(), \"inside\" !== u.indexLabelPlacement)) {\n              h();\n              for (E = 0; E < x.length; E++) {\n                F[E].isDirty || (a = F[E].textBlock.x + F[E].width, a = (P - a) / 2, 0 == E && (A = a), A > a && (A = a));\n              }for (E = 0; E < M.length; E++) {\n                M[E].x1 += A, M[E].x2 += A, M[E].x3 += A, M[E].x4 += A, M[E].x5 && (M[E].x5 += A, M[E].x6 += A), F[E].textBlock.x += A;\n              }\n            }for (E = 0; E < M.length; E++) {\n              A = M[E], sa(R, A, u.fillOpacity), ka.push(A.y1);\n            }q(R);J && u.visible && (\"inside\" === u.indexLabelPlacement || s.animationEnabled || r(R), s.animationEnabled || m());if (!J) for (E = 0; E < x.length; E++) {\n              A = u.dataPointIds[E], a = { id: A, objectType: \"dataPoint\", dataPointIndex: E, dataSeriesIndex: 0,\n                funnelSection: M[u.reversed ? x.length - 1 - E : E] }, s._eventManager.objectMap[A] = a;\n            }!s.animationEnabled && I ? t(s, -1, 0) : s.animationEnabled && !s.animatedRender && t(s, -1, 0);this.funnelPyramidClickHandler = function (a) {\n              var b = -1;if (!ja && !s.isAnimating && (y(a.dataSeries.explodeOnClick) || a.dataSeries.explodeOnClick) && (b = u.reversed ? x.length - 1 - a.dataPointIndex : a.dataPointIndex, 0 <= b)) {\n                a = b;if (\"funnel\" === u.type || \"pyramid\" === u.type) u.reversed ? x[x.length - 1 - a].exploded = x[x.length - 1 - a].exploded ? !1 : !0 : x[a].exploded = x[a].exploded ? !1 : !0;t(s, b, 500);\n              }\n            };return { source: R, dest: this.plotArea.ctx, animationCallback: function animationCallback(a, b) {\n                H.fadeInAnimation(a, b);1 <= a && (t(s, -1, 500), q(s.plotArea.ctx || s.ctx));\n              }, easingFunction: H.easing.easeInQuad, animationBase: 0 };\n          }\n        }\n      }\n    };q.prototype.animationRequestId = null;q.prototype.requestAnimFrame = function () {\n      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (a) {\n        window.setTimeout(a, 1E3 / 60);\n      };\n    }();\n    q.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;q.prototype.set = function (a, f, b) {\n      b = \"undefined\" === typeof b ? !0 : b;\"options\" === a ? (this.options = f, b && this.render()) : q.base.set.call(this, a, f, b);\n    };q.prototype.exportChart = function (a) {\n      a = \"undefined\" === typeof a ? {} : a;var f = a.format ? a.format : \"png\",\n          b = a.fileName ? a.fileName : this.exportFileName;\n      if (a.toDataURL) return this.canvas.toDataURL(\"image/\" + f);s(this.canvas, f, b);\n    };q.prototype.print = function () {\n      var a = this.exportChart({ toDataURL: !0 }),\n          f = document.createElement(\"iframe\");f.setAttribute(\"class\", \"canvasjs-chart-print-frame\");f.setAttribute(\"style\", \"position:absolute; width:100%; border: 0px; margin: 0px 0px 0px 0px; padding 0px 0px 0px 0px;\");f.style.height = this.height + \"px\";this._canvasJSContainer.appendChild(f);var b = this,\n          c = f.contentWindow || f.contentDocument.document || f.contentDocument;c.document.open();\n      c.document.write('<!DOCTYPE HTML>\\n<html><body style=\"margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px;\"><img src=\"' + a + '\"/><body/></html>');c.document.close();setTimeout(function () {\n        c.focus();c.print();setTimeout(function () {\n          b._canvasJSContainer.removeChild(f);\n        }, 1E3);\n      }, 500);\n    };q.prototype.getPercentAndTotal = function (a, f) {\n      var b = null,\n          c = null,\n          e = null;if (0 <= a.type.indexOf(\"stacked\")) c = 0, b = f.x.getTime ? f.x.getTime() : f.x, b in a.plotUnit.yTotals && (c = a.plotUnit.yTotals[b], e = isNaN(f.y) ? 0 : 100 * (f.y / c));else if (\"pie\" === a.type || \"doughnut\" === a.type || \"funnel\" === a.type || \"pyramid\" === a.type) {\n        for (i = c = 0; i < a.dataPoints.length; i++) {\n          isNaN(a.dataPoints[i].y) || (c += a.dataPoints[i].y);\n        }e = isNaN(f.y) ? 0 : 100 * (f.y / c);\n      }return { percent: e, total: c };\n    };q.prototype.replaceKeywordsWithValue = function (a, f, b, c, e) {\n      var g = this;e = \"undefined\" === typeof e ? 0 : e;if ((0 <= b.type.indexOf(\"stacked\") || \"pie\" === b.type || \"doughnut\" === b.type || \"funnel\" === b.type || \"pyramid\" === b.type) && (0 <= a.indexOf(\"#percent\") || 0 <= a.indexOf(\"#total\"))) {\n        var h = \"#percent\",\n            l = \"#total\",\n            t = this.getPercentAndTotal(b, f),\n            l = isNaN(t.total) ? l : t.total,\n            h = isNaN(t.percent) ? h : t.percent;do {\n          t = \"\";if (b.percentFormatString) t = b.percentFormatString;else {\n            var t = \"#,##0.\",\n                k = Math.max(Math.ceil(Math.log(1 / Math.abs(h)) / Math.LN10), 2);if (isNaN(k) || !isFinite(k)) k = 2;for (var r = 0; r < k; r++) {\n              t += \"#\";\n            }b.percentFormatString = t;\n          }a = a.replace(\"#percent\", W(h, t, g._cultureInfo));a = a.replace(\"#total\", W(l, b.yValueFormatString ? b.yValueFormatString : \"#,##0.########\", g._cultureInfo));\n        } while (0 <= a.indexOf(\"#percent\") || 0 <= a.indexOf(\"#total\"));\n      }return a.replace(/\\{.*?\\}|\"[^\"]*\"|'[^']*'/g, function (a) {\n        if ('\"' === a[0] && '\"' === a[a.length - 1] || \"'\" === a[0] && \"'\" === a[a.length - 1]) return a.slice(1, a.length - 1);a = Ga(a.slice(1, a.length - 1));a = a.replace(\"#index\", e);var h = null;try {\n          var d = a.match(/(.*?)\\s*\\[\\s*(.*?)\\s*\\]/);d && 0 < d.length && (h = Ga(d[2]), a = Ga(d[1]));\n        } catch (k) {}d = null;if (\"color\" === a) return \"waterfall\" === b.type ? f.color ? f.color : -1 < f.y ? b.risingColor : b.fallingColor : \"error\" === b.type ? b.color ? b.color : b._colorSet[h % b._colorSet.length] : f.color ? f.color : b.color ? b.color : b._colorSet[c % b._colorSet.length];if (f.hasOwnProperty(a)) d = f;else if (b.hasOwnProperty(a)) d = b;else return \"\";d = d[a];null !== h && (d = d[h]);if (\"x\" === a) {\n          if (\"dateTime\" === b.axisX.valueType || \"dateTime\" === b.xValueType || f.x && f.x.getTime) {\n            if (g.plotInfo.plotTypes[0].plotUnits[0].axisX && !g.plotInfo.plotTypes[0].plotUnits[0].axisX.logarithmic) return Ba(d, f.xValueFormatString ? f.xValueFormatString : b.xValueFormatString ? b.xValueFormatString : b.xValueFormatString = g.axisX && g.axisX.autoValueFormatString ? g.axisX.autoValueFormatString : \"DD MMM YY\", g._cultureInfo);\n          } else return W(d, f.xValueFormatString ? f.xValueFormatString : b.xValueFormatString ? b.xValueFormatString : b.xValueFormatString = \"#,##0.########\", g._cultureInfo);\n        } else return \"y\" === a ? W(d, f.yValueFormatString ? f.yValueFormatString : b.yValueFormatString ? b.yValueFormatString : b.yValueFormatString = \"#,##0.########\", g._cultureInfo) : \"z\" === a ? W(d, f.zValueFormatString ? f.zValueFormatString : b.zValueFormatString ? b.zValueFormatString : b.zValueFormatString = \"#,##0.########\", g._cultureInfo) : d;\n      });\n    };pa(T, X);T.prototype.render = function () {\n      var a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart,\n          f = a.layoutManager.getFreeSpace(),\n          b = null,\n          c = 0,\n          e = 0,\n          g = 0,\n          h = 0,\n          l = this.markerMargin = this.chart.options.legend && !y(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : 0.3 * this.fontSize;this.height = 0;var t = [],\n          k = [];\"top\" === this.verticalAlign || \"bottom\" === this.verticalAlign ? (this.orientation = \"horizontal\", b = this.verticalAlign, g = this.maxWidth = null !== this.maxWidth ? this.maxWidth : f.width, h = this.maxHeight = null !== this.maxHeight ? this.maxHeight : 0.5 * f.height) : \"center\" === this.verticalAlign && (this.orientation = \"vertical\", b = this.horizontalAlign, g = this.maxWidth = null !== this.maxWidth ? this.maxWidth : 0.5 * f.width, h = this.maxHeight = null !== this.maxHeight ? this.maxHeight : f.height);for (var r = [], p = 0; p < this.dataSeries.length; p++) {\n        var n = this.dataSeries[p];if (n.dataPoints && n.dataPoints.length) if (\"pie\" !== n.type && \"doughnut\" !== n.type && \"funnel\" !== n.type && \"pyramid\" !== n.type) {\n          var d = n.legendMarkerType = n.legendMarkerType ? n.legendMarkerType : \"line\" !== n.type && \"stepLine\" !== n.type && \"spline\" !== n.type && \"scatter\" !== n.type && \"bubble\" !== n.type || !n.markerType ? \"error\" === n.type && n._linkedSeries ? n._linkedSeries.legendMarkerType ? n._linkedSeries.legendMarkerType : Q.getDefaultLegendMarker(n._linkedSeries.type) : Q.getDefaultLegendMarker(n.type) : n.markerType,\n              m = n.legendText ? n.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: n, dataPoint: null }) : n.name,\n              q = n.legendMarkerColor = n.legendMarkerColor ? n.legendMarkerColor : n.markerColor ? n.markerColor : \"error\" === n.type ? y(n.whiskerColor) ? n._colorSet[0] : n.whiskerColor : n._colorSet[0],\n              s = n.markerSize || \"line\" !== n.type && \"stepLine\" !== n.type && \"spline\" !== n.type ? 0.75 * this.lineHeight : 0,\n              u = n.legendMarkerBorderColor ? n.legendMarkerBorderColor : n.markerBorderColor,\n              v = n.legendMarkerBorderThickness ? n.legendMarkerBorderThickness : n.markerBorderThickness ? Math.max(1, Math.round(0.2 * s)) : 0;\"error\" === n.type && r.push(q);m = this.chart.replaceKeywordsWithValue(m, n.dataPoints[0], n, p);d = { markerType: d, markerColor: q, text: m, textBlock: null, chartType: n.type,\n            markerSize: s, lineColor: n._colorSet[0], dataSeriesIndex: n.index, dataPointIndex: null, markerBorderColor: u, markerBorderThickness: v };t.push(d);\n        } else for (var x = 0; x < n.dataPoints.length; x++) {\n          var z = n.dataPoints[x],\n              d = z.legendMarkerType ? z.legendMarkerType : n.legendMarkerType ? n.legendMarkerType : Q.getDefaultLegendMarker(n.type),\n              m = z.legendText ? z.legendText : n.legendText ? n.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: n, dataPoint: z }) : z.name ? z.name : \"DataPoint: \" + (x + 1),\n              q = z.legendMarkerColor ? z.legendMarkerColor : n.legendMarkerColor ? n.legendMarkerColor : z.color ? z.color : n.color ? n.color : n._colorSet[x % n._colorSet.length],\n              s = 0.75 * this.lineHeight,\n              u = z.legendMarkerBorderColor ? z.legendMarkerBorderColor : n.legendMarkerBorderColor ? n.legendMarkerBorderColor : z.markerBorderColor ? z.markerBorderColor : n.markerBorderColor,\n              v = z.legendMarkerBorderThickness ? z.legendMarkerBorderThickness : n.legendMarkerBorderThickness ? n.legendMarkerBorderThickness : z.markerBorderThickness || n.markerBorderThickness ? Math.max(1, Math.round(0.2 * s)) : 0,\n              m = this.chart.replaceKeywordsWithValue(m, z, n, x),\n              d = { markerType: d, markerColor: q, text: m, textBlock: null, chartType: n.type, markerSize: s, dataSeriesIndex: p, dataPointIndex: x, markerBorderColor: u, markerBorderThickness: v };(z.showInLegend || n.showInLegend && !1 !== z.showInLegend) && t.push(d);\n        }\n      }!0 === this.reversed && t.reverse();if (0 < t.length) {\n        n = null;m = x = z = v = 0;z = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, g) : this.itemMaxWidth = Math.min(this.itemWidth, g) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, g) : this.itemMaxWidth = g;s = 0 === s ? 0.75 * this.lineHeight : s;z -= s + l;for (p = 0; p < t.length; p++) {\n          d = t[p];q = z;if (\"line\" === d.chartType || \"spline\" === d.chartType || \"stepLine\" === d.chartType) q -= 2 * 0.1 * this.lineHeight;if (!(0 >= h || \"undefined\" === typeof h || 0 >= q || \"undefined\" === typeof q)) {\n            if (\"horizontal\" === this.orientation) {\n              d.textBlock = new la(this.ctx, { x: 0, y: 0, maxWidth: q, maxHeight: this.itemWrap ? h : this.lineHeight, angle: 0, text: d.text, horizontalAlign: \"left\", fontSize: this.fontSize,\n                fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: \"middle\" });d.textBlock.measureText();null !== this.itemWidth && (d.textBlock.width = this.itemWidth - (s + l + (\"line\" === d.chartType || \"spline\" === d.chartType || \"stepLine\" === d.chartType ? 2 * 0.1 * this.lineHeight : 0)));if (!n || n.width + Math.round(d.textBlock.width + s + l + (0 === n.width ? 0 : this.horizontalSpacing) + (\"line\" === d.chartType || \"spline\" === d.chartType || \"stepLine\" === d.chartType ? 2 * 0.1 * this.lineHeight : 0)) > g) n = { items: [], width: 0 }, k.push(n), this.height += x, x = 0;x = Math.max(x, d.textBlock.height);\n            } else d.textBlock = new la(this.ctx, { x: 0, y: 0, maxWidth: z, maxHeight: !0 === this.itemWrap ? h : 1.5 * this.fontSize, angle: 0, text: d.text, horizontalAlign: \"left\", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: \"middle\" }), d.textBlock.measureText(), null !== this.itemWidth && (d.textBlock.width = this.itemWidth - (s + l + (\"line\" === d.chartType || \"spline\" === d.chartType || \"stepLine\" === d.chartType ? 2 * 0.1 * this.lineHeight : 0))), this.height < h - this.lineHeight ? (n = { items: [], width: 0 }, k.push(n)) : (n = k[v], v = (v + 1) % k.length), this.height += d.textBlock.height;d.textBlock.x = n.width;d.textBlock.y = 0;n.width += Math.round(d.textBlock.width + s + l + (0 === n.width ? 0 : this.horizontalSpacing) + (\"line\" === d.chartType || \"spline\" === d.chartType || \"stepLine\" === d.chartType ? 2 * 0.1 * this.lineHeight : 0));n.items.push(d);this.width = Math.max(n.width, this.width);m = d.textBlock.width + (s + l + (\"line\" === d.chartType || \"spline\" === d.chartType || \"stepLine\" === d.chartType ? 2 * 0.1 * this.lineHeight : 0));\n          }\n        }this.itemWidth = m;this.height = !1 === this.itemWrap ? k.length * this.lineHeight : this.height + x;this.height = Math.min(h, this.height);this.width = Math.min(g, this.width);\n      }\"top\" === this.verticalAlign ? (e = \"left\" === this.horizontalAlign ? f.x1 : \"right\" === this.horizontalAlign ? f.x2 - this.width : f.x1 + f.width / 2 - this.width / 2, c = f.y1) : \"center\" === this.verticalAlign ? (e = \"left\" === this.horizontalAlign ? f.x1 : \"right\" === this.horizontalAlign ? f.x2 - this.width : f.x1 + f.width / 2 - this.width / 2, c = f.y1 + f.height / 2 - this.height / 2) : \"bottom\" === this.verticalAlign && (e = \"left\" === this.horizontalAlign ? f.x1 : \"right\" === this.horizontalAlign ? f.x2 - this.width : f.x1 + f.width / 2 - this.width / 2, c = f.y2 - this.height);this.items = t;for (p = 0; p < this.items.length; p++) {\n        d = t[p], d.id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[d.id] = { id: d.id, objectType: \"legendItem\", legendItemIndex: p, dataSeriesIndex: d.dataSeriesIndex, dataPointIndex: d.dataPointIndex };\n      }(0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(e, c, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);for (p = f = 0; p < k.length; p++) {\n        n = k[p];for (z = x = 0; z < n.items.length; z++) {\n          d = n.items[z];q = d.textBlock.x + e + (0 === z ? 0.2 * s : this.horizontalSpacing);u = c + f;m = q;this.chart.data[d.dataSeriesIndex].visible || (this.ctx.globalAlpha = 0.5);this.ctx.save();this.ctx.beginPath();this.ctx.rect(e, c, g, Math.max(h - h % this.lineHeight, 0));this.ctx.clip();if (\"line\" === d.chartType || \"stepLine\" === d.chartType || \"spline\" === d.chartType) this.ctx.strokeStyle = d.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(q - 0.1 * this.lineHeight, u + this.lineHeight / 2), this.ctx.lineTo(q + 0.85 * this.lineHeight, u + this.lineHeight / 2), this.ctx.stroke(), m -= 0.1 * this.lineHeight;if (\"error\" === d.chartType) {\n            this.ctx.strokeStyle = r[0];v = s / 8;this.ctx.lineWidth = v;this.ctx.beginPath();var v = q - 0.08 * this.lineHeight + 0.1 * this.lineHeight,\n                B = u + 0.15 * this.lineHeight,\n                A = 0.7 * this.lineHeight,\n                C = A + 0.02 * this.lineHeight;this.ctx.moveTo(v, B);this.ctx.lineTo(v + A, B);this.ctx.stroke();this.ctx.beginPath();this.ctx.moveTo(v + A / 2, B);this.ctx.lineTo(v + A / 2, B + C);this.ctx.stroke();this.ctx.beginPath();this.ctx.moveTo(v, B + C);this.ctx.lineTo(v + A, B + C);this.ctx.stroke();r.shift();\n          }ja.drawMarker(q + s / 2, u + this.lineHeight / 2, this.ctx, d.markerType, \"error\" === d.chartType || \"line\" === d.chartType || \"spline\" === d.chartType ? d.markerSize / 2 : d.markerSize, d.markerColor, d.markerBorderColor, d.markerBorderThickness);d.textBlock.x = q + l + s;if (\"line\" === d.chartType || \"stepLine\" === d.chartType || \"spline\" === d.chartType) d.textBlock.x += 0.1 * this.lineHeight;d.textBlock.y = Math.round(u + this.lineHeight / 2);d.textBlock.render(!0);this.ctx.restore();x = 0 < z ? Math.max(x, d.textBlock.height) : d.textBlock.height;this.chart.data[d.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1);v = R(d.id);this.ghostCtx.fillStyle = v;this.ghostCtx.beginPath();this.ghostCtx.fillRect(m, d.textBlock.y - this.lineHeight / 2, d.textBlock.x + d.textBlock.width - m, d.textBlock.height);d.x1 = this.chart._eventManager.objectMap[d.id].x1 = m;d.y1 = this.chart._eventManager.objectMap[d.id].y1 = d.textBlock.y - this.lineHeight / 2;d.x2 = this.chart._eventManager.objectMap[d.id].x2 = d.textBlock.x + d.textBlock.width;d.y2 = this.chart._eventManager.objectMap[d.id].y2 = d.textBlock.y + d.textBlock.height - this.lineHeight / 2;\n        }f += x;\n      }0 < t.length && a.layoutManager.registerSpace(b, { width: this.width + 2 + 2, height: this.height + 5 + 5 });this.bounds = { x1: e, y1: c, x2: e + this.width, y2: c + this.height };\n    };pa(Q, X);Q.prototype.getDefaultAxisPlacement = function () {\n      var a = this.type;if (\"column\" === a || \"line\" === a || \"stepLine\" === a || \"spline\" === a || \"area\" === a || \"stepArea\" === a || \"splineArea\" === a || \"stackedColumn\" === a || \"stackedLine\" === a || \"bubble\" === a || \"scatter\" === a || \"stackedArea\" === a || \"stackedColumn100\" === a || \"stackedLine100\" === a || \"stackedArea100\" === a || \"candlestick\" === a || \"ohlc\" === a || \"rangeColumn\" === a || \"rangeArea\" === a || \"rangeSplineArea\" === a || \"boxAndWhisker\" === a || \"waterfall\" === a) return \"normal\";if (\"bar\" === a || \"stackedBar\" === a || \"stackedBar100\" === a || \"rangeBar\" === a) return \"xySwapped\";if (\"pie\" === a || \"doughnut\" === a || \"funnel\" === a || \"pyramid\" === a) return \"none\";\"error\" !== a && window.console.log(\"Unknown Chart Type: \" + a);return null;\n    };Q.getDefaultLegendMarker = function (a) {\n      if (\"column\" === a || \"stackedColumn\" === a || \"stackedLine\" === a || \"bar\" === a || \"stackedBar\" === a || \"stackedBar100\" === a || \"bubble\" === a || \"scatter\" === a || \"stackedColumn100\" === a || \"stackedLine100\" === a || \"stepArea\" === a || \"candlestick\" === a || \"ohlc\" === a || \"rangeColumn\" === a || \"rangeBar\" === a || \"rangeArea\" === a || \"rangeSplineArea\" === a || \"boxAndWhisker\" === a || \"waterfall\" === a) return \"square\";\n      if (\"line\" === a || \"stepLine\" === a || \"spline\" === a || \"pie\" === a || \"doughnut\" === a) return \"circle\";if (\"area\" === a || \"splineArea\" === a || \"stackedArea\" === a || \"stackedArea100\" === a || \"funnel\" === a || \"pyramid\" === a) return \"triangle\";if (\"error\" === a) return \"none\";window.console.log(\"Unknown Chart Type: \" + a);return null;\n    };Q.prototype.getDataPointAtX = function (a, f) {\n      if (!this.dataPoints || 0 === this.dataPoints.length) return null;var b = { dataPoint: null, distance: Infinity, index: NaN },\n          c = null,\n          e = 0,\n          g = 0,\n          h = 1,\n          l = Infinity,\n          t = 0,\n          k = 0,\n          r = 0;\"none\" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? (r = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), r = 1 < r ? Math.min(Math.max((this.dataPoints.length - 1) / r * Math.log(a / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (r = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, r = 0 < r ? Math.min(Math.max((this.dataPoints.length - 1) / r * (a - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0));for (;;) {\n        g = 0 < h ? r + e : r - e;if (0 <= g && g < this.dataPoints.length) {\n          var c = this.dataPoints[g],\n              p = this.axisX.logarithmic ? c.x > a ? c.x / a : a / c.x : Math.abs(c.x - a);p < b.distance && (b.dataPoint = c, b.distance = p, b.index = g);c = p;c <= l ? l = c : 0 < h ? t++ : k++;if (1E3 < t && 1E3 < k) break;\n        } else if (0 > r - e && r + e >= this.dataPoints.length) break;-1 === h ? (e++, h = 1) : h = -1;\n      }return f || b.dataPoint.x !== a ? f && null !== b.dataPoint ? b : null : b;\n    };Q.prototype.getDataPointAtXY = function (a, f, b) {\n      if (!this.dataPoints || 0 === this.dataPoints.length || a < this.chart.plotArea.x1 || a > this.chart.plotArea.x2 || f < this.chart.plotArea.y1 || f > this.chart.plotArea.y2) return null;b = b || !1;var c = [],\n          e = 0,\n          g = 0,\n          h = 1,\n          l = !1,\n          t = Infinity,\n          k = 0,\n          r = 0,\n          p = 0;if (\"none\" !== this.chart.plotInfo.axisPlacement) if (p = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({ x: a, y: f }), this.axisX.logarithmic) var n = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x),\n          p = 1 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * Math.log(p / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;else n = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, p = 0 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * (p - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;for (;;) {\n        g = 0 < h ? p + e : p - e;if (0 <= g && g < this.dataPoints.length) {\n          var n = this.chart._eventManager.objectMap[this.dataPointIds[g]],\n              d = this.dataPoints[g],\n              m = null;if (n) {\n            switch (this.type) {case \"column\":case \"stackedColumn\":case \"stackedColumn100\":case \"bar\":case \"stackedBar\":case \"stackedBar100\":case \"rangeColumn\":case \"rangeBar\":case \"waterfall\":case \"error\":\n                a >= n.x1 && a <= n.x2 && f >= n.y1 && f <= n.y2 && (c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y1 - f), Math.abs(n.y2 - f)) }), l = !0);break;case \"line\":case \"stepLine\":case \"spline\":case \"area\":case \"stepArea\":case \"stackedArea\":case \"stackedArea100\":case \"splineArea\":case \"scatter\":\n                var q = na(\"markerSize\", d, this) || 4,\n                    s = b ? 20 : q,\n                    m = Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - f, 2));m <= s && c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: m });n = Math.abs(n.x1 - a);n <= t ? t = n : 0 < h ? k++ : r++;m <= q / 2 && (l = !0);break;case \"rangeArea\":case \"rangeSplineArea\":\n                q = na(\"markerSize\", d, this) || 4;s = b ? 20 : q;m = Math.min(Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - f, 2)), Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y2 - f, 2)));m <= s && c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: m });n = Math.abs(n.x1 - a);n <= t ? t = n : 0 < h ? k++ : r++;m <= q / 2 && (l = !0);break;case \"bubble\":\n                q = n.size;m = Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - f, 2));m <= q / 2 && (c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: m }), l = !0);break;case \"pie\":case \"doughnut\":\n                q = n.center;s = \"doughnut\" === this.type ? n.percentInnerRadius * n.radius : 0;m = Math.sqrt(Math.pow(q.x - a, 2) + Math.pow(q.y - f, 2));m < n.radius && m > s && (m = Math.atan2(f - q.y, a - q.x), 0 > m && (m += 2 * Math.PI), m = Number(((180 * (m / Math.PI) % 360 + 360) % 360).toFixed(12)), q = Number(((180 * (n.startAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), s = Number(((180 * (n.endAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 0 === s && 1 < n.endAngle && (s = 360), q >= s && 0 !== d.y && (s += 360, m < q && (m += 360)), m > q && m < s && (c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: 0 }), l = !0));break;case \"funnel\":case \"pyramid\":\n                m = n.funnelSection;\n                f > m.y1 && f < m.y4 && (m.y6 ? f > m.y6 ? (g = m.x6 + (m.x5 - m.x6) / (m.y5 - m.y6) * (f - m.y6), m = m.x3 + (m.x4 - m.x3) / (m.y4 - m.y3) * (f - m.y3)) : (g = m.x1 + (m.x6 - m.x1) / (m.y6 - m.y1) * (f - m.y1), m = m.x2 + (m.x3 - m.x2) / (m.y3 - m.y2) * (f - m.y2)) : (g = m.x1 + (m.x4 - m.x1) / (m.y4 - m.y1) * (f - m.y1), m = m.x2 + (m.x3 - m.x2) / (m.y3 - m.y2) * (f - m.y2)), a > g && a < m && (c.push({ dataPoint: d, dataPointIndex: n.dataPointIndex, dataSeries: this, distance: 0 }), l = !0));break;case \"boxAndWhisker\":\n                if (a >= n.x1 - n.borderThickness / 2 && a <= n.x2 + n.borderThickness / 2 && f >= n.y4 - n.borderThickness / 2 && f <= n.y1 + n.borderThickness / 2 || Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && f >= n.y1 && f <= n.y4) c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - f), Math.abs(n.y3 - f)) }), l = !0;break;case \"candlestick\":\n                if (a >= n.x1 - n.borderThickness / 2 && a <= n.x2 + n.borderThickness / 2 && f >= n.y2 - n.borderThickness / 2 && f <= n.y3 + n.borderThickness / 2 || Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && f >= n.y1 && f <= n.y4) c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - f), Math.abs(n.y3 - f)) }), l = !0;break;case \"ohlc\":\n                if (Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && f >= n.y2 && f <= n.y3 || a >= n.x1 && a <= (n.x2 + n.x1) / 2 && f >= n.y1 - n.borderThickness / 2 && f <= n.y1 + n.borderThickness / 2 || a >= (n.x1 + n.x2) / 2 && a <= n.x2 && f >= n.y4 - n.borderThickness / 2 && f <= n.y4 + n.borderThickness / 2) c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - f), Math.abs(n.y3 - f)) }), l = !0;}if (l || 1E3 < k && 1E3 < r) break;\n          }\n        } else if (0 > p - e && p + e >= this.dataPoints.length) break;-1 === h ? (e++, h = 1) : h = -1;\n      }a = null;for (f = 0; f < c.length; f++) {\n        a ? c[f].distance <= a.distance && (a = c[f]) : a = c[f];\n      }return a;\n    };Q.prototype.getMarkerProperties = function (a, f, b, c) {\n      var e = this.dataPoints;return { x: f, y: b, ctx: c, type: e[a].markerType ? e[a].markerType : this.markerType, size: e[a].markerSize ? e[a].markerSize : this.markerSize, color: e[a].markerColor ? e[a].markerColor : this.markerColor ? this.markerColor : e[a].color ? e[a].color : this.color ? this.color : this._colorSet[a % this._colorSet.length], borderColor: e[a].markerBorderColor ? e[a].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null, borderThickness: e[a].markerBorderThickness ? e[a].markerBorderThickness : this.markerBorderThickness ? this.markerBorderThickness : null };\n    };pa(C, X);C.prototype.createExtraLabelsForLog = function (a) {\n      a = (a || 0) + 1;if (!(5 < a)) {\n        var f = this.logLabelValues[0] || this.intervalStartPosition;if (Math.log(this.range) / Math.log(f / this.viewportMinimum) < this.noTicks - 1) {\n          for (var b = C.getNiceNumber((f - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), !0), c = Math.ceil(this.viewportMinimum / b) * b; c < f; c += b) {\n            c < this.viewportMinimum || this.logLabelValues.push(c);\n          }this.logLabelValues.sort(Pa);this.createExtraLabelsForLog(a);\n        }\n      }\n    };C.prototype.createLabels = function () {\n      var a,\n          f,\n          b = 0,\n          c = 0,\n          e,\n          g = 0,\n          h = 0,\n          c = 0,\n          c = this.interval,\n          l = 0,\n          t,\n          k = 0.6 * this.chart.height,\n          m;a = !1;var p = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [],\n          n = p.length ? y(this.scaleBreaks.firstBreakIndex) ? 0 : this.scaleBreaks.firstBreakIndex : 0;if (\"axisX\" !== this.type || \"dateTime\" !== this.valueType || this.logarithmic) {\n        e = this.viewportMaximum;if (this.labels) {\n          a = Math.ceil(c);for (var c = Math.ceil(this.intervalStartPosition), d = !1, b = c; b < this.viewportMaximum; b += a) {\n            if (this.labels[b]) d = !0;else {\n              d = !1;break;\n            }\n          }d && (this.interval = a, this.intervalStartPosition = c);\n        }if (this.logarithmic && !this.equidistantInterval) for (this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()), c = 0, d = n; c < this.logLabelValues.length; c++) {\n          if (b = this.logLabelValues[c], b < this.viewportMinimum) c++;else {\n            for (; d < p.length && b > p[d].endValue; d++) {}a = d < p.length && b >= p[d].startValue && b <= p[d].endValue;m = b;a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: m, label: this.labels[m] ? this.labels[m] : null }) : \"axisX\" === this.type && this.labels[m] ? this.labels[m] : W(m, this.valueFormatString, this.chart._cultureInfo), a = new la(this.ctx, _defineProperty({ x: 0, y: 0, maxWidth: g, maxHeight: h, angle: this.labelAngle, text: this.prefix + a + this.suffix, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius,\n              horizontalAlign: \"left\", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: \"middle\" }, \"borderThickness\", 0)), this._labels.push({ position: m, textBlock: a, effectiveHeight: null }));\n          }\n        }d = n;for (b = this.intervalStartPosition; b <= e; b = parseFloat((this.logarithmic && this.equidistantInterval ? b * Math.pow(this.logarithmBase, this.interval) : b + this.interval).toFixed(12))) {\n          for (; d < p.length && b > p[d].endValue; d++) {}a = d < p.length && b >= p[d].startValue && b <= p[d].endValue;m = b;a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: m, label: this.labels[m] ? this.labels[m] : null }) : \"axisX\" === this.type && this.labels[m] ? this.labels[m] : W(m, this.valueFormatString, this.chart._cultureInfo), a = new la(this.ctx, { x: 0, y: 0, maxWidth: g, maxHeight: h, angle: this.labelAngle, text: this.prefix + a + this.suffix, horizontalAlign: \"left\", backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness,\n            cornerRadius: this.labelCornerRadius, fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: \"middle\" }), this._labels.push({ position: m, textBlock: a, effectiveHeight: null }));\n        }\n      } else for (this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), e = Ta(new Date(this.viewportMaximum), this.interval, this.intervalType), d = n, b = this.intervalStartPosition; b < e; Ta(b, c, this.intervalType)) {\n        for (a = b.getTime(); d < p.length && a > p[d].endValue; d++) {}m = a;a = d < p.length && a >= p[d].startValue && a <= p[d].endValue;a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: new Date(m), label: this.labels[m] ? this.labels[m] : null }) : \"axisX\" === this.type && this.labels[m] ? this.labels[m] : Ba(m, this.valueFormatString, this.chart._cultureInfo), a = new la(this.ctx, { x: 0, y: 0, maxWidth: g, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness,\n          cornerRadius: this.labelCornerRadius, maxHeight: h, angle: this.labelAngle, text: this.prefix + a + this.suffix, horizontalAlign: \"left\", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: \"middle\" }), this._labels.push({ position: m, textBlock: a, effectiveHeight: null, breaksLabelType: void 0 }));\n      }if (\"bottom\" === this._position || \"top\" === this._position) l = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * U[this.intervalType + \"Duration\"] * this.interval, g = \"undefined\" === typeof this.options.labelMaxWidth ? 0.5 * this.chart.width >> 0 : this.options.labelMaxWidth, this.chart.panEnabled || (h = \"undefined\" === typeof this.options.labelWrap || this.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize);else if (\"left\" === this._position || \"right\" === this._position) l = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * U[this.intervalType + \"Duration\"] * this.interval, this.chart.panEnabled || (g = \"undefined\" === typeof this.options.labelMaxWidth ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth), h = \"undefined\" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize;for (c = 0; c < this._labels.length; c++) {\n        a = this._labels[c].textBlock;a.maxWidth = g;a.maxHeight = h;var q = a.measureText();t = q.height;\n      }e = [];n = p = 0;if (this.labelAutoFit || this.options.labelAutoFit) if (y(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), \"bottom\" === this._position || \"top\" === this._position) {\n        if (g = 0.9 * l >> 0, n = 0, !this.chart.panEnabled && 1 <= this._labels.length) {\n          this.sessionVariables.labelFontSize = this.labelFontSize;this.sessionVariables.labelMaxWidth = g;this.sessionVariables.labelMaxHeight = h;this.sessionVariables.labelAngle = this.labelAngle;this.sessionVariables.labelWrap = this.labelWrap;for (b = 0; b < this._labels.length; b++) {\n            if (!this._labels[b].breaksLabelType) {\n              a = this._labels[b].textBlock;for (var s, d = a.text.split(\" \"), c = 0; c < d.length; c++) {\n                m = d[c], this.ctx.font = a.fontStyle + \" \" + a.fontWeight + \" \" + a.fontSize + \"px \" + a.fontFamily, m = this.ctx.measureText(m), m.width > n && (s = b, n = m.width);\n              }\n            }\n          }b = 0;for (b = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; b < this._labels.length; b++) {\n            if (!this._labels[b].breaksLabelType) {\n              a = this._labels[b].textBlock;\n              q = a.measureText();for (d = b + 1; d < this._labels.length; d++) {\n                if (!this._labels[d].breaksLabelType) {\n                  f = this._labels[d].textBlock;f = f.measureText();break;\n                }\n              }e.push(a.height);this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));c = g * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (h - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));if (y(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle) {\n                if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : Math.min((c - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), c), m = (k - (t + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), !y(this.options.labelWrap)) this.labelWrap ? y(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), m), this.sessionVariables.labelWrap = this.labelWrap, q.width + f.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle) : y(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelMaxWidth = g, q.width + f.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelWrap = this.labelWrap);else {\n                  if (y(this.options.labelWrap)) if (!y(this.options.labelMaxWidth)) this.options.labelMaxWidth < g ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = h);else if (!y(f)) if (c = q.width + f.width >> 0, d = this.labelFontSize, n < g) c - 2 * g > p && (p = c - 2 * g, c >= 2 * g && c < 2.2 * g ? (this.sessionVariables.labelMaxWidth = g, y(this.options.labelFontSize) && 12 < d && (d = Math.floor(12 / 13 * d), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : c >= 2.2 * g && c < 2.8 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelFontSize = d) : c >= 2.8 * g && c < 3.2 * g ? (this.sessionVariables.labelMaxWidth = Math.max(g, n), this.sessionVariables.labelWrap = !0, y(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : c >= 3.2 * g && c < 3.6 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelFontSize = this.labelFontSize) : c > 3.6 * g && c < 5 * g ? (y(this.options.labelFontSize) && 12 < d && (d = Math.floor(12 / 13 * d), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m) : c > 5 * g && (this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelFontSize = d, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelAngle = this.labelAngle));else if (s === b && (0 === s && n + this._labels[s + 1].textBlock.measureText().width - 2 * g > p || s === this._labels.length - 1 && n + this._labels[s - 1].textBlock.measureText().width - 2 * g > p || 0 < s && s < this._labels.length - 1 && n + this._labels[s + 1].textBlock.measureText().width - 2 * g > p && n + this._labels[s - 1].textBlock.measureText().width - 2 * g > p)) p = 0 === s ? n + this._labels[s + 1].textBlock.measureText().width - 2 * g : n + this._labels[s - 1].textBlock.measureText().width - 2 * g, this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m;else if (0 === p) for (this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, c = 0; c < this._labels.length; c++) {\n                    a = this._labels[c].textBlock, a.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), m), q = a.measureText(), c < this._labels.length - 1 && (d = c + 1, f = this._labels[d].textBlock, f.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), m), f = f.measureText(), q.width + f.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25));\n                  }\n                }\n              } else (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : Math.min((c - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), c), m = 0 != this.labelAngle ? (k - (t + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : g, this.sessionVariables.labelMaxHeight = h = this.labelWrap ? (k - m * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, y(this.options.labelWrap)) ? y(this.options.labelWrap) && (this.labelWrap && !y(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m, this.sessionVariables.labelMaxHeight = h) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelMaxHeight = c < 0.9 * l ? 0.9 * l : c, this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m) : (y(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = h);\n            }\n          }for (c = 0; c < this._labels.length; c++) {\n            a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();\n          }\n        } else for (b = 0; b < this._labels.length; b++) {\n          a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = y(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = y(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = y(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = y(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();\n        }\n      } else if (\"left\" === this._position || \"right\" === this._position) if (g = y(this.options.labelMaxWidth) ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth, h = \"undefined\" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) {\n        this.sessionVariables.labelFontSize = this.labelFontSize;this.sessionVariables.labelMaxWidth = g;this.sessionVariables.labelMaxHeight = h;this.sessionVariables.labelAngle = y(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;this.sessionVariables.labelWrap = this.labelWrap;for (b = 0; b < this._labels.length; b++) {\n          if (!this._labels[b].breaksLabelType) {\n            a = this._labels[b].textBlock;q = a.measureText();for (d = b + 1; d < this._labels.length; d++) {\n              if (!this._labels[d].breaksLabelType) {\n                f = this._labels[d].textBlock;f = f.measureText();break;\n              }\n            }e.push(a.height);this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);c = g * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (h - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));\n            y(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? y(this.options.labelWrap) ? y(this.options.labelWrap) && (y(this.options.labelMaxWidth) ? y(f) || (l = q.height + f.height >> 0, l - 2 * h > n && (n = l - 2 * h, l >= 2 * h && l < 2.4 * h ? (y(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) : l >= 2.4 * h && l < 2.8 * h ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = !0) : l >= 2.8 * h && l < 3.2 * h ? (this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelWrap = !0, y(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelAngle = y(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : l >= 3.2 * h && l < 3.6 * h ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelFontSize = this.labelFontSize) : l > 3.6 * h && l < 10 * h ? (y(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelAngle = y(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : l > 10 * h && l < 50 * h && (y(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelAngle = y(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle))) : (this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = h) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? g : Math.min((c - h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), h), y(this.options.labelWrap)) ? y(this.options.labelWrap) && (this.labelWrap && !y(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth > this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : c, y(this.options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : c, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = g) : (this.sessionVariables.labelMaxHeight = h, y(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap);\n          }\n        }for (c = 0; c < this._labels.length; c++) {\n          a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();\n        }\n      } else for (b = 0; b < this._labels.length; b++) {\n        a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = y(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = y(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = y(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = y(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();\n      }for (b = 0; b < this.stripLines.length; b++) {\n        var g = this.stripLines[b],\n            x;if (\"outside\" === g.labelPlacement) {\n          h = this.sessionVariables.labelMaxWidth;if (\"bottom\" === this._position || \"top\" === this._position) x = y(g.options.labelWrap) ? this.sessionVariables.labelMaxHeight : g.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize;if (\"left\" === this._position || \"right\" === this._position) x = y(g.options.labelWrap) ? this.sessionVariables.labelMaxHeight : g.labelWrap ? 0.8 * this.chart.width >> 0 : 1.5 * this.labelFontSize;y(g.labelBackgroundColor) && (g.labelBackgroundColor = \"#EEEEEE\");\n        } else h = \"bottom\" === this._position || \"top\" === this._position ? 0.9 * this.chart.width >> 0 : 0.9 * this.chart.height >> 0, x = y(g.options.labelWrap) || g.labelWrap ? \"bottom\" === this._position || \"top\" === this._position ? 0.8 * this.chart.width >> 0 : 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, y(g.labelBackgroundColor) && (y(g.startValue) && 0 !== g.startValue ? g.labelBackgroundColor = v ? \"transparent\" : null : g.labelBackgroundColor = \"#EEEEEE\");a = new la(this.ctx, { x: 0, y: 0, backgroundColor: g.labelBackgroundColor, borderColor: g.labelBorderColor, borderThickness: g.labelBorderThickness, cornerRadius: g.labelCornerRadius, maxWidth: g.options.labelMaxWidth ? g.options.labelMaxWidth : h, maxHeight: x, angle: this.labelAngle, text: g.labelFormatter ? g.labelFormatter({ chart: this.chart, axis: this, stripLine: g }) : g.label, horizontalAlign: \"left\", fontSize: \"outside\" === g.labelPlacement ? g.options.labelFontSize ? g.labelFontSize : this.labelFontSize : g.labelFontSize, fontFamily: \"outside\" === g.labelPlacement ? g.options.labelFontFamily ? g.labelFontFamily : this.labelFontFamily : g.labelFontFamily, fontWeight: \"outside\" === g.labelPlacement ? g.options.labelFontWeight ? g.labelFontWeight : this.labelFontWeight : g.labelFontWeight, fontColor: g.labelFontColor || g.color, fontStyle: \"outside\" === g.labelPlacement ? g.options.labelFontStyle ? g.labelFontStyle : this.fontWeight : g.labelFontStyle, textBaseline: \"middle\" });this._stripLineLabels.push({ position: g.value, textBlock: a,\n          effectiveHeight: null, stripLine: g });\n      }\n    };C.prototype.createLabelsAndCalculateWidth = function () {\n      var a = 0,\n          f = 0;this._labels = [];this._stripLineLabels = [];if (\"left\" === this._position || \"right\" === this._position) {\n        this.createLabels();for (f = 0; f < this._labels.length; f++) {\n          var b = this._labels[f].textBlock,\n              c = b.measureText(),\n              e = 0,\n              e = 0 === this.labelAngle ? c.width : c.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (c.height - b.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));a < e && (a = e);this._labels[f].effectiveWidth = e;\n        }for (f = 0; f < this._stripLineLabels.length; f++) {\n          \"outside\" === this._stripLineLabels[f].stripLine.labelPlacement && this._stripLineLabels[f].stripLine.value > this.viewportMinimum && this._stripLineLabels[f].stripLine.value < this.viewportMaximum && (b = this._stripLineLabels[f].textBlock, c = b.measureText(), e = 0 === this.labelAngle ? c.width : c.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (c.height - b.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), a < e && (a = e), this._stripLineLabels[f].effectiveWidth = e);\n        }\n      }f = this.title ? this._titleTextBlock.measureText().height + 2 : 0;return b = \"inside\" === this.labelPlacement ? b = f + 5 : f + a + this.tickLength + 5;\n    };C.prototype.createLabelsAndCalculateHeight = function () {\n      var a = 0;this._labels = [];this._stripLineLabels = [];var f,\n          b = 0;this.createLabels();if (\"bottom\" === this._position || \"top\" === this._position) {\n        for (b = 0; b < this._labels.length; b++) {\n          f = this._labels[b].textBlock;var c = f.measureText(),\n              e = 0,\n              e = 0 === this.labelAngle ? c.height : c.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (c.height - f.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));a < e && (a = e);this._labels[b].effectiveHeight = e;\n        }for (b = 0; b < this._stripLineLabels.length; b++) {\n          \"outside\" === this._stripLineLabels[b].stripLine.labelPlacement && (f = this._stripLineLabels[b].textBlock, c = f.measureText(), e = 0 === this.labelAngle ? c.height : c.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (c.height - f.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), a < e && (a = e), this._stripLineLabels[b].effectiveHeight = e);\n        }\n      }f = this.title ? this._titleTextBlock.measureText().height + 2 : 0;return b = \"inside\" === this.labelPlacement ? b = f + 5 : f + a + this.tickLength + 5;\n    };C.setLayoutAndRender = function (a, f, b, c, e, g) {\n      var h,\n          l,\n          t,\n          k,\n          m = a[0] ? a[0].chart : f[0].chart,\n          p = m.ctx,\n          n = m._axes;if (a && 0 < a.length) for (var d = 0; d < a.length; d++) {\n        a[d] && a[d].calculateAxisParameters();\n      }if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n        f[d].calculateAxisParameters();\n      }if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n        b[d].calculateAxisParameters();\n      }if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n        c[d].calculateAxisParameters();\n      }for (d = 0; d < n.length; d++) {\n        if (n[d] && n[d].scaleBreaks && n[d].scaleBreaks._appliedBreaks.length) for (var q = n[d].scaleBreaks._appliedBreaks, s = 0; s < q.length && !(q[s].startValue > n[d].viewportMaximum); s++) {\n          q[s].endValue < n[d].viewportMinimum || (y(n[d].scaleBreaks.firstBreakIndex) && (n[d].scaleBreaks.firstBreakIndex = s), q[s].startValue >= n[d].viewPortMinimum && (n[d].scaleBreaks.lastBreakIndex = s));\n        }\n      }for (var x = s = 0, u = 0, z = 0, C = 0, G = 0, B = 0, A, H, L = l = 0, J, I, N, q = J = I = N = !1, d = 0; d < n.length; d++) {\n        n[d] && n[d].title && (n[d]._titleTextBlock = new la(n[d].ctx, { text: n[d].title, horizontalAlign: \"center\",\n          fontSize: n[d].titleFontSize, fontFamily: n[d].titleFontFamily, fontWeight: n[d].titleFontWeight, fontColor: n[d].titleFontColor, fontStyle: n[d].titleFontStyle, borderColor: n[d].titleBorderColor, borderThickness: n[d].titleBorderThickness, backgroundColor: n[d].titleBackgroundColor, cornerRadius: n[d].titleCornerRadius, textBaseline: \"top\" }));\n      }for (d = 0; d < n.length; d++) {\n        if (n[d].title) switch (n[d]._position) {case \"left\":\n            n[d]._titleTextBlock.maxWidth = n[d].titleMaxWidth || g.height;n[d]._titleTextBlock.maxHeight = n[d].titleWrap ? 0.8 * g.width : 1.5 * n[d].titleFontSize;n[d]._titleTextBlock.angle = -90;break;case \"right\":\n            n[d]._titleTextBlock.maxWidth = n[d].titleMaxWidth || g.height;n[d]._titleTextBlock.maxHeight = n[d].titleWrap ? 0.8 * g.width : 1.5 * n[d].titleFontSize;n[d]._titleTextBlock.angle = 90;break;default:\n            n[d]._titleTextBlock.maxWidth = n[d].titleMaxWidth || g.width, n[d]._titleTextBlock.maxHeight = n[d].titleWrap ? 0.8 * g.height : 1.5 * n[d].titleFontSize, n[d]._titleTextBlock.angle = 0;}\n      }if (\"normal\" === e) {\n        for (var z = [], C = [], G = [], B = [], O = [], P = [], R = [], Q = []; 4 > s;) {\n          var E = 0,\n              T = 0,\n              U = 0,\n              X = 0,\n              V = e = 0,\n              K = 0,\n              Z = 0,\n              Y = 0,\n              W = 0,\n              M = 0,\n              aa = 0;if (b && 0 < b.length) for (G = [], d = M = 0; d < b.length; d++) {\n            G.push(Math.ceil(b[d] ? b[d].createLabelsAndCalculateWidth() : 0)), M += G[d], K += b[d] ? b[d].margin : 0;\n          } else G.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateWidth() : 0));R.push(G);if (c && 0 < c.length) for (B = [], d = aa = 0; d < c.length; d++) {\n            B.push(Math.ceil(c[d] ? c[d].createLabelsAndCalculateWidth() : 0)), aa += B[d], Z += c[d] ? c[d].margin : 0;\n          } else B.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateWidth() : 0));Q.push(B);h = Math.round(g.x1 + M + K);t = Math.round(g.x2 - aa - Z > m.width - 10 ? m.width - 10 : g.x2 - aa - Z);if (a && 0 < a.length) for (z = [], d = Y = 0; d < a.length; d++) {\n            a[d] && (a[d].lineCoordinates = {}), a[d].lineCoordinates.width = Math.abs(t - h), a[d].title && (a[d]._titleTextBlock.maxWidth = 0 < a[d].titleMaxWidth && a[d].titleMaxWidth < a[d].lineCoordinates.width ? a[d].titleMaxWidth : a[d].lineCoordinates.width), z.push(Math.ceil(a[d] ? a[d].createLabelsAndCalculateHeight() : 0)), Y += z[d], e += a[d] ? a[d].margin : 0;\n          } else z.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0));\n          O.push(z);if (f && 0 < f.length) for (C = [], d = W = 0; d < f.length; d++) {\n            f[d] && (f[d].lineCoordinates = {}), f[d].lineCoordinates.width = Math.abs(t - h), f[d].title && (f[d]._titleTextBlock.maxWidth = 0 < f[d].titleMaxWidth && f[d].titleMaxWidth < f[d].lineCoordinates.width ? f[d].titleMaxWidth : f[d].lineCoordinates.width), C.push(Math.ceil(f[d] ? f[d].createLabelsAndCalculateHeight() : 0)), W += C[d], V += f[d] ? f[d].margin : 0;\n          } else C.push(Math.ceil(f[0] ? f[0].createLabelsAndCalculateHeight() : 0));P.push(C);if (a && 0 < a.length) for (d = 0; d < a.length; d++) {\n            a[d] && (a[d].lineCoordinates.x1 = h, t = Math.round(g.x2 - aa - Z > m.width - 10 ? m.width - 10 : g.x2 - aa - Z), a[d]._labels && 1 < a[d]._labels.length && (l = k = 0, k = a[d]._labels[1], l = \"dateTime\" === a[d].valueType ? a[d]._labels[a[d]._labels.length - 2] : a[d]._labels[a[d]._labels.length - 1], x = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), u = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle))), a[d] && a[d].labelAutoFit && !y(A) && !y(H) && (l = 0, 0 < a[d].labelAngle ? H + u > t && (l += 0 < a[d].labelAngle ? H + u - t - aa : 0) : 0 > a[d].labelAngle ? A - x < h && A - x < a[d].viewportMinimum && (L = h - (K + a[d].tickLength + G + A - x + a[d].labelFontSize / 2)) : 0 === a[d].labelAngle && (H + u > t && (l = H + u / 2 - t - aa), A - x < h && A - x < a[d].viewportMinimum && (L = h - K - a[d].tickLength - G - A + x / 2)), a[d].viewportMaximum === a[d].maximum && a[d].viewportMinimum === a[d].minimum && 0 < a[d].labelAngle && 0 < l ? t -= l : a[d].viewportMaximum === a[d].maximum && a[d].viewportMinimum === a[d].minimum && 0 > a[d].labelAngle && 0 < L ? h += L : a[d].viewportMaximum === a[d].maximum && a[d].viewportMinimum === a[d].minimum && 0 === a[d].labelAngle && (0 < L && (h += L), 0 < l && (t -= l))), m.panEnabled ? Y = m.sessionVariables.axisX.height : m.sessionVariables.axisX.height = Y, l = Math.round(g.y2 - Y - e + E), k = Math.round(g.y2), a[d].lineCoordinates.x2 = t, a[d].lineCoordinates.width = t - h, a[d].lineCoordinates.y1 = l, a[d].lineCoordinates.y2 = l, a[d].bounds = { x1: h, y1: l, x2: t, y2: k - (Y + e - z[d] - E), width: t - h, height: k - l }), E += z[d] + a[d].margin;\n          }if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n            f[d].lineCoordinates.x1 = Math.round(g.x1 + M + K), f[d].lineCoordinates.x2 = Math.round(g.x2 - aa - Z > m.width - 10 ? m.width - 10 : g.x2 - aa - Z), f[d].lineCoordinates.width = Math.abs(t - h), f[d]._labels && 1 < f[d]._labels.length && (k = f[d]._labels[1], l = \"dateTime\" === f[d].valueType ? f[d]._labels[f[d]._labels.length - 2] : f[d]._labels[f[d]._labels.length - 1], x = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), u = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle))), m.panEnabled ? W = m.sessionVariables.axisX2.height : m.sessionVariables.axisX2.height = W, l = Math.round(g.y1), k = Math.round(g.y2 + f[d].margin), f[d].lineCoordinates.y1 = l + W + V - T, f[d].lineCoordinates.y2 = l, f[d].bounds = { x1: h, y1: l + (W + V - C[d] - T), x2: t, y2: k, width: t - h, height: k - l }, T += C[d] + f[d].margin;\n          }if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n            K = 10, b[d] && (h = Math.round(a[0] ? a[0].lineCoordinates.x1 : f[0].lineCoordinates.x1), K = b[d]._labels && 0 < b[d]._labels.length ? b[d]._labels[b[d]._labels.length - 1].textBlock.height / 2 : 10, l = Math.round(g.y1 + W + V < Math.max(K, 10) ? Math.max(K, 10) : g.y1 + W + V), t = Math.round(a[0] ? a[0].lineCoordinates.x1 : f[0].lineCoordinates.x1), K = 0 < a.length ? 0 : b[d]._labels && 0 < b[d]._labels.length ? b[d]._labels[0].textBlock.height / 2 : 10, k = Math.round(g.y2 - Y - e - K), b[d].lineCoordinates = { x1: t - U, y1: l, x2: t - U, y2: k, height: Math.abs(k - l) }, b[d].bounds = { x1: h - (G[d] + U), y1: l, x2: t, y2: k, width: t - h, height: k - l }, b[d].title && (b[d]._titleTextBlock.maxWidth = 0 < b[d].titleMaxWidth && b[d].titleMaxWidth < b[d].lineCoordinates.height ? b[d].titleMaxWidth : b[d].lineCoordinates.height), U += G[d] + b[d].margin);\n          }if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n            c[d] && (h = Math.round(a[0] ? a[0].lineCoordinates.x2 : f[0].lineCoordinates.x2), t = Math.round(h), K = c[d]._labels && 0 < c[d]._labels.length ? c[d]._labels[c[d]._labels.length - 1].textBlock.height / 2 : 0, l = Math.round(g.y1 + W + V < Math.max(K, 10) ? Math.max(K, 10) : g.y1 + W + V), K = 0 < a.length ? 0 : c[d]._labels && 0 < c[d]._labels.length ? c[d]._labels[0].textBlock.height / 2 : 0, k = Math.round(g.y2 - (Y + e + K)), c[d].lineCoordinates = { x1: h + X, y1: l, x2: h + X, y2: k, height: Math.abs(k - l) }, c[d].bounds = { x1: h, y1: l, x2: t + (B[d] + X), y2: k, width: t - h, height: k - l }, c[d].title && (c[d]._titleTextBlock.maxWidth = 0 < c[d].titleMaxWidth && c[d].titleMaxWidth < c[d].lineCoordinates.height ? c[d].titleMaxWidth : c[d].lineCoordinates.height), X += B[d] + c[d].margin);\n          }if (a && 0 < a.length) for (d = 0; d < a.length; d++) {\n            a[d] && (a[d].calculateValueToPixelConversionParameters(), a[d].calculateBreaksSizeInValues(), a[d]._labels && 1 < a[d]._labels.length && (A = (a[d].logarithmic ? Math.log(a[d]._labels[1].position / a[d].viewportMinimum) / a[d].conversionParameters.lnLogarithmBase : a[d]._labels[1].position - a[d].viewportMinimum) * Math.abs(a[d].conversionParameters.pixelPerUnit) + a[d].lineCoordinates.x1, h = a[d]._labels[a[d]._labels.length - (\"dateTime\" === a[d].valueType ? 2 : 1)].position, h = a[d].getApparentDifference(a[d].viewportMinimum, h), H = a[d].logarithmic ? (1 < h ? Math.log(h) / a[d].conversionParameters.lnLogarithmBase * Math.abs(a[d].conversionParameters.pixelPerUnit) : 0) + a[d].lineCoordinates.x1 : (0 < h ? h * Math.abs(a[d].conversionParameters.pixelPerUnit) : 0) + a[d].lineCoordinates.x1));\n          }if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n            f[d].calculateValueToPixelConversionParameters(), f[d].calculateBreaksSizeInValues(), f[d]._labels && 1 < f[d]._labels.length && (A = (f[d].logarithmic ? Math.log(f[d]._labels[1].position / f[d].viewportMinimum) / f[d].conversionParameters.lnLogarithmBase : f[d]._labels[1].position - f[d].viewportMinimum) * Math.abs(f[d].conversionParameters.pixelPerUnit) + f[d].lineCoordinates.x1, h = f[d]._labels[f[d]._labels.length - (\"dateTime\" === f[d].valueType ? 2 : 1)].position, h = f[d].getApparentDifference(f[d].viewportMinimum, h), H = f[d].logarithmic ? (1 < h ? Math.log(h) / f[d].conversionParameters.lnLogarithmBase * Math.abs(f[d].conversionParameters.pixelPerUnit) : 0) + f[d].lineCoordinates.x1 : (0 < h ? h * Math.abs(f[d].conversionParameters.pixelPerUnit) : 0) + f[d].lineCoordinates.x1);\n          }for (d = 0; d < n.length; d++) {\n            \"axisY\" === n[d].type && (n[d].calculateValueToPixelConversionParameters(), n[d].calculateBreaksSizeInValues());\n          }if (0 < s) {\n            if (a && 0 < a.length) for (d = 0; d < a.length; d++) {\n              q = O[s - 1][d] === O[s][d] ? !0 : !1;\n            } else q = !0;if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n              J = P[s - 1][d] === P[s][d] ? !0 : !1;\n            } else J = !0;if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n              I = R[s - 1][d] === R[s][d] ? !0 : !1;\n            } else I = !0;if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n              N = Q[s - 1][d] === Q[s][d] ? !0 : !1;\n            } else N = !0;\n          }if (q && J && I && N) break;s++;\n        }p.save();p.beginPath();a[0] && p.rect(5, a[0].bounds.y1, a[0].chart.width - 10, a[0].bounds.height);f[0] && p.rect(5, f[f.length - 1].bounds.y1, f[0].chart.width - 10, f[0].bounds.height);\n        p.clip();if (a && 0 < a.length) for (d = 0; d < a.length; d++) {\n          a[d].calculateStripLinesThicknessInValues(), a[d].calculateBreaksInPixels(), a[d].renderLabelsTicksAndTitle();\n        }if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n          f[d].calculateStripLinesThicknessInValues(), f[d].calculateBreaksInPixels(), f[d].renderLabelsTicksAndTitle();\n        }p.restore();if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n          b[d].calculateStripLinesThicknessInValues(), b[d].calculateBreaksInPixels(), b[d].renderLabelsTicksAndTitle();\n        }if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n          c[d].calculateStripLinesThicknessInValues(), c[d].calculateBreaksInPixels(), c[d].renderLabelsTicksAndTitle();\n        }\n      } else {\n        A = [];L = [];x = [];H = [];u = [];O = [];P = [];for (R = []; 4 > s;) {\n          W = Y = M = X = Z = K = V = e = U = Q = T = E = 0;if (a && 0 < a.length) for (x = [], d = Y = 0; d < a.length; d++) {\n            x.push(Math.ceil(a[d] ? a[d].createLabelsAndCalculateWidth() : 0)), Y += x[d], e += a[d] ? a[d].margin : 0;\n          } else x.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateWidth() : 0));P.push(x);if (f && 0 < f.length) for (H = [], d = W = 0; d < f.length; d++) {\n            H.push(Math.ceil(f[d] ? f[d].createLabelsAndCalculateWidth() : 0)), W += H[d], V += f[d] ? f[d].margin : 0;\n          } else H.push(Math.ceil(f[0] ? f[0].createLabelsAndCalculateWidth() : 0));R.push(H);if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n            b[d].lineCoordinates = {}, h = Math.round(g.x1 + Y + e), t = Math.round(g.x2 - W - V > m.width - 10 ? m.width - 10 : g.x2 - W - V), b[d].labelAutoFit && !y(z) && (0 < !a.length && (h = 0 > b[d].labelAngle ? Math.max(h, z) : 0 === b[d].labelAngle ? Math.max(h, z / 2) : h), 0 < !f.length && (t = 0 < b[d].labelAngle ? t - C / 2 : 0 === b[d].labelAngle ? t - C / 2 : t)), b[d].lineCoordinates.x1 = h, b[d].lineCoordinates.x2 = t, b[d].lineCoordinates.width = Math.abs(t - h), b[d].title && (b[d]._titleTextBlock.maxWidth = 0 < b[d].titleMaxWidth && b[d].titleMaxWidth < b[d].lineCoordinates.width ? b[d].titleMaxWidth : b[d].lineCoordinates.width);\n          }if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n            c[d].lineCoordinates = {}, h = Math.round(g.x1 + Y + e), t = Math.round(g.x2 - W - V > c[d].chart.width - 10 ? c[d].chart.width - 10 : g.x2 - W - V), c[d] && c[d].labelAutoFit && !y(G) && (0 < !a.length && (h = 0 < c[d].labelAngle ? Math.max(h, G) : 0 === c[d].labelAngle ? Math.max(h, G / 2) : h), 0 < !f.length && (t -= B / 2)), c[d].lineCoordinates.x1 = h, c[d].lineCoordinates.x2 = t, c[d].lineCoordinates.width = Math.abs(t - h), c[d].title && (c[d]._titleTextBlock.maxWidth = 0 < c[d].titleMaxWidth && c[d].titleMaxWidth < c[d].lineCoordinates.width ? c[d].titleMaxWidth : c[d].lineCoordinates.width);\n          }if (b && 0 < b.length) for (A = [], d = X = 0; d < b.length; d++) {\n            A.push(Math.ceil(b[d] ? b[d].createLabelsAndCalculateHeight() : 0)), X += A[d] + b[d].margin, K += b[d].margin;\n          } else A.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateHeight() : 0));u.push(A);if (c && 0 < c.length) for (L = [], d = M = 0; d < c.length; d++) {\n            L.push(Math.ceil(c[d] ? c[d].createLabelsAndCalculateHeight() : 0)), M += L[d], Z += c[d].margin;\n          } else L.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateHeight() : 0));O.push(L);if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n            0 < b[d]._labels.length && (k = b[d]._labels[0], l = b[d]._labels[b[d]._labels.length - 1], z = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), C = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)));\n          }if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n            c[d] && 0 < c[d]._labels.length && (k = c[d]._labels[0], l = c[d]._labels[c[d]._labels.length - 1], G = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), B = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)));\n          }if (m.panEnabled) for (d = 0; d < b.length; d++) {\n            A[d] = m.sessionVariables.axisY.height;\n          } else for (d = 0; d < b.length; d++) {\n            m.sessionVariables.axisY.height = A[d];\n          }if (b && 0 < b.length) for (d = b.length - 1; 0 <= d; d--) {\n            l = Math.round(g.y2), k = Math.round(g.y2 > b[d].chart.height - 10 ? b[d].chart.height - 10 : g.y2), b[d].lineCoordinates.y1 = l - (A[d] + b[d].margin + E), b[d].lineCoordinates.y2 = l - (A[d] + b[d].margin + E), b[d].bounds = { x1: h, y1: l - (A[d] + E + b[d].margin), x2: t, y2: k - (E + b[d].margin), width: t - h, height: A[d] }, b[d].title && (b[d]._titleTextBlock.maxWidth = 0 < b[d].titleMaxWidth && b[d].titleMaxWidth < b[d].lineCoordinates.width ? b[d].titleMaxWidth : b[d].lineCoordinates.width), E += A[d] + b[d].margin;\n          }if (c && 0 < c.length) for (d = c.length - 1; 0 <= d; d--) {\n            c[d] && (l = Math.round(g.y1), k = Math.round(g.y1 + (L[d] + c[d].margin + T)), c[d].lineCoordinates.y1 = k, c[d].lineCoordinates.y2 = k, c[d].bounds = { x1: h, y1: l + (c[d].margin + T), x2: t, y2: k, width: t - h, height: M }, c[d].title && (c[d]._titleTextBlock.maxWidth = 0 < c[d].titleMaxWidth && c[d].titleMaxWidth < c[d].lineCoordinates.width ? c[d].titleMaxWidth : c[d].lineCoordinates.width), T += L[d] + c[d].margin);\n          }if (a && 0 < a.length) for (d = 0; d < a.length; d++) {\n            K = a[d]._labels && 0 < a[d]._labels.length ? a[d]._labels[0].textBlock.fontSize / 2 : 0;h = Math.round(g.x1 + e);l = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y2 : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1) : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1;t = Math.round(g.x1 + Y + e);k = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y1 : g.y2 - X > m.height - Math.max(K, 10) ? m.height - Math.max(K, 10) : g.y2 - X) : g.y2 > m.height - Math.max(K, 10) ? m.height - Math.max(K, 10) : g.y2;if (b && 0 < b.length) for (K = 0; K < b.length; K++) {\n              b[K] && b[K].labelAutoFit && (t = 0 > b[K].labelAngle ? Math.max(t, z) : 0 === b[K].labelAngle ? Math.max(t, z / 2) : t, h = 0 > b[K].labelAngle || 0 === b[K].labelAngle ? t - Y : h);\n            }if (c && 0 < c.length) for (K = 0; K < c.length; K++) {\n              c[K] && c[K].labelAutoFit && (t = c[K].lineCoordinates.x1, h = t - Y);\n            }a[d].lineCoordinates = { x1: t - Q, y1: l, x2: t - Q, y2: k, height: Math.abs(k - l) };a[d].bounds = { x1: t - (x[d] + Q), y1: l, x2: t, y2: k, width: t - h, height: k - l };a[d].title && (a[d]._titleTextBlock.maxWidth = 0 < a[d].titleMaxWidth && a[d].titleMaxWidth < a[d].lineCoordinates.height ? a[d].titleMaxWidth : a[d].lineCoordinates.height);a[d].calculateValueToPixelConversionParameters();a[d].calculateBreaksSizeInValues();Q += x[d] + a[d].margin;\n          }if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n            K = f[d]._labels && 0 < f[d]._labels.length ? f[d]._labels[0].textBlock.fontSize / 2 : 0;h = Math.round(g.x1 - e);l = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y2 : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1) : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1;t = Math.round(g.x2 - W - V);k = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y1 : g.y2 - X > m.height - Math.max(K, 10) ? m.height - Math.max(K, 10) : g.y2 - X) : g.y2 > m.height - Math.max(K, 10) ? m.height - Math.max(K, 10) : g.y2;if (b && 0 < b.length) for (K = 0; K < b.length; K++) {\n              b[K] && b[K].labelAutoFit && (t = 0 > b[K].labelAngle ? Math.max(t, z) : 0 === b[K].labelAngle ? Math.max(t, z / 2) : t, h = 0 > b[K].labelAngle || 0 === b[K].labelAngle ? t - W : h);\n            }if (c && 0 < c.length) for (K = 0; K < c.length; K++) {\n              c[K] && c[K].labelAutoFit && (t = c[K].lineCoordinates.x2, h = t - W);\n            }f[d].lineCoordinates = { x1: t + U, y1: l, x2: t + U, y2: k, height: Math.abs(k - l) };f[d].bounds = { x1: h, y1: l, x2: t + H[d] + U, y2: k, width: t - h, height: k - l };f[d].title && (f[d]._titleTextBlock.maxWidth = 0 < f[d].titleMaxWidth && f[d].titleMaxWidth < f[d].lineCoordinates.height ? f[d].titleMaxWidth : f[d].lineCoordinates.height);f[d].calculateValueToPixelConversionParameters();f[d].calculateBreaksSizeInValues();U += H[d] + f[d].margin;\n          }for (d = 0; d < n.length; d++) {\n            \"axisY\" === n[d].type && (n[d].calculateValueToPixelConversionParameters(), n[d].calculateBreaksSizeInValues());\n          }if (0 < s) {\n            if (a && 0 < a.length) for (d = 0; d < a.length; d++) {\n              q = P[s - 1][d] === P[s][d] ? !0 : !1;\n            } else q = !0;if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n              J = R[s - 1][d] === R[s][d] ? !0 : !1;\n            } else J = !0;if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n              I = u[s - 1][d] === u[s][d] ? !0 : !1;\n            } else I = !0;if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n              N = O[s - 1][d] === O[s][d] ? !0 : !1;\n            } else N = !0;\n          }if (q && J && I && N) break;s++;\n        }if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n          b[d].calculateStripLinesThicknessInValues(), b[d].calculateBreaksInPixels(), b[d].renderLabelsTicksAndTitle();\n        }if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n          c[d].calculateStripLinesThicknessInValues(), c[d].calculateBreaksInPixels(), c[d].renderLabelsTicksAndTitle();\n        }if (a && 0 < a.length) for (d = 0; d < a.length; d++) {\n          a[d].calculateStripLinesThicknessInValues(), a[d].calculateBreaksInPixels(), a[d].renderLabelsTicksAndTitle();\n        }if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n          f[d].calculateStripLinesThicknessInValues(), f[d].calculateBreaksInPixels(), f[d].renderLabelsTicksAndTitle();\n        }\n      }m.preparePlotArea();g = m.plotArea;p.save();p.beginPath();p.rect(g.x1, g.y1, Math.abs(g.x2 - g.x1), Math.abs(g.y2 - g.y1));p.clip();if (a && 0 < a.length) for (d = 0; d < n.length; d++) {\n        n[d].renderStripLinesOfThicknessType(\"value\");\n      }if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n        f[d].renderStripLinesOfThicknessType(\"value\");\n      }if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n        b[d].renderStripLinesOfThicknessType(\"value\");\n      }if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n        c[d].renderStripLinesOfThicknessType(\"value\");\n      }if (a && 0 < a.length) for (d = 0; d < a.length; d++) {\n        a[d].renderInterlacedColors();\n      }if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n        f[d].renderInterlacedColors();\n      }if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n        b[d].renderInterlacedColors();\n      }if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n        c[d].renderInterlacedColors();\n      }p.restore();if (a && 0 < a.length) for (d = 0; d < a.length; d++) {\n        a[d].renderGrid(), v && (a[d].createMask(), a[d].renderBreaksBackground());\n      }if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n        f[d].renderGrid(), v && (f[d].createMask(), f[d].renderBreaksBackground());\n      }if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n        b[d].renderGrid(), v && (b[d].createMask(), b[d].renderBreaksBackground());\n      }if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n        c[d].renderGrid(), v && (c[d].createMask(), c[d].renderBreaksBackground());\n      }if (a && 0 < a.length) for (d = 0; d < a.length; d++) {\n        a[d].renderAxisLine();\n      }if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n        f[d].renderAxisLine();\n      }if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n        b[d].renderAxisLine();\n      }if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n        c[d].renderAxisLine();\n      }if (a && 0 < a.length) for (d = 0; d < a.length; d++) {\n        a[d].renderStripLinesOfThicknessType(\"pixel\");\n      }if (f && 0 < f.length) for (d = 0; d < f.length; d++) {\n        f[d].renderStripLinesOfThicknessType(\"pixel\");\n      }if (b && 0 < b.length) for (d = 0; d < b.length; d++) {\n        b[d].renderStripLinesOfThicknessType(\"pixel\");\n      }if (c && 0 < c.length) for (d = 0; d < c.length; d++) {\n        c[d].renderStripLinesOfThicknessType(\"pixel\");\n      }\n    };C.prototype.calculateStripLinesThicknessInValues = function () {\n      for (var a = 0; a < this.stripLines.length; a++) {\n        if (null !== this.stripLines[a].startValue && null !== this.stripLines[a].endValue) {\n          var f = Math.min(this.stripLines[a].startValue, this.stripLines[a].endValue),\n              b = Math.max(this.stripLines[a].startValue, this.stripLines[a].endValue),\n              f = this.getApparentDifference(f, b);this.stripLines[a].value = this.logarithmic ? this.stripLines[a].value * Math.sqrt(Math.log(this.stripLines[a].endValue / this.stripLines[a].startValue) / Math.log(f)) : this.stripLines[a].value + (Math.abs(this.stripLines[a].endValue - this.stripLines[a].startValue) - f) / 2;this.stripLines[a].thickness = f;this.stripLines[a]._thicknessType = \"value\";\n        }\n      }\n    };C.prototype.calculateBreaksSizeInValues = function () {\n      for (var a = \"left\" === this._position || \"right\" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, f = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], b = this.conversionParameters.pixelPerUnit || a / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum - this.conversionParameters.minimum), c = this.scaleBreaks && !y(this.scaleBreaks.options.spacing), e, g = 0; g < f.length; g++) {\n        e = c || !y(f[g].options.spacing), f[g].spacing = O(f[g].spacing, a, 8, e ? 0.1 * a : 8, e ? 0 : 3) << 0, f[g].size = 0 > f[g].spacing ? 0 : Math.abs(f[g].spacing / b), this.logarithmic && (f[g].size = Math.pow(this.logarithmBase, f[g].size));\n      }\n    };C.prototype.calculateBreaksInPixels = function () {\n      if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) {\n        var a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];a.length && (this.scaleBreaks.firstBreakIndex = this.scaleBreaks.lastBreakIndex = null);for (var f = 0; f < a.length && !(a[f].startValue > this.conversionParameters.maximum); f++) {\n          a[f].endValue < this.conversionParameters.minimum || (y(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = f), a[f].startValue >= this.conversionParameters.minimum && (a[f].startPixel = this.convertValueToPixel(a[f].startValue), this.scaleBreaks.lastBreakIndex = f), a[f].endValue <= this.conversionParameters.maximum && (a[f].endPixel = this.convertValueToPixel(a[f].endValue)));\n        }\n      }\n    };C.prototype.renderLabelsTicksAndTitle = function () {\n      var a = this,\n          f = !1,\n          b = 0,\n          c = 0,\n          e = 1,\n          g = 0;0 !== this.labelAngle && 360 !== this.labelAngle && (e = 1.2);if (\"undefined\" === typeof this.options.interval) {\n        if (\"bottom\" === this._position || \"top\" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {\n          for (var b = [], e = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2, h, l = this.viewportMaximum, m = this.lineCoordinates.width / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {\n            p = this._labels[k];if (p.position < this.viewportMinimum) break;p.position > this.viewportMaximum || !(k === this._labels.length - 1 || h < Math.log(l / p.position) * m / e) || (b.push(p), l = p.position, h = p.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));\n          }this._labels = b;\n        } else {\n          for (k = 0; k < this._labels.length; k++) {\n            p = this._labels[k], p.position < this.viewportMinimum || (h = p.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), b += h);\n          }b > this.lineCoordinates.width * e && this.labelAutoFit && (f = !0);\n        }if (\"left\" === this._position || \"right\" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {\n          for (var b = [], r, l = this.viewportMaximum, m = this.lineCoordinates.height / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {\n            p = this._labels[k];if (p.position < this.viewportMinimum) break;\n            p.position > this.viewportMaximum || !(k === this._labels.length - 1 || r < Math.log(l / p.position) * m) || (b.push(p), l = p.position, r = p.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));\n          }this._labels = b;\n        } else {\n          for (k = 0; k < this._labels.length; k++) {\n            p = this._labels[k], p.position < this.viewportMinimum || (r = p.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), c += r);\n          }c > this.lineCoordinates.height * e && this.labelAutoFit && (f = !0);\n        }\n      }this.logarithmic && !this.equidistantInterval && this.labelAutoFit && this._labels.sort(function (a, b) {\n        return a.position - b.position;\n      });var k = 0,\n          p,\n          n;if (\"bottom\" === this._position) {\n        for (k = 0; k < this._labels.length; k++) {\n          p = this._labels[k], p.position < this.viewportMinimum || p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit || (n = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && \"inside\" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, n.y << 0), this.ctx.lineTo(c, n.y + this.tickLength << 0), this.ctx.stroke()), 0 === p.textBlock.angle ? (n.x -= p.textBlock.width / 2, n.y = \"inside\" === this.labelPlacement ? n.y - (this.tickLength + p.textBlock.fontSize / 2) : n.y + this.tickLength + p.textBlock.fontSize / 2) : (n.x = \"inside\" === this.labelPlacement ? 0 > this.labelAngle ? n.x : n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : n.x - (0 > this.labelAngle ? p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), n.y = \"inside\" === this.labelPlacement ? 0 > this.labelAngle ? n.y - this.tickLength - 5 : n.y - this.tickLength - Math.abs(p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + 5) : n.y + this.tickLength + Math.abs(0 > this.labelAngle ? p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), p.textBlock.x = n.x, p.textBlock.y = n.y);\n        }\"inside\" === this.labelPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n          for (k = 0; k < a._labels.length; k++) {\n            if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {\n              a.ctx.lineWidth = a.tickThickness;a.ctx.strokeStyle = a.tickColor;var b = 1 === a.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0;a.ctx.save();a.ctx.beginPath();a.ctx.moveTo(b, n.y << 0);a.ctx.lineTo(b, n.y - a.tickLength << 0);a.ctx.stroke();a.ctx.restore();\n            }\n          }\n        }, this);this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height - 3, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\n      } else if (\"top\" === this._position) {\n        for (k = 0; k < this._labels.length; k++) {\n          p = this._labels[k], p.position < this.viewportMinimum || p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit || (n = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && \"inside\" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, n.y << 0), this.ctx.lineTo(c, n.y - this.tickLength << 0), this.ctx.stroke()), 0 === p.textBlock.angle ? (n.x -= p.textBlock.width / 2, n.y = \"inside\" === this.labelPlacement ? n.y + this.labelFontSize / 2 + this.tickLength + 5 : n.y - (this.tickLength + p.textBlock.height - p.textBlock.fontSize / 2)) : (n.x = \"inside\" === this.labelPlacement ? 0 < this.labelAngle ? n.x : n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : n.x + (p.textBlock.height - this.tickLength - this.labelFontSize) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), n.y = \"inside\" === this.labelPlacement ? 0 < this.labelAngle ? n.y + this.tickLength + 5 : n.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength + 5 : n.y - (this.tickLength + ((p.textBlock.height - p.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))), p.textBlock.x = n.x, p.textBlock.y = n.y);\n        }\"inside\" === this.labelPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n          for (k = 0; k < a._labels.length; k++) {\n            if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {\n              a.ctx.lineWidth = a.tickThickness;a.ctx.strokeStyle = a.tickColor;var b = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0;a.ctx.save();a.ctx.beginPath();a.ctx.moveTo(b, n.y << 0);a.ctx.lineTo(b, n.y + a.tickLength << 0);a.ctx.stroke();a.ctx.restore();\n            }\n          }\n        }, this);this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y1 + 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\n      } else if (\"left\" === this._position) {\n        for (k = 0; k < this._labels.length; k++) {\n          p = this._labels[k], p.position < this.viewportMinimum || p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit || (n = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && \"inside\" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0, this.ctx.beginPath(), this.ctx.moveTo(n.x << 0, c), this.ctx.lineTo(n.x - this.tickLength << 0, c), this.ctx.stroke()), 0 === this.labelAngle ? (p.textBlock.y = n.y, p.textBlock.x = \"inside\" === this.labelPlacement ? n.x + this.tickLength + 5 : n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5) : (p.textBlock.y = \"inside\" === this.labelPlacement ? n.y : n.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), p.textBlock.x = \"inside\" === this.labelPlacement ? n.x + this.tickLength + 5 : 0 < this.labelAngle ? n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength));\n        }\"inside\" === this.labelPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n          for (k = 0; k < a._labels.length; k++) {\n            if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {\n              a.ctx.lineWidth = a.tickThickness;a.ctx.strokeStyle = a.tickColor;var b = 1 === a.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0;a.ctx.save();a.ctx.beginPath();a.ctx.moveTo(n.x << 0, b);a.ctx.lineTo(n.x + a.tickLength << 0, b);a.ctx.stroke();a.ctx.restore();\n            }\n          }\n        }, this);this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\n      } else if (\"right\" === this._position) {\n        for (k = 0; k < this._labels.length; k++) {\n          p = this._labels[k], p.position < this.viewportMinimum || p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit || (n = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && \"inside\" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0, this.ctx.beginPath(), this.ctx.moveTo(n.x << 0, c), this.ctx.lineTo(n.x + this.tickLength << 0, c), this.ctx.stroke()), 0 === this.labelAngle ? (p.textBlock.y = n.y, p.textBlock.x = \"inside\" === this.labelPlacement ? n.x - p.textBlock.width - this.tickLength - 5 : n.x + this.tickLength + 5) : (p.textBlock.y = \"inside\" === this.labelPlacement ? n.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0 > this.labelAngle ? n.y : n.y - (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), p.textBlock.x = \"inside\" === this.labelPlacement ? n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : 0 < this.labelAngle ? n.x + (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : n.x + this.tickLength + 5));\n        }\"inside\" === this.labelPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n          for (k = 0; k < a._labels.length; k++) {\n            if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {\n              a.ctx.lineWidth = a.tickThickness;a.ctx.strokeStyle = a.tickColor;var b = 1 === a.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0;a.ctx.save();a.ctx.beginPath();a.ctx.moveTo(n.x << 0, b);a.ctx.lineTo(n.x - a.tickLength << 0, b);a.ctx.stroke();a.ctx.restore();\n            }\n          }\n        }, this);this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\n      }g = 0;if (\"inside\" === this.labelPlacement) this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n        for (k = 0; k < a._labels.length; k++) {\n          p = a._labels[k], p.position < a.viewportMinimum || p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit && p.skipFlag || (a.ctx.save(), a.ctx.beginPath(), p.textBlock.render(!0), a.ctx.restore());\n        }\n      }, p.textBlock);else for (k = 0; k < this._labels.length; k++) {\n        p = this._labels[k], p.position < this.viewportMinimum || p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit && p.skipFlag || p.textBlock.render(!0);\n      }\n    };C.prototype.renderInterlacedColors = function () {\n      var a = this.chart.plotArea.ctx,\n          f,\n          b,\n          c = this.chart.plotArea,\n          e = 0;f = !0;if ((\"bottom\" === this._position || \"top\" === this._position) && this.interlacedColor) for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++) {\n        f ? (f = this.getPixelCoordinatesOnAxis(this._labels[e].position), b = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(Math.min(b.x, f.x), c.y1, Math.abs(b.x - f.x), Math.abs(c.y1 - c.y2)), f = !1) : f = !0;\n      } else if ((\"left\" === this._position || \"right\" === this._position) && this.interlacedColor) for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++) {\n        f ? (b = this.getPixelCoordinatesOnAxis(this._labels[e].position), f = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(c.x1, Math.min(b.y, f.y), Math.abs(c.x1 - c.x2), Math.abs(f.y - b.y)), f = !1) : f = !0;\n      }a.beginPath();\n    };C.prototype.renderStripLinesOfThicknessType = function (a) {\n      if (this.stripLines && 0 < this.stripLines.length && a) {\n        for (var f = this, b, c = 0, e = 0, g = !1, h = !1, l = [], m = [], h = !1, c = 0; c < this.stripLines.length; c++) {\n          var k = this.stripLines[c];k._thicknessType === a && (\"pixel\" === a && (k.value < this.viewportMinimum || k.value > this.viewportMaximum || y(k.value) || isNaN(this.range)) || l.push(k));\n        }for (c = 0; c < this._stripLineLabels.length; c++) {\n          if (k = this.stripLines[c], b = this._stripLineLabels[c], !(b.position < this.viewportMinimum || b.position > this.viewportMaximum || isNaN(this.range))) {\n            a = this.getPixelCoordinatesOnAxis(b.position);if (\"outside\" === b.stripLine.labelPlacement) {\n              if (k && (this.ctx.strokeStyle = k.color, \"pixel\" === k._thicknessType && (this.ctx.lineWidth = k.thickness)), \"bottom\" === this._position) {\n                var r = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0;this.ctx.beginPath();this.ctx.moveTo(r, a.y << 0);\n                this.ctx.lineTo(r, a.y + this.tickLength << 0);this.ctx.stroke();0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y += this.tickLength + b.textBlock.fontSize / 2) : (a.x -= 0 > this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, a.y += this.tickLength + Math.abs(0 > this.labelAngle ? b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5));\n              } else \"top\" === this._position ? (r = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, this.ctx.beginPath(), this.ctx.moveTo(r, a.y << 0), this.ctx.lineTo(r, a.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y -= this.tickLength + b.textBlock.height) : (a.x += (b.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), a.y -= this.tickLength + (b.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : \"left\" === this._position ? (r = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, r), this.ctx.lineTo(a.x - this.tickLength << 0, r), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (a.y -= b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : \"right\" === this._position && (r = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, r), this.ctx.lineTo(a.x + this.tickLength << 0, r), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x + this.tickLength + 5 : (a.y = 0 > this.labelAngle ? a.y : a.y - (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : a.x + this.tickLength + 5));\n            } else b.textBlock.angle = -90, \"bottom\" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? y(k.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize / 2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, y(k.startValue) ? a.x += b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y1 + b.textBlock.width + 3 : \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - b.textBlock.width - 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : \"top\" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? y(k.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize / 2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, y(k.startValue) ? a.x += b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + b.textBlock.width + 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y2 - b.textBlock.width - 3) : \"left\" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - b.textBlock.height > this.chart.plotArea.y1 ? y(k.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : y(k.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3, a.x = \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x2 - b.textBlock.width - 3) : \"right\" === this._position && (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - +b.textBlock.height > this.chart.plotArea.y1 ? y(k.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 - 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : y(k.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3, a.x = \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.x2 - b.textBlock.width - 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x1 + 3);b.textBlock.x = a.x;b.textBlock.y = a.y;m.push(b);\n          }\n        }if (!h) {\n          h = !1;this.ctx.save();this.ctx.beginPath();this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);this.ctx.clip();for (c = 0; c < l.length; c++) {\n            k = l[c], k.showOnTop ? g || (g = !0, this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n              this.ctx.save();this.ctx.beginPath();this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);this.ctx.clip();for (e = 0; e < l.length; e++) {\n                k = l[e], k.showOnTop && k.render();\n              }this.ctx.restore();\n            }, k)) : k.render();\n          }for (c = 0; c < m.length; c++) {\n            b = m[c], b.stripLine.showOnTop ? h || (h = !0, this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n              for (e = 0; e < m.length; e++) {\n                b = m[e], \"inside\" === b.stripLine.labelPlacement && b.stripLine.showOnTop && (f.ctx.save(), f.ctx.beginPath(), f.ctx.rect(f.chart.plotArea.x1, f.chart.plotArea.y1, f.chart.plotArea.width, f.chart.plotArea.height), f.ctx.clip(), b.textBlock.render(!0), f.ctx.restore());\n              }\n            }, b.textBlock)) : \"inside\" === b.stripLine.labelPlacement && b.textBlock.render(!0);\n          }this.ctx.restore();h = !0;\n        }if (h) for (h = !1, c = 0; c < m.length; c++) {\n          b = m[c], b.stripLine.showOnTop ? h || (h = !0, this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n            for (e = 0; e < m.length; e++) {\n              b = m[e], \"outside\" === b.stripLine.labelPlacement && b.stripLine.showOnTop && b.textBlock.render(!0);\n            }\n          }, b.textBlock)) : \"outside\" === b.stripLine.labelPlacement && b.textBlock.render(!0);\n        }\n      }\n    };C.prototype.renderBreaksBackground = function () {\n      this.chart._breaksCanvas && this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas && (this.chart._breaksCanvasCtx.save(), this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx.restore());\n    };C.prototype.createMask = function () {\n      if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) {\n        var a = this.scaleBreaks._appliedBreaks;v ? (this.maskCanvas = ua(this.chart.width, this.chart.height), this.maskCtx = this.maskCanvas.getContext(\"2d\")) : (this.maskCanvas = this.chart.plotArea.canvas, this.maskCtx = this.chart.plotArea.ctx);this.maskCtx.save();this.maskCtx.beginPath();this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);this.maskCtx.clip();for (var f = 0; f < a.length; f++) {\n          a[f].endValue < this.viewportMinimum || a[f].startValue > this.viewportMaximum || isNaN(this.range) || a[f].render(this.maskCtx);\n        }this.maskCtx.restore();\n      }\n    };C.prototype.renderCrosshair = function (a, f) {\n      this.crosshair.render(a, f);\n    };C.prototype.renderGrid = function () {\n      if (this.gridThickness && 0 < this.gridThickness) {\n        var a = this.chart.ctx;a.save();var f,\n            b = this.chart.plotArea;a.lineWidth = this.gridThickness;a.strokeStyle = this.gridColor;a.setLineDash && a.setLineDash(G(this.gridDashType, this.gridThickness));if (\"bottom\" === this._position || \"top\" === this._position) for (c = 0; c < this._labels.length; c++) {\n          this._labels[c].position < this.viewportMinimum || this._labels[c].position > this.viewportMaximum || this._labels[c].breaksLabelType || (a.beginPath(), f = this.getPixelCoordinatesOnAxis(this._labels[c].position), f = 1 === a.lineWidth % 2 ? (f.x << 0) + 0.5 : f.x << 0, a.moveTo(f, b.y1 << 0), a.lineTo(f, b.y2 << 0), a.stroke());\n        } else if (\"left\" === this._position || \"right\" === this._position) for (var c = 0; c < this._labels.length; c++) {\n          this._labels[c].position < this.viewportMinimum || this._labels[c].position > this.viewportMaximum || this._labels[c].breaksLabelType || (a.beginPath(), f = this.getPixelCoordinatesOnAxis(this._labels[c].position), f = 1 === a.lineWidth % 2 ? (f.y << 0) + 0.5 : f.y << 0, a.moveTo(b.x1 << 0, f), a.lineTo(b.x2 << 0, f), a.stroke());\n        }a.restore();\n      }\n    };C.prototype.renderAxisLine = function () {\n      var a = this.chart.ctx,\n          f = v ? this.chart._preRenderCtx : a,\n          b = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)),\n          c = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2)),\n          e,\n          g;f.save();if (\"bottom\" === this._position || \"top\" === this._position) {\n        if (this.lineThickness) {\n          this.reversed ? (e = this.lineCoordinates.x2, g = this.lineCoordinates.x1) : (e = this.lineCoordinates.x1, g = this.lineCoordinates.x2);f.lineWidth = this.lineThickness;f.strokeStyle = this.lineColor ? this.lineColor : \"black\";f.setLineDash && f.setLineDash(G(this.lineDashType, this.lineThickness));var h = 1 === this.lineThickness % 2 ? (this.lineCoordinates.y1 << 0) + 0.5 : this.lineCoordinates.y1 << 0;f.beginPath();if (this.scaleBreaks && !y(this.scaleBreaks.firstBreakIndex)) if (y(this.scaleBreaks.lastBreakIndex)) e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + c;else for (var l = this.scaleBreaks.firstBreakIndex; l <= this.scaleBreaks.lastBreakIndex; l++) {\n            f.moveTo(e, h), f.lineTo(this.scaleBreaks._appliedBreaks[l].startPixel + b, h), e = this.scaleBreaks._appliedBreaks[l].endPixel + c;\n          }e && (f.moveTo(e, h), f.lineTo(g, h));f.stroke();\n        }\n      } else if ((\"left\" === this._position || \"right\" === this._position) && this.lineThickness) {\n        this.reversed ? (e = this.lineCoordinates.y1, g = this.lineCoordinates.y2) : (e = this.lineCoordinates.y2, g = this.lineCoordinates.y1);f.lineWidth = this.lineThickness;f.strokeStyle = this.lineColor;f.setLineDash && f.setLineDash(G(this.lineDashType, this.lineThickness));h = 1 === this.lineThickness % 2 ? (this.lineCoordinates.x1 << 0) + 0.5 : this.lineCoordinates.x1 << 0;f.beginPath();if (this.scaleBreaks && !y(this.scaleBreaks.firstBreakIndex)) if (y(this.scaleBreaks.lastBreakIndex)) e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + b;else for (l = this.scaleBreaks.firstBreakIndex; l <= this.scaleBreaks.lastBreakIndex; l++) {\n          f.moveTo(h, e), f.lineTo(h, this.scaleBreaks._appliedBreaks[l].startPixel + c), e = this.scaleBreaks._appliedBreaks[l].endPixel + b;\n        }e && (f.moveTo(h, e), f.lineTo(h, g));f.stroke();\n      }v && (a.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), f.clearRect(0, 0, this.chart.width, this.chart.height));f.restore();\n    };C.prototype.getPixelCoordinatesOnAxis = function (a) {\n      var f = {};if (\"bottom\" === this._position || \"top\" === this._position) f.x = this.convertValueToPixel(a), f.y = this.lineCoordinates.y1;if (\"left\" === this._position || \"right\" === this._position) f.y = this.convertValueToPixel(a), f.x = this.lineCoordinates.x2;return f;\n    };C.prototype.convertPixelToValue = function (a) {\n      if (\"undefined\" === typeof a) return null;var f = 0,\n          b = 0,\n          c,\n          f = !0,\n          e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [],\n          b = \"number\" === typeof a ? a : \"left\" === this._position || \"right\" === this._position ? a.y : a.x;if (this.logarithmic) {\n        a = c = Math.pow(this.logarithmBase, (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit);if (b <= this.conversionParameters.reference === (\"left\" === this._position || \"right\" === this._position) !== this.reversed) for (b = 0; b < e.length; b++) {\n          if (!(e[b].endValue < this.conversionParameters.minimum)) if (f) {\n            if (e[b].startValue < this.conversionParameters.minimum) {\n              if (1 < e[b].size && this.conversionParameters.minimum * Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size)) < e[b].endValue) {\n                a = Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size));break;\n              } else a *= e[b].endValue / this.conversionParameters.minimum / Math.pow(e[b].size, Math.log(e[b].endValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue)), c /= Math.pow(e[b].size, Math.log(e[b].endValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue));f = !1;\n            } else if (c > e[b].startValue / this.conversionParameters.minimum) {\n              c /= e[b].startValue / this.conversionParameters.minimum;if (c < e[b].size) {\n                a *= Math.pow(e[b].endValue / e[b].startValue, 1 === e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) / c;break;\n              } else a *= e[b].endValue / e[b].startValue / e[b].size;c /= e[b].size;f = !1;\n            } else break;\n          } else if (c > e[b].startValue / e[b - 1].endValue) {\n            c /= e[b].startValue / e[b - 1].endValue;if (c < e[b].size) {\n              a *= Math.pow(e[b].endValue / e[b].startValue, 1 === e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) / c;break;\n            } else a *= e[b].endValue / e[b].startValue / e[b].size;c /= e[b].size;\n          } else break;\n        } else for (b = e.length - 1; 0 <= b; b--) {\n          if (!(e[b].startValue > this.conversionParameters.minimum)) if (f) {\n            if (e[b].endValue > this.conversionParameters.minimum) {\n              if (1 < e[b].size && this.conversionParameters.minimum * Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size)) > e[b].startValue) {\n                a = Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size));break;\n              } else a *= e[b].startValue / this.conversionParameters.minimum * Math.pow(e[b].size, Math.log(e[b].startValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue)) * c, c *= Math.pow(e[b].size, Math.log(this.conversionParameters.minimum / e[b].startValue) / Math.log(e[b].endValue / e[b].startValue));f = !1;\n            } else if (c < e[b].endValue / this.conversionParameters.minimum) {\n              c /= e[b].endValue / this.conversionParameters.minimum;if (c > 1 / e[b].size) {\n                a *= Math.pow(e[b].endValue / e[b].startValue, 1 >= e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) * c;break;\n              } else a /= e[b].endValue / e[b].startValue / e[b].size;c *= e[b].size;f = !1;\n            } else break;\n          } else if (c < e[b].endValue / e[b + 1].startValue) {\n            c /= e[b].endValue / e[b + 1].startValue;if (c > 1 / e[b].size) {\n              a *= Math.pow(e[b].endValue / e[b].startValue, 1 >= e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) * c;break;\n            } else a /= e[b].endValue / e[b].startValue / e[b].size;c *= e[b].size;\n          } else break;\n        }f = a * this.viewportMinimum;\n      } else {\n        a = c = (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;if (b <= this.conversionParameters.reference === (\"left\" === this._position || \"right\" === this._position) !== this.reversed) for (b = 0; b < e.length; b++) {\n          if (!(e[b].endValue < this.conversionParameters.minimum)) if (f) {\n            if (e[b].startValue < this.conversionParameters.minimum) {\n              if (e[b].size && this.conversionParameters.minimum + c * (e[b].endValue - e[b].startValue) / e[b].size < e[b].endValue) {\n                a = 0 >= e[b].size ? 0 : c * (e[b].endValue - e[b].startValue) / e[b].size;break;\n              } else a += e[b].endValue - this.conversionParameters.minimum - e[b].size * (e[b].endValue - this.conversionParameters.minimum) / (e[b].endValue - e[b].startValue), c -= e[b].size * (e[b].endValue - this.conversionParameters.minimum) / (e[b].endValue - e[b].startValue);f = !1;\n            } else if (c > e[b].startValue - this.conversionParameters.minimum) {\n              c -= e[b].startValue - this.conversionParameters.minimum;if (c < e[b].size) {\n                a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) - c;break;\n              } else a += e[b].endValue - e[b].startValue - e[b].size;c -= e[b].size;f = !1;\n            } else break;\n          } else if (c > e[b].startValue - e[b - 1].endValue) {\n            c -= e[b].startValue - e[b - 1].endValue;if (c < e[b].size) {\n              a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) - c;break;\n            } else a += e[b].endValue - e[b].startValue - e[b].size;c -= e[b].size;\n          } else break;\n        } else for (b = e.length - 1; 0 <= b; b--) {\n          if (!(e[b].startValue > this.conversionParameters.minimum)) if (f) {\n            if (e[b].endValue > this.conversionParameters.minimum) {\n              if (e[b].size && this.conversionParameters.minimum + c * (e[b].endValue - e[b].startValue) / e[b].size > e[b].startValue) {\n                a = 0 >= e[b].size ? 0 : c * (e[b].endValue - e[b].startValue) / e[b].size;break;\n              } else a += e[b].startValue - this.conversionParameters.minimum + e[b].size * (this.conversionParameters.minimum - e[b].startValue) / (e[b].endValue - e[b].startValue), c += e[b].size * (this.conversionParameters.minimum - e[b].startValue) / (e[b].endValue - e[b].startValue), f = !1;\n            } else if (c < e[b].endValue - this.conversionParameters.minimum) {\n              c -= e[b].endValue - this.conversionParameters.minimum;if (c > -1 * e[b].size) {\n                a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) + c;break;\n              } else a -= e[b].endValue - e[b].startValue - e[b].size;c += e[b].size;f = !1;\n            } else break;\n          } else if (c < e[b].endValue - e[b + 1].startValue) {\n            c -= e[b].endValue - e[b + 1].startValue;if (c > -1 * e[b].size) {\n              a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) + c;break;\n            } else a -= e[b].endValue - e[b].startValue - e[b].size;c += e[b].size;\n          } else break;\n        }f = this.conversionParameters.minimum + a;\n      }return f;\n    };C.prototype.convertValueToPixel = function (a) {\n      a = this.getApparentDifference(this.conversionParameters.minimum, a, a);return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + 0.5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5 << 0;\n    };C.prototype.getApparentDifference = function (a, f, b, c) {\n      var e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];if (this.logarithmic) {\n        b = y(b) ? f / a : b;for (var g = 0; g < e.length && !(f < e[g].startValue); g++) {\n          a > e[g].endValue || (a <= e[g].startValue && f >= e[g].endValue ? b = b / e[g].endValue * e[g].startValue * e[g].size : a >= e[g].startValue && f >= e[g].endValue ? b = b / e[g].endValue * a * Math.pow(e[g].size, Math.log(e[g].endValue / a) / Math.log(e[g].endValue / e[g].startValue)) : a <= e[g].startValue && f <= e[g].endValue ? b = b / f * e[g].startValue * Math.pow(e[g].size, Math.log(f / e[g].startValue) / Math.log(e[g].endValue / e[g].startValue)) : !c && a > e[g].startValue && f < e[g].endValue && (b = a * Math.pow(e[g].size, Math.log(f / a) / Math.log(e[g].endValue / e[g].startValue))));\n        }\n      } else for (b = y(b) ? Math.abs(f - a) : b, g = 0; g < e.length && !(f < e[g].startValue); g++) {\n        a > e[g].endValue || (a <= e[g].startValue && f >= e[g].endValue ? b = b - e[g].endValue + e[g].startValue + e[g].size : a > e[g].startValue && f >= e[g].endValue ? b = b - e[g].endValue + a + e[g].size * (e[g].endValue - a) / (e[g].endValue - e[g].startValue) : a <= e[g].startValue && f < e[g].endValue ? b = b - f + e[g].startValue + e[g].size * (f - e[g].startValue) / (e[g].endValue - e[g].startValue) : !c && a > e[g].startValue && f < e[g].endValue && (b = a + e[g].size * (f - a) / (e[g].endValue - e[g].startValue)));\n      }return b;\n    };C.prototype.setViewPortRange = function (a, f) {\n      this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a, f);this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(a, f);\n    };C.prototype.getXValueAt = function (a) {\n      if (!a) return null;var f = null;\"left\" === this._position ? f = this.convertPixelToValue(a.y) : \"bottom\" === this._position && (f = this.convertPixelToValue(a.x));return f;\n    };C.prototype.calculateValueToPixelConversionParameters = function (a) {\n      a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];var f = { pixelPerUnit: null, minimum: null, reference: null },\n          b = this.lineCoordinates.width,\n          c = this.lineCoordinates.height,\n          b = \"bottom\" === this._position || \"top\" === this._position ? b : c,\n          c = Math.abs(this.range);if (this.logarithmic) for (var e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++) {\n        this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <= a[e].endValue ? b = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c / a[e].endValue * a[e].startValue, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100) : b - Math.min(a[e].spacing, 0.1 * b)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c / a[e].endValue * this.viewportMinimum, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100 * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) : this.viewportMinimum <= a[e].startValue && this.viewportMaximum < a[e].endValue && (c = c / this.viewportMaximum * a[e].startValue, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100 * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)));\n      } else for (e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++) {\n        this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <= a[e].endValue ? b = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c - a[e].endValue + a[e].startValue, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100) : b - Math.min(a[e].spacing, 0.1 * b)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c - a[e].endValue + this.viewportMinimum, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100 * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : this.viewportMinimum <= a[e].startValue && this.viewportMaximum < a[e].endValue && (c = c - this.viewportMaximum + a[e].startValue, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100 * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)));\n      }f.minimum = this.viewportMinimum;f.maximum = this.viewportMaximum;f.range = c;if (\"bottom\" === this._position || \"top\" === this._position) this.logarithmic ? (f.lnLogarithmBase = Math.log(this.logarithmBase), f.pixelPerUnit = (this.reversed ? -1 : 1) * b * f.lnLogarithmBase / Math.log(Math.abs(c))) : f.pixelPerUnit = (this.reversed ? -1 : 1) * b / Math.abs(c), f.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1;if (\"left\" === this._position || \"right\" === this._position) this.logarithmic ? (f.lnLogarithmBase = Math.log(this.logarithmBase), f.pixelPerUnit = (this.reversed ? 1 : -1) * b * f.lnLogarithmBase / Math.log(Math.abs(c))) : f.pixelPerUnit = (this.reversed ? 1 : -1) * b / Math.abs(c), f.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2;this.conversionParameters = f;\n    };C.prototype.calculateAxisParameters = function () {\n      if (this.logarithmic) this.calculateLogarithmicAxisParameters();else {\n        var a = this.chart.layoutManager.getFreeSpace(),\n            f = !1,\n            b = !1;\"bottom\" === this._position || \"top\" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);var a = \"axisX\" === this.type ? \"xySwapped\" === this.chart.plotInfo.axisPlacement ? 62 : 70 : \"xySwapped\" === this.chart.plotInfo.axisPlacement ? 50 : 40,\n            c = 4;\"axisX\" === this.type && (c = 600 > this.maxWidth ? 8 : 6);var a = Math.max(c, Math.floor(this.maxWidth / a)),\n            e,\n            g,\n            h,\n            c = 0;!y(this.options.viewportMinimum) && !y(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum && (this.viewportMinimum = this.viewportMaximum = null);if (y(this.options.viewportMinimum) && !y(this.sessionVariables.newViewportMinimum) && !isNaN(this.sessionVariables.newViewportMinimum)) this.viewportMinimum = this.sessionVariables.newViewportMinimum;else if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = this.minimum;if (y(this.options.viewportMaximum) && !y(this.sessionVariables.newViewportMaximum) && !isNaN(this.sessionVariables.newViewportMaximum)) this.viewportMaximum = this.sessionVariables.newViewportMaximum;else if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum;if (this.scaleBreaks) for (c = 0; c < this.scaleBreaks._appliedBreaks.length; c++) {\n          if ((!y(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[c].startValue || !y(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[c].startValue || !y(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[c].startValue) && (!y(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[c].endValue || !y(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[c].endValue || !y(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[c].endValue)) {\n            this.scaleBreaks._appliedBreaks.splice(c, 1);break;\n          }\n        }if (\"axisX\" === this.type) {\n          if (this.dataSeries && 0 < this.dataSeries.length) for (e = 0; e < this.dataSeries.length; e++) {\n            \"dateTime\" === this.dataSeries[e].xValueType && (b = !0);\n          }e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin;g = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax;0 === g - e && (c = \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval, g += c, e -= c);Infinity !== this.dataInfo.minDiff ? h = this.dataInfo.minDiff : 1 < g - e ? h = 0.5 * Math.abs(g - e) : (h = 1, b && (f = !0));\n        } else \"axisY\" === this.type && (e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, g = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, isFinite(e) || isFinite(g) ? isFinite(e) ? isFinite(g) || (g = e) : e = g : (g = \"undefined\" === typeof this.options.interval ? -Infinity : this.options.interval, e = \"undefined\" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), 0 === e && 0 === g ? (g += 9, e = 0) : 0 === g - e ? (c = Math.min(Math.abs(0.01 * Math.abs(g)), 5), g += c, e -= c) : e > g ? (c = Math.min(0.01 * Math.abs(this.getApparentDifference(g, e, null, !0)), 5), 0 <= g ? e = g - c : g = isFinite(e) ? e + c : 0) : (c = Math.min(0.01 * Math.abs(this.getApparentDifference(e, g, null, !0)), 0.05), 0 !== g && (g += c), 0 !== e && (e -= c)), h = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < e && (e = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > g && (g = 0));c = this.getApparentDifference(isNaN(this.viewportMinimum) || null === this.viewportMinimum ? e : this.viewportMinimum, isNaN(this.viewportMaximum) || null === this.viewportMaximum ? g : this.viewportMaximum, null, !0);if (\"axisX\" === this.type && b) {\n          this.intervalType || (c / 1 <= a ? (this.interval = 1, this.intervalType = \"millisecond\") : c / 2 <= a ? (this.interval = 2, this.intervalType = \"millisecond\") : c / 5 <= a ? (this.interval = 5, this.intervalType = \"millisecond\") : c / 10 <= a ? (this.interval = 10, this.intervalType = \"millisecond\") : c / 20 <= a ? (this.interval = 20, this.intervalType = \"millisecond\") : c / 50 <= a ? (this.interval = 50, this.intervalType = \"millisecond\") : c / 100 <= a ? (this.interval = 100, this.intervalType = \"millisecond\") : c / 200 <= a ? (this.interval = 200, this.intervalType = \"millisecond\") : c / 250 <= a ? (this.interval = 250, this.intervalType = \"millisecond\") : c / 300 <= a ? (this.interval = 300, this.intervalType = \"millisecond\") : c / 400 <= a ? (this.interval = 400, this.intervalType = \"millisecond\") : c / 500 <= a ? (this.interval = 500, this.intervalType = \"millisecond\") : c / (1 * U.secondDuration) <= a ? (this.interval = 1, this.intervalType = \"second\") : c / (2 * U.secondDuration) <= a ? (this.interval = 2, this.intervalType = \"second\") : c / (5 * U.secondDuration) <= a ? (this.interval = 5, this.intervalType = \"second\") : c / (10 * U.secondDuration) <= a ? (this.interval = 10, this.intervalType = \"second\") : c / (15 * U.secondDuration) <= a ? (this.interval = 15, this.intervalType = \"second\") : c / (20 * U.secondDuration) <= a ? (this.interval = 20, this.intervalType = \"second\") : c / (30 * U.secondDuration) <= a ? (this.interval = 30, this.intervalType = \"second\") : c / (1 * U.minuteDuration) <= a ? (this.interval = 1, this.intervalType = \"minute\") : c / (2 * U.minuteDuration) <= a ? (this.interval = 2, this.intervalType = \"minute\") : c / (5 * U.minuteDuration) <= a ? (this.interval = 5, this.intervalType = \"minute\") : c / (10 * U.minuteDuration) <= a ? (this.interval = 10, this.intervalType = \"minute\") : c / (15 * U.minuteDuration) <= a ? (this.interval = 15, this.intervalType = \"minute\") : c / (20 * U.minuteDuration) <= a ? (this.interval = 20, this.intervalType = \"minute\") : c / (30 * U.minuteDuration) <= a ? (this.interval = 30, this.intervalType = \"minute\") : c / (1 * U.hourDuration) <= a ? (this.interval = 1, this.intervalType = \"hour\") : c / (2 * U.hourDuration) <= a ? (this.interval = 2, this.intervalType = \"hour\") : c / (3 * U.hourDuration) <= a ? (this.interval = 3, this.intervalType = \"hour\") : c / (6 * U.hourDuration) <= a ? (this.interval = 6, this.intervalType = \"hour\") : c / (1 * U.dayDuration) <= a ? (this.interval = 1, this.intervalType = \"day\") : c / (2 * U.dayDuration) <= a ? (this.interval = 2, this.intervalType = \"day\") : c / (4 * U.dayDuration) <= a ? (this.interval = 4, this.intervalType = \"day\") : c / (1 * U.weekDuration) <= a ? (this.interval = 1, this.intervalType = \"week\") : c / (2 * U.weekDuration) <= a ? (this.interval = 2, this.intervalType = \"week\") : c / (3 * U.weekDuration) <= a ? (this.interval = 3, this.intervalType = \"week\") : c / (1 * U.monthDuration) <= a ? (this.interval = 1, this.intervalType = \"month\") : c / (2 * U.monthDuration) <= a ? (this.interval = 2, this.intervalType = \"month\") : c / (3 * U.monthDuration) <= a ? (this.interval = 3, this.intervalType = \"month\") : c / (6 * U.monthDuration) <= a ? (this.interval = 6, this.intervalType = \"month\") : (this.interval = c / (1 * U.yearDuration) <= a ? 1 : c / (2 * U.yearDuration) <= a ? 2 : c / (4 * U.yearDuration) <= a ? 4 : Math.floor(C.getNiceNumber(c / (a - 1), !0) / U.yearDuration), this.intervalType = \"year\"));if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = e - h / 2;if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = g + h / 2;f ? this.autoValueFormatString = \"MMM DD YYYY HH:mm\" : \"year\" === this.intervalType ? this.autoValueFormatString = \"YYYY\" : \"month\" === this.intervalType ? this.autoValueFormatString = \"MMM YYYY\" : \"week\" === this.intervalType ? this.autoValueFormatString = \"MMM DD YYYY\" : \"day\" === this.intervalType ? this.autoValueFormatString = \"MMM DD YYYY\" : \"hour\" === this.intervalType ? this.autoValueFormatString = \"hh:mm TT\" : \"minute\" === this.intervalType ? this.autoValueFormatString = \"hh:mm TT\" : \"second\" === this.intervalType ? this.autoValueFormatString = \"hh:mm:ss TT\" : \"millisecond\" === this.intervalType && (this.autoValueFormatString = \"fff'ms'\");this.valueFormatString || (this.valueFormatString = this.autoValueFormatString);\n        } else {\n          this.intervalType = \"number\";c = C.getNiceNumber(c, !1);this.interval = this.options && 0 < this.options.interval ? this.options.interval : C.getNiceNumber(c / (a - 1), !0);if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = \"axisX\" === this.type ? e - h / 2 : Math.floor(e / this.interval) * this.interval;if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = \"axisX\" === this.type ? g + h / 2 : Math.ceil(g / this.interval) * this.interval;0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), this.options && \"undefined\" === typeof this.options.interval && (this.interval = C.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)));\n        }if (null === this.minimum || null === this.maximum) if (\"axisX\" === this.type ? (e = null !== this.minimum ? this.minimum : this.dataInfo.min, g = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 === g - e && (c = \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval, g += c, e -= c), h = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1) : \"axisY\" === this.type && (e = null !== this.minimum ? this.minimum : this.dataInfo.min, g = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(e) || isFinite(g) ? 0 === e && 0 === g ? (g += 9, e = 0) : 0 === g - e ? (c = Math.min(Math.abs(0.01 * Math.abs(g)), 5), g += c, e -= c) : e > g ? (c = Math.min(0.01 * Math.abs(this.getApparentDifference(g, e, null, !0)), 5), 0 <= g ? e = g - c : g = isFinite(e) ? e + c : 0) : (c = Math.min(0.01 * Math.abs(this.getApparentDifference(e, g, null, !0)), 0.05), 0 !== g && (g += c), 0 !== e && (e -= c)) : (g = \"undefined\" === typeof this.options.interval ? -Infinity : this.options.interval, e = \"undefined\" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), h = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < e && (e = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > g && (g = 0)), Math.abs(this.getApparentDifference(e, g, null, !0)), \"axisX\" === this.type && b) {\n          this.valueType = \"dateTime\";if (null === this.minimum || isNaN(this.minimum)) this.minimum = e - h / 2;if (null === this.maximum || isNaN(this.maximum)) this.maximum = g + h / 2;\n        } else this.intervalType = this.valueType = \"number\", null === this.minimum && (this.minimum = \"axisX\" === this.type ? e - h / 2 : Math.floor(e / this.interval) * this.interval, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = \"axisX\" === this.type ? g + h / 2 : Math.ceil(g / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 === this.options.maximum && (this.minimum -= 10));y(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));y(this.sessionVariables.newViewportMaximum) && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));\n        this.range = this.viewportMaximum - this.viewportMinimum;this.intervalStartPosition = \"axisX\" === this.type && b ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + 0.2 * this.interval) / this.interval) * this.interval;this.valueFormatString || (this.valueFormatString = C.generateValueFormatString(this.range, 2));\n      }\n    };C.prototype.calculateLogarithmicAxisParameters = function () {\n      var a = this.chart.layoutManager.getFreeSpace(),\n          f = Math.log(this.logarithmBase),\n          b;\n      \"bottom\" === this._position || \"top\" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);var a = \"axisX\" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3),\n          c,\n          e,\n          g,\n          h;h = 1;if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = this.minimum;if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum;if (this.scaleBreaks) for (h = 0; h < this.scaleBreaks._appliedBreaks.length; h++) {\n        if ((!y(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[h].startValue || !y(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[h].startValue || !y(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[h].startValue) && (!y(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[h].endValue || !y(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[h].endValue || !y(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[h].endValue)) {\n          this.scaleBreaks._appliedBreaks.splice(h, 1);break;\n        }\n      }\"axisX\" === this.type ? (c = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 1 === e / c && (h = Math.pow(this.logarithmBase, \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval), e *= h, c /= h), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : \"axisY\" === this.type && (c = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= c && !isFinite(e) ? (e = \"undefined\" === typeof this.options.interval ? 0 : this.options.interval, c = 1) : 0 >= c ? c = e : isFinite(e) || (e = c), 1 === c && 1 === e ? (e *= this.logarithmBase - 1 / this.logarithmBase, c = 1) : 1 === e / c ? (h = Math.min(e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), e *= h, c /= h) : c > e ? (h = Math.min(c / e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), 1 <= e ? c = e / h : e = c * h) : (h = Math.min(e / c * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= h), 1 !== c && (c /= h)), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < c && (c = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > e && (e = 1));h = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? c : this.viewportMinimum);linearRange = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? c : this.viewportMinimum);this.intervalType = \"number\";h = Math.pow(this.logarithmBase, C.getNiceNumber(Math.abs(Math.log(h) / f), !1));this.options && 0 < this.options.interval ? this.interval = this.options.interval : (this.interval = C.getNiceExponent(Math.log(h) / f / (a - 1), !0), b = C.getNiceNumber(linearRange / (a - 1), !0));if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = \"axisX\" === this.type ? c / Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(c) / f / this.interval));if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = \"axisX\" === this.type ? e * Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / f / this.interval));1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this.options && \"undefined\" === typeof this.options.interval && (this.interval = C.getNiceExponent(Math.ceil(Math.log(h) / f) / (a - 1)), b = C.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)));if (null === this.minimum || null === this.maximum) \"axisX\" === this.type ? (c = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 === e / c && (h = Math.pow(this.logarithmBase, \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval), e *= h, c /= h), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : \"axisY\" === this.type && (c = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(c) || isFinite(e) ? 1 === c && 1 === e ? (e *= this.logarithmBase, c /= this.logarithmBase) : 1 === e / c ? (h = Math.pow(this.logarithmBase, this.interval), e *= h, c /= h) : c > e ? (h = Math.min(0.01 * (c / e), 5), 1 <= e ? c = e / h : e = c * h) : (h = Math.min(e / c * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= h), 1 !== c && (c /= h)) : (e = \"undefined\" === typeof this.options.interval ? 0 : this.options.interval, c = 1), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < c && (c = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > e && (e = 1)), this.intervalType = \"number\", null === this.minimum && (this.minimum = \"axisX\" === this.type ? c / Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(c) / f / this.interval)), this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? \"undefined\" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = \"axisX\" === this.type ? e * Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / f / this.interval)), this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? \"undefined\" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum)), 1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase));this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum || this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum || this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum = (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum);c = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (f * this.interval) + 0.2) * this.interval);this.range = this.viewportMaximum / this.viewportMinimum;this.noTicks = a;if (!this.options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > a ? 2 : 3)) {\n        for (f = Math.floor(this.viewportMinimum / b + 0.5) * b; f < this.viewportMinimum;) {\n          f += b;\n        }this.equidistantInterval = !1;this.intervalStartPosition = f;this.interval = b;\n      } else this.options.interval || (b = Math.ceil(this.interval), this.range > this.interval && (this.interval = b, c = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (f * this.interval) + 0.2) * this.interval))), this.equidistantInterval = !0, this.intervalStartPosition = c;if (!this.valueFormatString && (this.valueFormatString = \"#,##0.##\", 1 > this.viewportMinimum)) {\n        f = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2;if (isNaN(f) || !isFinite(f)) f = 2;if (2 < f) for (h = 0; h < f - 2; h++) {\n          this.valueFormatString += \"#\";\n        }\n      }\n    };C.generateValueFormatString = function (a, f) {\n      var b = \"#,##0.\",\n          c = f;1 > a && (c += Math.floor(Math.abs(Math.log(a) / Math.LN10)), isNaN(c) || !isFinite(c)) && (c = f);for (var e = 0; e < c; e++) {\n        b += \"#\";\n      }return b;\n    };C.getNiceExponent = function (a, f) {\n      var b = Math.floor(Math.log(a) / Math.LN10),\n          c = a / Math.pow(10, b),\n          c = 0 > b ? 1 >= c ? 1 : 5 >= c ? 5 : 10 : Math.max(Math.floor(c), 1);return Number((c * Math.pow(10, b)).toFixed(20));\n    };C.getNiceNumber = function (a, f) {\n      var b = Math.floor(Math.log(a) / Math.LN10),\n          c = a / Math.pow(10, b);return Number(((f ? 1.5 > c ? 1 : 3 > c ? 2 : 7 > c ? 5 : 10 : 1 >= c ? 1 : 2 >= c ? 2 : 5 >= c ? 5 : 10) * Math.pow(10, b)).toFixed(20));\n    };C.prototype.getLabelStartPoint = function () {\n      var a = U[this.intervalType + \"Duration\"] * this.interval,\n          a = new Date(Math.floor(this.viewportMinimum / a) * a);if (\"millisecond\" !== this.intervalType) if (\"second\" === this.intervalType) 0 < a.getMilliseconds() && (a.setSeconds(a.getSeconds() + 1), a.setMilliseconds(0));else if (\"minute\" === this.intervalType) {\n        if (0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setMinutes(a.getMinutes() + 1), a.setSeconds(0), a.setMilliseconds(0);\n      } else if (\"hour\" === this.intervalType) {\n        if (0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setHours(a.getHours() + 1), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\n      } else if (\"day\" === this.intervalType) {\n        if (0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setDate(a.getDate() + 1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\n      } else if (\"week\" === this.intervalType) {\n        if (0 < a.getDay() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setDate(a.getDate() + (7 - a.getDay())), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\n      } else if (\"month\" === this.intervalType) {\n        if (1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setMonth(a.getMonth() + 1), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\n      } else \"year\" === this.intervalType && (0 < a.getMonth() || 1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setFullYear(a.getFullYear() + 1), a.setMonth(0), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0));return a;\n    };pa(P, X);pa(aa, X);aa.prototype.createUserOptions = function (a) {\n      if (\"undefined\" !== typeof a || this.options._isPlaceholder) {\n        var f = 0;this.parent.options._isPlaceholder && this.parent.createUserOptions();this.options._isPlaceholder || (Da(this.parent[this.optionsName]), f = this.parent.options[this.optionsName].indexOf(this.options));this.options = \"undefined\" === typeof a ? {} : a;this.parent.options[this.optionsName][f] = this.options;\n      }\n    };aa.prototype.render = function (a) {\n      if (0 !== this.spacing || 0 !== this.options.lineThickness && (\"undefined\" !== typeof this.options.lineThickness || 0 !== this.parent.lineThickness)) {\n        var f = this.ctx,\n            b = this.ctx.globalAlpha;this.ctx = a || this.ctx;this.ctx.save();this.ctx.beginPath();\n        this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);this.ctx.clip();var c = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue),\n            e = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue);this.ctx.strokeStyle = this.lineColor;this.ctx.fillStyle = this.color;this.ctx.beginPath();this.ctx.globalAlpha = 1;R(this.id);var g, h, l, m, k, r;a = Math.max(this.spacing, 3);var p = Math.max(0, this.lineThickness);this.ctx.lineWidth = p;this.ctx.setLineDash && this.ctx.setLineDash(G(this.lineDashType, p));if (\"bottom\" === this.scaleBreaks.parent._position || \"top\" === this.scaleBreaks.parent._position) {\n          if (c = 1 === p % 2 ? (c.x << 0) + 0.5 : c.x << 0, h = 1 === p % 2 ? (e.x << 0) + 0.5 : e.x << 0, \"top\" === this.scaleBreaks.parent._position ? (e = this.chart.plotArea.y1, l = this.chart.plotArea.y2 + p / 2 + 0.5 << 0) : (e = this.chart.plotArea.y2, l = this.chart.plotArea.y1 - p / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: c - p / 2, y1: e, x2: h + p / 2, y2: l }, this.ctx.moveTo(c, e), \"straight\" === this.type || \"top\" === this.scaleBreaks.parent._position && 0 >= a || \"bottom\" === this.scaleBreaks.parent._position && 0 <= a) this.ctx.lineTo(c, l), this.ctx.lineTo(h, l), this.ctx.lineTo(h, e);else if (\"wavy\" === this.type) {\n            m = c;k = e;g = 0.5;r = (l - k) / a / 3;for (var n = 0; n < r; n++) {\n              this.ctx.bezierCurveTo(m + g * a, k + a, m + g * a, k + 2 * a, m, k + 3 * a), k += 3 * a, g *= -1;\n            }this.ctx.bezierCurveTo(m + g * a, k + a, m + g * a, k + 2 * a, m, k + 3 * a);m = h;g *= -1;this.ctx.lineTo(m, k);for (n = 0; n < r; n++) {\n              this.ctx.bezierCurveTo(m + g * a, k - a, m + g * a, k - 2 * a, m, k - 3 * a), k -= 3 * a, g *= -1;\n            }\n          } else {\n            if (\"zigzag\" === this.type) {\n              g = -1;k = e + a;m = c + a;r = (l - k) / a / 2;for (n = 0; n < r; n++) {\n                this.ctx.lineTo(m, k), m += 2 * g * a, k += 2 * a, g *= -1;\n              }this.ctx.lineTo(m, k);m += h - c;for (n = 0; n < r + 1; n++) {\n                this.ctx.lineTo(m, k), m += 2 * g * a, k -= 2 * a, g *= -1;\n              }this.ctx.lineTo(m + g * a, k + a);\n            }\n          }\n        } else if (\"left\" === this.scaleBreaks.parent._position || \"right\" === this.scaleBreaks.parent._position) if (e = 1 === p % 2 ? (e.y << 0) + 0.5 : e.y << 0, l = 1 === p % 2 ? (c.y << 0) + 0.5 : c.y << 0, \"left\" === this.scaleBreaks.parent._position ? (c = this.chart.plotArea.x1, h = this.chart.plotArea.x2 + p / 2 + 0.5 << 0) : (c = this.chart.plotArea.x2, h = this.chart.plotArea.x1 - p / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: c, y1: e - p / 2, x2: h, y2: l + p / 2 }, this.ctx.moveTo(c, e), \"straight\" === this.type || \"left\" === this.scaleBreaks.parent._position && 0 >= a || \"right\" === this.scaleBreaks.parent._position && 0 <= a) this.ctx.lineTo(h, e), this.ctx.lineTo(h, l), this.ctx.lineTo(c, l);else if (\"wavy\" === this.type) {\n          m = c;k = e;g = 0.5;r = (h - m) / a / 3;for (n = 0; n < r; n++) {\n            this.ctx.bezierCurveTo(m + a, k + g * a, m + 2 * a, k + g * a, m + 3 * a, k), m += 3 * a, g *= -1;\n          }this.ctx.bezierCurveTo(m + a, k + g * a, m + 2 * a, k + g * a, m + 3 * a, k);k = l;g *= -1;this.ctx.lineTo(m, k);for (n = 0; n < r; n++) {\n            this.ctx.bezierCurveTo(m - a, k + g * a, m - 2 * a, k + g * a, m - 3 * a, k), m -= 3 * a, g *= -1;\n          }\n        } else if (\"zigzag\" === this.type) {\n          g = 1;k = e - a;m = c + a;r = (h - m) / a / 2;for (n = 0; n < r; n++) {\n            this.ctx.lineTo(m, k), k += 2 * g * a, m += 2 * a, g *= -1;\n          }this.ctx.lineTo(m, k);k += l - e;for (n = 0; n < r + 1; n++) {\n            this.ctx.lineTo(m, k), k += 2 * g * a, m -= 2 * a, g *= -1;\n          }this.ctx.lineTo(m + a, k + g * a);\n        }0 < p && this.ctx.stroke();this.ctx.closePath();this.ctx.globalAlpha = this.fillOpacity;this.ctx.globalCompositeOperation = \"destination-over\";this.ctx.fill();this.ctx.restore();this.ctx.globalAlpha = b;this.ctx = f;\n      }\n    };pa(ga, X);ga.prototype.createUserOptions = function (a) {\n      if (\"undefined\" !== typeof a || this.options._isPlaceholder) {\n        var f = 0;this.parent.options._isPlaceholder && this.parent.createUserOptions();this.options._isPlaceholder || (Da(this.parent.stripLines), f = this.parent.options.stripLines.indexOf(this.options));this.options = \"undefined\" === typeof a ? {} : a;this.parent.options.stripLines[f] = this.options;\n      }\n    };ga.prototype.render = function () {\n      this.ctx.save();var a = this.parent.getPixelCoordinatesOnAxis(this.value),\n          f = Math.abs(\"pixel\" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness);if (0 < f) {\n        var b = null === this.opacity ? 1 : this.opacity;this.ctx.strokeStyle = this.color;this.ctx.beginPath();var c = this.ctx.globalAlpha;this.ctx.globalAlpha = b;R(this.id);var e, g, h, l;this.ctx.lineWidth = f;this.ctx.setLineDash && this.ctx.setLineDash(G(this.lineDashType, f));if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) e = g = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, h = this.chart.plotArea.y1, l = this.chart.plotArea.y2, this.bounds = { x1: e - f / 2, y1: h, x2: g + f / 2, y2: l };else if (\"left\" === this.parent._position || \"right\" === this.parent._position) h = l = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, e = this.chart.plotArea.x1, g = this.chart.plotArea.x2, this.bounds = { x1: e, y1: h - f / 2, x2: g, y2: l + f / 2 };this.ctx.moveTo(e, h);this.ctx.lineTo(g, l);this.ctx.stroke();this.ctx.globalAlpha = c;\n      }this.ctx.restore();\n    };pa(ia, X);ia.prototype.render = function (a, f) {\n      var b,\n          c,\n          e,\n          g,\n          h = null,\n          l = h = null,\n          m = \"\";if (!this.valueFormatString) if (\"dateTime\" === this.parent.valueType) this.valueFormatString = this.parent.valueFormatString;else {\n        var k = 0,\n            k = \"xySwapped\" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0);this.valueFormatString = C.generateValueFormatString(this.parent.range, k);\n      }var l = null === this.opacity ? 1 : this.opacity,\n          k = Math.abs(\"pixel\" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness),\n          r = this.chart.overlaidCanvasCtx,\n          p = r.globalAlpha;r.globalAlpha = l;r.beginPath();r.strokeStyle = this.color;r.lineWidth = k;r.save();this.labelFontSize = y(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize;if (\"left\" === this.parent._position || \"right\" === this.parent._position) this.labelMaxWidth = y(this.options.labelMaxWidth) ? this.parent.bounds.x2 - this.parent.bounds.x1 : this.labelMaxWidth, this.labelMaxHeight = y(this.options.labelWrap) || this.labelWrap ? 3 * this.chart.height : 2 * this.labelFontSize;else if (\"top\" === this.parent._position || \"bottom\" === this.parent._position) this.labelMaxWidth = y(this.options.labelMaxWidth) ? 3 * this.chart.width : this.labelMaxWidth, this.labelMaxHeight = y(this.options.labelWrap) || this.labelWrap ? this.parent.bounds.height : 2 * this.labelFontSize;0 < k && r.setLineDash && r.setLineDash(G(this.lineDashType, k));l = new la(r, { x: 0, y: 0, padding: { top: 2, right: 3, bottom: 2, left: 4 },\n        backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, maxWidth: this.labelMaxWidth, maxHeight: this.labelMaxHeight, angle: this.labelAngle, text: m, horizontalAlign: \"left\", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: \"middle\" });if (this.snapToDataPoint) {\n        var n = 0,\n            h = [];if (\"xySwapped\" === this.chart.plotInfo.axisPlacement) {\n          var d = null;if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) n = this.parent.dataSeries[0].axisX.convertPixelToValue({ y: f });else if (\"left\" === this.parent._position || \"right\" === this.parent._position) n = this.parent.convertPixelToValue({ y: f });for (var q = 0; q < this.parent.dataSeries.length; q++) {\n            (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (d.dataSeries = this.parent.dataSeries[q], null !== d.dataPoint.y && h.push(d));\n          }d = null;if (0 === h.length) return;h.sort(function (a, b) {\n            return a.distance - b.distance;\n          });d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y));q = 0;if (\"rangeBar\" === h[0].dataSeries.type || \"error\" === h[0].dataSeries.type) for (var d = Math.abs(a - this.parent.convertValueToPixel(h[q].dataPoint.y[0])), s = 0, n = 0; n < h.length; n++) {\n            if (h[n].dataPoint.y && h[n].dataPoint.y.length) for (m = 0; m < h[n].dataPoint.y.length; m++) {\n              s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\n            } else s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y)), s < d && (d = s, q = n);\n          } else if (\"stackedBar\" === h[0].dataSeries.type) for (var d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y)), v = s = 0, n = q = 0; n < h.length; n++) {\n            if (h[n].dataPoint.y && h[n].dataPoint.y.length) for (m = 0; m < h[n].dataPoint.y.length; m++) {\n              s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\n            } else v += h[n].dataPoint.y, s = Math.abs(a - this.parent.convertValueToPixel(v)), s < d && (d = s, q = n);\n          } else if (\"stackedBar100\" === h[0].dataSeries.type) for (var d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y)), u = v = s = 0, n = 0; n < h.length; n++) {\n            if (h[n].dataPoint.y && h[n].dataPoint.y.length) for (m = 0; m < h[n].dataPoint.y.length; m++) {\n              s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\n            } else v += h[n].dataPoint.y, u = h[n].dataPoint.x.getTime ? h[n].dataPoint.x.getTime() : h[n].dataPoint.x, u = 100 * (v / h[n].dataSeries.plotUnit.dataPointYSums[u]), s = Math.abs(a - this.parent.convertValueToPixel(u)), s < d && (d = s, q = n);\n          } else for (d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y)), n = q = s = 0; n < h.length; n++) {\n            if (h[n].dataPoint.y && h[n].dataPoint.y.length) for (m = 0; m < h[n].dataPoint.y.length; m++) {\n              s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\n            } else s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y)), s < d && (d = s, q = n);\n          }m = h[q];if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) {\n            b = 0;if (\"rangeBar\" === this.parent.dataSeries[q].type || \"error\" === this.parent.dataSeries[q].type) {\n              d = Math.abs(a - this.parent.convertValueToPixel(m.dataPoint.y[0]));for (n = s = 0; n < m.dataPoint.y.length; n++) {\n                s = Math.abs(a - this.parent.convertValueToPixel(m.dataPoint.y[n])), s < d && (d = s, b = n);\n              }h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.y[b]) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.y[b]) << 0;l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.y[b] }) : y(this.options.label) ? W(m.dataPoint.y[b], this.valueFormatString, this.chart._cultureInfo) : this.label;\n            } else if (\"stackedBar\" === this.parent.dataSeries[q].type) {\n              d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y));v = s = 0;for (n = q; 0 <= n; n--) {\n                v += h[n].dataPoint.y, s = Math.abs(a - this.parent.convertValueToPixel(v)), s < d && (d = s, b = n);\n              }h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(v) << 0) + 0.5 : this.parent.convertValueToPixel(v) << 0;l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.y }) : y(this.options.label) ? W(m.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;\n            } else if (\"stackedBar100\" === this.parent.dataSeries[q].type) {\n              d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y));u = v = s = 0;for (n = q; 0 <= n; n--) {\n                v += h[n].dataPoint.y, u = h[n].dataPoint.x.getTime ? h[n].dataPoint.x.getTime() : h[n].dataPoint.x, u = 100 * (v / h[n].dataSeries.plotUnit.dataPointYSums[u]), s = Math.abs(a - this.parent.convertValueToPixel(u)), s < d && (d = s, b = n);\n              }h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(u) << 0) + 0.5 : this.parent.convertValueToPixel(u) << 0;l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options,\n                crosshair: this.options, value: u }) : y(this.options.label) ? W(u, this.valueFormatString, this.chart._cultureInfo) : this.label;\n            } else h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.y) << 0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.y }) : y(this.options.label) ? W(m.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;b = c = h;e = this.chart.plotArea.y1;\n            g = this.chart.plotArea.y2;this.bounds = { x1: b - k / 2, y1: e, x2: c + k / 2, y2: g };l.x = b - l.measureText().width / 2;l.x + l.width > this.chart.bounds.x2 ? l.x = this.chart.bounds.x2 - l.width : l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2;\n          } else if (\"left\" === this.parent._position || \"right\" === this.parent._position) {\n            e = g = h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.x) << 0;b = this.chart.plotArea.x1;c = this.chart.plotArea.x2;\n            this.bounds = { x1: b, y1: e - k / 2, x2: c, y2: g + k / 2 };u = !1;if (this.parent.labels) for (h = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += h) {\n              if (this.parent.labels[n]) u = !0;else {\n                u = !1;break;\n              }\n            }if (u) {\n              if (\"axisX\" === this.parent.type) for (n = this.parent.convertPixelToValue({ y: f }), d = null, q = 0; q < this.parent.dataSeries.length; q++) {\n                (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.x }) : y(this.options.label) ? d.dataPoint.label : this.label);\n              }\n            } else \"dateTime\" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.x }) : y(this.options.label) ? Ba(m.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : \"number\" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.x }) : y(this.options.label) ? W(m.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label);l.y = g + l.fontSize / 2 - l.measureText().height / 2 + 2;l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);\"left\" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : \"right\" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);\n          }\n        } else if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) {\n          n = this.parent.convertPixelToValue({ x: a });for (q = 0; q < this.parent.dataSeries.length; q++) {\n            (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (d.dataSeries = this.parent.dataSeries[q], null !== d.dataPoint.y && h.push(d));\n          }if (0 === h.length) return;h.sort(function (a, b) {\n            return a.distance - b.distance;\n          });m = h[0];b = c = h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.x) << 0;e = this.chart.plotArea.y1;\n          g = this.chart.plotArea.y2;this.bounds = { x1: b - k / 2, y1: e, x2: c + k / 2, y2: g };u = !1;if (this.parent.labels) for (h = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += h) {\n            if (this.parent.labels[n]) u = !0;else {\n              u = !1;break;\n            }\n          }if (u) {\n            if (\"axisX\" === this.parent.type) for (n = this.parent.convertPixelToValue({ x: a }), d = null, q = 0; q < this.parent.dataSeries.length; q++) {\n              (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options,\n                crosshair: this.options, value: m.dataPoint.x }) : y(this.options.label) ? d.dataPoint.label : this.label);\n            }\n          } else \"dateTime\" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.x }) : y(this.options.label) ? Ba(m.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : \"number\" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options,\n            value: m.dataPoint.x }) : y(this.options.label) ? W(m.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label);l.x = b - l.measureText().width / 2;l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width);l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);\"bottom\" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2 : \"top\" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2);\n        } else if (\"left\" === this.parent._position || \"right\" === this.parent._position) {\n          !y(this.parent.dataSeries) && 0 < this.parent.dataSeries.length && (n = this.parent.dataSeries[0].axisX.convertPixelToValue({ x: a }));for (q = 0; q < this.parent.dataSeries.length; q++) {\n            (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (d.dataSeries = this.parent.dataSeries[q], null !== d.dataPoint.y && h.push(d));\n          }if (0 === h.length) return;h.sort(function (a, b) {\n            return a.distance - b.distance;\n          });q = 0;if (\"rangeColumn\" === h[0].dataSeries.type || \"rangeArea\" === h[0].dataSeries.type || \"error\" === h[0].dataSeries.type || \"rangeSplineArea\" === h[0].dataSeries.type || \"candlestick\" === h[0].dataSeries.type || \"ohlc\" === h[0].dataSeries.type || \"boxAndWhisker\" === h[0].dataSeries.type) for (d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y[0])), n = s = 0; n < h.length; n++) {\n            if (h[n].dataPoint.y && h[n].dataPoint.y.length) for (m = 0; m < h[n].dataPoint.y.length; m++) {\n              s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\n            } else s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y)), s < d && (d = s, q = n);\n          } else if (\"stackedColumn\" === h[0].dataSeries.type || \"stackedArea\" === h[0].dataSeries.type) for (d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y)), n = v = s = 0; n < h.length; n++) {\n            if (h[n].dataPoint.y && h[n].dataPoint.y.length) for (m = 0; m < h[n].dataPoint.y.length; m++) {\n              s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\n            } else v += h[n].dataPoint.y, s = Math.abs(f - this.parent.convertValueToPixel(v)), s < d && (d = s, q = n);\n          } else if (\"stackedColumn100\" === h[0].dataSeries.type || \"stackedArea100\" === h[0].dataSeries.type) for (d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y)), n = u = v = s = 0; n < h.length; n++) {\n            if (h[n].dataPoint.y && h[n].dataPoint.y.length) for (m = 0; m < h[n].dataPoint.y.length; m++) {\n              s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\n            } else v += h[n].dataPoint.y, u = h[n].dataPoint.x.getTime ? h[n].dataPoint.x.getTime() : h[n].dataPoint.x, u = 100 * (v / h[n].dataSeries.plotUnit.dataPointYSums[u]), s = Math.abs(f - this.parent.convertValueToPixel(u)), s < d && (d = s, q = n);\n          } else for (d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y)), n = s = 0; n < h.length; n++) {\n            if (h[n].dataPoint.y && h[n].dataPoint.y.length) for (m = 0; m < h[n].dataPoint.y.length; m++) {\n              s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\n            } else s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y)), s < d && (d = s, q = n);\n          }m = h[q];b = 0;if (\"rangeColumn\" === this.parent.dataSeries[q].type || \"rangeArea\" === this.parent.dataSeries[q].type || \"error\" === this.parent.dataSeries[q].type || \"rangeSplineArea\" === this.parent.dataSeries[q].type || \"candlestick\" === this.parent.dataSeries[q].type || \"ohlc\" === this.parent.dataSeries[q].type || \"boxAndWhisker\" === this.parent.dataSeries[q].type) {\n            d = Math.abs(f - this.parent.convertValueToPixel(m.dataPoint.y[0]));for (n = s = 0; n < m.dataPoint.y.length; n++) {\n              s = Math.abs(f - this.parent.convertValueToPixel(m.dataPoint.y[n])), s < d && (d = s, b = n);\n            }h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.y[b]) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.y[b]) << 0;l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.y[b] }) : y(this.options.label) ? W(m.dataPoint.y[b], this.valueFormatString, this.chart._cultureInfo) : this.label;\n          } else if (\"stackedColumn\" === this.parent.dataSeries[q].type || \"stackedArea\" === this.parent.dataSeries[q].type) {\n            d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y));v = s = 0;for (n = q; 0 <= n; n--) {\n              v += h[n].dataPoint.y, s = Math.abs(f - this.parent.convertValueToPixel(v)), s < d && (d = s, b = n);\n            }h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(v) << 0) + 0.5 : this.parent.convertValueToPixel(v) << 0;l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart,\n              axis: this.parent.options, crosshair: this.options, value: m.dataPoint.y }) : y(this.options.label) ? W(m.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;\n          } else if (\"stackedColumn100\" === this.parent.dataSeries[q].type || \"stackedArea100\" === this.parent.dataSeries[q].type) {\n            d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y));v = s = 0;for (n = q; 0 <= n; n--) {\n              v += h[n].dataPoint.y, u = h[n].dataPoint.x.getTime ? h[n].dataPoint.x.getTime() : h[n].dataPoint.x, u = 100 * (v / h[n].dataSeries.plotUnit.dataPointYSums[u]), s = Math.abs(f - this.parent.convertValueToPixel(u)), s < d && (d = s, b = n);\n            }h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(u) << 0) + 0.5 : this.parent.convertValueToPixel(u) << 0;l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: u }) : y(this.options.label) ? W(u, this.valueFormatString, this.chart._cultureInfo) : this.label;\n          } else \"waterfall\" === this.parent.dataSeries[q].type ? (h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataSeries.dataPointEOs[m.index].cumulativeSum) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataSeries.dataPointEOs[m.index].cumulativeSum) << 0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataSeries.dataPointEOs[m.index].cumulativeSum }) : y(this.options.label) ? W(m.dataSeries.dataPointEOs[m.index].cumulativeSum, this.valueFormatString, this.chart._cultureInfo) : this.label) : (h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.y) << 0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.y }) : y(this.options.label) ? W(m.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label);e = g = h;b = this.chart.plotArea.x1;c = this.chart.plotArea.x2;this.bounds = { x1: b, y1: e - k / 2, x2: c, y2: g + k / 2 };l.y = g + l.fontSize / 2 - l.measureText().height / 2 + 2;l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);\"left\" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : \"right\" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);\n        }h = null;(\"bottom\" === this.parent._position || \"top\" === this.parent._position) && b >= this.parent.convertValueToPixel(this.parent.viewportMinimum) && c <= this.parent.convertValueToPixel(this.parent.viewportMaximum) && (0 < k && (r.moveTo(b, e), r.lineTo(c, g), r.stroke()), r.restore(), !y(l.text) && (\"number\" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0));(\"left\" === this.parent._position || \"right\" === this.parent._position) && g >= this.parent.convertValueToPixel(this.parent.viewportMaximum) && e <= this.parent.convertValueToPixel(this.parent.viewportMinimum) && (0 < k && (r.moveTo(b, e), r.lineTo(c, g), r.stroke()), r.restore(), !y(l.text) && (\"number\" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0));\n      } else {\n        if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) b = c = h = 1 === r.lineWidth % 2 ? (a << 0) + 0.5 : a << 0, e = this.chart.plotArea.y1, g = this.chart.plotArea.y2, this.bounds = { x1: b - k / 2, y1: e, x2: c + k / 2, y2: g };else if (\"left\" === this.parent._position || \"right\" === this.parent._position) e = g = h = 1 === r.lineWidth % 2 ? (f << 0) + 0.5 : f << 0, b = this.chart.plotArea.x1, c = this.chart.plotArea.x2, this.bounds = { x1: b, y1: e - k / 2, x2: c, y2: g + k / 2 };if (\"xySwapped\" === this.chart.plotInfo.axisPlacement) {\n          if (\"left\" === this.parent._position || \"right\" === this.parent._position) {\n            u = !1;if (this.parent.labels) for (h = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += h) {\n              if (this.parent.labels[n]) u = !0;else {\n                u = !1;break;\n              }\n            }if (u) {\n              if (\"axisX\" === this.parent.type) for (n = this.parent.convertPixelToValue({ y: f }), d = null, q = 0; q < this.parent.dataSeries.length; q++) {\n                (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : y(this.options.label) ? d.dataPoint.label : this.label);\n              }\n            } else \"dateTime\" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(f) }) : y(this.options.label) ? Ba(this.parent.convertPixelToValue(f), this.valueFormatString, this.chart._cultureInfo) : this.label : \"number\" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(f) }) : y(this.options.label) ? W(this.parent.convertPixelToValue(f), this.valueFormatString, this.chart._cultureInfo) : this.label);l.y = f + l.fontSize / 2 - l.measureText().height / 2 + 2;l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);\"left\" === this.parent._position ? l.x = this.parent.lineCoordinates.x1 - l.measureText().width : \"right\" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);\n          } else {\n            if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : y(this.options.label) ? W(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label, l.x = b - l.measureText().width / 2, l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width), l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1), \"bottom\" === this.parent._position && (l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2), \"top\" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2);\n          }\n        } else if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) {\n          u = !1;m = \"\";if (this.parent.labels) for (h = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += h) {\n            if (this.parent.labels[n]) u = !0;else {\n              u = !1;break;\n            }\n          }if (u) {\n            if (\"axisX\" === this.parent.type) for (n = this.parent.convertPixelToValue({ x: a }), d = null, q = 0; q < this.parent.dataSeries.length; q++) {\n              (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : y(this.options.label) ? d.dataPoint.label : this.label);\n            }\n          } else \"dateTime\" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : y(this.options.label) ? Ba(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label : \"number\" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(a) : \"\" }) : y(this.options.label) ? W(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label);l.x = b - l.measureText().width / 2;l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width);l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);\n          \"bottom\" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2 : \"top\" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2);\n        } else if (\"left\" === this.parent._position || \"right\" === this.parent._position) l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(f) }) : y(this.options.label) ? W(this.parent.convertPixelToValue(f), this.valueFormatString, this.chart._cultureInfo) : this.label, l.y = f + l.fontSize / 2 - l.measureText().height / 2 + 2, l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2), \"left\" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : \"right\" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);0 < k && (r.moveTo(b, e), r.lineTo(c, g), r.stroke());r.restore();!y(l.text) && (\"number\" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0);\n      }r.globalAlpha = p;\n    };pa(Y, X);Y.prototype._initialize = function () {\n      if (this.enabled) {\n        this.container = document.createElement(\"div\");this.container.setAttribute(\"class\", \"canvasjs-chart-tooltip\");this.container.style.position = \"absolute\";this.container.style.height = \"auto\";this.container.style.boxShadow = \"1px 1px 2px 2px rgba(0,0,0,0.1)\";this.container.style.zIndex = \"1000\";this.container.style.pointerEvents = \"none\";this.container.style.display = \"none\";var a;a = '<div style=\" width: auto;height: auto;min-width: 50px;';\n        a += \"line-height: auto;\";a += \"margin: 0px 0px 0px 0px;\";a += \"padding: 5px;\";a += \"font-family: Calibri, Arial, Georgia, serif;\";a += \"font-weight: normal;\";a += \"font-style: \" + (v ? \"italic;\" : \"normal;\");a += \"font-size: 14px;\";a += \"color: #000000;\";a += \"text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);\";a += \"text-align: left;\";a += \"border: 2px solid gray;\";a += v ? \"background: rgba(255,255,255,.9);\" : \"background: rgb(255,255,255);\";a += \"text-indent: 0px;\";a += \"white-space: nowrap;\";a += \"border-radius: 5px;\";a += \"-moz-user-select:none;\";\n        a += \"-khtml-user-select: none;\";a += \"-webkit-user-select: none;\";a += \"-ms-user-select: none;\";a += \"user-select: none;\";v || (a += \"filter: alpha(opacity = 90);\", a += \"filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666');\");a += '} \"> Sample Tooltip</div>';this.container.innerHTML = a;this.contentDiv = this.container.firstChild;this.container.style.borderRadius = this.contentDiv.style.borderRadius;this.chart._canvasJSContainer.appendChild(this.container);\n      }\n    };Y.prototype.mouseMoveHandler = function (a, f) {\n      this._lastUpdated && 4 > new Date().getTime() - this._lastUpdated || (this._lastUpdated = new Date().getTime(), this.chart.resetOverlayedCanvas(), this._updateToolTip(a, f));\n    };Y.prototype._updateToolTip = function (a, f, b) {\n      b = \"undefined\" === typeof b ? !0 : b;this.container || this._initialize();this.enabled || this.hide();if (!this.chart.disableToolTip) {\n        if (\"undefined\" === typeof a || \"undefined\" === typeof f) {\n          if (isNaN(this._prevX) || isNaN(this._prevY)) return;a = this._prevX;f = this._prevY;\n        } else this._prevX = a, this._prevY = f;\n        var c = null,\n            e = null,\n            g = [],\n            h = 0;if (this.shared && this.enabled && \"none\" !== this.chart.plotInfo.axisPlacement) {\n          if (\"xySwapped\" === this.chart.plotInfo.axisPlacement) {\n            var l = [];if (this.chart.axisX) for (var m = 0; m < this.chart.axisX.length; m++) {\n              for (var h = this.chart.axisX[m].convertPixelToValue({ y: f }), k = null, c = 0; c < this.chart.axisX[m].dataSeries.length; c++) {\n                (k = this.chart.axisX[m].dataSeries[c].getDataPointAtX(h, b)) && 0 <= k.index && (k.dataSeries = this.chart.axisX[m].dataSeries[c], null !== k.dataPoint.y && l.push(k));\n              }k = null;\n            }if (this.chart.axisX2) for (m = 0; m < this.chart.axisX2.length; m++) {\n              h = this.chart.axisX2[m].convertPixelToValue({ y: f });k = null;for (c = 0; c < this.chart.axisX2[m].dataSeries.length; c++) {\n                (k = this.chart.axisX2[m].dataSeries[c].getDataPointAtX(h, b)) && 0 <= k.index && (k.dataSeries = this.chart.axisX2[m].dataSeries[c], null !== k.dataPoint.y && l.push(k));\n              }k = null;\n            }\n          } else {\n            l = [];if (this.chart.axisX) for (m = 0; m < this.chart.axisX.length; m++) {\n              for (h = this.chart.axisX[m].convertPixelToValue({ x: a }), k = null, c = 0; c < this.chart.axisX[m].dataSeries.length; c++) {\n                (k = this.chart.axisX[m].dataSeries[c].getDataPointAtX(h, b)) && 0 <= k.index && (k.dataSeries = this.chart.axisX[m].dataSeries[c], null !== k.dataPoint.y && l.push(k));\n              }\n            }if (this.chart.axisX2) for (m = 0; m < this.chart.axisX2.length; m++) {\n              for (h = this.chart.axisX2[m].convertPixelToValue({ x: a }), k = null, c = 0; c < this.chart.axisX2[m].dataSeries.length; c++) {\n                (k = this.chart.axisX2[m].dataSeries[c].getDataPointAtX(h, b)) && 0 <= k.index && (k.dataSeries = this.chart.axisX2[m].dataSeries[c], null !== k.dataPoint.y && l.push(k));\n              }\n            }\n          }if (0 === l.length) return;l.sort(function (a, b) {\n            return a.distance - b.distance;\n          });b = l[0];\n          for (c = 0; c < l.length; c++) {\n            l[c].dataPoint.x.valueOf() === b.dataPoint.x.valueOf() && g.push(l[c]);\n          }l = null;\n        } else {\n          if (k = this.chart.getDataPointAtXY(a, f, b)) this.currentDataPointIndex = k.dataPointIndex, this.currentSeriesIndex = k.dataSeries.index;else if (v) {\n            if (k = Wa(a, f, this.chart._eventManager.ghostCtx), 0 < k && \"undefined\" !== typeof this.chart._eventManager.objectMap[k]) {\n              k = this.chart._eventManager.objectMap[k];if (\"legendItem\" === k.objectType) return;this.currentSeriesIndex = k.dataSeriesIndex;this.currentDataPointIndex = 0 <= k.dataPointIndex ? k.dataPointIndex : -1;\n            } else this.currentDataPointIndex = -1;\n          } else this.currentDataPointIndex = -1;if (0 <= this.currentSeriesIndex) {\n            e = this.chart.data[this.currentSeriesIndex];k = {};if (0 <= this.currentDataPointIndex) c = e.dataPoints[this.currentDataPointIndex], k.dataSeries = e, k.dataPoint = c, k.index = this.currentDataPointIndex, k.distance = Math.abs(c.x - h), \"waterfall\" === e.type && (k.cumulativeSumYStartValue = e.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, k.cumulativeSum = e.dataPointEOs[this.currentDataPointIndex].cumulativeSum);else {\n              if (!this.enabled || \"line\" !== e.type && \"stepLine\" !== e.type && \"spline\" !== e.type && \"area\" !== e.type && \"stepArea\" !== e.type && \"splineArea\" !== e.type && \"stackedArea\" !== e.type && \"stackedArea100\" !== e.type && \"rangeArea\" !== e.type && \"rangeSplineArea\" !== e.type && \"candlestick\" !== e.type && \"ohlc\" !== e.type && \"boxAndWhisker\" !== e.type) return;h = e.axisX.convertPixelToValue({ x: a });k = e.getDataPointAtX(h, b);k.dataSeries = e;this.currentDataPointIndex = k.index;c = k.dataPoint;\n            }if (!y(k.dataPoint.y)) if (k.dataSeries.axisY) {\n              if (0 < k.dataPoint.y.length) {\n                for (c = b = 0; c < k.dataPoint.y.length; c++) {\n                  k.dataPoint.y[c] < k.dataSeries.axisY.viewportMinimum ? b-- : k.dataPoint.y[c] > k.dataSeries.axisY.viewportMaximum && b++;\n                }b < k.dataPoint.y.length && b > -k.dataPoint.y.length && g.push(k);\n              } else \"column\" === e.type || \"bar\" === e.type ? 0 > k.dataPoint.y ? 0 > k.dataSeries.axisY.viewportMinimum && k.dataSeries.axisY.viewportMaximum >= k.dataPoint.y && g.push(k) : k.dataSeries.axisY.viewportMinimum <= k.dataPoint.y && 0 <= k.dataSeries.axisY.viewportMaximum && g.push(k) : \"bubble\" === e.type ? (b = this.chart._eventManager.objectMap[e.dataPointIds[k.index]].size / 2, k.dataPoint.y >= k.dataSeries.axisY.viewportMinimum - b && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum + b && g.push(k)) : \"waterfall\" === e.type ? (b = 0, k.cumulativeSumYStartValue < k.dataSeries.axisY.viewportMinimum ? b-- : k.cumulativeSumYStartValue > k.dataSeries.axisY.viewportMaximum && b++, k.cumulativeSum < k.dataSeries.axisY.viewportMinimum ? b-- : k.cumulativeSum > k.dataSeries.axisY.viewportMaximum && b++, 2 > b && -2 < b && g.push(k)) : (0 <= k.dataSeries.type.indexOf(\"100\") || \"stackedColumn\" === e.type || \"stackedBar\" === e.type || k.dataPoint.y >= k.dataSeries.axisY.viewportMinimum && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum) && g.push(k);\n            } else g.push(k);\n          }\n        }if (0 < g.length && (this.highlightObjects(g), this.enabled)) if (b = \"\", b = this.getToolTipInnerHTML({ entries: g }), null !== b) {\n          this.contentDiv.innerHTML = b;b = !1;\"none\" === this.container.style.display && (b = !0, this.container.style.display = \"block\");try {\n            this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : v ? \"rgba(255,255,255,.9)\" : \"rgb(255,255,255)\", this.borderColor = \"waterfall\" === g[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : -1 < g[0].dataPoint.y ? g[0].dataSeries.risingColor : g[0].dataSeries.fallingColor : \"error\" === g[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataSeries.color ? g[0].dataSeries.color : g[0].dataSeries._colorSet[e.index % g[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : g[0].dataSeries.color ? g[0].dataSeries.color : g[0].dataSeries._colorSet[g[0].index % g[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + \"px\" : \"2px\", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + \"px\" : \"5px\", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + \"px\" : \"14px\", this.contentDiv.style.color = this.fontColor ? this.fontColor : \"#000000\", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : \"Calibri, Arial, Georgia, serif;\", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : \"normal\", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : v ? \"italic\" : \"normal\";\n          } catch (q) {}\"pie\" === g[0].dataSeries.type || \"doughnut\" === g[0].dataSeries.type || \"funnel\" === g[0].dataSeries.type || \"pyramid\" === g[0].dataSeries.type || \"bar\" === g[0].dataSeries.type || \"rangeBar\" === g[0].dataSeries.type || \"stackedBar\" === g[0].dataSeries.type || \"stackedBar100\" === g[0].dataSeries.type ? a = a - 10 - this.container.clientWidth : (a = g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) - this.container.clientWidth << 0, a -= 10);0 > a && (a += this.container.clientWidth + 20);a + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (a = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));f = 1 !== g.length || this.shared || \"line\" !== g[0].dataSeries.type && \"stepLine\" !== g[0].dataSeries.type && \"spline\" !== g[0].dataSeries.type && \"area\" !== g[0].dataSeries.type && \"stepArea\" !== g[0].dataSeries.type && \"splineArea\" !== g[0].dataSeries.type ? \"bar\" === g[0].dataSeries.type || \"rangeBar\" === g[0].dataSeries.type || \"stackedBar\" === g[0].dataSeries.type || \"stackedBar100\" === g[0].dataSeries.type ? g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) : f : g[0].dataSeries.axisY.convertValueToPixel(g[0].dataPoint.y);f = -f + 10;0 < f + this.container.clientHeight + 5 && (f -= f + this.container.clientHeight + 5 - 0);this.fixMozTransitionDelay(a, f);!this.animationEnabled || b ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);this.container.style.left = a + \"px\";this.container.style.bottom = f + \"px\";\n        } else this.hide(!1);\n      }\n    };\n    Y.prototype.highlightObjects = function (a) {\n      var f = this.chart.overlaidCanvasCtx;this.chart.resetOverlayedCanvas();f.clearRect(0, 0, this.chart.width, this.chart.height);f.save();var b = this.chart.plotArea,\n          c = 0;f.beginPath();f.rect(b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1);f.clip();for (b = 0; b < a.length; b++) {\n        var e = a[b];if ((e = this.chart._eventManager.objectMap[e.dataSeries.dataPointIds[e.index]]) && e.objectType && \"dataPoint\" === e.objectType) {\n          var c = this.chart.data[e.dataSeriesIndex],\n              g = c.dataPoints[e.dataPointIndex],\n              h = e.dataPointIndex;\n          !1 === g.highlightEnabled || !0 !== c.highlightEnabled && !0 !== g.highlightEnabled || (\"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"scatter\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"stackedArea\" === c.type || \"stackedArea100\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type ? (g = c.getMarkerProperties(h, e.x1, e.y1, this.chart.overlaidCanvasCtx), g.size = Math.max(1.5 * g.size << 0, 10), g.borderColor = g.borderColor || \"#FFFFFF\", g.borderThickness = g.borderThickness || Math.ceil(0.1 * g.size), ja.drawMarkers([g]), \"undefined\" !== typeof e.y2 && (g = c.getMarkerProperties(h, e.x1, e.y2, this.chart.overlaidCanvasCtx), g.size = Math.max(1.5 * g.size << 0, 10), g.borderColor = g.borderColor || \"#FFFFFF\", g.borderThickness = g.borderThickness || Math.ceil(0.1 * g.size), ja.drawMarkers([g]))) : \"bubble\" === c.type ? (g = c.getMarkerProperties(h, e.x1, e.y1, this.chart.overlaidCanvasCtx), g.size = e.size, g.color = \"white\", g.borderColor = \"white\", f.globalAlpha = 0.3, ja.drawMarkers([g]), f.globalAlpha = 1) : \"column\" === c.type || \"stackedColumn\" === c.type || \"stackedColumn100\" === c.type || \"bar\" === c.type || \"rangeBar\" === c.type || \"stackedBar\" === c.type || \"stackedBar100\" === c.type || \"rangeColumn\" === c.type || \"waterfall\" === c.type ? V(f, e.x1, e.y1, e.x2, e.y2, \"white\", 0, null, !1, !1, !1, !1, 0.3) : \"pie\" === c.type || \"doughnut\" === c.type ? ra(f, e.center, e.radius, \"white\", c.type, e.startAngle, e.endAngle, 0.3, e.percentInnerRadius) : \"funnel\" === c.type || \"pyramid\" === c.type ? sa(f, e.funnelSection, 0.3, \"white\") : \"candlestick\" === c.type ? (f.globalAlpha = 1, f.strokeStyle = e.color, f.lineWidth = 2 * e.borderThickness, c = 0 === f.lineWidth % 2 ? 0 : 0.5, f.beginPath(), f.moveTo(e.x3 - c, Math.min(e.y2, e.y3)), f.lineTo(e.x3 - c, Math.min(e.y1, e.y4)), f.stroke(), f.beginPath(), f.moveTo(e.x3 - c, Math.max(e.y1, e.y4)), f.lineTo(e.x3 - c, Math.max(e.y2, e.y3)), f.stroke(), V(f, e.x1, Math.min(e.y1, e.y4), e.x2, Math.max(e.y1, e.y4), \"transparent\", 2 * e.borderThickness, e.color, !1, !1, !1, !1), f.globalAlpha = 1) : \"ohlc\" === c.type ? (f.globalAlpha = 1, f.strokeStyle = e.color, f.lineWidth = 2 * e.borderThickness, c = 0 === f.lineWidth % 2 ? 0 : 0.5, f.beginPath(), f.moveTo(e.x3 - c, e.y2), f.lineTo(e.x3 - c, e.y3), f.stroke(), f.beginPath(), f.moveTo(e.x3, e.y1), f.lineTo(e.x1, e.y1), f.stroke(), f.beginPath(), f.moveTo(e.x3, e.y4), f.lineTo(e.x2, e.y4), f.stroke(), f.globalAlpha = 1) : \"boxAndWhisker\" === c.type ? (f.save(), f.globalAlpha = 1, f.strokeStyle = e.stemColor, f.lineWidth = 2 * e.stemThickness, 0 < e.stemThickness && (f.beginPath(), f.moveTo(e.x3, e.y2 + e.borderThickness / 2), f.lineTo(e.x3, e.y1 + e.whiskerThickness / 2), f.stroke(), f.beginPath(), f.moveTo(e.x3, e.y4 - e.whiskerThickness / 2), f.lineTo(e.x3, e.y3 - e.borderThickness / 2), f.stroke()), f.beginPath(), V(f, e.x1 - e.borderThickness / 2, Math.max(e.y2 + e.borderThickness / 2, e.y3 + e.borderThickness / 2), e.x2 + e.borderThickness / 2, Math.min(e.y2 - e.borderThickness / 2, e.y3 - e.borderThickness / 2), \"transparent\", e.borderThickness, e.color, !1, !1, !1, !1), f.globalAlpha = 1, f.strokeStyle = e.whiskerColor, f.lineWidth = 2 * e.whiskerThickness, 0 < e.whiskerThickness && (f.beginPath(), f.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y4), f.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y4), f.stroke(), f.beginPath(), f.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y1), f.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y1), f.stroke()), f.globalAlpha = 1, f.strokeStyle = e.lineColor, f.lineWidth = 2 * e.lineThickness, 0 < e.lineThickness && (f.beginPath(), f.moveTo(e.x1, e.y5), f.lineTo(e.x2, e.y5), f.stroke()), f.restore(), f.globalAlpha = 1) : \"error\" === c.type && z(f, e.x1, e.y1, e.x2, e.y2, \"white\", e.whiskerProperties, e.stemProperties, e.isXYSwapped, 0.3));\n        }\n      }f.restore();f.globalAlpha = 1;f.beginPath();\n    };Y.prototype.getToolTipInnerHTML = function (a) {\n      a = a.entries;for (var f = null, b = null, c = null, e = 0, g = \"\", h = !0, l = 0; l < a.length; l++) {\n        if (a[l].dataSeries.toolTipContent || a[l].dataPoint.toolTipContent) {\n          h = !1;break;\n        }\n      }if (h && (this.content && \"function\" === typeof this.content || this.contentFormatter)) a = { chart: this.chart, toolTip: this.options, entries: a }, f = this.contentFormatter ? this.contentFormatter(a) : this.content(a);else if (this.shared && \"none\" !== this.chart.plotInfo.axisPlacement) {\n        for (var m = null, k = \"\", l = 0; l < a.length; l++) {\n          b = a[l].dataSeries, c = a[l].dataPoint, e = a[l].index, g = \"\", 0 === l && h && !this.content && (this.chart.axisX && 0 < this.chart.axisX.length ? k += \"undefined\" !== typeof this.chart.axisX[0].labels[c.x] ? this.chart.axisX[0].labels[c.x] : \"{x}\" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (k += \"undefined\" !== typeof this.chart.axisX2[0].labels[c.x] ? this.chart.axisX2[0].labels[c.x] : \"{x}\"), k += \"</br>\", k = this.chart.replaceKeywordsWithValue(k, c, b, e)), null === c.toolTipContent || \"undefined\" === typeof c.toolTipContent && null === b.options.toolTipContent || (\"line\" === b.type || \"stepLine\" === b.type || \"spline\" === b.type || \"area\" === b.type || \"stepArea\" === b.type || \"splineArea\" === b.type || \"column\" === b.type || \"bar\" === b.type || \"scatter\" === b.type || \"stackedColumn\" === b.type || \"stackedColumn100\" === b.type || \"stackedBar\" === b.type || \"stackedBar100\" === b.type || \"stackedArea\" === b.type || \"stackedArea100\" === b.type || \"waterfall\" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span>&nbsp;&nbsp;{y}\", m = b.axisXIndex) : \"bubble\" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}\") : \"rangeColumn\" === b.type || \"rangeBar\" === b.type || \"rangeArea\" === b.type || \"rangeSplineArea\" === b.type || \"error\" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}\") : \"candlestick\" === b.type || \"ohlc\" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}\") : \"boxAndWhisker\" === b.type && (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}\"), null === f && (f = \"\"), !0 === this.reversed ? (f = this.chart.replaceKeywordsWithValue(g, c, b, e) + f, l < a.length - 1 && (f = \"</br>\" + f)) : (f += this.chart.replaceKeywordsWithValue(g, c, b, e), l < a.length - 1 && (f += \"</br>\")));\n        }null !== f && (f = k + f);\n      } else {\n        b = a[0].dataSeries;c = a[0].dataPoint;e = a[0].index;if (null === c.toolTipContent || \"undefined\" === typeof c.toolTipContent && null === b.options.toolTipContent) return null;\"line\" === b.type || \"stepLine\" === b.type || \"spline\" === b.type || \"area\" === b.type || \"stepArea\" === b.type || \"splineArea\" === b.type || \"column\" === b.type || \"bar\" === b.type || \"scatter\" === b.type || \"stackedColumn\" === b.type || \"stackedColumn100\" === b.type || \"stackedBar\" === b.type || \"stackedBar100\" === b.type || \"stackedArea\" === b.type || \"stackedArea100\" === b.type || \"waterfall\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \":</span>&nbsp;&nbsp;{y}\" : \"bubble\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}\" : \"pie\" === b.type || \"doughnut\" === b.type || \"funnel\" === b.type || \"pyramid\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.name ? \"{name}:</span>&nbsp;&nbsp;\" : c.label ? \"{label}:</span>&nbsp;&nbsp;\" : \"</span>\") + \"{y}\" : \"rangeColumn\" === b.type || \"rangeBar\" === b.type || \"rangeArea\" === b.type || \"rangeSplineArea\" === b.type || \"error\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \" :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}\" : \"candlestick\" === b.type || \"ohlc\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \"</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}\" : \"boxAndWhisker\" === b.type && (g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \"</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}\");\n        null === f && (f = \"\");f += this.chart.replaceKeywordsWithValue(g, c, b, e);\n      }return f;\n    };Y.prototype.enableAnimation = function () {\n      if (!this.container.style.WebkitTransition) {\n        var a = this.getContainerTransition(this.containerTransitionDuration);this.container.style.WebkitTransition = a;this.container.style.MsTransition = a;this.container.style.transition = a;this.container.style.MozTransition = this.mozContainerTransition;\n      }\n    };Y.prototype.disableAnimation = function () {\n      this.container.style.WebkitTransition && (this.container.style.WebkitTransition = \"\", this.container.style.MozTransition = \"\", this.container.style.MsTransition = \"\", this.container.style.transition = \"\");\n    };Y.prototype.hide = function (a) {\n      this.container && (this.container.style.display = \"none\", this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, (\"undefined\" === typeof a || a) && this.chart.resetOverlayedCanvas());\n    };Y.prototype.show = function (a, f, b) {\n      this._updateToolTip(a, f, \"undefined\" === typeof b ? !1 : b);\n    };Y.prototype.fixMozTransitionDelay = function (a, f) {\n      if (20 < this.chart._eventManager.lastObjectId) this.mozContainerTransition = this.getContainerTransition(0);else {\n        var b = parseFloat(this.container.style.left),\n            b = isNaN(b) ? 0 : b,\n            c = parseFloat(this.container.style.bottom),\n            c = isNaN(c) ? 0 : c;10 < Math.sqrt(Math.pow(b - a, 2) + Math.pow(c - f, 2)) ? this.mozContainerTransition = this.getContainerTransition(0.1) : this.mozContainerTransition = this.getContainerTransition(0);\n      }\n    };Y.prototype.getContainerTransition = function (a) {\n      return \"left \" + a + \"s ease-out 0s, bottom \" + a + \"s ease-out 0s\";\n    };fa.prototype.reset = function () {\n      this.lastObjectId = 0;this.objectMap = [];this.rectangularRegionEventSubscriptions = [];this.previousDataPointEventObject = null;this.eventObjects = [];v && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath());\n    };fa.prototype.getNewObjectTrackingId = function () {\n      return ++this.lastObjectId;\n    };fa.prototype.mouseEventHandler = function (a) {\n      if (\"mousemove\" === a.type || \"click\" === a.type) {\n        var f = [],\n            b = Oa(a),\n            c = null;if ((c = this.chart.getObjectAtXY(b.x, b.y, !1)) && \"undefined\" !== typeof this.objectMap[c]) if (c = this.objectMap[c], \"dataPoint\" === c.objectType) {\n          var e = this.chart.data[c.dataSeriesIndex],\n              g = e.dataPoints[c.dataPointIndex],\n              h = c.dataPointIndex;c.eventParameter = { x: b.x, y: b.y, dataPoint: g, dataSeries: e.options, dataPointIndex: h, dataSeriesIndex: e.index, chart: this.chart };c.eventContext = { context: g, userContext: g, mouseover: \"mouseover\", mousemove: \"mousemove\", mouseout: \"mouseout\", click: \"click\" };f.push(c);c = this.objectMap[e.id];c.eventParameter = { x: b.x, y: b.y, dataPoint: g, dataSeries: e.options, dataPointIndex: h, dataSeriesIndex: e.index, chart: this.chart };c.eventContext = { context: e, userContext: e.options, mouseover: \"mouseover\",\n            mousemove: \"mousemove\", mouseout: \"mouseout\", click: \"click\" };f.push(this.objectMap[e.id]);\n        } else \"legendItem\" === c.objectType && (e = this.chart.data[c.dataSeriesIndex], g = null !== c.dataPointIndex ? e.dataPoints[c.dataPointIndex] : null, c.eventParameter = { x: b.x, y: b.y, dataSeries: e.options, dataPoint: g, dataPointIndex: c.dataPointIndex, dataSeriesIndex: c.dataSeriesIndex, chart: this.chart }, c.eventContext = { context: this.chart.legend, userContext: this.chart.legend.options, mouseover: \"itemmouseover\", mousemove: \"itemmousemove\", mouseout: \"itemmouseout\",\n          click: \"itemclick\" }, f.push(c));e = [];for (b = 0; b < this.mouseoveredObjectMaps.length; b++) {\n          g = !0;for (c = 0; c < f.length; c++) {\n            if (f[c].id === this.mouseoveredObjectMaps[b].id) {\n              g = !1;break;\n            }\n          }g ? this.fireEvent(this.mouseoveredObjectMaps[b], \"mouseout\", a) : e.push(this.mouseoveredObjectMaps[b]);\n        }this.mouseoveredObjectMaps = e;for (b = 0; b < f.length; b++) {\n          e = !1;for (c = 0; c < this.mouseoveredObjectMaps.length; c++) {\n            if (f[b].id === this.mouseoveredObjectMaps[c].id) {\n              e = !0;break;\n            }\n          }e || (this.fireEvent(f[b], \"mouseover\", a), this.mouseoveredObjectMaps.push(f[b]));\n          \"click\" === a.type ? this.fireEvent(f[b], \"click\", a) : \"mousemove\" === a.type && this.fireEvent(f[b], \"mousemove\", a);\n        }\n      }\n    };fa.prototype.fireEvent = function (a, f, b) {\n      if (a && f) {\n        var c = a.eventParameter,\n            e = a.eventContext,\n            g = a.eventContext.userContext;g && e && g[e[f]] && g[e[f]].call(g, c);\"mouseout\" !== f ? g.cursor && g.cursor !== b.target.style.cursor && (b.target.style.cursor = g.cursor) : (b.target.style.cursor = this.chart._defaultCursor, delete a.eventParameter, delete a.eventContext);\"click\" === f && \"dataPoint\" === a.objectType && this.chart.pieDoughnutClickHandler && this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex], c);\"click\" === f && \"dataPoint\" === a.objectType && this.chart.funnelPyramidClickHandler && this.chart.funnelPyramidClickHandler.call(this.chart.data[a.dataSeriesIndex], c);\n      }\n    };ka.prototype.animate = function (a, f, b, c, e) {\n      var g = this;this.chart.isAnimating = !0;e = e || H.easing.linear;b && this.animations.push({ startTime: new Date().getTime() + (a ? a : 0), duration: f, animationCallback: b, onComplete: c });for (a = []; 0 < this.animations.length;) {\n        if (f = this.animations.shift(), b = new Date().getTime(), c = 0, f.startTime <= b && (c = e(Math.min(b - f.startTime, f.duration), 0, 1, f.duration), c = Math.min(c, 1), isNaN(c) || !isFinite(c)) && (c = 1), 1 > c && a.push(f), f.animationCallback(c), 1 <= c && f.onComplete) f.onComplete();\n      }this.animations = a;0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, function () {\n        g.animate.call(g);\n      }) : this.chart.isAnimating = !1;\n    };ka.prototype.cancelAllAnimations = function () {\n      this.animations = [];this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId);this.animationRequestId = null;this.chart.isAnimating = !1;\n    };var H = { yScaleAnimation: function yScaleAnimation(a, f) {\n        if (0 !== a) {\n          var b = f.dest,\n              c = f.source.canvas,\n              e = f.animationBase;b.drawImage(c, 0, 0, c.width, c.height, 0, e - e * a, b.canvas.width / ha, a * b.canvas.height / ha);\n        }\n      }, xScaleAnimation: function xScaleAnimation(a, f) {\n        if (0 !== a) {\n          var b = f.dest,\n              c = f.source.canvas,\n              e = f.animationBase;b.drawImage(c, 0, 0, c.width, c.height, e - e * a, 0, a * b.canvas.width / ha, b.canvas.height / ha);\n        }\n      }, xClipAnimation: function xClipAnimation(a, f) {\n        if (0 !== a) {\n          var b = f.dest,\n              c = f.source.canvas;\n          b.save();0 < a && b.drawImage(c, 0, 0, c.width * a, c.height, 0, 0, c.width * a / ha, c.height / ha);b.restore();\n        }\n      }, fadeInAnimation: function fadeInAnimation(a, f) {\n        if (0 !== a) {\n          var b = f.dest,\n              c = f.source.canvas;b.save();b.globalAlpha = a;b.drawImage(c, 0, 0, c.width, c.height, 0, 0, b.canvas.width / ha, b.canvas.height / ha);b.restore();\n        }\n      }, easing: { linear: function linear(a, f, b, c) {\n          return b * a / c + f;\n        }, easeOutQuad: function easeOutQuad(a, f, b, c) {\n          return -b * (a /= c) * (a - 2) + f;\n        }, easeOutQuart: function easeOutQuart(a, f, b, c) {\n          return -b * ((a = a / c - 1) * a * a * a - 1) + f;\n        }, easeInQuad: function easeInQuad(a, f, b, c) {\n          return b * (a /= c) * a + f;\n        }, easeInQuart: function easeInQuart(a, f, b, c) {\n          return b * (a /= c) * a * a * a + f;\n        } } },\n        ja = { drawMarker: function drawMarker(a, f, b, c, e, g, h, l) {\n        if (b) {\n          var m = 1;b.fillStyle = g ? g : \"#000000\";b.strokeStyle = h ? h : \"#000000\";b.lineWidth = l ? l : 0;\"circle\" === c ? (b.moveTo(a, f), b.beginPath(), b.arc(a, f, e / 2, 0, 2 * Math.PI, !1), g && b.fill(), l && (h ? b.stroke() : (m = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = \"black\", b.stroke(), b.globalAlpha = m))) : \"square\" === c ? (b.beginPath(), b.rect(a - e / 2, f - e / 2, e, e), g && b.fill(), l && (h ? b.stroke() : (m = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = \"black\", b.stroke(), b.globalAlpha = m))) : \"triangle\" === c ? (b.beginPath(), b.moveTo(a - e / 2, f + e / 2), b.lineTo(a + e / 2, f + e / 2), b.lineTo(a, f - e / 2), b.closePath(), g && b.fill(), l && (h ? b.stroke() : (m = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = \"black\", b.stroke(), b.globalAlpha = m)), b.beginPath()) : \"cross\" === c && (b.strokeStyle = g, b.lineWidth = e / 4, b.beginPath(), b.moveTo(a - e / 2, f - e / 2), b.lineTo(a + e / 2, f + e / 2), b.stroke(), b.moveTo(a + e / 2, f - e / 2), b.lineTo(a - e / 2, f + e / 2), b.stroke());\n        }\n      }, drawMarkers: function drawMarkers(a) {\n        for (var f = 0; f < a.length; f++) {\n          var b = a[f];ja.drawMarker(b.x, b.y, b.ctx, b.type, b.size, b.color, b.borderColor, b.borderThickness);\n        }\n      } };return q;\n  }();x.Chart.version = \"v2.0.1 GA\";\n})();\n\n/*\r\n  excanvas is used to support IE678 which do not implement HTML5 Canvas Element. You can safely remove the following excanvas code if you don't need to support older browsers.\r\n\r\n  Copyright 2006 Google Inc. https://code.google.com/p/explorercanvas/\r\n  Licensed under the Apache License, Version 2.0\r\n*/\ndocument.createElement(\"canvas\").getContext || function () {\n  function V() {\n    return this.context_ || (this.context_ = new C(this));\n  }function W(a, b, c) {\n    var g = M.call(arguments, 2);return function () {\n      return a.apply(b, g.concat(M.call(arguments)));\n    };\n  }function N(a) {\n    return String(a).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\");\n  }function O(a) {\n    a.namespaces.g_vml_ || a.namespaces.add(\"g_vml_\", \"urn:schemas-microsoft-com:vml\", \"#default#VML\");a.namespaces.g_o_ || a.namespaces.add(\"g_o_\", \"urn:schemas-microsoft-com:office:office\", \"#default#VML\");\n    a.styleSheets.ex_canvas_ || (a = a.createStyleSheet(), a.owningElement.id = \"ex_canvas_\", a.cssText = \"canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}\");\n  }function X(a) {\n    var b = a.srcElement;switch (a.propertyName) {case \"width\":\n        b.getContext().clearRect();b.style.width = b.attributes.width.nodeValue + \"px\";b.firstChild.style.width = b.clientWidth + \"px\";break;case \"height\":\n        b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + \"px\", b.firstChild.style.height = b.clientHeight + \"px\";}\n  }function Y(a) {\n    a = a.srcElement;a.firstChild && (a.firstChild.style.width = a.clientWidth + \"px\", a.firstChild.style.height = a.clientHeight + \"px\");\n  }function D() {\n    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n  }function t(a, b) {\n    for (var c = D(), g = 0; 3 > g; g++) {\n      for (var e = 0; 3 > e; e++) {\n        for (var f = 0, d = 0; 3 > d; d++) {\n          f += a[g][d] * b[d][e];\n        }c[g][e] = f;\n      }\n    }return c;\n  }function P(a, b) {\n    b.fillStyle = a.fillStyle;b.lineCap = a.lineCap;b.lineJoin = a.lineJoin;b.lineWidth = a.lineWidth;b.miterLimit = a.miterLimit;b.shadowBlur = a.shadowBlur;b.shadowColor = a.shadowColor;b.shadowOffsetX = a.shadowOffsetX;b.shadowOffsetY = a.shadowOffsetY;b.strokeStyle = a.strokeStyle;b.globalAlpha = a.globalAlpha;b.font = a.font;b.textAlign = a.textAlign;b.textBaseline = a.textBaseline;b.arcScaleX_ = a.arcScaleX_;b.arcScaleY_ = a.arcScaleY_;b.lineScale_ = a.lineScale_;\n  }function Q(a) {\n    var b = a.indexOf(\"(\", 3),\n        c = a.indexOf(\")\", b + 1),\n        b = a.substring(b + 1, c).split(\",\");if (4 != b.length || \"a\" != a.charAt(3)) b[3] = 1;return b;\n  }function E(a, b, c) {\n    return Math.min(c, Math.max(b, a));\n  }function F(a, b, c) {\n    0 > c && c++;1 < c && c--;return 1 > 6 * c ? a + 6 * (b - a) * c : 1 > 2 * c ? b : 2 > 3 * c ? a + 6 * (b - a) * (2 / 3 - c) : a;\n  }function G(a) {\n    if (a in H) return H[a];var b,\n        c = 1;a = String(a);if (\"#\" == a.charAt(0)) b = a;else if (/^rgb/.test(a)) {\n      c = Q(a);b = \"#\";for (var g, e = 0; 3 > e; e++) {\n        g = -1 != c[e].indexOf(\"%\") ? Math.floor(255 * (parseFloat(c[e]) / 100)) : +c[e], b += v[E(g, 0, 255)];\n      }c = +c[3];\n    } else if (/^hsl/.test(a)) {\n      e = c = Q(a);b = parseFloat(e[0]) / 360 % 360;0 > b && b++;g = E(parseFloat(e[1]) / 100, 0, 1);e = E(parseFloat(e[2]) / 100, 0, 1);if (0 == g) g = e = b = e;else {\n        var f = 0.5 > e ? e * (1 + g) : e + g - e * g,\n            d = 2 * e - f;g = F(d, f, b + 1 / 3);e = F(d, f, b);b = F(d, f, b - 1 / 3);\n      }b = \"#\" + v[Math.floor(255 * g)] + v[Math.floor(255 * e)] + v[Math.floor(255 * b)];c = c[3];\n    } else b = Z[a] || a;return H[a] = { color: b, alpha: c };\n  }function C(a) {\n    this.m_ = D();this.mStack_ = [];this.aStack_ = [];this.currentPath_ = [];this.fillStyle = this.strokeStyle = \"#000\";this.lineWidth = 1;this.lineJoin = \"miter\";this.lineCap = \"butt\";this.miterLimit = 1 * q;this.globalAlpha = 1;this.font = \"10px sans-serif\";this.textAlign = \"left\";this.textBaseline = \"alphabetic\";this.canvas = a;var b = \"width:\" + a.clientWidth + \"px;height:\" + a.clientHeight + \"px;overflow:hidden;position:absolute\",\n        c = a.ownerDocument.createElement(\"div\");c.style.cssText = b;a.appendChild(c);b = c.cloneNode(!1);b.style.backgroundColor = \"red\";b.style.filter = \"alpha(opacity=0)\";a.appendChild(b);this.element_ = c;this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1;\n  }function R(a, b, c, g) {\n    a.currentPath_.push({ type: \"bezierCurveTo\", cp1x: b.x, cp1y: b.y, cp2x: c.x, cp2y: c.y, x: g.x, y: g.y });a.currentX_ = g.x;a.currentY_ = g.y;\n  }function S(a, b) {\n    var c = G(a.strokeStyle),\n        g = c.color,\n        c = c.alpha * a.globalAlpha,\n        e = a.lineScale_ * a.lineWidth;1 > e && (c *= e);b.push(\"<g_vml_:stroke\", ' opacity=\"', c, '\"', ' joinstyle=\"', a.lineJoin, '\"', ' miterlimit=\"', a.miterLimit, '\"', ' endcap=\"', $[a.lineCap] || \"square\", '\"', ' weight=\"', e, 'px\"', ' color=\"', g, '\" />');\n  }function T(a, b, c, g) {\n    var e = a.fillStyle,\n        f = a.arcScaleX_,\n        d = a.arcScaleY_,\n        k = g.x - c.x,\n        n = g.y - c.y;if (e instanceof w) {\n      var h = 0,\n          l = g = 0,\n          u = 0,\n          m = 1;if (\"gradient\" == e.type_) {\n        h = e.x1_ / f;c = e.y1_ / d;var p = s(a, e.x0_ / f, e.y0_ / d),\n            h = s(a, h, c),\n            h = 180 * Math.atan2(h.x - p.x, h.y - p.y) / Math.PI;0 > h && (h += 360);1E-6 > h && (h = 0);\n      } else p = s(a, e.x0_, e.y0_), g = (p.x - c.x) / k, l = (p.y - c.y) / n, k /= f * q, n /= d * q, m = x.max(k, n), u = 2 * e.r0_ / m, m = 2 * e.r1_ / m - u;f = e.colors_;f.sort(function (a, b) {\n        return a.offset - b.offset;\n      });d = f.length;p = f[0].color;c = f[d - 1].color;k = f[0].alpha * a.globalAlpha;a = f[d - 1].alpha * a.globalAlpha;for (var n = [], r = 0; r < d; r++) {\n        var t = f[r];n.push(t.offset * m + u + \" \" + t.color);\n      }b.push('<g_vml_:fill type=\"', e.type_, '\"', ' method=\"none\" focus=\"100%\"', ' color=\"', p, '\"', ' color2=\"', c, '\"', ' colors=\"', n.join(\",\"), '\"', ' opacity=\"', a, '\"', ' g_o_:opacity2=\"', k, '\"', ' angle=\"', h, '\"', ' focusposition=\"', g, \",\", l, '\" />');\n    } else e instanceof I ? k && n && b.push(\"<g_vml_:fill\", ' position=\"', -c.x / k * f * f, \",\", -c.y / n * d * d, '\"', ' type=\"tile\"', ' src=\"', e.src_, '\" />') : (e = G(a.fillStyle), b.push('<g_vml_:fill color=\"', e.color, '\" opacity=\"', e.alpha * a.globalAlpha, '\" />'));\n  }function s(a, b, c) {\n    a = a.m_;return { x: q * (b * a[0][0] + c * a[1][0] + a[2][0]) - r, y: q * (b * a[0][1] + c * a[1][1] + a[2][1]) - r };\n  }function z(a, b, c) {\n    isFinite(b[0][0]) && isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1]) && (a.m_ = b, c && (a.lineScale_ = aa(ba(b[0][0] * b[1][1] - b[0][1] * b[1][0]))));\n  }function w(a) {\n    this.type_ = a;this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0;this.colors_ = [];\n  }function I(a, b) {\n    if (!a || 1 != a.nodeType || \"IMG\" != a.tagName) throw new A(\"TYPE_MISMATCH_ERR\");if (\"complete\" != a.readyState) throw new A(\"INVALID_STATE_ERR\");switch (b) {case \"repeat\":case null:case \"\":\n        this.repetition_ = \"repeat\";break;case \"repeat-x\":case \"repeat-y\":case \"no-repeat\":\n        this.repetition_ = b;break;default:\n        throw new A(\"SYNTAX_ERR\");}this.src_ = a.src;this.width_ = a.width;this.height_ = a.height;\n  }\n  function A(a) {\n    this.code = this[a];this.message = a + \": DOM Exception \" + this.code;\n  }var x = Math,\n      k = x.round,\n      J = x.sin,\n      K = x.cos,\n      ba = x.abs,\n      aa = x.sqrt,\n      q = 10,\n      r = q / 2;navigator.userAgent.match(/MSIE ([\\d.]+)?/);var M = Array.prototype.slice;O(document);var U = { init: function init(a) {\n      a = a || document;a.createElement(\"canvas\");a.attachEvent(\"onreadystatechange\", W(this.init_, this, a));\n    }, init_: function init_(a) {\n      a = a.getElementsByTagName(\"canvas\");for (var b = 0; b < a.length; b++) {\n        this.initElement(a[b]);\n      }\n    }, initElement: function initElement(a) {\n      if (!a.getContext) {\n        a.getContext = V;O(a.ownerDocument);a.innerHTML = \"\";a.attachEvent(\"onpropertychange\", X);a.attachEvent(\"onresize\", Y);var b = a.attributes;b.width && b.width.specified ? a.style.width = b.width.nodeValue + \"px\" : a.width = a.clientWidth;b.height && b.height.specified ? a.style.height = b.height.nodeValue + \"px\" : a.height = a.clientHeight;\n      }return a;\n    } };U.init();for (var v = [], d = 0; 16 > d; d++) {\n    for (var B = 0; 16 > B; B++) {\n      v[16 * d + B] = d.toString(16) + B.toString(16);\n    }\n  }var Z = { aliceblue: \"#F0F8FF\", antiquewhite: \"#FAEBD7\", aquamarine: \"#7FFFD4\", azure: \"#F0FFFF\", beige: \"#F5F5DC\",\n    bisque: \"#FFE4C4\", black: \"#000000\", blanchedalmond: \"#FFEBCD\", blueviolet: \"#8A2BE2\", brown: \"#A52A2A\", burlywood: \"#DEB887\", cadetblue: \"#5F9EA0\", chartreuse: \"#7FFF00\", chocolate: \"#D2691E\", coral: \"#FF7F50\", cornflowerblue: \"#6495ED\", cornsilk: \"#FFF8DC\", crimson: \"#DC143C\", cyan: \"#00FFFF\", darkblue: \"#00008B\", darkcyan: \"#008B8B\", darkgoldenrod: \"#B8860B\", darkgray: \"#A9A9A9\", darkgreen: \"#006400\", darkgrey: \"#A9A9A9\", darkkhaki: \"#BDB76B\", darkmagenta: \"#8B008B\", darkolivegreen: \"#556B2F\", darkorange: \"#FF8C00\", darkorchid: \"#9932CC\", darkred: \"#8B0000\",\n    darksalmon: \"#E9967A\", darkseagreen: \"#8FBC8F\", darkslateblue: \"#483D8B\", darkslategray: \"#2F4F4F\", darkslategrey: \"#2F4F4F\", darkturquoise: \"#00CED1\", darkviolet: \"#9400D3\", deeppink: \"#FF1493\", deepskyblue: \"#00BFFF\", dimgray: \"#696969\", dimgrey: \"#696969\", dodgerblue: \"#1E90FF\", firebrick: \"#B22222\", floralwhite: \"#FFFAF0\", forestgreen: \"#228B22\", gainsboro: \"#DCDCDC\", ghostwhite: \"#F8F8FF\", gold: \"#FFD700\", goldenrod: \"#DAA520\", grey: \"#808080\", greenyellow: \"#ADFF2F\", honeydew: \"#F0FFF0\", hotpink: \"#FF69B4\", indianred: \"#CD5C5C\", indigo: \"#4B0082\",\n    ivory: \"#FFFFF0\", khaki: \"#F0E68C\", lavender: \"#E6E6FA\", lavenderblush: \"#FFF0F5\", lawngreen: \"#7CFC00\", lemonchiffon: \"#FFFACD\", lightblue: \"#ADD8E6\", lightcoral: \"#F08080\", lightcyan: \"#E0FFFF\", lightgoldenrodyellow: \"#FAFAD2\", lightgreen: \"#90EE90\", lightgrey: \"#D3D3D3\", lightpink: \"#FFB6C1\", lightsalmon: \"#FFA07A\", lightseagreen: \"#20B2AA\", lightskyblue: \"#87CEFA\", lightslategray: \"#778899\", lightslategrey: \"#778899\", lightsteelblue: \"#B0C4DE\", lightyellow: \"#FFFFE0\", limegreen: \"#32CD32\", linen: \"#FAF0E6\", magenta: \"#FF00FF\", mediumaquamarine: \"#66CDAA\",\n    mediumblue: \"#0000CD\", mediumorchid: \"#BA55D3\", mediumpurple: \"#9370DB\", mediumseagreen: \"#3CB371\", mediumslateblue: \"#7B68EE\", mediumspringgreen: \"#00FA9A\", mediumturquoise: \"#48D1CC\", mediumvioletred: \"#C71585\", midnightblue: \"#191970\", mintcream: \"#F5FFFA\", mistyrose: \"#FFE4E1\", moccasin: \"#FFE4B5\", navajowhite: \"#FFDEAD\", oldlace: \"#FDF5E6\", olivedrab: \"#6B8E23\", orange: \"#FFA500\", orangered: \"#FF4500\", orchid: \"#DA70D6\", palegoldenrod: \"#EEE8AA\", palegreen: \"#98FB98\", paleturquoise: \"#AFEEEE\", palevioletred: \"#DB7093\", papayawhip: \"#FFEFD5\",\n    peachpuff: \"#FFDAB9\", peru: \"#CD853F\", pink: \"#FFC0CB\", plum: \"#DDA0DD\", powderblue: \"#B0E0E6\", rosybrown: \"#BC8F8F\", royalblue: \"#4169E1\", saddlebrown: \"#8B4513\", salmon: \"#FA8072\", sandybrown: \"#F4A460\", seagreen: \"#2E8B57\", seashell: \"#FFF5EE\", sienna: \"#A0522D\", skyblue: \"#87CEEB\", slateblue: \"#6A5ACD\", slategray: \"#708090\", slategrey: \"#708090\", snow: \"#FFFAFA\", springgreen: \"#00FF7F\", steelblue: \"#4682B4\", tan: \"#D2B48C\", thistle: \"#D8BFD8\", tomato: \"#FF6347\", turquoise: \"#40E0D0\", violet: \"#EE82EE\", wheat: \"#F5DEB3\", whitesmoke: \"#F5F5F5\", yellowgreen: \"#9ACD32\" },\n      H = {},\n      L = {},\n      $ = { butt: \"flat\", round: \"round\" },\n      d = C.prototype;d.clearRect = function () {\n    this.textMeasureEl_ && (this.textMeasureEl_.removeNode(!0), this.textMeasureEl_ = null);this.element_.innerHTML = \"\";\n  };d.beginPath = function () {\n    this.currentPath_ = [];\n  };d.moveTo = function (a, b) {\n    var c = s(this, a, b);this.currentPath_.push({ type: \"moveTo\", x: c.x, y: c.y });this.currentX_ = c.x;this.currentY_ = c.y;\n  };d.lineTo = function (a, b) {\n    var c = s(this, a, b);this.currentPath_.push({ type: \"lineTo\", x: c.x, y: c.y });this.currentX_ = c.x;this.currentY_ = c.y;\n  };d.bezierCurveTo = function (a, b, c, g, e, f) {\n    e = s(this, e, f);a = s(this, a, b);c = s(this, c, g);R(this, a, c, e);\n  };d.quadraticCurveTo = function (a, b, c, g) {\n    a = s(this, a, b);c = s(this, c, g);g = { x: this.currentX_ + 2 / 3 * (a.x - this.currentX_), y: this.currentY_ + 2 / 3 * (a.y - this.currentY_) };R(this, g, { x: g.x + (c.x - this.currentX_) / 3, y: g.y + (c.y - this.currentY_) / 3 }, c);\n  };d.arc = function (a, b, c, g, e, f) {\n    c *= q;var d = f ? \"at\" : \"wa\",\n        k = a + K(g) * c - r,\n        n = b + J(g) * c - r;g = a + K(e) * c - r;e = b + J(e) * c - r;k != g || f || (k += 0.125);a = s(this, a, b);k = s(this, k, n);g = s(this, g, e);this.currentPath_.push({ type: d,\n      x: a.x, y: a.y, radius: c, xStart: k.x, yStart: k.y, xEnd: g.x, yEnd: g.y });\n  };d.rect = function (a, b, c, g) {\n    this.moveTo(a, b);this.lineTo(a + c, b);this.lineTo(a + c, b + g);this.lineTo(a, b + g);this.closePath();\n  };d.strokeRect = function (a, b, c, g) {\n    var e = this.currentPath_;this.beginPath();this.moveTo(a, b);this.lineTo(a + c, b);this.lineTo(a + c, b + g);this.lineTo(a, b + g);this.closePath();this.stroke();this.currentPath_ = e;\n  };d.fillRect = function (a, b, c, g) {\n    var e = this.currentPath_;this.beginPath();this.moveTo(a, b);this.lineTo(a + c, b);this.lineTo(a + c, b + g);this.lineTo(a, b + g);this.closePath();this.fill();this.currentPath_ = e;\n  };d.createLinearGradient = function (a, b, c, g) {\n    var e = new w(\"gradient\");e.x0_ = a;e.y0_ = b;e.x1_ = c;e.y1_ = g;return e;\n  };d.createRadialGradient = function (a, b, c, g, e, f) {\n    var d = new w(\"gradientradial\");d.x0_ = a;d.y0_ = b;d.r0_ = c;d.x1_ = g;d.y1_ = e;d.r1_ = f;return d;\n  };d.drawImage = function (a, b) {\n    var c, g, e, d, r, y, n, h;e = a.runtimeStyle.width;d = a.runtimeStyle.height;a.runtimeStyle.width = \"auto\";a.runtimeStyle.height = \"auto\";var l = a.width,\n        u = a.height;a.runtimeStyle.width = e;a.runtimeStyle.height = d;if (3 == arguments.length) c = arguments[1], g = arguments[2], r = y = 0, n = e = l, h = d = u;else if (5 == arguments.length) c = arguments[1], g = arguments[2], e = arguments[3], d = arguments[4], r = y = 0, n = l, h = u;else if (9 == arguments.length) r = arguments[1], y = arguments[2], n = arguments[3], h = arguments[4], c = arguments[5], g = arguments[6], e = arguments[7], d = arguments[8];else throw Error(\"Invalid number of arguments\");var m = s(this, c, g),\n        p = [];p.push(\" <g_vml_:group\", ' coordsize=\"', 10 * q, \",\", 10 * q, '\"', ' coordorigin=\"0,0\"', ' style=\"width:', 10, \"px;height:\", 10, \"px;position:absolute;\");if (1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {\n      var t = [];t.push(\"M11=\", this.m_[0][0], \",\", \"M12=\", this.m_[1][0], \",\", \"M21=\", this.m_[0][1], \",\", \"M22=\", this.m_[1][1], \",\", \"Dx=\", k(m.x / q), \",\", \"Dy=\", k(m.y / q), \"\");var v = s(this, c + e, g),\n          w = s(this, c, g + d);c = s(this, c + e, g + d);m.x = x.max(m.x, v.x, w.x, c.x);m.y = x.max(m.y, v.y, w.y, c.y);p.push(\"padding:0 \", k(m.x / q), \"px \", k(m.y / q), \"px 0;filter:progid:DXImageTransform.Microsoft.Matrix(\", t.join(\"\"), \", sizingmethod='clip');\");\n    } else p.push(\"top:\", k(m.y / q), \"px;left:\", k(m.x / q), \"px;\");p.push(' \">', '<g_vml_:image src=\"', a.src, '\"', ' style=\"width:', q * e, \"px;\", \" height:\", q * d, 'px\"', ' cropleft=\"', r / l, '\"', ' croptop=\"', y / u, '\"', ' cropright=\"', (l - r - n) / l, '\"', ' cropbottom=\"', (u - y - h) / u, '\"', \" />\", \"</g_vml_:group>\");this.element_.insertAdjacentHTML(\"BeforeEnd\", p.join(\"\"));\n  };d.stroke = function (a) {\n    var b = [];b.push(\"<g_vml_:shape\", ' filled=\"', !!a, '\"', ' style=\"position:absolute;width:', 10, \"px;height:\", 10, 'px;\"', ' coordorigin=\"0,0\"', ' coordsize=\"', 10 * q, \",\", 10 * q, '\"', ' stroked=\"', !a, '\"', ' path=\"');for (var c = { x: null, y: null }, d = { x: null, y: null }, e = 0; e < this.currentPath_.length; e++) {\n      var f = this.currentPath_[e];switch (f.type) {case \"moveTo\":\n          b.push(\" m \", k(f.x), \",\", k(f.y));break;case \"lineTo\":\n          b.push(\" l \", k(f.x), \",\", k(f.y));break;case \"close\":\n          b.push(\" x \");f = null;break;case \"bezierCurveTo\":\n          b.push(\" c \", k(f.cp1x), \",\", k(f.cp1y), \",\", k(f.cp2x), \",\", k(f.cp2y), \",\", k(f.x), \",\", k(f.y));break;case \"at\":case \"wa\":\n          b.push(\" \", f.type, \" \", k(f.x - this.arcScaleX_ * f.radius), \",\", k(f.y - this.arcScaleY_ * f.radius), \" \", k(f.x + this.arcScaleX_ * f.radius), \",\", k(f.y + this.arcScaleY_ * f.radius), \" \", k(f.xStart), \",\", k(f.yStart), \" \", k(f.xEnd), \",\", k(f.yEnd));}if (f) {\n        if (null == c.x || f.x < c.x) c.x = f.x;if (null == d.x || f.x > d.x) d.x = f.x;if (null == c.y || f.y < c.y) c.y = f.y;if (null == d.y || f.y > d.y) d.y = f.y;\n      }\n    }b.push(' \">');a ? T(this, b, c, d) : S(this, b);b.push(\"</g_vml_:shape>\");this.element_.insertAdjacentHTML(\"beforeEnd\", b.join(\"\"));\n  };d.fill = function () {\n    this.stroke(!0);\n  };d.closePath = function () {\n    this.currentPath_.push({ type: \"close\" });\n  };d.save = function () {\n    var a = {};P(this, a);this.aStack_.push(a);this.mStack_.push(this.m_);this.m_ = t(D(), this.m_);\n  };d.restore = function () {\n    this.aStack_.length && (P(this.aStack_.pop(), this), this.m_ = this.mStack_.pop());\n  };d.translate = function (a, b) {\n    z(this, t([[1, 0, 0], [0, 1, 0], [a, b, 1]], this.m_), !1);\n  };d.rotate = function (a) {\n    var b = K(a);a = J(a);z(this, t([[b, a, 0], [-a, b, 0], [0, 0, 1]], this.m_), !1);\n  };d.scale = function (a, b) {\n    this.arcScaleX_ *= a;this.arcScaleY_ *= b;z(this, t([[a, 0, 0], [0, b, 0], [0, 0, 1]], this.m_), !0);\n  };d.transform = function (a, b, c, d, e, f) {\n    z(this, t([[a, b, 0], [c, d, 0], [e, f, 1]], this.m_), !0);\n  };d.setTransform = function (a, b, c, d, e, f) {\n    z(this, [[a, b, 0], [c, d, 0], [e, f, 1]], !0);\n  };d.drawText_ = function (a, b, c, d, e) {\n    var f = this.m_;d = 0;var r = 1E3,\n        t = 0,\n        n = [],\n        h;h = this.font;if (L[h]) h = L[h];else {\n      var l = document.createElement(\"div\").style;try {\n        l.font = h;\n      } catch (u) {}h = L[h] = { style: l.fontStyle || \"normal\", variant: l.fontVariant || \"normal\", weight: l.fontWeight || \"normal\", size: l.fontSize || 10, family: l.fontFamily || \"sans-serif\" };\n    }var l = h,\n        m = this.element_;h = {};for (var p in l) {\n      h[p] = l[p];\n    }p = parseFloat(m.currentStyle.fontSize);\n    m = parseFloat(l.size);\"number\" == typeof l.size ? h.size = l.size : -1 != l.size.indexOf(\"px\") ? h.size = m : -1 != l.size.indexOf(\"em\") ? h.size = p * m : -1 != l.size.indexOf(\"%\") ? h.size = p / 100 * m : -1 != l.size.indexOf(\"pt\") ? h.size = m / 0.75 : h.size = p;h.size *= 0.981;p = h.style + \" \" + h.variant + \" \" + h.weight + \" \" + h.size + \"px \" + h.family;m = this.element_.currentStyle;l = this.textAlign.toLowerCase();switch (l) {case \"left\":case \"center\":case \"right\":\n        break;case \"end\":\n        l = \"ltr\" == m.direction ? \"right\" : \"left\";break;case \"start\":\n        l = \"rtl\" == m.direction ? \"right\" : \"left\";break;default:\n        l = \"left\";}switch (this.textBaseline) {case \"hanging\":case \"top\":\n        t = h.size / 1.75;break;case \"middle\":\n        break;default:case null:case \"alphabetic\":case \"ideographic\":case \"bottom\":\n        t = -h.size / 2.25;}switch (l) {case \"right\":\n        d = 1E3;r = 0.05;break;case \"center\":\n        d = r = 500;}b = s(this, b + 0, c + t);n.push('<g_vml_:line from=\"', -d, ' 0\" to=\"', r, ' 0.05\" ', ' coordsize=\"100 100\" coordorigin=\"0 0\"', ' filled=\"', !e, '\" stroked=\"', !!e, '\" style=\"position:absolute;width:1px;height:1px;\">');e ? S(this, n) : T(this, n, { x: -d, y: 0 }, { x: r, y: h.size });e = f[0][0].toFixed(3) + \",\" + f[1][0].toFixed(3) + \",\" + f[0][1].toFixed(3) + \",\" + f[1][1].toFixed(3) + \",0,0\";b = k(b.x / q) + \",\" + k(b.y / q);n.push('<g_vml_:skew on=\"t\" matrix=\"', e, '\" ', ' offset=\"', b, '\" origin=\"', d, ' 0\" />', '<g_vml_:path textpathok=\"true\" />', '<g_vml_:textpath on=\"true\" string=\"', N(a), '\" style=\"v-text-align:', l, \";font:\", N(p), '\" /></g_vml_:line>');this.element_.insertAdjacentHTML(\"beforeEnd\", n.join(\"\"));\n  };d.fillText = function (a, b, c, d) {\n    this.drawText_(a, b, c, d, !1);\n  };d.strokeText = function (a, b, c, d) {\n    this.drawText_(a, b, c, d, !0);\n  };d.measureText = function (a) {\n    this.textMeasureEl_ || (this.element_.insertAdjacentHTML(\"beforeEnd\", '<span style=\"position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;\"></span>'), this.textMeasureEl_ = this.element_.lastChild);var b = this.element_.ownerDocument;this.textMeasureEl_.innerHTML = \"\";this.textMeasureEl_.style.font = this.font;this.textMeasureEl_.appendChild(b.createTextNode(a));return { width: this.textMeasureEl_.offsetWidth };\n  };d.clip = function () {};\n  d.arcTo = function () {};d.createPattern = function (a, b) {\n    return new I(a, b);\n  };w.prototype.addColorStop = function (a, b) {\n    b = G(b);this.colors_.push({ offset: a, color: b.color, alpha: b.alpha });\n  };d = A.prototype = Error();d.INDEX_SIZE_ERR = 1;d.DOMSTRING_SIZE_ERR = 2;d.HIERARCHY_REQUEST_ERR = 3;d.WRONG_DOCUMENT_ERR = 4;d.INVALID_CHARACTER_ERR = 5;d.NO_DATA_ALLOWED_ERR = 6;d.NO_MODIFICATION_ALLOWED_ERR = 7;d.NOT_FOUND_ERR = 8;d.NOT_SUPPORTED_ERR = 9;d.INUSE_ATTRIBUTE_ERR = 10;d.INVALID_STATE_ERR = 11;d.SYNTAX_ERR = 12;d.INVALID_MODIFICATION_ERR = 13;d.NAMESPACE_ERR = 14;d.INVALID_ACCESS_ERR = 15;d.VALIDATION_ERR = 16;d.TYPE_MISMATCH_ERR = 17;G_vmlCanvasManager = U;CanvasRenderingContext2D = C;CanvasGradient = w;CanvasPattern = I;DOMException = A;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NsaWVudC9hcHAvQ2FudmFzSlMuanM/ZjA3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gQ2FudmFzSlMgSFRNTDUgJiBKYXZhU2NyaXB0IENoYXJ0cyAtIHYyLjAuMSBHQSAtIGh0dHBzOi8vY2FudmFzanMuY29tLyBcclxuIENvcHlyaWdodCAyMDE3IGZlbm9waXhcclxuXHJcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExpY2Vuc2UgSW5mb3JtYXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuIENhbnZhc0pTIGlzIGEgY29tbWVyY2lhbCBwcm9kdWN0IHdoaWNoIHJlcXVpcmVzIHB1cmNoYXNlIG9mIGxpY2Vuc2UuIFdpdGhvdXQgYSBjb21tZXJjaWFsIGxpY2Vuc2UgeW91IGNhbiB1c2UgaXQgZm9yIGV2YWx1YXRpb24gcHVycG9zZXMgZm9yIHVwdG8gMzAgZGF5cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBmb2xsb3dpbmcgbGluayBmb3IgZnVydGhlciBkZXRhaWxzLlxyXG4gICAgIGh0dHBzOi8vY2FudmFzanMuY29tL2xpY2Vuc2UtY2FudmFzanMvXHJcblxyXG4qL1xyXG4oZnVuY3Rpb24oKXtmdW5jdGlvbiBwYShtLHMpe20ucHJvdG90eXBlPSRhKHMucHJvdG90eXBlKTttLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1tO20uYmFzZT1zLnByb3RvdHlwZX1mdW5jdGlvbiAkYShtKXtmdW5jdGlvbiBzKCl7fXMucHJvdG90eXBlPW07cmV0dXJuIG5ldyBzfWZ1bmN0aW9uIFRhKG0scyxxKXtcIm1pbGxpc2Vjb25kXCI9PT1xP20uc2V0TWlsbGlzZWNvbmRzKG0uZ2V0TWlsbGlzZWNvbmRzKCkrMSpzKTpcInNlY29uZFwiPT09cT9tLnNldFNlY29uZHMobS5nZXRTZWNvbmRzKCkrMSpzKTpcIm1pbnV0ZVwiPT09cT9tLnNldE1pbnV0ZXMobS5nZXRNaW51dGVzKCkrMSpzKTpcImhvdXJcIj09PXE/bS5zZXRIb3VycyhtLmdldEhvdXJzKCkrMSpzKTpcImRheVwiPT09cT9tLnNldERhdGUobS5nZXREYXRlKCkrMSpzKTpcIndlZWtcIj09PXE/bS5zZXREYXRlKG0uZ2V0RGF0ZSgpKzcqcyk6XCJtb250aFwiPT09cT9tLnNldE1vbnRoKG0uZ2V0TW9udGgoKSsxKnMpOlwieWVhclwiPT09cSYmbS5zZXRGdWxsWWVhcihtLmdldEZ1bGxZZWFyKCkrXHJcbjEqcyk7cmV0dXJuIG19ZnVuY3Rpb24gaWEobSxzKXt2YXIgcT0hMTswPm0mJihxPSEwLG0qPS0xKTttPVwiXCIrbTtmb3Iocz1zP3M6MTttLmxlbmd0aDxzOyltPVwiMFwiK207cmV0dXJuIHE/XCItXCIrbTptfWZ1bmN0aW9uIEdhKG0pe2lmKCFtKXJldHVybiBtO209bS5yZXBsYWNlKC9eXFxzXFxzKi8sXCJcIik7Zm9yKHZhciBzPS9cXHMvLHE9bS5sZW5ndGg7cy50ZXN0KG0uY2hhckF0KC0tcSkpOyk7cmV0dXJuIG0uc2xpY2UoMCxxKzEpfWZ1bmN0aW9uIENhKG0pe20ucm91bmRSZWN0PWZ1bmN0aW9uKG0scSx2LHkseCx6LFEsQyl7USYmKHRoaXMuZmlsbFN0eWxlPVEpO0MmJih0aGlzLnN0cm9rZVN0eWxlPUMpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgeCYmKHg9NSk7dGhpcy5saW5lV2lkdGg9ejt0aGlzLmJlZ2luUGF0aCgpO3RoaXMubW92ZVRvKG0reCxxKTt0aGlzLmxpbmVUbyhtK3YteCxxKTt0aGlzLnF1YWRyYXRpY0N1cnZlVG8obSt2LHEsbSt2LHEreCk7dGhpcy5saW5lVG8obSt2LHEreS1cclxueCk7dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKG0rdixxK3ksbSt2LXgscSt5KTt0aGlzLmxpbmVUbyhtK3gscSt5KTt0aGlzLnF1YWRyYXRpY0N1cnZlVG8obSxxK3ksbSxxK3kteCk7dGhpcy5saW5lVG8obSxxK3gpO3RoaXMucXVhZHJhdGljQ3VydmVUbyhtLHEsbSt4LHEpO3RoaXMuY2xvc2VQYXRoKCk7USYmdGhpcy5maWxsKCk7QyYmMDx6JiZ0aGlzLnN0cm9rZSgpfX1mdW5jdGlvbiBQYShtLHMpe3JldHVybiBtLXN9ZnVuY3Rpb24gUihtKXt2YXIgcz0oKG0mMTY3MTE2ODApPj4xNikudG9TdHJpbmcoMTYpLHE9KChtJjY1MjgwKT4+OCkudG9TdHJpbmcoMTYpO209KChtJjI1NSk+PjApLnRvU3RyaW5nKDE2KTtzPTI+cy5sZW5ndGg/XCIwXCIrczpzO3E9Mj5xLmxlbmd0aD9cIjBcIitxOnE7bT0yPm0ubGVuZ3RoP1wiMFwiK206bTtyZXR1cm5cIiNcIitzK3ErbX1mdW5jdGlvbiBhYihtLHMpe3ZhciBxPXRoaXMubGVuZ3RoPj4+MCx2PU51bWJlcihzKXx8MCx2PTA+dj9NYXRoLmNlaWwodik6TWF0aC5mbG9vcih2KTtcclxuZm9yKDA+diYmKHYrPXEpO3Y8cTt2KyspaWYodiBpbiB0aGlzJiZ0aGlzW3ZdPT09bSlyZXR1cm4gdjtyZXR1cm4tMX1mdW5jdGlvbiB5KG0pe3JldHVybiBudWxsPT09bXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBtfWZ1bmN0aW9uIERhKG0pe20uaW5kZXhPZnx8KG0uaW5kZXhPZj1hYik7cmV0dXJuIG19ZnVuY3Rpb24gYmIobSl7aWYoWi5mU0RlYyltW2thKFwiYGVlRHdkb3VNaHJ1ZG9kc1wiKV0oa2EoXCJlYHVgQG9obGB1aG5vSHVkc2B1aG5vRG9lXCIpLGZ1bmN0aW9uKCl7Wi5fZlRXbSYmWi5fZlRXbShtKX0pfWZ1bmN0aW9uIFVhKG0scyxxKXtxPXF8fFwibm9ybWFsXCI7dmFyIHY9bStcIl9cIitzK1wiX1wiK3EseT1WYVt2XTtpZihpc05hTih5KSl7dHJ5e209XCJwb3NpdGlvbjphYnNvbHV0ZTsgbGVmdDowcHg7IHRvcDotMjAwMDBweDsgcGFkZGluZzowcHg7bWFyZ2luOjBweDtib3JkZXI6bm9uZTt3aGl0ZS1zcGFjZTpwcmU7bGluZS1oZWlnaHQ6bm9ybWFsO2ZvbnQtZmFtaWx5OlwiK20rXCI7IGZvbnQtc2l6ZTpcIitcclxucytcInB4OyBmb250LXdlaWdodDpcIitxK1wiO1wiO2lmKCFyYSl7dmFyIHg9ZG9jdW1lbnQuYm9keTtyYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtyYS5pbm5lckhUTUw9XCJcIjt2YXIgej1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIk1wZ3lpXCIpO3JhLmFwcGVuZENoaWxkKHopO3guYXBwZW5kQ2hpbGQocmEpfXJhLnN0eWxlLmRpc3BsYXk9XCJcIjtyYS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLG0pO3k9TWF0aC5yb3VuZChyYS5vZmZzZXRIZWlnaHQpO3JhLnN0eWxlLmRpc3BsYXk9XCJub25lXCJ9Y2F0Y2goUSl7eT1NYXRoLmNlaWwoMS4xKnMpfXk9TWF0aC5tYXgoeSxzKTtWYVt2XT15fXJldHVybiB5fWZ1bmN0aW9uIEcobSxzKXt2YXIgcT1bXTtpZihxPXtzb2xpZDpbXSxzaG9ydERhc2g6WzMsMV0sc2hvcnREb3Q6WzEsMV0sc2hvcnREYXNoRG90OlszLDEsMSwxXSxzaG9ydERhc2hEb3REb3Q6WzMsMSwxLDEsMSwxXSxkb3Q6WzEsMl0sZGFzaDpbNCwyXSxkYXNoRG90Ols0LDIsMSxcclxuMl0sbG9uZ0Rhc2g6WzgsMl0sbG9uZ0Rhc2hEb3Q6WzgsMiwxLDJdLGxvbmdEYXNoRG90RG90Ols4LDIsMSwyLDEsMl19W218fFwic29saWRcIl0pZm9yKHZhciB2PTA7djxxLmxlbmd0aDt2KyspcVt2XSo9cztlbHNlIHE9W107cmV0dXJuIHF9ZnVuY3Rpb24gTihtLHMscSx2KXtyZXR1cm4gbS5hZGRFdmVudExpc3RlbmVyPyhtLmFkZEV2ZW50TGlzdGVuZXIocyxxLHZ8fCExKSxxKTptLmF0dGFjaEV2ZW50Pyh2PWZ1bmN0aW9uKHMpe3M9c3x8d2luZG93LmV2ZW50O3MucHJldmVudERlZmF1bHQ9cy5wcmV2ZW50RGVmYXVsdHx8ZnVuY3Rpb24oKXtzLnJldHVyblZhbHVlPSExfTtzLnN0b3BQcm9wYWdhdGlvbj1zLnN0b3BQcm9wYWdhdGlvbnx8ZnVuY3Rpb24oKXtzLmNhbmNlbEJ1YmJsZT0hMH07cS5jYWxsKG0scyl9LG0uYXR0YWNoRXZlbnQoXCJvblwiK3Msdiksdik6ITF9ZnVuY3Rpb24gV2EobSxzLHEpe20qPWhhO3MqPWhhO209cS5nZXRJbWFnZURhdGEobSxzLDIsMikuZGF0YTtzPVxyXG4hMDtmb3IocT0wOzQ+cTtxKyspaWYobVtxXSE9PW1bcSs0XXxtW3FdIT09bVtxKzhdfG1bcV0hPT1tW3ErMTJdKXtzPSExO2JyZWFrfXJldHVybiBzP21bMF08PDE2fG1bMV08PDh8bVsyXTowfWZ1bmN0aW9uIG5hKG0scyxxKXtyZXR1cm4gbSBpbiBzP3NbbV06cVttXX1mdW5jdGlvbiBIYShtLHMscSl7aWYodiYmWGEpe3ZhciB5PW0uZ2V0Q29udGV4dChcIjJkXCIpO0xhPXkud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8eS5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHx5Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8eS5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8eS5iYWNraW5nU3RvcmVQaXhlbFJhdGlvfHwxO2hhPVFhL0xhO20ud2lkdGg9cypoYTttLmhlaWdodD1xKmhhO1FhIT09TGEmJihtLnN0eWxlLndpZHRoPXMrXCJweFwiLG0uc3R5bGUuaGVpZ2h0PXErXCJweFwiLHkuc2NhbGUoaGEsaGEpKX1lbHNlIG0ud2lkdGg9cyxtLmhlaWdodD1xfWZ1bmN0aW9uIGNiKG0pe2lmKCFZYSl7dmFyIHM9XHJcbiExLHE9ITE7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBzYS5DaGFydC5jcmVkaXRIcmVmPyhtLmNyZWRpdEhyZWY9a2EoXCJpdXVxcjsuLmJgb3dgcmtyL2JubC5cIiksbS5jcmVkaXRUZXh0PWthKFwiQmBvd2ByS1IvYm5sXCIpKToocz1tLnVwZGF0ZU9wdGlvbihcImNyZWRpdFRleHRcIikscT1tLnVwZGF0ZU9wdGlvbihcImNyZWRpdEhyZWZcIikpO2lmKG0uY3JlZGl0SHJlZiYmbS5jcmVkaXRUZXh0KXttLl9jcmVkaXRMaW5rfHwobS5fY3JlZGl0TGluaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSxtLl9jcmVkaXRMaW5rLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsXCJjYW52YXNqcy1jaGFydC1jcmVkaXRcIiksbS5fY3JlZGl0TGluay5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLFwib3V0bGluZTpub25lO21hcmdpbjowcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MnB4O3RvcDpcIisobS5oZWlnaHQtMTQpK1wicHg7Y29sb3I6ZGltZ3JleTt0ZXh0LWRlY29yYXRpb246bm9uZTtmb250LXNpemU6MTFweDtmb250LWZhbWlseTogQ2FsaWJyaSwgTHVjaWRhIEdyYW5kZSwgTHVjaWRhIFNhbnMgVW5pY29kZSwgQXJpYWwsIHNhbnMtc2VyaWZcIiksXHJcbm0uX2NyZWRpdExpbmsuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwtMSksbS5fY3JlZGl0TGluay5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIixcIl9ibGFua1wiKSk7aWYoMD09PW0ucmVuZGVyQ291bnR8fHN8fHEpbS5fY3JlZGl0TGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsbS5jcmVkaXRIcmVmKSxtLl9jcmVkaXRMaW5rLmlubmVySFRNTD1tLmNyZWRpdFRleHQ7bS5fY3JlZGl0TGluayYmbS5jcmVkaXRIcmVmJiZtLmNyZWRpdFRleHQ/KG0uX2NyZWRpdExpbmsucGFyZW50RWxlbWVudHx8bS5fY2FudmFzSlNDb250YWluZXIuYXBwZW5kQ2hpbGQobS5fY3JlZGl0TGluayksbS5fY3JlZGl0TGluay5zdHlsZS50b3A9bS5oZWlnaHQtMTQrXCJweFwiKTptLl9jcmVkaXRMaW5rLnBhcmVudEVsZW1lbnQmJm0uX2NhbnZhc0pTQ29udGFpbmVyLnJlbW92ZUNoaWxkKG0uX2NyZWRpdExpbmspfX19ZnVuY3Rpb24gdWEobSxzKXt2YXIgcT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3Euc2V0QXR0cmlidXRlKFwiY2xhc3NcIixcclxuXCJjYW52YXNqcy1jaGFydC1jYW52YXNcIik7SGEocSxtLHMpO3Z8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgR192bWxDYW52YXNNYW5hZ2VyfHxHX3ZtbENhbnZhc01hbmFnZXIuaW5pdEVsZW1lbnQocSk7cmV0dXJuIHF9ZnVuY3Rpb24gcWEobSxzLHEpe2Zvcih2YXIgdiBpbiBxKXMuc3R5bGVbdl09cVt2XX1mdW5jdGlvbiB2YShtLHMscSl7cy5nZXRBdHRyaWJ1dGUoXCJzdGF0ZVwiKXx8KHMuc3R5bGUuYmFja2dyb3VuZENvbG9yPW0udG9vbGJhci5iYWNrZ3JvdW5kQ29sb3Iscy5zdHlsZS5jb2xvcj1tLnRvb2xiYXIuZm9udENvbG9yLHMuc3R5bGUuYm9yZGVyPVwibm9uZVwiLHFhKG0scyx7V2Via2l0VXNlclNlbGVjdDpcIm5vbmVcIixNb3pVc2VyU2VsZWN0Olwibm9uZVwiLG1zVXNlclNlbGVjdDpcIm5vbmVcIix1c2VyU2VsZWN0Olwibm9uZVwifSkpO3MuZ2V0QXR0cmlidXRlKFwic3RhdGVcIikhPT1xJiYocy5zZXRBdHRyaWJ1dGUoXCJzdGF0ZVwiLHEpLHMuc2V0QXR0cmlidXRlKFwidHlwZVwiLFwiYnV0dG9uXCIpLFxyXG5xYShtLHMse3BhZGRpbmc6XCI1cHggMTJweFwiLGN1cnNvcjpcInBvaW50ZXJcIixcImZsb2F0XCI6XCJsZWZ0XCIsd2lkdGg6XCI0MHB4XCIsaGVpZ2h0OlwiMjVweFwiLG91dGxpbmU6XCIwcHhcIix2ZXJ0aWNhbEFsaWduOlwiYmFzZWxpbmVcIixsaW5lSGVpZ2h0OlwiMFwifSkscy5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLG0uX2N1bHR1cmVJbmZvW3ErXCJUZXh0XCJdKSxzLmlubmVySFRNTD1cIjxpbWcgc3R5bGU9J2hlaWdodDo5NSU7JyBzcmM9J1wiK2RiW3FdLmltYWdlK1wiJyBhbHQ9J1wiK20uX2N1bHR1cmVJbmZvW3ErXCJUZXh0XCJdK1wiJyAvPlwiKX1mdW5jdGlvbiBNYSgpe2Zvcih2YXIgbT1udWxsLHM9MDtzPGFyZ3VtZW50cy5sZW5ndGg7cysrKW09YXJndW1lbnRzW3NdLG0uc3R5bGUmJihtLnN0eWxlLmRpc3BsYXk9XCJpbmxpbmVcIil9ZnVuY3Rpb24gd2EoKXtmb3IodmFyIG09bnVsbCxzPTA7czxhcmd1bWVudHMubGVuZ3RoO3MrKykobT1hcmd1bWVudHNbc10pJiZtLnN0eWxlJiYobS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiKX1cclxuZnVuY3Rpb24gWChtLHMscSx2LHgpe3RoaXMuX2RlZmF1bHRzS2V5PW07dGhpcy5fdGhlbWVPcHRpb25zS2V5PXM7dGhpcy5faW5kZXg9djt0aGlzLnBhcmVudD14O3RoaXMuX2V2ZW50TGlzdGVuZXJzPVtdO209e307dGhpcy50aGVtZSYmeShzKSYmeSh2KT9tPXkoeWFbdGhpcy50aGVtZV0pP3lhLmxpZ2h0MTp5YVt0aGlzLnRoZW1lXTp0aGlzLnBhcmVudCYmKHRoaXMucGFyZW50LnRoZW1lT3B0aW9ucyYmdGhpcy5wYXJlbnQudGhlbWVPcHRpb25zW3NdKSYmKG51bGw9PT12P209dGhpcy5wYXJlbnQudGhlbWVPcHRpb25zW3NdOjA8dGhpcy5wYXJlbnQudGhlbWVPcHRpb25zW3NdLmxlbmd0aCYmKHY9TWF0aC5taW4odGhpcy5wYXJlbnQudGhlbWVPcHRpb25zW3NdLmxlbmd0aC0xLHYpLG09dGhpcy5wYXJlbnQudGhlbWVPcHRpb25zW3NdW3ZdKSk7dGhpcy50aGVtZU9wdGlvbnM9bTt0aGlzLm9wdGlvbnM9cT9xOntfaXNQbGFjZWhvbGRlcjohMH07dGhpcy5zZXRPcHRpb25zKHRoaXMub3B0aW9ucyxcclxubSl9ZnVuY3Rpb24gRWEobSxzLHEsdix5KXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIHkmJih5PTApO3RoaXMuX3BhZGRpbmc9eTt0aGlzLl94MT1tO3RoaXMuX3kxPXM7dGhpcy5feDI9cTt0aGlzLl95Mj12O3RoaXMuX3JpZ2h0T2NjdXBpZWQ9dGhpcy5fbGVmdE9jY3VwaWVkPXRoaXMuX2JvdHRvbU9jY3VwaWVkPXRoaXMuX3RvcE9jY3VwaWVkPXRoaXMuX3BhZGRpbmd9ZnVuY3Rpb24gbGEobSxzKXtsYS5iYXNlLmNvbnN0cnVjdG9yLmNhbGwodGhpcyxcIlRleHRCbG9ja1wiLG51bGwscyxudWxsLG51bGwpO3RoaXMuY3R4PW07dGhpcy5faXNEaXJ0eT0hMDt0aGlzLl93cmFwcGVkVGV4dD1udWxsO3RoaXMuX2luaXRpYWxpemUoKX1mdW5jdGlvbiBSYShtLHMpe1JhLmJhc2UuY29uc3RydWN0b3IuY2FsbCh0aGlzLFwiVG9vbGJhclwiLFwidG9vbGJhclwiLHMsbnVsbCxtKTt0aGlzLmNoYXJ0PW07dGhpcy5jYW52YXM9bS5jYW52YXM7dGhpcy5jdHg9dGhpcy5jaGFydC5jdHg7dGhpcy5vcHRpb25zTmFtZT1cclxuXCJ0b29sYmFyXCJ9ZnVuY3Rpb24gSWEobSxzKXtJYS5iYXNlLmNvbnN0cnVjdG9yLmNhbGwodGhpcyxcIlRpdGxlXCIsXCJ0aXRsZVwiLHMsbnVsbCxtKTt0aGlzLmNoYXJ0PW07dGhpcy5jYW52YXM9bS5jYW52YXM7dGhpcy5jdHg9dGhpcy5jaGFydC5jdHg7dGhpcy5vcHRpb25zTmFtZT1cInRpdGxlXCI7aWYoeSh0aGlzLm9wdGlvbnMubWFyZ2luKSYmbS5vcHRpb25zLnN1YnRpdGxlcylmb3IodmFyIHE9bS5vcHRpb25zLnN1YnRpdGxlcyx2PTA7djxxLmxlbmd0aDt2KyspaWYoKHkocVt2XS5ob3Jpem9udGFsQWxpZ24pJiZcImNlbnRlclwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ258fHFbdl0uaG9yaXpvbnRhbEFsaWduPT09dGhpcy5ob3Jpem9udGFsQWxpZ24pJiYoeShxW3ZdLnZlcnRpY2FsQWxpZ24pJiZcInRvcFwiPT09dGhpcy52ZXJ0aWNhbEFsaWdufHxxW3ZdLnZlcnRpY2FsQWxpZ249PT10aGlzLnZlcnRpY2FsQWxpZ24pJiYhcVt2XS5kb2NrSW5zaWRlUGxvdEFyZWE9PT0hdGhpcy5kb2NrSW5zaWRlUGxvdEFyZWEpe3RoaXMubWFyZ2luPVxyXG4wO2JyZWFrfVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmZvbnRTaXplJiYodGhpcy5mb250U2l6ZT10aGlzLmNoYXJ0LmdldEF1dG9Gb250U2l6ZSh0aGlzLmZvbnRTaXplKSk7dGhpcy5oZWlnaHQ9dGhpcy53aWR0aD1udWxsO3RoaXMuYm91bmRzPXt4MTpudWxsLHkxOm51bGwseDI6bnVsbCx5MjpudWxsfX1mdW5jdGlvbiBOYShtLHMscSl7TmEuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJTdWJ0aXRsZVwiLFwic3VidGl0bGVzXCIscyxxLG0pO3RoaXMuY2hhcnQ9bTt0aGlzLmNhbnZhcz1tLmNhbnZhczt0aGlzLmN0eD10aGlzLmNoYXJ0LmN0eDt0aGlzLm9wdGlvbnNOYW1lPVwic3VidGl0bGVzXCI7dGhpcy5pc09wdGlvbnNJbkFycmF5PSEwO1widW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmZvbnRTaXplJiYodGhpcy5mb250U2l6ZT10aGlzLmNoYXJ0LmdldEF1dG9Gb250U2l6ZSh0aGlzLmZvbnRTaXplKSk7dGhpcy5oZWlnaHQ9dGhpcy53aWR0aD1udWxsO1xyXG50aGlzLmJvdW5kcz17eDE6bnVsbCx5MTpudWxsLHgyOm51bGwseTI6bnVsbH19ZnVuY3Rpb24gSmEobSl7dmFyIHM7bSYmS2FbbV0mJihzPUthW21dKTtKYS5iYXNlLmNvbnN0cnVjdG9yLmNhbGwodGhpcyxcIkN1bHR1cmVJbmZvXCIsbnVsbCxzLG51bGwsbnVsbCl9dmFyIFo9e30sdj0hIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dCxzYT17Q2hhcnQ6e3dpZHRoOjUwMCxoZWlnaHQ6NDAwLHpvb21FbmFibGVkOiExLHpvb21UeXBlOlwieFwiLGJhY2tncm91bmRDb2xvcjpcIndoaXRlXCIsdGhlbWU6XCJsaWdodDFcIixhbmltYXRpb25FbmFibGVkOiExLGFuaW1hdGlvbkR1cmF0aW9uOjEyMDAsZGF0YVBvaW50V2lkdGg6bnVsbCxkYXRhUG9pbnRNaW5XaWR0aDpudWxsLGRhdGFQb2ludE1heFdpZHRoOm51bGwsY29sb3JTZXQ6XCJjb2xvclNldDFcIixjdWx0dXJlOlwiZW5cIixjcmVkaXRIcmVmOlwiXCIsY3JlZGl0VGV4dDpcIkNhbnZhc0pTXCIsaW50ZXJhY3Rpdml0eUVuYWJsZWQ6ITAsXHJcbmV4cG9ydEVuYWJsZWQ6ITEsZXhwb3J0RmlsZU5hbWU6XCJDaGFydFwiLHJhbmdlQ2hhbmdpbmc6bnVsbCxyYW5nZUNoYW5nZWQ6bnVsbCxwdWJsaWNQcm9wZXJ0aWVzOnt0aXRsZTpcInJlYWRXcml0ZVwiLHN1YnRpdGxlczpcInJlYWRXcml0ZVwiLHRvb2xiYXI6XCJyZWFkV3JpdGVcIix0b29sVGlwOlwicmVhZFdyaXRlXCIsbGVnZW5kOlwicmVhZFdyaXRlXCIsYXhpc1g6XCJyZWFkV3JpdGVcIixheGlzWTpcInJlYWRXcml0ZVwiLGF4aXNYMjpcInJlYWRXcml0ZVwiLGF4aXNZMjpcInJlYWRXcml0ZVwiLGRhdGE6XCJyZWFkV3JpdGVcIixvcHRpb25zOlwicmVhZFdyaXRlXCIsYm91bmRzOlwicmVhZE9ubHlcIixjb250YWluZXI6XCJyZWFkT25seVwifX0sVGl0bGU6e3BhZGRpbmc6MCx0ZXh0Om51bGwsdmVydGljYWxBbGlnbjpcInRvcFwiLGhvcml6b250YWxBbGlnbjpcImNlbnRlclwiLGZvbnRTaXplOjIwLGZvbnRGYW1pbHk6XCJDYWxpYnJpXCIsZm9udFdlaWdodDpcIm5vcm1hbFwiLGZvbnRDb2xvcjpcImJsYWNrXCIsZm9udFN0eWxlOlwibm9ybWFsXCIsXHJcbmJvcmRlclRoaWNrbmVzczowLGJvcmRlckNvbG9yOlwiYmxhY2tcIixjb3JuZXJSYWRpdXM6MCxiYWNrZ3JvdW5kQ29sb3I6dj9cInRyYW5zcGFyZW50XCI6bnVsbCxtYXJnaW46NSx3cmFwOiEwLG1heFdpZHRoOm51bGwsZG9ja0luc2lkZVBsb3RBcmVhOiExLHB1YmxpY1Byb3BlcnRpZXM6e29wdGlvbnM6XCJyZWFkV3JpdGVcIixib3VuZHM6XCJyZWFkT25seVwiLGNoYXJ0OlwicmVhZE9ubHlcIn19LFN1YnRpdGxlOntwYWRkaW5nOjAsdGV4dDpudWxsLHZlcnRpY2FsQWxpZ246XCJ0b3BcIixob3Jpem9udGFsQWxpZ246XCJjZW50ZXJcIixmb250U2l6ZToxNCxmb250RmFtaWx5OlwiQ2FsaWJyaVwiLGZvbnRXZWlnaHQ6XCJub3JtYWxcIixmb250Q29sb3I6XCJibGFja1wiLGZvbnRTdHlsZTpcIm5vcm1hbFwiLGJvcmRlclRoaWNrbmVzczowLGJvcmRlckNvbG9yOlwiYmxhY2tcIixjb3JuZXJSYWRpdXM6MCxiYWNrZ3JvdW5kQ29sb3I6bnVsbCxtYXJnaW46Mix3cmFwOiEwLG1heFdpZHRoOm51bGwsZG9ja0luc2lkZVBsb3RBcmVhOiExLFxyXG5wdWJsaWNQcm9wZXJ0aWVzOntvcHRpb25zOlwicmVhZFdyaXRlXCIsYm91bmRzOlwicmVhZE9ubHlcIixjaGFydDpcInJlYWRPbmx5XCJ9fSxUb29sYmFyOntiYWNrZ3JvdW5kQ29sb3I6XCJ3aGl0ZVwiLGJhY2tncm91bmRDb2xvck9uSG92ZXI6XCIjMjE5NmYzXCIsYm9yZGVyQ29sb3I6XCIjMjE5NmYzXCIsYm9yZGVyVGhpY2tuZXNzOjEsZm9udENvbG9yOlwiYmxhY2tcIixmb250Q29sb3JPbkhvdmVyOlwid2hpdGVcIixwdWJsaWNQcm9wZXJ0aWVzOntvcHRpb25zOlwicmVhZFdyaXRlXCIsY2hhcnQ6XCJyZWFkT25seVwifX0sTGVnZW5kOntuYW1lOm51bGwsdmVydGljYWxBbGlnbjpcImNlbnRlclwiLGhvcml6b250YWxBbGlnbjpcInJpZ2h0XCIsZm9udFNpemU6MTQsZm9udEZhbWlseTpcImNhbGlicmlcIixmb250V2VpZ2h0Olwibm9ybWFsXCIsZm9udENvbG9yOlwiYmxhY2tcIixmb250U3R5bGU6XCJub3JtYWxcIixjdXJzb3I6bnVsbCxpdGVtbW91c2VvdmVyOm51bGwsaXRlbW1vdXNlb3V0Om51bGwsaXRlbW1vdXNlbW92ZTpudWxsLFxyXG5pdGVtY2xpY2s6bnVsbCxkb2NrSW5zaWRlUGxvdEFyZWE6ITEscmV2ZXJzZWQ6ITEsYmFja2dyb3VuZENvbG9yOnY/XCJ0cmFuc3BhcmVudFwiOm51bGwsYm9yZGVyQ29sb3I6dj9cInRyYW5zcGFyZW50XCI6bnVsbCxib3JkZXJUaGlja25lc3M6MCxjb3JuZXJSYWRpdXM6MCxtYXhXaWR0aDpudWxsLG1heEhlaWdodDpudWxsLG1hcmtlck1hcmdpbjpudWxsLGl0ZW1NYXhXaWR0aDpudWxsLGl0ZW1XaWR0aDpudWxsLGl0ZW1XcmFwOiEwLGl0ZW1UZXh0Rm9ybWF0dGVyOm51bGwscHVibGljUHJvcGVydGllczp7b3B0aW9uczpcInJlYWRXcml0ZVwiLGJvdW5kczpcInJlYWRPbmx5XCIsY2hhcnQ6XCJyZWFkT25seVwifX0sVG9vbFRpcDp7ZW5hYmxlZDohMCxzaGFyZWQ6ITEsYW5pbWF0aW9uRW5hYmxlZDohMCxjb250ZW50Om51bGwsY29udGVudEZvcm1hdHRlcjpudWxsLHJldmVyc2VkOiExLGJhY2tncm91bmRDb2xvcjp2P1wicmdiYSgyNTUsMjU1LDI1NSwuOSlcIjpcInJnYigyNTUsMjU1LDI1NSlcIixib3JkZXJDb2xvcjpudWxsLFxyXG5ib3JkZXJUaGlja25lc3M6Mixjb3JuZXJSYWRpdXM6NSxmb250U2l6ZToxNCxmb250Q29sb3I6XCJibGFja1wiLGZvbnRGYW1pbHk6XCJDYWxpYnJpLCBBcmlhbCwgR2VvcmdpYSwgc2VyaWY7XCIsZm9udFdlaWdodDpcIm5vcm1hbFwiLGZvbnRTdHlsZTpcIml0YWxpY1wiLHB1YmxpY1Byb3BlcnRpZXM6e29wdGlvbnM6XCJyZWFkV3JpdGVcIixjaGFydDpcInJlYWRPbmx5XCJ9fSxBeGlzOnttaW5pbXVtOm51bGwsbWF4aW11bTpudWxsLHZpZXdwb3J0TWluaW11bTpudWxsLHZpZXdwb3J0TWF4aW11bTpudWxsLGludGVydmFsOm51bGwsaW50ZXJ2YWxUeXBlOm51bGwscmV2ZXJzZWQ6ITEsbG9nYXJpdGhtaWM6ITEsbG9nYXJpdGhtQmFzZToxMCx0aXRsZTpudWxsLHRpdGxlRm9udENvbG9yOlwiYmxhY2tcIix0aXRsZUZvbnRTaXplOjIwLHRpdGxlRm9udEZhbWlseTpcImFyaWFsXCIsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsdGl0bGVGb250U3R5bGU6XCJub3JtYWxcIix0aXRsZVdyYXA6ITAsdGl0bGVNYXhXaWR0aDpudWxsLFxyXG50aXRsZUJhY2tncm91bmRDb2xvcjp2P1widHJhbnNwYXJlbnRcIjpudWxsLHRpdGxlQm9yZGVyQ29sb3I6dj9cInRyYW5zcGFyZW50XCI6bnVsbCx0aXRsZUJvcmRlclRoaWNrbmVzczowLHRpdGxlQ29ybmVyUmFkaXVzOjAsbGFiZWxBbmdsZTowLGxhYmVsRm9udEZhbWlseTpcImFyaWFsXCIsbGFiZWxGb250Q29sb3I6XCJibGFja1wiLGxhYmVsRm9udFNpemU6MTIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250U3R5bGU6XCJub3JtYWxcIixsYWJlbEF1dG9GaXQ6ITAsbGFiZWxXcmFwOiEwLGxhYmVsTWF4V2lkdGg6bnVsbCxsYWJlbEZvcm1hdHRlcjpudWxsLGxhYmVsQmFja2dyb3VuZENvbG9yOnY/XCJ0cmFuc3BhcmVudFwiOm51bGwsbGFiZWxCb3JkZXJDb2xvcjp2P1widHJhbnNwYXJlbnRcIjpudWxsLGxhYmVsQm9yZGVyVGhpY2tuZXNzOjAsbGFiZWxDb3JuZXJSYWRpdXM6MCxsYWJlbFBsYWNlbWVudDpcIm91dHNpZGVcIixwcmVmaXg6XCJcIixzdWZmaXg6XCJcIixpbmNsdWRlWmVybzohMCx0aWNrTGVuZ3RoOjUsXHJcbnRpY2tDb2xvcjpcImJsYWNrXCIsdGlja1RoaWNrbmVzczoxLGxpbmVDb2xvcjpcImJsYWNrXCIsbGluZVRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcInNvbGlkXCIsZ3JpZENvbG9yOlwiQTBBMEEwXCIsZ3JpZFRoaWNrbmVzczowLGdyaWREYXNoVHlwZTpcInNvbGlkXCIsaW50ZXJsYWNlZENvbG9yOnY/XCJ0cmFuc3BhcmVudFwiOm51bGwsdmFsdWVGb3JtYXRTdHJpbmc6bnVsbCxtYXJnaW46MixwdWJsaWNQcm9wZXJ0aWVzOntvcHRpb25zOlwicmVhZFdyaXRlXCIsc3RyaXBMaW5lczpcInJlYWRXcml0ZVwiLHNjYWxlQnJlYWtzOlwicmVhZFdyaXRlXCIsY3Jvc3NoYWlyOlwicmVhZFdyaXRlXCIsYm91bmRzOlwicmVhZE9ubHlcIixjaGFydDpcInJlYWRPbmx5XCJ9fSxTdHJpcExpbmU6e3ZhbHVlOm51bGwsc3RhcnRWYWx1ZTpudWxsLGVuZFZhbHVlOm51bGwsY29sb3I6XCJvcmFuZ2VcIixvcGFjaXR5Om51bGwsdGhpY2tuZXNzOjIsbGluZURhc2hUeXBlOlwic29saWRcIixsYWJlbDpcIlwiLGxhYmVsUGxhY2VtZW50OlwiaW5zaWRlXCIsXHJcbmxhYmVsQWxpZ246XCJmYXJcIixsYWJlbFdyYXA6ITAsbGFiZWxNYXhXaWR0aDpudWxsLGxhYmVsQmFja2dyb3VuZENvbG9yOm51bGwsbGFiZWxCb3JkZXJDb2xvcjp2P1widHJhbnNwYXJlbnRcIjpudWxsLGxhYmVsQm9yZGVyVGhpY2tuZXNzOjAsbGFiZWxDb3JuZXJSYWRpdXM6MCxsYWJlbEZvbnRGYW1pbHk6XCJhcmlhbFwiLGxhYmVsRm9udENvbG9yOlwib3JhbmdlXCIsbGFiZWxGb250U2l6ZToxMixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEZvbnRTdHlsZTpcIm5vcm1hbFwiLGxhYmVsRm9ybWF0dGVyOm51bGwsc2hvd09uVG9wOiExLHB1YmxpY1Byb3BlcnRpZXM6e29wdGlvbnM6XCJyZWFkV3JpdGVcIixheGlzOlwicmVhZE9ubHlcIixib3VuZHM6XCJyZWFkT25seVwiLGNoYXJ0OlwicmVhZE9ubHlcIn19LFNjYWxlQnJlYWtzOnthdXRvQ2FsY3VsYXRlOiExLGNvbGxhcHNpYmxlVGhyZXNob2xkOlwiMjUlXCIsbWF4TnVtYmVyT2ZBdXRvQnJlYWtzOjIsc3BhY2luZzo4LHR5cGU6XCJzdHJhaWdodFwiLFxyXG5jb2xvcjpcIiNGRkZGRkZcIixmaWxsT3BhY2l0eTowLjksbGluZVRoaWNrbmVzczoyLGxpbmVDb2xvcjpcIiNFMTZFNkVcIixsaW5lRGFzaFR5cGU6XCJzb2xpZFwiLHB1YmxpY1Byb3BlcnRpZXM6e29wdGlvbnM6XCJyZWFkV3JpdGVcIixjdXN0b21CcmVha3M6XCJyZWFkV3JpdGVcIixheGlzOlwicmVhZE9ubHlcIixhdXRvQnJlYWtzOlwicmVhZE9ubHlcIixib3VuZHM6XCJyZWFkT25seVwiLGNoYXJ0OlwicmVhZE9ubHlcIn19LEJyZWFrOntzdGFydFZhbHVlOm51bGwsZW5kVmFsdWU6bnVsbCxzcGFjaW5nOjgsdHlwZTpcInN0cmFpZ2h0XCIsY29sb3I6XCIjRkZGRkZGXCIsZmlsbE9wYWNpdHk6MC45LGxpbmVUaGlja25lc3M6MixsaW5lQ29sb3I6XCIjRTE2RTZFXCIsbGluZURhc2hUeXBlOlwic29saWRcIixwdWJsaWNQcm9wZXJ0aWVzOntvcHRpb25zOlwicmVhZFdyaXRlXCIsc2NhbGVCcmVha3M6XCJyZWFkT25seVwiLGJvdW5kczpcInJlYWRPbmx5XCIsY2hhcnQ6XCJyZWFkT25seVwifX0sQ3Jvc3NoYWlyOntlbmFibGVkOiExLHNuYXBUb0RhdGFQb2ludDohMSxcclxuY29sb3I6XCJncmV5XCIsb3BhY2l0eTpudWxsLHRoaWNrbmVzczoyLGxpbmVEYXNoVHlwZTpcInNvbGlkXCIsbGFiZWw6XCJcIixsYWJlbFdyYXA6ITAsbGFiZWxNYXhXaWR0aDpudWxsLGxhYmVsQmFja2dyb3VuZENvbG9yOnY/XCJncmV5XCI6bnVsbCxsYWJlbEJvcmRlckNvbG9yOnY/XCJncmV5XCI6bnVsbCxsYWJlbEJvcmRlclRoaWNrbmVzczowLGxhYmVsQ29ybmVyUmFkaXVzOjAsbGFiZWxGb250RmFtaWx5OnY/XCJDYWxpYnJpLCBPcHRpbWEsIENhbmRhcmEsIFZlcmRhbmEsIEdlbmV2YSwgc2Fucy1zZXJpZlwiOlwiY2FsaWJyaVwiLGxhYmVsRm9udFNpemU6MTIsbGFiZWxGb250Q29sb3I6XCIjZmZmXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250U3R5bGU6XCJub3JtYWxcIixsYWJlbEZvcm1hdHRlcjpudWxsLHZhbHVlRm9ybWF0U3RyaW5nOm51bGwscHVibGljUHJvcGVydGllczp7b3B0aW9uczpcInJlYWRXcml0ZVwiLGF4aXM6XCJyZWFkT25seVwiLGJvdW5kczpcInJlYWRPbmx5XCIsY2hhcnQ6XCJyZWFkT25seVwifX0sXHJcbkRhdGFTZXJpZXM6e25hbWU6bnVsbCxkYXRhUG9pbnRzOm51bGwsbGFiZWw6XCJcIixiZXZlbEVuYWJsZWQ6ITEsaGlnaGxpZ2h0RW5hYmxlZDohMCxjdXJzb3I6XCJkZWZhdWx0XCIsaW5kZXhMYWJlbDpcIlwiLGluZGV4TGFiZWxQbGFjZW1lbnQ6XCJhdXRvXCIsaW5kZXhMYWJlbE9yaWVudGF0aW9uOlwiaG9yaXpvbnRhbFwiLGluZGV4TGFiZWxGb250Q29sb3I6XCJibGFja1wiLGluZGV4TGFiZWxGb250U2l6ZToxMixpbmRleExhYmVsRm9udFN0eWxlOlwibm9ybWFsXCIsaW5kZXhMYWJlbEZvbnRGYW1pbHk6XCJBcmlhbFwiLGluZGV4TGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsaW5kZXhMYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGluZGV4TGFiZWxMaW5lQ29sb3I6XCJncmF5XCIsaW5kZXhMYWJlbExpbmVUaGlja25lc3M6MSxpbmRleExhYmVsTGluZURhc2hUeXBlOlwic29saWRcIixpbmRleExhYmVsTWF4V2lkdGg6bnVsbCxpbmRleExhYmVsV3JhcDohMCxpbmRleExhYmVsRm9ybWF0dGVyOm51bGwsbGluZVRoaWNrbmVzczoyLFxyXG5saW5lRGFzaFR5cGU6XCJzb2xpZFwiLGNvbm5lY3ROdWxsRGF0YTohMSxudWxsRGF0YUxpbmVEYXNoVHlwZTpcImRhc2hcIixjb2xvcjpudWxsLGxpbmVDb2xvcjpudWxsLHJpc2luZ0NvbG9yOlwid2hpdGVcIixmYWxsaW5nQ29sb3I6XCJyZWRcIixmaWxsT3BhY2l0eTpudWxsLHN0YXJ0QW5nbGU6MCxyYWRpdXM6bnVsbCxpbm5lclJhZGl1czpudWxsLG5lY2tIZWlnaHQ6bnVsbCxuZWNrV2lkdGg6bnVsbCxyZXZlcnNlZDohMSx2YWx1ZVJlcHJlc2VudHM6bnVsbCxsaW5rZWREYXRhU2VyaWVzSW5kZXg6bnVsbCx3aGlza2VyVGhpY2tuZXNzOjIsd2hpc2tlckRhc2hUeXBlOlwic29saWRcIix3aGlza2VyQ29sb3I6bnVsbCx3aGlza2VyTGVuZ3RoOm51bGwsc3RlbVRoaWNrbmVzczoyLHN0ZW1Db2xvcjpudWxsLHN0ZW1EYXNoVHlwZTpcInNvbGlkXCIsdXBwZXJCb3hDb2xvcjpcIndoaXRlXCIsbG93ZXJCb3hDb2xvcjpcIndoaXRlXCIsdHlwZTpcImNvbHVtblwiLHhWYWx1ZVR5cGU6XCJudW1iZXJcIixheGlzWFR5cGU6XCJwcmltYXJ5XCIsXHJcbmF4aXNZVHlwZTpcInByaW1hcnlcIixheGlzWEluZGV4OjAsYXhpc1lJbmRleDowLHhWYWx1ZUZvcm1hdFN0cmluZzpudWxsLHlWYWx1ZUZvcm1hdFN0cmluZzpudWxsLHpWYWx1ZUZvcm1hdFN0cmluZzpudWxsLHBlcmNlbnRGb3JtYXRTdHJpbmc6bnVsbCxzaG93SW5MZWdlbmQ6bnVsbCxsZWdlbmRNYXJrZXJUeXBlOm51bGwsbGVnZW5kTWFya2VyQ29sb3I6bnVsbCxsZWdlbmRUZXh0Om51bGwsbGVnZW5kTWFya2VyQm9yZGVyQ29sb3I6dj9cInRyYW5zcGFyZW50XCI6bnVsbCxsZWdlbmRNYXJrZXJCb3JkZXJUaGlja25lc3M6MCxtYXJrZXJUeXBlOlwiY2lyY2xlXCIsbWFya2VyQ29sb3I6bnVsbCxtYXJrZXJTaXplOm51bGwsbWFya2VyQm9yZGVyQ29sb3I6dj9cInRyYW5zcGFyZW50XCI6bnVsbCxtYXJrZXJCb3JkZXJUaGlja25lc3M6MCxtb3VzZW92ZXI6bnVsbCxtb3VzZW91dDpudWxsLG1vdXNlbW92ZTpudWxsLGNsaWNrOm51bGwsdG9vbFRpcENvbnRlbnQ6bnVsbCx2aXNpYmxlOiEwLHB1YmxpY1Byb3BlcnRpZXM6e29wdGlvbnM6XCJyZWFkV3JpdGVcIixcclxuYXhpc1g6XCJyZWFkV3JpdGVcIixheGlzWTpcInJlYWRXcml0ZVwiLGNoYXJ0OlwicmVhZE9ubHlcIn19LFRleHRCbG9jazp7eDowLHk6MCx3aWR0aDpudWxsLGhlaWdodDpudWxsLG1heFdpZHRoOm51bGwsbWF4SGVpZ2h0Om51bGwscGFkZGluZzowLGFuZ2xlOjAsdGV4dDpcIlwiLGhvcml6b250YWxBbGlnbjpcImNlbnRlclwiLGZvbnRTaXplOjEyLGZvbnRGYW1pbHk6XCJjYWxpYnJpXCIsZm9udFdlaWdodDpcIm5vcm1hbFwiLGZvbnRDb2xvcjpcImJsYWNrXCIsZm9udFN0eWxlOlwibm9ybWFsXCIsYm9yZGVyVGhpY2tuZXNzOjAsYm9yZGVyQ29sb3I6XCJibGFja1wiLGNvcm5lclJhZGl1czowLGJhY2tncm91bmRDb2xvcjpudWxsLHRleHRCYXNlbGluZTpcInRvcFwifSxDdWx0dXJlSW5mbzp7ZGVjaW1hbFNlcGFyYXRvcjpcIi5cIixkaWdpdEdyb3VwU2VwYXJhdG9yOlwiLFwiLHpvb21UZXh0OlwiWm9vbVwiLHBhblRleHQ6XCJQYW5cIixyZXNldFRleHQ6XCJSZXNldFwiLG1lbnVUZXh0OlwiTW9yZSBPcHRpb25zXCIsc2F2ZUpQR1RleHQ6XCJTYXZlIGFzIEpQRUdcIixcclxuc2F2ZVBOR1RleHQ6XCJTYXZlIGFzIFBOR1wiLHByaW50VGV4dDpcIlByaW50XCIsZGF5czpcIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLHNob3J0RGF5czpcIlN1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdFwiLnNwbGl0KFwiIFwiKSxtb250aHM6XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWNcIi5zcGxpdChcIiBcIil9fSxLYT17ZW46e319LHg9dj9cIlRyZWJ1Y2hldCBNUywgSGVsdmV0aWNhLCBzYW5zLXNlcmlmXCI6XCJBcmlhbFwiLEZhPXY/XCJJbXBhY3QsIENoYXJjb2FsLCBzYW5zLXNlcmlmXCI6XCJBcmlhbFwiLEFhPXtjb2xvclNldDE6XCIjNEY4MUJDICNDMDUwNEUgIzlCQkI1OCAjMjNCRkFBICM4MDY0QTEgIzRBQUNDNSAjRjc5NjQ3ICM3RjYwODQgIzc3QTAzMyAjMzM1NThCICNFNTk1NjZcIi5zcGxpdChcIiBcIiksXHJcbmNvbG9yU2V0MjpcIiM2RDc4QUQgIzUxQ0RBMCAjREY3OTcwICM0QzlDQTAgI0FFN0Q5OSAjQzlENDVDICM1NTkyQUQgI0RGODc0RCAjNTJCQ0E4ICM4RTdBQTMgI0UzQ0I2NCAjQzc3Qjg1ICNDMzk3NjIgIzhERDE3RSAjQjU3OTUyICNGQ0MyNkNcIi5zcGxpdChcIiBcIiksY29sb3JTZXQzOlwiIzhDQTFCQyAjMzY4NDVDICMwMTdFODIgIzhDQjlEMCAjNzA4Qzk4ICM5NDgzOEQgI0YwODg5MSAjMDM2NkE3ICMwMDgyNzYgI0VFNzc1NyAjRTVCQTNBICNGMjk5MEIgIzAzNTU3QiAjNzgyOTcwXCIuc3BsaXQoXCIgXCIpfSxPLGdhLFQsWSxmYTtnYT1cIiMzMzMzMzNcIjtUPVwiIzAwMDAwMFwiO089XCIjNjY2NjY2XCI7ZmE9WT1cIiMwMDAwMDBcIjt2YXIgYWE9MjAsej0xNCxTYT17Y29sb3JTZXQ6XCJjb2xvclNldDFcIixiYWNrZ3JvdW5kQ29sb3I6XCIjRkZGRkZGXCIsdGl0bGU6e2ZvbnRGYW1pbHk6RmEsZm9udFNpemU6MzIsZm9udENvbG9yOmdhLGZvbnRXZWlnaHQ6XCJub3JtYWxcIix2ZXJ0aWNhbEFsaWduOlwidG9wXCIsXHJcbm1hcmdpbjo1fSxzdWJ0aXRsZXM6W3tmb250RmFtaWx5OkZhLGZvbnRTaXplOnosZm9udENvbG9yOmdhLGZvbnRXZWlnaHQ6XCJub3JtYWxcIix2ZXJ0aWNhbEFsaWduOlwidG9wXCIsbWFyZ2luOjV9XSxkYXRhOlt7aW5kZXhMYWJlbEZvbnRGYW1pbHk6eCxpbmRleExhYmVsRm9udFNpemU6eixpbmRleExhYmVsRm9udENvbG9yOmdhLGluZGV4TGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsaW5kZXhMYWJlbExpbmVUaGlja25lc3M6MX1dLGF4aXNYOlt7dGl0bGVGb250RmFtaWx5OngsdGl0bGVGb250U2l6ZTphYSx0aXRsZUZvbnRDb2xvcjpnYSx0aXRsZUZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6VCxsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsaW5lVGhpY2tuZXNzOjEsbGluZUNvbG9yOk8sdGlja1RoaWNrbmVzczoxLHRpY2tDb2xvcjpPLGdyaWRUaGlja25lc3M6MCxncmlkQ29sb3I6TyxzdHJpcExpbmVzOlt7bGFiZWxGb250RmFtaWx5OngsXHJcbmxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpcIiNGRjczMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGNzMwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjRUVFRUVFXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6ZmEsY29sb3I6WSx0aGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJkYXNoXCJ9LHNjYWxlQnJlYWtzOnt0eXBlOlwiemlnemFnXCIsc3BhY2luZzpcIjIlXCIsbGluZUNvbG9yOlwiI0JCQkJCQlwiLGxpbmVUaGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJzb2xpZFwifX1dLGF4aXNYMjpbe3RpdGxlRm9udEZhbWlseTp4LHRpdGxlRm9udFNpemU6YWEsdGl0bGVGb250Q29sb3I6Z2EsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LFxyXG5sYWJlbEZvbnRDb2xvcjpULGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxpbmVUaGlja25lc3M6MSxsaW5lQ29sb3I6Tyx0aWNrVGhpY2tuZXNzOjEsdGlja0NvbG9yOk8sZ3JpZFRoaWNrbmVzczowLGdyaWRDb2xvcjpPLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjRkY3MzAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6bnVsbCxjb2xvcjpcIiNGRjczMDBcIix0aGlja25lc3M6MX1dLGNyb3NzaGFpcjp7bGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlwiI0VFRUVFRVwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOmZhLGNvbG9yOlksdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZGFzaFwifSxzY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiNCQkJCQkJcIixsaW5lVGhpY2tuZXNzOjEsXHJcbmxpbmVEYXNoVHlwZTpcInNvbGlkXCJ9fV0sYXhpc1k6W3t0aXRsZUZvbnRGYW1pbHk6eCx0aXRsZUZvbnRTaXplOmFhLHRpdGxlRm9udENvbG9yOmdhLHRpdGxlRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpULGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxpbmVUaGlja25lc3M6MSxsaW5lQ29sb3I6Tyx0aWNrVGhpY2tuZXNzOjEsdGlja0NvbG9yOk8sZ3JpZFRoaWNrbmVzczoxLGdyaWRDb2xvcjpPLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjRkY3MzAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6bnVsbCxjb2xvcjpcIiNGRjczMDBcIix0aGlja25lc3M6MX1dLGNyb3NzaGFpcjp7bGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlwiI0VFRUVFRVwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLFxyXG5sYWJlbEJhY2tncm91bmRDb2xvcjpmYSxjb2xvcjpZLHRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcImRhc2hcIn0sc2NhbGVCcmVha3M6e3R5cGU6XCJ6aWd6YWdcIixzcGFjaW5nOlwiMiVcIixsaW5lQ29sb3I6XCIjQkJCQkJCXCIsbGluZVRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcInNvbGlkXCJ9fV0sYXhpc1kyOlt7dGl0bGVGb250RmFtaWx5OngsdGl0bGVGb250U2l6ZTphYSx0aXRsZUZvbnRDb2xvcjpnYSx0aXRsZUZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6VCxsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsaW5lVGhpY2tuZXNzOjEsbGluZUNvbG9yOk8sdGlja1RoaWNrbmVzczoxLHRpY2tDb2xvcjpPLGdyaWRUaGlja25lc3M6MSxncmlkQ29sb3I6TyxzdHJpcExpbmVzOlt7bGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlwiI0ZGNzMwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLFxyXG5sYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGNzMwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjRUVFRUVFXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6ZmEsY29sb3I6WSx0aGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJkYXNoXCJ9LHNjYWxlQnJlYWtzOnt0eXBlOlwiemlnemFnXCIsc3BhY2luZzpcIjIlXCIsbGluZUNvbG9yOlwiI0JCQkJCQlwiLGxpbmVUaGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJzb2xpZFwifX1dLGxlZ2VuZDp7Zm9udEZhbWlseTp4LGZvbnRTaXplOjE0LGZvbnRDb2xvcjpnYSxmb250V2VpZ2h0OlwiYm9sZFwiLHZlcnRpY2FsQWxpZ246XCJib3R0b21cIixob3Jpem9udGFsQWxpZ246XCJjZW50ZXJcIn0sdG9vbFRpcDp7Zm9udEZhbWlseTp4LGZvbnRTaXplOjE0LGZvbnRTdHlsZTpcIm5vcm1hbFwiLGNvcm5lclJhZGl1czowLGJvcmRlclRoaWNrbmVzczoxfX07XHJcblQ9Z2E9XCIjRjVGNUY1XCI7Tz1cIiNGRkZGRkZcIjtZPVwiIzQwQkFGMVwiO2ZhPVwiI0Y1RjVGNVwiO3ZhciBhYT0yMCx6PTE0LFphPXtjb2xvclNldDpcImNvbG9yU2V0MlwiLHRpdGxlOntmb250RmFtaWx5OngsZm9udFNpemU6MzMsZm9udENvbG9yOlwiIzNBM0EzQVwiLGZvbnRXZWlnaHQ6XCJib2xkXCIsdmVydGljYWxBbGlnbjpcInRvcFwiLG1hcmdpbjo1fSxzdWJ0aXRsZXM6W3tmb250RmFtaWx5OngsZm9udFNpemU6eixmb250Q29sb3I6XCIjM0EzQTNBXCIsZm9udFdlaWdodDpcIm5vcm1hbFwiLHZlcnRpY2FsQWxpZ246XCJ0b3BcIixtYXJnaW46NX1dLGRhdGE6W3tpbmRleExhYmVsRm9udEZhbWlseTp4LGluZGV4TGFiZWxGb250U2l6ZTp6LGluZGV4TGFiZWxGb250Q29sb3I6XCIjNjY2NjY2XCIsaW5kZXhMYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixpbmRleExhYmVsTGluZVRoaWNrbmVzczoxfV0sYXhpc1g6W3t0aXRsZUZvbnRGYW1pbHk6eCx0aXRsZUZvbnRTaXplOmFhLHRpdGxlRm9udENvbG9yOlwiIzY2NjY2NlwiLFxyXG50aXRsZUZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjNjY2NjY2XCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczoxLGxpbmVDb2xvcjpcIiNCQkJCQkJcIix0aWNrVGhpY2tuZXNzOjEsdGlja0NvbG9yOlwiI0JCQkJCQlwiLGdyaWRUaGlja25lc3M6MSxncmlkQ29sb3I6XCIjQkJCQkJCXCIsc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpcIiNGRkE1MDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGQTUwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjRUVFRUVFXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6XCJibGFja1wiLGNvbG9yOlwiYmxhY2tcIixcclxudGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZG90XCJ9LHNjYWxlQnJlYWtzOnt0eXBlOlwiemlnemFnXCIsc3BhY2luZzpcIjIlXCIsbGluZUNvbG9yOlwiI0JCQkJCQlwiLGxpbmVUaGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJzb2xpZFwifX1dLGF4aXNYMjpbe3RpdGxlRm9udEZhbWlseTp4LHRpdGxlRm9udFNpemU6YWEsdGl0bGVGb250Q29sb3I6XCIjNjY2NjY2XCIsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlwiIzY2NjY2NlwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxpbmVUaGlja25lc3M6MSxsaW5lQ29sb3I6XCIjQkJCQkJCXCIsdGlja0NvbG9yOlwiI0JCQkJCQlwiLHRpY2tUaGlja25lc3M6MSxncmlkVGhpY2tuZXNzOjEsZ3JpZENvbG9yOlwiI0JCQkJCQlwiLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjRkZBNTAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsXHJcbmxhYmVsQmFja2dyb3VuZENvbG9yOm51bGwsY29sb3I6XCIjRkZBNTAwXCIsdGhpY2tuZXNzOjF9XSxjcm9zc2hhaXI6e2xhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpcIiNFRUVFRUVcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpcImJsYWNrXCIsY29sb3I6XCJibGFja1wiLHRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcImRvdFwifSxzY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiNCQkJCQkJcIixsaW5lVGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwic29saWRcIn19XSxheGlzWTpbe3RpdGxlRm9udEZhbWlseTp4LHRpdGxlRm9udFNpemU6YWEsdGl0bGVGb250Q29sb3I6XCIjNjY2NjY2XCIsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlwiIzY2NjY2NlwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLFxyXG5saW5lVGhpY2tuZXNzOjAsbGluZUNvbG9yOlwiI0JCQkJCQlwiLHRpY2tDb2xvcjpcIiNCQkJCQkJcIix0aWNrVGhpY2tuZXNzOjEsZ3JpZFRoaWNrbmVzczoxLGdyaWRDb2xvcjpcIiNCQkJCQkJcIixzdHJpcExpbmVzOlt7bGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlwiI0ZGQTUwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOm51bGwsY29sb3I6XCIjRkZBNTAwXCIsdGhpY2tuZXNzOjF9XSxjcm9zc2hhaXI6e2xhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpcIiNFRUVFRUVcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpcImJsYWNrXCIsY29sb3I6XCJibGFja1wiLHRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcImRvdFwifSxzY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiNCQkJCQkJcIixsaW5lVGhpY2tuZXNzOjEsXHJcbmxpbmVEYXNoVHlwZTpcInNvbGlkXCJ9fV0sYXhpc1kyOlt7dGl0bGVGb250RmFtaWx5OngsdGl0bGVGb250U2l6ZTphYSx0aXRsZUZvbnRDb2xvcjpcIiM2NjY2NjZcIix0aXRsZUZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjNjY2NjY2XCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczowLGxpbmVDb2xvcjpcIiNCQkJCQkJcIix0aWNrQ29sb3I6XCIjQkJCQkJCXCIsdGlja1RoaWNrbmVzczoxLGdyaWRUaGlja25lc3M6MSxncmlkQ29sb3I6XCIjQkJCQkJCXCIsc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpcIiNGRkE1MDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGQTUwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosXHJcbmxhYmVsRm9udENvbG9yOlwiI0VFRUVFRVwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOlwiYmxhY2tcIixjb2xvcjpcImJsYWNrXCIsdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZG90XCJ9LHNjYWxlQnJlYWtzOnt0eXBlOlwiemlnemFnXCIsc3BhY2luZzpcIjIlXCIsbGluZUNvbG9yOlwiI0JCQkJCQlwiLGxpbmVUaGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJzb2xpZFwifX1dLGxlZ2VuZDp7Zm9udEZhbWlseTp4LGZvbnRTaXplOjE0LGZvbnRDb2xvcjpcIiMzQTNBM0FcIixmb250V2VpZ2h0OlwiYm9sZFwiLHZlcnRpY2FsQWxpZ246XCJib3R0b21cIixob3Jpem9udGFsQWxpZ246XCJjZW50ZXJcIn0sdG9vbFRpcDp7Zm9udEZhbWlseTp4LGZvbnRTaXplOjE0LGZvbnRTdHlsZTpcIm5vcm1hbFwiLGNvcm5lclJhZGl1czowLGJvcmRlclRoaWNrbmVzczoxfX07VD1nYT1cIiNGNUY1RjVcIjtPPVwiI0ZGRkZGRlwiO1k9XCIjNDBCQUYxXCI7ZmE9XCIjRjVGNUY1XCI7YWE9MjA7ej0xNDtGYT17Y29sb3JTZXQ6XCJjb2xvclNldDEyXCIsXHJcbmJhY2tncm91bmRDb2xvcjpcIiMyQTJBMkFcIix0aXRsZTp7Zm9udEZhbWlseTpGYSxmb250U2l6ZTozMixmb250Q29sb3I6Z2EsZm9udFdlaWdodDpcIm5vcm1hbFwiLHZlcnRpY2FsQWxpZ246XCJ0b3BcIixtYXJnaW46NX0sc3VidGl0bGVzOlt7Zm9udEZhbWlseTpGYSxmb250U2l6ZTp6LGZvbnRDb2xvcjpnYSxmb250V2VpZ2h0Olwibm9ybWFsXCIsdmVydGljYWxBbGlnbjpcInRvcFwiLG1hcmdpbjo1fV0sdG9vbGJhcjp7YmFja2dyb3VuZENvbG9yOlwiIzY2NjY2NlwiLGJhY2tncm91bmRDb2xvck9uSG92ZXI6XCIjRkY3MzcyXCIsYm9yZGVyQ29sb3I6XCIjRkY3MzcyXCIsYm9yZGVyVGhpY2tuZXNzOjEsZm9udENvbG9yOlwiI0Y1RjVGNVwiLGZvbnRDb2xvck9uSG92ZXI6XCIjRjVGNUY1XCJ9LGRhdGE6W3tpbmRleExhYmVsRm9udEZhbWlseTp4LGluZGV4TGFiZWxGb250U2l6ZTp6LGluZGV4TGFiZWxGb250Q29sb3I6VCxpbmRleExhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGluZGV4TGFiZWxMaW5lVGhpY2tuZXNzOjF9XSxcclxuYXhpc1g6W3t0aXRsZUZvbnRGYW1pbHk6eCx0aXRsZUZvbnRTaXplOmFhLHRpdGxlRm9udENvbG9yOlQsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlQsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczoxLGxpbmVDb2xvcjpPLHRpY2tUaGlja25lc3M6MSx0aWNrQ29sb3I6TyxncmlkVGhpY2tuZXNzOjAsZ3JpZENvbG9yOk8sc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpcIiNGRjczMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGNzMwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjMDAwMDAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6ZmEsXHJcbmNvbG9yOlksdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZGFzaFwifSxzY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiM3Nzc3NzdcIixsaW5lVGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwic29saWRcIixjb2xvcjpcIiMxMTExMTFcIn19XSxheGlzWDI6W3t0aXRsZUZvbnRGYW1pbHk6eCx0aXRsZUZvbnRTaXplOmFhLHRpdGxlRm9udENvbG9yOlQsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlQsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczoxLGxpbmVDb2xvcjpPLHRpY2tUaGlja25lc3M6MSx0aWNrQ29sb3I6TyxncmlkVGhpY2tuZXNzOjAsZ3JpZENvbG9yOk8sc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpcIiNGRjczMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLFxyXG5jb2xvcjpcIiNGRjczMDBcIix0aGlja25lc3M6MX1dLGNyb3NzaGFpcjp7bGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlwiIzAwMDAwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOmZhLGNvbG9yOlksdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZGFzaFwifSxzY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiM3Nzc3NzdcIixsaW5lVGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwic29saWRcIixjb2xvcjpcIiMxMTExMTFcIn19XSxheGlzWTpbe3RpdGxlRm9udEZhbWlseTp4LHRpdGxlRm9udFNpemU6YWEsdGl0bGVGb250Q29sb3I6VCx0aXRsZUZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6VCxsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsaW5lVGhpY2tuZXNzOjEsbGluZUNvbG9yOk8sdGlja1RoaWNrbmVzczoxLFxyXG50aWNrQ29sb3I6TyxncmlkVGhpY2tuZXNzOjEsZ3JpZENvbG9yOk8sc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpcIiNGRjczMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGNzMwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjMDAwMDAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6ZmEsY29sb3I6WSx0aGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJkYXNoXCJ9LHNjYWxlQnJlYWtzOnt0eXBlOlwiemlnemFnXCIsc3BhY2luZzpcIjIlXCIsbGluZUNvbG9yOlwiIzc3Nzc3N1wiLGxpbmVUaGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJzb2xpZFwiLGNvbG9yOlwiIzExMTExMVwifX1dLGF4aXNZMjpbe3RpdGxlRm9udEZhbWlseTp4LHRpdGxlRm9udFNpemU6YWEsXHJcbnRpdGxlRm9udENvbG9yOlQsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlQsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczoxLGxpbmVDb2xvcjpPLHRpY2tUaGlja25lc3M6MSx0aWNrQ29sb3I6TyxncmlkVGhpY2tuZXNzOjEsZ3JpZENvbG9yOk8sc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpcIiNGRjczMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGNzMwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjMDAwMDAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6ZmEsY29sb3I6WSx0aGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJkYXNoXCJ9LFxyXG5zY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiM3Nzc3NzdcIixsaW5lVGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwic29saWRcIixjb2xvcjpcIiMxMTExMTFcIn19XSxsZWdlbmQ6e2ZvbnRGYW1pbHk6eCxmb250U2l6ZToxNCxmb250Q29sb3I6Z2EsZm9udFdlaWdodDpcImJvbGRcIix2ZXJ0aWNhbEFsaWduOlwiYm90dG9tXCIsaG9yaXpvbnRhbEFsaWduOlwiY2VudGVyXCJ9LHRvb2xUaXA6e2ZvbnRGYW1pbHk6eCxmb250U2l6ZToxNCxmb250U3R5bGU6XCJub3JtYWxcIixjb3JuZXJSYWRpdXM6MCxib3JkZXJUaGlja25lc3M6MSxmb250Q29sb3I6VCxiYWNrZ3JvdW5kQ29sb3I6XCJyZ2JhKDAsIDAsIDAsIC43KVwifX07Tz1cIiNGRkZGRkZcIjtUPWdhPVwiI0ZBRkFGQVwiO1k9XCIjNDBCQUYxXCI7ZmE9XCIjRjVGNUY1XCI7dmFyIGFhPTIwLHo9MTQseWE9e2xpZ2h0MTpTYSxsaWdodDI6WmEsZGFyazE6RmEsZGFyazI6e2NvbG9yU2V0OlwiY29sb3JTZXQyXCIsYmFja2dyb3VuZENvbG9yOlwiIzMyMzczQVwiLFxyXG50aXRsZTp7Zm9udEZhbWlseTp4LGZvbnRTaXplOjMyLGZvbnRDb2xvcjpnYSxmb250V2VpZ2h0Olwibm9ybWFsXCIsdmVydGljYWxBbGlnbjpcInRvcFwiLG1hcmdpbjo1fSxzdWJ0aXRsZXM6W3tmb250RmFtaWx5OngsZm9udFNpemU6eixmb250Q29sb3I6Z2EsZm9udFdlaWdodDpcIm5vcm1hbFwiLHZlcnRpY2FsQWxpZ246XCJ0b3BcIixtYXJnaW46NX1dLHRvb2xiYXI6e2JhY2tncm91bmRDb2xvcjpcIiM2NjY2NjZcIixiYWNrZ3JvdW5kQ29sb3JPbkhvdmVyOlwiI0ZGNzM3MlwiLGJvcmRlckNvbG9yOlwiI0ZGNzM3MlwiLGJvcmRlclRoaWNrbmVzczoxLGZvbnRDb2xvcjpcIiNGNUY1RjVcIixmb250Q29sb3JPbkhvdmVyOlwiI0Y1RjVGNVwifSxkYXRhOlt7aW5kZXhMYWJlbEZvbnRGYW1pbHk6eCxpbmRleExhYmVsRm9udFNpemU6eixpbmRleExhYmVsRm9udENvbG9yOlQsaW5kZXhMYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixpbmRleExhYmVsTGluZVRoaWNrbmVzczoxfV0sYXhpc1g6W3t0aXRsZUZvbnRGYW1pbHk6eCxcclxudGl0bGVGb250U2l6ZTphYSx0aXRsZUZvbnRDb2xvcjpULHRpdGxlRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpULGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxpbmVUaGlja25lc3M6MSxsaW5lQ29sb3I6Tyx0aWNrVGhpY2tuZXNzOjEsdGlja0NvbG9yOk8sZ3JpZFRoaWNrbmVzczowLGdyaWRDb2xvcjpPLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjRkY3MzAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6bnVsbCxjb2xvcjpcIiNGRjczMDBcIix0aGlja25lc3M6MX1dLGNyb3NzaGFpcjp7bGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlwiIzAwMDAwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOmZhLGNvbG9yOlksdGhpY2tuZXNzOjEsXHJcbmxpbmVEYXNoVHlwZTpcImRhc2hcIn0sc2NhbGVCcmVha3M6e3R5cGU6XCJ6aWd6YWdcIixzcGFjaW5nOlwiMiVcIixsaW5lQ29sb3I6XCIjNzc3Nzc3XCIsbGluZVRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcInNvbGlkXCIsY29sb3I6XCIjMTExMTExXCJ9fV0sYXhpc1gyOlt7dGl0bGVGb250RmFtaWx5OngsdGl0bGVGb250U2l6ZTphYSx0aXRsZUZvbnRDb2xvcjpULHRpdGxlRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpULGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxpbmVUaGlja25lc3M6MSxsaW5lQ29sb3I6Tyx0aWNrVGhpY2tuZXNzOjEsdGlja0NvbG9yOk8sZ3JpZFRoaWNrbmVzczowLGdyaWRDb2xvcjpPLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjRkY3MzAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6bnVsbCxcclxuY29sb3I6XCIjRkY3MzAwXCIsdGhpY2tuZXNzOjF9XSxjcm9zc2hhaXI6e2xhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpcIiMwMDAwMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpmYSxjb2xvcjpZLHRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcImRhc2hcIn0sc2NhbGVCcmVha3M6e3R5cGU6XCJ6aWd6YWdcIixzcGFjaW5nOlwiMiVcIixsaW5lQ29sb3I6XCIjNzc3Nzc3XCIsbGluZVRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcInNvbGlkXCIsY29sb3I6XCIjMTExMTExXCJ9fV0sYXhpc1k6W3t0aXRsZUZvbnRGYW1pbHk6eCx0aXRsZUZvbnRTaXplOmFhLHRpdGxlRm9udENvbG9yOlQsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlQsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczowLGxpbmVDb2xvcjpPLHRpY2tUaGlja25lc3M6MSxcclxudGlja0NvbG9yOk8sZ3JpZFRoaWNrbmVzczoxLGdyaWRDb2xvcjpPLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjRkY3MzAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6bnVsbCxjb2xvcjpcIiNGRjczMDBcIix0aGlja25lc3M6MX1dLGNyb3NzaGFpcjp7bGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlwiIzAwMDAwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOmZhLGNvbG9yOlksdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZGFzaFwifSxzY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiM3Nzc3NzdcIixsaW5lVGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwic29saWRcIixjb2xvcjpcIiMxMTExMTFcIn19XSxheGlzWTI6W3t0aXRsZUZvbnRGYW1pbHk6eCx0aXRsZUZvbnRTaXplOmFhLFxyXG50aXRsZUZvbnRDb2xvcjpULHRpdGxlRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsRm9udEZhbWlseTp4LGxhYmVsRm9udFNpemU6eixsYWJlbEZvbnRDb2xvcjpULGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxpbmVUaGlja25lc3M6MCxsaW5lQ29sb3I6Tyx0aWNrVGhpY2tuZXNzOjEsdGlja0NvbG9yOk8sZ3JpZFRoaWNrbmVzczoxLGdyaWRDb2xvcjpPLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6eCxsYWJlbEZvbnRTaXplOnosbGFiZWxGb250Q29sb3I6XCIjRkY3MzAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6bnVsbCxjb2xvcjpcIiNGRjczMDBcIix0aGlja25lc3M6MX1dLGNyb3NzaGFpcjp7bGFiZWxGb250RmFtaWx5OngsbGFiZWxGb250U2l6ZTp6LGxhYmVsRm9udENvbG9yOlwiIzAwMDAwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOmZhLGNvbG9yOlksdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZGFzaFwifSxcclxuc2NhbGVCcmVha3M6e3R5cGU6XCJ6aWd6YWdcIixzcGFjaW5nOlwiMiVcIixsaW5lQ29sb3I6XCIjNzc3Nzc3XCIsbGluZVRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcInNvbGlkXCIsY29sb3I6XCIjMTExMTExXCJ9fV0sbGVnZW5kOntmb250RmFtaWx5OngsZm9udFNpemU6MTQsZm9udENvbG9yOmdhLGZvbnRXZWlnaHQ6XCJib2xkXCIsdmVydGljYWxBbGlnbjpcImJvdHRvbVwiLGhvcml6b250YWxBbGlnbjpcImNlbnRlclwifSx0b29sVGlwOntmb250RmFtaWx5OngsZm9udFNpemU6MTQsZm9udFN0eWxlOlwibm9ybWFsXCIsY29ybmVyUmFkaXVzOjAsYm9yZGVyVGhpY2tuZXNzOjEsZm9udENvbG9yOlQsYmFja2dyb3VuZENvbG9yOlwicmdiYSgwLCAwLCAwLCAuNylcIn19LHRoZW1lMTpTYSx0aGVtZTI6WmEsdGhlbWUzOlNhfSxVPXtudW1iZXJEdXJhdGlvbjoxLHllYXJEdXJhdGlvbjozMTQ0OTZFNSxtb250aER1cmF0aW9uOjI1OTJFNix3ZWVrRHVyYXRpb246NjA0OEU1LGRheUR1cmF0aW9uOjg2NEU1LGhvdXJEdXJhdGlvbjozNkU1LFxyXG5taW51dGVEdXJhdGlvbjo2RTQsc2Vjb25kRHVyYXRpb246MUUzLG1pbGxpc2Vjb25kRHVyYXRpb246MSxkYXlPZldlZWtGcm9tSW50OlwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIil9OyhmdW5jdGlvbigpe1ouZlNEZWM9ZnVuY3Rpb24obSl7Zm9yKHZhciBzPVwiXCIscT0wO3E8bS5sZW5ndGg7cSsrKXMrPVN0cmluZy5mcm9tQ2hhckNvZGUoTWF0aC5jZWlsKG0ubGVuZ3RoLzU3LzUpXm0uY2hhckNvZGVBdChxKSk7cmV0dXJuIHN9O1oub2JqPXt0clZzOlwiVXNoYG0hV2Rzcmhub1wiLGZudFN0cjpcInF5IUJgbWhjc2gtIU10YmhlYCFGc2BvZWQtIU10YmhlYCFSYG9yIVRvaGJuZWQtIUBzaGBtLSFyYG9yLHJkc2hnXCIsdHh0Qmw6XCJ1ZHl1Q2ByZG1ob2RcIixmbnQ6XCJnbm91XCIsZlN5OlwiZ2htbVJ1eG1kXCIsZlR4OlwiZ2htbVVkeXVcIixnckNscjpcImZzZHhcIixjbnR4OlwiYnV5XCIsdHA6XCJ1bnFcIn07ZGVsZXRlIHNhW1ouZlNEZWMoXCJCaWBzdVwiKV1bWi5mU0RlYyhcImJzZGVodUlzZGdcIildO1xyXG5aLnBybz17c0NIOnNhW1ouZlNEZWMoXCJCaWBzdVwiKV1bWi5mU0RlYyhcImJzZGVodUlzZGdcIildfTtaLl9mVFdtPWZ1bmN0aW9uKG0pe2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgWi5wcm8uc0NIJiYhWWEpdHJ5e3ZhciBzPW1bWi5mU0RlYyhaLm9iai5jbnR4KV07c1taLmZTRGVjKFoub2JqLnR4dEJsKV09Wi5mU0RlYyhaLm9iai50cCk7c1taLmZTRGVjKFoub2JqLmZudCldPTExK1ouZlNEZWMoWi5vYmouZm50U3RyKTtzW1ouZlNEZWMoWi5vYmouZlN5KV09Wi5mU0RlYyhaLm9iai5nckNscik7c1taLmZTRGVjKFoub2JqLmZUeCldKFouZlNEZWMoWi5vYmoudHJWcyksMixtLmhlaWdodC0xMS0yKX1jYXRjaChxKXt9fX0pKCk7dmFyIFZhPXt9LHJhPW51bGwsQmE9ZnVuY3Rpb24oKXt2YXIgbT0vRHsxLDR9fE17MSw0fXxZezEsNH18aHsxLDJ9fEh7MSwyfXxtezEsMn18c3sxLDJ9fGZ7MSwzfXx0ezEsMn18VHsxLDJ9fEt8ensxLDN9fFwiW15cIl0qXCJ8J1teJ10qJy9nLHM9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxcclxucT1cIlN1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdFwiLnNwbGl0KFwiIFwiKSx2PVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKSx5PVwiSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWNcIi5zcGxpdChcIiBcIikseD0vXFxiKD86W1BNQ0VBXVtTRFBdVHwoPzpQYWNpZmljfE1vdW50YWlufENlbnRyYWx8RWFzdGVybnxBdGxhbnRpYykgKD86U3RhbmRhcmR8RGF5bGlnaHR8UHJldmFpbGluZykgVGltZXwoPzpHTVR8VVRDKSg/OlstK11cXGR7NH0pPylcXGIvZyx6PS9bXi0rXFxkQS1aXS9nO3JldHVybiBmdW5jdGlvbihRLEMsUCl7dmFyIEc9UD9QLmRheXM6cyxPPVA/UC5tb250aHM6dixSPVA/UC5zaG9ydERheXM6cSxOPVA/UC5zaG9ydE1vbnRoczp5O1A9XCJcIjt2YXIgVT0hMTtRPVEmJlEuZ2V0VGltZT9ROlE/bmV3IERhdGUoUSk6bmV3IERhdGU7XHJcbmlmKGlzTmFOKFEpKXRocm93IFN5bnRheEVycm9yKFwiaW52YWxpZCBkYXRlXCIpO1wiVVRDOlwiPT09Qy5zbGljZSgwLDQpJiYoQz1DLnNsaWNlKDQpLFU9ITApO1A9VT9cImdldFVUQ1wiOlwiZ2V0XCI7dmFyIFo9UVtQK1wiRGF0ZVwiXSgpLFY9UVtQK1wiRGF5XCJdKCksWD1RW1ArXCJNb250aFwiXSgpLFQ9UVtQK1wiRnVsbFllYXJcIl0oKSxIPVFbUCtcIkhvdXJzXCJdKCksVz1RW1ArXCJNaW51dGVzXCJdKCksYT1RW1ArXCJTZWNvbmRzXCJdKCksZj1RW1ArXCJNaWxsaXNlY29uZHNcIl0oKSxiPVU/MDpRLmdldFRpbWV6b25lT2Zmc2V0KCk7cmV0dXJuIFA9Qy5yZXBsYWNlKG0sZnVuY3Rpb24oYyl7c3dpdGNoKGMpe2Nhc2UgXCJEXCI6cmV0dXJuIFo7Y2FzZSBcIkREXCI6cmV0dXJuIGlhKFosMik7Y2FzZSBcIkRERFwiOnJldHVybiBSW1ZdO2Nhc2UgXCJEREREXCI6cmV0dXJuIEdbVl07Y2FzZSBcIk1cIjpyZXR1cm4gWCsxO2Nhc2UgXCJNTVwiOnJldHVybiBpYShYKzEsMik7Y2FzZSBcIk1NTVwiOnJldHVybiBOW1hdO2Nhc2UgXCJNTU1NXCI6cmV0dXJuIE9bWF07XHJcbmNhc2UgXCJZXCI6cmV0dXJuIHBhcnNlSW50KFN0cmluZyhUKS5zbGljZSgtMikpO2Nhc2UgXCJZWVwiOnJldHVybiBpYShTdHJpbmcoVCkuc2xpY2UoLTIpLDIpO2Nhc2UgXCJZWVlcIjpyZXR1cm4gaWEoU3RyaW5nKFQpLnNsaWNlKC0zKSwzKTtjYXNlIFwiWVlZWVwiOnJldHVybiBpYShULDQpO2Nhc2UgXCJoXCI6cmV0dXJuIEglMTJ8fDEyO2Nhc2UgXCJoaFwiOnJldHVybiBpYShIJTEyfHwxMiwyKTtjYXNlIFwiSFwiOnJldHVybiBIO2Nhc2UgXCJISFwiOnJldHVybiBpYShILDIpO2Nhc2UgXCJtXCI6cmV0dXJuIFc7Y2FzZSBcIm1tXCI6cmV0dXJuIGlhKFcsMik7Y2FzZSBcInNcIjpyZXR1cm4gYTtjYXNlIFwic3NcIjpyZXR1cm4gaWEoYSwyKTtjYXNlIFwiZlwiOnJldHVybiBTdHJpbmcoZikuc2xpY2UoMCwxKTtjYXNlIFwiZmZcIjpyZXR1cm4gaWEoU3RyaW5nKGYpLnNsaWNlKDAsMiksMik7Y2FzZSBcImZmZlwiOnJldHVybiBpYShTdHJpbmcoZikuc2xpY2UoMCwzKSwzKTtjYXNlIFwidFwiOnJldHVybiAxMj5IP1wiYVwiOlwicFwiO1xyXG5jYXNlIFwidHRcIjpyZXR1cm4gMTI+SD9cImFtXCI6XCJwbVwiO2Nhc2UgXCJUXCI6cmV0dXJuIDEyPkg/XCJBXCI6XCJQXCI7Y2FzZSBcIlRUXCI6cmV0dXJuIDEyPkg/XCJBTVwiOlwiUE1cIjtjYXNlIFwiS1wiOnJldHVybiBVP1wiVVRDXCI6KFN0cmluZyhRKS5tYXRjaCh4KXx8W1wiXCJdKS5wb3AoKS5yZXBsYWNlKHosXCJcIik7Y2FzZSBcInpcIjpyZXR1cm4oMDxiP1wiLVwiOlwiK1wiKStNYXRoLmZsb29yKE1hdGguYWJzKGIpLzYwKTtjYXNlIFwienpcIjpyZXR1cm4oMDxiP1wiLVwiOlwiK1wiKStpYShNYXRoLmZsb29yKE1hdGguYWJzKGIpLzYwKSwyKTtjYXNlIFwienp6XCI6cmV0dXJuKDA8Yj9cIi1cIjpcIitcIikraWEoTWF0aC5mbG9vcihNYXRoLmFicyhiKS82MCksMikraWEoTWF0aC5hYnMoYiklNjAsMik7ZGVmYXVsdDpyZXR1cm4gYy5zbGljZSgxLGMubGVuZ3RoLTEpfX0pfX0oKSxXPWZ1bmN0aW9uKG0scyxxKXtpZihudWxsPT09bSlyZXR1cm5cIlwiO2lmKCFpc0Zpbml0ZShtKSlyZXR1cm4gbTttPU51bWJlcihtKTt2YXIgdj0wPm0/ITA6XHJcbiExO3YmJihtKj0tMSk7dmFyIHk9cT9xLmRlY2ltYWxTZXBhcmF0b3I6XCIuXCIseD1xP3EuZGlnaXRHcm91cFNlcGFyYXRvcjpcIixcIix6PVwiXCI7cz1TdHJpbmcocyk7dmFyIHo9MSxRPXE9XCJcIixDPS0xLFA9W10sRz1bXSxPPTAsUj0wLFU9MCxOPSExLFo9MCxRPXMubWF0Y2goL1wiW15cIl0qXCJ8J1teJ10qJ3xbZUVdWystXSpbMF0rfFssXStbLl18XFx1MjAzMHwuL2cpO3M9bnVsbDtmb3IodmFyIFY9MDtRJiZWPFEubGVuZ3RoO1YrKylpZihzPVFbVl0sXCIuXCI9PT1zJiYwPkMpQz1WO2Vsc2V7aWYoXCIlXCI9PT1zKXoqPTEwMDtlbHNlIGlmKFwiXFx1MjAzMFwiPT09cyl7eio9MUUzO2NvbnRpbnVlfWVsc2UgaWYoXCIsXCI9PT1zWzBdJiZcIi5cIj09PXNbcy5sZW5ndGgtMV0pe3ovPU1hdGgucG93KDFFMyxzLmxlbmd0aC0xKTtDPVYrcy5sZW5ndGgtMTtjb250aW51ZX1lbHNlXCJFXCIhPT1zWzBdJiZcImVcIiE9PXNbMF18fFwiMFwiIT09c1tzLmxlbmd0aC0xXXx8KE49ITApOzA+Qz8oUC5wdXNoKHMpLFwiI1wiPT09c3x8XHJcblwiMFwiPT09cz9PKys6XCIsXCI9PT1zJiZVKyspOihHLnB1c2gocyksXCIjXCIhPT1zJiZcIjBcIiE9PXN8fFIrKyl9TiYmKHM9TWF0aC5mbG9vcihtKSxRPS1NYXRoLmZsb29yKE1hdGgubG9nKG0pL01hdGguTE4xMCsxKSxaPTA9PT1tPzA6MD09PXM/LShPK1EpOlN0cmluZyhzKS5sZW5ndGgtTyx6Lz1NYXRoLnBvdygxMCxaKSk7MD5DJiYoQz1WKTt6PShtKnopLnRvRml4ZWQoUik7cz16LnNwbGl0KFwiLlwiKTt6PShzWzBdK1wiXCIpLnNwbGl0KFwiXCIpO209KHNbMV0rXCJcIikuc3BsaXQoXCJcIik7eiYmXCIwXCI9PT16WzBdJiZ6LnNoaWZ0KCk7Zm9yKE49UT1WPVI9Qz0wOzA8UC5sZW5ndGg7KWlmKHM9UC5wb3AoKSxcIiNcIj09PXN8fFwiMFwiPT09cylpZihDKyssQz09PU8pe3ZhciBYPXosej1bXTtpZihcIjBcIj09PXMpZm9yKHM9Ty1SLShYP1gubGVuZ3RoOjApOzA8czspWC51bnNoaWZ0KFwiMFwiKSxzLS07Zm9yKDswPFgubGVuZ3RoOylxPVgucG9wKCkrcSxOKyssMD09PU4lUSYmKFY9PT1VJiYwPFgubGVuZ3RoKSYmXHJcbihxPXgrcSl9ZWxzZSAwPHoubGVuZ3RoPyhxPXoucG9wKCkrcSxSKyssTisrKTpcIjBcIj09PXMmJihxPVwiMFwiK3EsUisrLE4rKyksMD09PU4lUSYmKFY9PT1VJiYwPHoubGVuZ3RoKSYmKHE9eCtxKTtlbHNlXCJFXCIhPT1zWzBdJiZcImVcIiE9PXNbMF18fFwiMFwiIT09c1tzLmxlbmd0aC0xXXx8IS9bZUVdWystXSpbMF0rLy50ZXN0KHMpP1wiLFwiPT09cz8oVisrLFE9TixOPTAsMDx6Lmxlbmd0aCYmKHE9eCtxKSk6cT0xPHMubGVuZ3RoJiYoJ1wiJz09PXNbMF0mJidcIic9PT1zW3MubGVuZ3RoLTFdfHxcIidcIj09PXNbMF0mJlwiJ1wiPT09c1tzLmxlbmd0aC0xXSk/cy5zbGljZSgxLHMubGVuZ3RoLTEpK3E6cytxOihzPTA+Wj9zLnJlcGxhY2UoXCIrXCIsXCJcIikucmVwbGFjZShcIi1cIixcIlwiKTpzLnJlcGxhY2UoXCItXCIsXCJcIikscSs9cy5yZXBsYWNlKC9bMF0rLyxmdW5jdGlvbihtKXtyZXR1cm4gaWEoWixtLmxlbmd0aCl9KSk7eD1cIlwiO2ZvcihQPSExOzA8Ry5sZW5ndGg7KXM9Ry5zaGlmdCgpLFwiI1wiPT09c3x8XCIwXCI9PT1cclxucz8wPG0ubGVuZ3RoJiYwIT09TnVtYmVyKG0uam9pbihcIlwiKSk/KHgrPW0uc2hpZnQoKSxQPSEwKTpcIjBcIj09PXMmJih4Kz1cIjBcIixQPSEwKToxPHMubGVuZ3RoJiYoJ1wiJz09PXNbMF0mJidcIic9PT1zW3MubGVuZ3RoLTFdfHxcIidcIj09PXNbMF0mJlwiJ1wiPT09c1tzLmxlbmd0aC0xXSk/eCs9cy5zbGljZSgxLHMubGVuZ3RoLTEpOlwiRVwiIT09c1swXSYmXCJlXCIhPT1zWzBdfHxcIjBcIiE9PXNbcy5sZW5ndGgtMV18fCEvW2VFXVsrLV0qWzBdKy8udGVzdChzKT94Kz1zOihzPTA+Wj9zLnJlcGxhY2UoXCIrXCIsXCJcIikucmVwbGFjZShcIi1cIixcIlwiKTpzLnJlcGxhY2UoXCItXCIsXCJcIikseCs9cy5yZXBsYWNlKC9bMF0rLyxmdW5jdGlvbihtKXtyZXR1cm4gaWEoWixtLmxlbmd0aCl9KSk7cSs9KFA/eTpcIlwiKSt4O3JldHVybiB2P1wiLVwiK3E6cX0sT2E9ZnVuY3Rpb24obSl7dmFyIHM9MCxxPTA7bT1tfHx3aW5kb3cuZXZlbnQ7bS5vZmZzZXRYfHwwPT09bS5vZmZzZXRYPyhzPW0ub2Zmc2V0WCxxPW0ub2Zmc2V0WSk6XHJcbm0ubGF5ZXJYfHwwPT1tLmxheWVyWD8ocz1tLmxheWVyWCxxPW0ubGF5ZXJZKToocz1tLnBhZ2VYLW0udGFyZ2V0Lm9mZnNldExlZnQscT1tLnBhZ2VZLW0udGFyZ2V0Lm9mZnNldFRvcCk7cmV0dXJue3g6cyx5OnF9fSxYYT0hMCxRYT13aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSxMYT0xLGhhPVhhP1FhL0xhOjEsa2E9ZnVuY3Rpb24obSl7Zm9yKHZhciBzPVwiXCIscT0wO3E8bS5sZW5ndGg7cSsrKXMrPVN0cmluZy5mcm9tQ2hhckNvZGUoTWF0aC5jZWlsKG0ubGVuZ3RoLzU3LzUpXm0uY2hhckNvZGVBdChxKSk7cmV0dXJuIHN9LFlhPXdpbmRvdyYmd2luZG93W2thKFwibW5iYHVobm9cIildJiZ3aW5kb3dba2EoXCJtbmJgdWhub1wiKV0uaHJlZiYmd2luZG93W2thKFwibW5iYHVobm9cIildLmhyZWYuaW5kZXhPZiYmKC0xIT09d2luZG93W2thKFwibW5iYHVobm9cIildLmhyZWYuaW5kZXhPZihrYShcImJgb3dgcmtyL2JubFwiKSl8fC0xIT09d2luZG93W2thKFwibW5iYHVobm9cIildLmhyZWYuaW5kZXhPZihrYShcImdkb25xaHkvYm5sXCIpKXx8XHJcbi0xIT09d2luZG93W2thKFwibW5iYHVobm9cIildLmhyZWYuaW5kZXhPZihrYShcImdoZWVtZFwiKSkpLGRiPXtyZXNldDp7aW1hZ2U6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNJQUFBQWVDQVlBQUFCSi84d1VBQUFBSUdOSVVrMEFBSG9sQUFDQWd3QUErZjhBQUlEcEFBQjFNQUFBNm1BQUFEcVlBQUFYYjVKZnhVWUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFQalNVUkJWRmhIeFZkSmFGTlJGUDFKL2p3a1A1TXhzYmFDMVdKRWdsU3hPRkFYSXNGcFZSRTNnZ2kxSzkwb2Jpb1JSQkEzM1hYblFuY2lpcmhRY01DZG9yZ1F4QmtYV2xSRWtGS3NXa3Y1bnB2Y2twL1huelJwS2g2NGtMdzczM2ZmZmU5TC93ckwwK21WVWRPOHVUU1ozTUJML3dlMnFnNHJrdVNwb2RDRUxzdFhFNDZ6aVZrTFE2RlFjR09tZVNTcTZ3ZDRhVjUwZDNkcldqajhrUUtaSlRVYzlreEZHZW52NzlkWnJEa3NUU1RXV0pwMlFZdEVQaUVyeXN5emRYMExzeHNDUVI4a2VYOGdzNlJISWs4eXNkZ0tGZzJHNTNtaHVPUHNzaFRsQmpLYUZvMWc3U3FMTm9TaEtMZEZYVDhodVEvcGFMU2J4YXRZbmMybUhNTTRocjE4Vmk4VEl2Q21YRjN2WXJXNmNGMjNnR1RPazBNMXdBNFJLdk9tcTZ2TFpSVkppcHZtU1dUNnRaNkNTRVlrY281VjUwVlBUNCtEN1J3T3FpNlJpU1ptMGZKK3ZnZ1Nxa2VveXBkc05tdXllbE53YlhzYmd2a1dZTXR6RFdOdldhaWpveU9CcUUraFZLOGFiY3NzVWVYUS9ZZkt5aTBnRll2MUlwZ2ZvajM0ZllHVEpMT1lKQTBPRGlyb2szMkdMTjhYaFVXQ3dTZXMxaEl3Qmc2THlkSi90RWVSUmFwQWRVcCt3U0FpWmNodFpaV1dnQVorSk5wRDhwZVlYUVZLOVV3VXhOcHpPSzhwcTk3a1VSWmhZVENLQndQRDdoMnpLK2pzN015aTdEOEZvZCswVGtNSTgrRU1BbmdMR2MvV3RCRldhd2tGSEZub2ovdDlLTGdHbUYwQjNRZmt4QytFYXJ4a2RobkZZbEZMWTA2VVNxVXdMN1VNaklDSGZoL3dPYzJzQ3FocHhHYkNrTHZMN0VVRGJGNzMrNkRrbVZXQjZ6aTd4VURRU0xlWXZXakFJTHZtOXpFbmtKaGxiUmNEUVpjdjZLZzJBaXB5VC9BeHc2d0tscVZTcXhEZGpGOEl6Zm9kMTNxVVJkckcvbnhlaFkreEdoK2gwQ1N6S3lnR3ZTTlFJY2MwOTdCSTI0amI5aGF4NmtqMkU3T3JNRlgxaWwrSUNFZjJOclBiaGlYTGwrZllsK1U3eks0aVlkc0RjeUxHZitvZkZsa3djTitzMTBLaG1wdVloaHRtMGhDTFZJRkwwTURzcU5sRElxeTl4MkNMczFqTDZPdnJJN3ZQUmJ0b2hYRzZlRm1zRm5IREdBcDZuOUFneXVWeVNSWnJHdlJPeFJnSWZMWGh6anJOWW5OQlV4TlgvZE1nUldUMW10NFhMRG92YUFwRDUzRTlXM2lsTlg1TTU1TEpIcFJ0SXNnQXZjaVI0V1djZ0syRHZiMVlxZ1hldm1GOHoyekVCVGNLRzM5RWZTS3NUOUViaFZVYUkyRlpPK29aSXFJbXhvbDZqNjYvaGNBdTRzU040dmMxWlBvS2VvRTZSR2hZTDJZWUEreW1PU1NpMFowd1dudGJ0a0dVV0N2ZlNEWEl4T05yYVovRlk5MEtVZk5UcGZDNXNwbk5MZ3hvWU5uUjlSTzRGOG9mWEVIT2dvZ0NRRTk5dytmRjJYdytiN081OXJFT3N5UnFHRWZwVm9hRE1RUTFDWnJHNDZiY002QVowQy93UHFOZkhsaXFlanlUeVN4aDlUcVFwTCt4bWJJbGtCOVNsQUFBQUFCSlJVNUVya0pnZ2c9PVwifSxcclxucGFuOntpbWFnZTpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQjRBQUFBZUNBWUFBQUE3TUs2aUFBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUlDU1VSQlZFaEx4WmJQYWhOUkdNVW4vNU1wdUFpQkVBSXVmUUdmenI1RTQwWXB0Qlhhall6dWRDRXVHcVMrZ0dsckZ3cXVER1JUdXRCZFlmeWR6SjNMemVRbUpHWnVlK0R3L1oxN01uZm11NVBvZjlIcjlaNjFXcTBiV1pNS2oyNjNPNnhXcTk5d1U5bE9welBNS2dFaEVjUnVjTk9jaW9PSyswUnpCaE52dDl0UFY0bm1WRjE5K09XaFZxdDl4WGdGWFpxKzhsQ3YxMTlVS3BVSjdpWDJGbXZGVEt6OFJIMzRZZEJzTms4d1Z0akU0ZkdZd204d3JyRGkzV0JHNW9LWFpHUlNTOWhHdU5Gb2pMVGUybEZ6NXhUaFdaSWt0YXl5aUUyRmRUM3J6WEJYejdrcktpTDhjMTd3QUtGRGpDdXMyQXZXK1lHWjl5MkpGMFZGUnVNUGZJLy9yc0NFL0MrczI2czRnUXU5dWw3cjROdGVLeDdIOFhPQzcyNHhOTkdiYU51KytJckJxYk9WN1RqM0ZnTVJ2Yy9ZS09yMyszc0U0N3dnRXQvQmwvZ2FLNWNIYk5VMTF2WVNYeWxmcEs3WE92anV1bVBwNFdjb2lwdTMwUXNlejJ1TVhZejRsZkkrbU9td290aFkrU0xpWEp5N21LVnBXczNTaTBDb09NZmVJOU9kNDNXaWMrak8rWlZ2K2Nyc205UVNOaFVXOUxYU2VvUEJZTFhvcHRoR3VGUWdkSXh4aFkrVUR3bHQxeDVDWjFoWCtOVFVkdC9PSXZqS2FEU211T0pmYUlWTlBLWCtXMThqL1BMQTIva1I0NHA1U2Q4SGJIbmdUL3lUZk5SV1VYWDE0WmNMM3dtWDArVExmOFlPN0NHVDh5RkU1ekIzL2duZXkyNS9PRVRSUDlDdFBERmU1alNoQUFBQUFFbEZUa1N1UW1DQ1wifSxcclxuem9vbTp7aW1hZ2U6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUI0QUFBQWVDQVlBQUFBN01LNmlBQUFBSUdOSVVrMEFBSG9sQUFDQWd3QUErZjhBQUlEcEFBQjFNQUFBNm1BQUFEcVlBQUFYYjVKZnhVWUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFMV1NVUkJWRWhMdlpaTGFCTlJGSWFieWZ0QklnRWZxQ0NCb0NDNk1ZcWlYWWlJajRVNzZVNFg3c1VIYmhRaFVCZml4aFpFVUJEQjE2WXVGRVJhVWFRTEs3b29DT0pqNFVLdFlFRlUwRXB0U2hPL0E5UGgzanMzazhsby9lSG5QN24zblAvTTNMbHpNejFoa1V3bU56aU9jeUtSU0Z5RnQrTHhlRC9jMldxMVltN0t2ME0ybTExT3MxT3hXR3ljbjFPd1pYQ0d1WGZ3SWhlemtkOS9qUmdOVDJMNGxkaHMxcGJrWDVPTEplNGV1Vnh1R1FhUENhM21uVWp0Sng3QkR1S3VzSlRDVjZqVlZHSFRNdVlSanhtYTd5SU9oVGdGWTZqTmFBS2V3MnhQS3BWYXk5Z2FubWt2aitNNDQ4L01mSmRUNUs1R2c0SEphY1JuZ1BGZ3FWUmFSTndXMUI0aTd5ZWhXZnNFRGR6MUsrQTAxQW94UElxR0FpdXdHZmtPVFk4KzFBNnU3QXlpRlRCMkh1MEtQSXJkaU9uekhMV0R5YmVJbXZ5K1dxMm1aYTViVUhzRDBacHorS3hIZFdReW1WNmtBYjFFbHFlT1JnSkx2Z25SZGoxK1IxQWZ6a0l2U1VqeFZqUVNhclZha3J1ZUlQVDgrSDFGNWpTVXkrV1hpSnJVWUJWV3lWeFU0UEVVOFR6aGZhaWpVcW5NSVdyamFZNDkyZVdSd2RLT0lxcm5JeG5Yd0xMZVJMd2syR1F6ckVNamcwYXZFYlh4a0l4cjRPb09JbXBqMlF3eUZnbXMxa29hL1NaVUc4cyswaUduRWhOZkNOWEVoeklYQlZ6ME1jVHpFdkorNzBQOW9ORnR4RXplaTNhRllyRll4bXVTVVBXU3Y5WWk5SU1tMnhFMVdlNTZNcDFPVjRuRHdxRm1CRFY5Z2s5QUVoNGdadEZITnQ4VzRrQVVDb1hGNU1vclk5Wi9rRG5pOW5EdjdoYzBpMmZoZ0x2VHRYOGE5OVBvTVBQYWdURlB4b2ZSem1ESjl5TStBeUVtVGZnR3lzWWJRY2ZoRHpQUEpEbVgwYzdnRGc0Z3M5QnFGSVdobS9OY3Q1SDhndEJxMUk3VWZJYnR2bUl1b2FHUWNwK2ZkcGJiU000M2VFSDV3cndMYlhtaG0vZlU2M1ZIWGpjdW9rN2hFQnlGWS9BZUhHQzhMNS9QTDNIVDV4R0gxdVl3ZlBPSUNHbytDQmNVMHZ3TzFCcXpVcUlMRGwvei85VllJTWZwZGRpQWM0N2pEUDhCc1VwYjEzd09MUndBQUFBQVNVVk9SSzVDWUlJPVwifSxcclxubWVudTp7aW1hZ2U6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNRQUFBQWVDQVlBQUFCRTRieFRBQUFBSUdOSVVrMEFBSG9sQUFDQWd3QUErZjhBQUlEcEFBQjFNQUFBNm1BQUFEcVlBQUFYYjVKZnhVWUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFEb1NVUkJWRmhIN2RjOUNzSkFGQVRnUnhJSUJDd0NxWktBVFg1c2Jhd3NZMk12V090RjlBQjZBVThnZ3VBSmJEMkFuWjJWWFFUL0tvMlRZR0NMMk9ZdFlRYytCdVlBKzFoQ3RuQ1Z3TW0yN1NHYVhwREpJQWlDdkNrVlIwNWhHT1pOTjNIa0ZNZHgzblFSUjA2Kzc2L1IxSWNGTEpsTlFFV2xtV2xCVHdKdEtMS0h5bmVoWnFuak9HTTBQWVdSVlhrNjFDMzdwN3hsWjNIazVIbmVDazFkbU1IODExeEdvS0xTekRpUXdJQlpCNG9jb1BKZHFOa0R0MnlLbHVlV1JWR1V0enkzclB3bzNzV1JVM25ManVMSTZPTzY3b1pNMDB3TXczaHJtcFp4MFhVOXN5eHJSMFQwQmVNcGI5ZG5lU1IyQUFBQUFFbEZUa1N1UW1DQ1wifX07XHJcblgucHJvdG90eXBlLnNldE9wdGlvbnM9ZnVuY3Rpb24obSxzKXtpZihzYVt0aGlzLl9kZWZhdWx0c0tleV0pe3ZhciBxPXNhW3RoaXMuX2RlZmF1bHRzS2V5XSx2O2Zvcih2IGluIHEpXCJwdWJsaWNQcm9wZXJ0aWVzXCIhPT12JiZxLmhhc093blByb3BlcnR5KHYpJiYodGhpc1t2XT1tJiZ2IGluIG0/bVt2XTpzJiZ2IGluIHM/c1t2XTpxW3ZdKX19O1gucHJvdG90eXBlLmdldD1mdW5jdGlvbihtKXt2YXIgcz1zYVt0aGlzLl9kZWZhdWx0c0tleV07aWYoXCJvcHRpb25zXCI9PT1tKXJldHVybiB0aGlzLm9wdGlvbnMmJnRoaXMub3B0aW9ucy5faXNQbGFjZWhvbGRlcj9udWxsOnRoaXMub3B0aW9ucztpZihzLmhhc093blByb3BlcnR5KG0pfHxzLnB1YmxpY1Byb3BlcnRpZXMmJnMucHVibGljUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShtKSlyZXR1cm4gdGhpc1ttXTt3aW5kb3cuY29uc29sZSYmd2luZG93LmNvbnNvbGUubG9nKCdQcm9wZXJ0eSBcIicrbStcIlxcXCIgZG9lc24ndCBleGlzdC4gUGxlYXNlIGNoZWNrIGZvciB0eXBvLlwiKX07XHJcblgucHJvdG90eXBlLnNldD1mdW5jdGlvbihtLHMscSl7cT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIHE/ITA6cTt2YXIgdj1zYVt0aGlzLl9kZWZhdWx0c0tleV07aWYoXCJvcHRpb25zXCI9PT1tKXRoaXMuY3JlYXRlVXNlck9wdGlvbnMocyk7ZWxzZSBpZih2Lmhhc093blByb3BlcnR5KG0pfHx2LnB1YmxpY1Byb3BlcnRpZXMmJnYucHVibGljUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShtKSYmXCJyZWFkV3JpdGVcIj09PXYucHVibGljUHJvcGVydGllc1ttXSl0aGlzLm9wdGlvbnMuX2lzUGxhY2Vob2xkZXImJnRoaXMuY3JlYXRlVXNlck9wdGlvbnMoKSx0aGlzLm9wdGlvbnNbbV09cztlbHNle3dpbmRvdy5jb25zb2xlJiYodi5wdWJsaWNQcm9wZXJ0aWVzJiZ2LnB1YmxpY1Byb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobSkmJlwicmVhZE9ubHlcIj09PXYucHVibGljUHJvcGVydGllc1ttXT93aW5kb3cuY29uc29sZS5sb2coJ1Byb3BlcnR5IFwiJyttKydcIiBpcyByZWFkLW9ubHkuJyk6d2luZG93LmNvbnNvbGUubG9nKCdQcm9wZXJ0eSBcIicrXHJcbm0rXCJcXFwiIGRvZXNuJ3QgZXhpc3QuIFBsZWFzZSBjaGVjayBmb3IgdHlwby5cIikpO3JldHVybn1xJiYodGhpcy5jaGFydHx8dGhpcykucmVuZGVyKCl9O1gucHJvdG90eXBlLmFkZFRvPWZ1bmN0aW9uKG0scyxxLHYpe3Y9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB2PyEwOnY7dmFyIHk9c2FbdGhpcy5fZGVmYXVsdHNLZXldO3kuaGFzT3duUHJvcGVydHkobSl8fHkucHVibGljUHJvcGVydGllcyYmeS5wdWJsaWNQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG0pJiZcInJlYWRXcml0ZVwiPT09eS5wdWJsaWNQcm9wZXJ0aWVzW21dPyh0aGlzLm9wdGlvbnMuX2lzUGxhY2Vob2xkZXImJnRoaXMuY3JlYXRlVXNlck9wdGlvbnMoKSxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9uc1ttXSYmKHRoaXMub3B0aW9uc1ttXT1bXSksbT10aGlzLm9wdGlvbnNbbV0scT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIHF8fG51bGw9PT1xP20ubGVuZ3RoOnEsbS5zcGxpY2UocSwwLHMpLHYmJih0aGlzLmNoYXJ0fHxcclxudGhpcykucmVuZGVyKCkpOndpbmRvdy5jb25zb2xlJiYoeS5wdWJsaWNQcm9wZXJ0aWVzJiZ5LnB1YmxpY1Byb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobSkmJlwicmVhZE9ubHlcIj09PXkucHVibGljUHJvcGVydGllc1ttXT93aW5kb3cuY29uc29sZS5sb2coJ1Byb3BlcnR5IFwiJyttKydcIiBpcyByZWFkLW9ubHkuJyk6d2luZG93LmNvbnNvbGUubG9nKCdQcm9wZXJ0eSBcIicrbStcIlxcXCIgZG9lc24ndCBleGlzdC4gUGxlYXNlIGNoZWNrIGZvciB0eXBvLlwiKSl9O1gucHJvdG90eXBlLmNyZWF0ZVVzZXJPcHRpb25zPWZ1bmN0aW9uKG0pe2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgbXx8dGhpcy5vcHRpb25zLl9pc1BsYWNlaG9sZGVyKWlmKHRoaXMucGFyZW50Lm9wdGlvbnMuX2lzUGxhY2Vob2xkZXImJnRoaXMucGFyZW50LmNyZWF0ZVVzZXJPcHRpb25zKCksdGhpcy5pc09wdGlvbnNJbkFycmF5KXt0aGlzLnBhcmVudC5vcHRpb25zW3RoaXMub3B0aW9uc05hbWVdfHwodGhpcy5wYXJlbnQub3B0aW9uc1t0aGlzLm9wdGlvbnNOYW1lXT1cclxuW10pO3ZhciBzPXRoaXMucGFyZW50Lm9wdGlvbnNbdGhpcy5vcHRpb25zTmFtZV0scT1zLmxlbmd0aDt0aGlzLm9wdGlvbnMuX2lzUGxhY2Vob2xkZXJ8fChEYShzKSxxPXMuaW5kZXhPZih0aGlzLm9wdGlvbnMpKTt0aGlzLm9wdGlvbnM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBtP3t9Om07c1txXT10aGlzLm9wdGlvbnN9ZWxzZSB0aGlzLm9wdGlvbnM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBtP3t9Om0sbT10aGlzLnBhcmVudC5vcHRpb25zLHRoaXMub3B0aW9uc05hbWU/cz10aGlzLm9wdGlvbnNOYW1lOihzPXRoaXMuX2RlZmF1bHRzS2V5KSYmMCE9PXMubGVuZ3RoPyhxPXMuY2hhckF0KDApLnRvTG93ZXJDYXNlKCksMTxzLmxlbmd0aCYmKHE9cS5jb25jYXQocy5zbGljZSgxKSkpLHM9cSk6cz12b2lkIDAsbVtzXT10aGlzLm9wdGlvbnN9O1gucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbihtKXttPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgbT8hMDptO2lmKHRoaXMuaXNPcHRpb25zSW5BcnJheSl7dmFyIHM9XHJcbnRoaXMucGFyZW50Lm9wdGlvbnNbdGhpcy5vcHRpb25zTmFtZV07RGEocyk7dmFyIHE9cy5pbmRleE9mKHRoaXMub3B0aW9ucyk7MDw9cSYmcy5zcGxpY2UocSwxKX1lbHNlIGRlbGV0ZSB0aGlzLnBhcmVudC5vcHRpb25zW3RoaXMub3B0aW9uc05hbWVdO20mJih0aGlzLmNoYXJ0fHx0aGlzKS5yZW5kZXIoKX07WC5wcm90b3R5cGUudXBkYXRlT3B0aW9uPWZ1bmN0aW9uKG0pe3ZhciBzPXNhW3RoaXMuX2RlZmF1bHRzS2V5XSxxPXt9LHY9dGhpc1ttXSx4PXRoaXMuX3RoZW1lT3B0aW9uc0tleSx6PXRoaXMuX2luZGV4O3RoaXMudGhlbWUmJnkoeCkmJnkoeik/cT15KHlhW3RoaXMudGhlbWVdKT95YS5saWdodDE6eWFbdGhpcy50aGVtZV06dGhpcy5wYXJlbnQmJih0aGlzLnBhcmVudC50aGVtZU9wdGlvbnMmJnRoaXMucGFyZW50LnRoZW1lT3B0aW9uc1t4XSkmJihudWxsPT09ej9xPXRoaXMucGFyZW50LnRoZW1lT3B0aW9uc1t4XTowPHRoaXMucGFyZW50LnRoZW1lT3B0aW9uc1t4XS5sZW5ndGgmJlxyXG4ocT1NYXRoLm1pbih0aGlzLnBhcmVudC50aGVtZU9wdGlvbnNbeF0ubGVuZ3RoLTEseikscT10aGlzLnBhcmVudC50aGVtZU9wdGlvbnNbeF1bcV0pKTt0aGlzLnRoZW1lT3B0aW9ucz1xO20gaW4gcyYmKHY9bSBpbiB0aGlzLm9wdGlvbnM/dGhpcy5vcHRpb25zW21dOnEmJm0gaW4gcT9xW21dOnNbbV0pO2lmKHY9PT10aGlzW21dKXJldHVybiExO3RoaXNbbV09djtyZXR1cm4hMH07WC5wcm90b3R5cGUudHJhY2tDaGFuZ2VzPWZ1bmN0aW9uKG0pe2lmKCF0aGlzLnNlc3Npb25WYXJpYWJsZXMpdGhyb3dcIlNlc3Npb24gVmFyaWFibGUgU3RvcmUgbm90IHNldFwiO3RoaXMuc2Vzc2lvblZhcmlhYmxlc1ttXT10aGlzLm9wdGlvbnNbbV19O1gucHJvdG90eXBlLmlzQmVpbmdUcmFja2VkPWZ1bmN0aW9uKG0pe3RoaXMub3B0aW9ucy5fb2xkT3B0aW9uc3x8KHRoaXMub3B0aW9ucy5fb2xkT3B0aW9ucz17fSk7cmV0dXJuIHRoaXMub3B0aW9ucy5fb2xkT3B0aW9uc1ttXT8hMDohMX07WC5wcm90b3R5cGUuaGFzT3B0aW9uQ2hhbmdlZD1cclxuZnVuY3Rpb24obSl7aWYoIXRoaXMuc2Vzc2lvblZhcmlhYmxlcyl0aHJvd1wiU2Vzc2lvbiBWYXJpYWJsZSBTdG9yZSBub3Qgc2V0XCI7cmV0dXJuIHRoaXMuc2Vzc2lvblZhcmlhYmxlc1ttXSE9PXRoaXMub3B0aW9uc1ttXX07WC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihtLHMsdil7bSYmcyYmKHRoaXMuX2V2ZW50TGlzdGVuZXJzW21dPXRoaXMuX2V2ZW50TGlzdGVuZXJzW21dfHxbXSx0aGlzLl9ldmVudExpc3RlbmVyc1ttXS5wdXNoKHtjb250ZXh0OnZ8fHRoaXMsZXZlbnRIYW5kbGVyOnN9KSl9O1gucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24obSxzKXtpZihtJiZzJiZ0aGlzLl9ldmVudExpc3RlbmVyc1ttXSlmb3IodmFyIHY9dGhpcy5fZXZlbnRMaXN0ZW5lcnNbbV0seT0wO3k8di5sZW5ndGg7eSsrKWlmKHZbeV0uZXZlbnRIYW5kbGVyPT09cyl7dlt5XS5zcGxpY2UoeSwxKTticmVha319O1gucHJvdG90eXBlLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzPVxyXG5mdW5jdGlvbigpe3RoaXMuX2V2ZW50TGlzdGVuZXJzPVtdfTtYLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50PWZ1bmN0aW9uKG0scyx2KXtpZihtJiZ0aGlzLl9ldmVudExpc3RlbmVyc1ttXSl7cz1zfHx7fTtmb3IodmFyIHk9dGhpcy5fZXZlbnRMaXN0ZW5lcnNbbV0seD0wO3g8eS5sZW5ndGg7eCsrKXlbeF0uZXZlbnRIYW5kbGVyLmNhbGwoeVt4XS5jb250ZXh0LHMpfVwiZnVuY3Rpb25cIj09PXR5cGVvZiB0aGlzW21dJiZ0aGlzW21dLmNhbGwodnx8dGhpcy5jaGFydCxzKX07RWEucHJvdG90eXBlLnJlZ2lzdGVyU3BhY2U9ZnVuY3Rpb24obSxzKXtcInRvcFwiPT09bT90aGlzLl90b3BPY2N1cGllZCs9cy5oZWlnaHQ6XCJib3R0b21cIj09PW0/dGhpcy5fYm90dG9tT2NjdXBpZWQrPXMuaGVpZ2h0OlwibGVmdFwiPT09bT90aGlzLl9sZWZ0T2NjdXBpZWQrPXMud2lkdGg6XCJyaWdodFwiPT09bSYmKHRoaXMuX3JpZ2h0T2NjdXBpZWQrPXMud2lkdGgpfTtFYS5wcm90b3R5cGUudW5SZWdpc3RlclNwYWNlPVxyXG5mdW5jdGlvbihtLHMpe1widG9wXCI9PT1tP3RoaXMuX3RvcE9jY3VwaWVkLT1zLmhlaWdodDpcImJvdHRvbVwiPT09bT90aGlzLl9ib3R0b21PY2N1cGllZC09cy5oZWlnaHQ6XCJsZWZ0XCI9PT1tP3RoaXMuX2xlZnRPY2N1cGllZC09cy53aWR0aDpcInJpZ2h0XCI9PT1tJiYodGhpcy5fcmlnaHRPY2N1cGllZC09cy53aWR0aCl9O0VhLnByb3RvdHlwZS5nZXRGcmVlU3BhY2U9ZnVuY3Rpb24oKXtyZXR1cm57eDE6dGhpcy5feDErdGhpcy5fbGVmdE9jY3VwaWVkLHkxOnRoaXMuX3kxK3RoaXMuX3RvcE9jY3VwaWVkLHgyOnRoaXMuX3gyLXRoaXMuX3JpZ2h0T2NjdXBpZWQseTI6dGhpcy5feTItdGhpcy5fYm90dG9tT2NjdXBpZWQsd2lkdGg6dGhpcy5feDItdGhpcy5feDEtdGhpcy5fcmlnaHRPY2N1cGllZC10aGlzLl9sZWZ0T2NjdXBpZWQsaGVpZ2h0OnRoaXMuX3kyLXRoaXMuX3kxLXRoaXMuX2JvdHRvbU9jY3VwaWVkLXRoaXMuX3RvcE9jY3VwaWVkfX07RWEucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5fcmlnaHRPY2N1cGllZD1cclxudGhpcy5fbGVmdE9jY3VwaWVkPXRoaXMuX2JvdHRvbU9jY3VwaWVkPXRoaXMuX3RvcE9jY3VwaWVkPXRoaXMuX3BhZGRpbmd9O3BhKGxhLFgpO2xhLnByb3RvdHlwZS5faW5pdGlhbGl6ZT1mdW5jdGlvbigpe3kodGhpcy5wYWRkaW5nKXx8XCJvYmplY3RcIiE9PXR5cGVvZiB0aGlzLnBhZGRpbmc/dGhpcy50b3BQYWRkaW5nPXRoaXMucmlnaHRQYWRkaW5nPXRoaXMuYm90dG9tUGFkZGluZz10aGlzLmxlZnRQYWRkaW5nPU51bWJlcih0aGlzLnBhZGRpbmcpfDA6KHRoaXMudG9wUGFkZGluZz15KHRoaXMucGFkZGluZy50b3ApPzA6TnVtYmVyKHRoaXMucGFkZGluZy50b3ApfDAsdGhpcy5yaWdodFBhZGRpbmc9eSh0aGlzLnBhZGRpbmcucmlnaHQpPzA6TnVtYmVyKHRoaXMucGFkZGluZy5yaWdodCl8MCx0aGlzLmJvdHRvbVBhZGRpbmc9eSh0aGlzLnBhZGRpbmcuYm90dG9tKT8wOk51bWJlcih0aGlzLnBhZGRpbmcuYm90dG9tKXwwLHRoaXMubGVmdFBhZGRpbmc9eSh0aGlzLnBhZGRpbmcubGVmdCk/XHJcbjA6TnVtYmVyKHRoaXMucGFkZGluZy5sZWZ0KXwwKX07bGEucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihtKXtpZigwIT09dGhpcy5mb250U2l6ZSl7bSYmdGhpcy5jdHguc2F2ZSgpO3ZhciBzPXRoaXMuY3R4LmZvbnQ7dGhpcy5jdHgudGV4dEJhc2VsaW5lPXRoaXMudGV4dEJhc2VsaW5lO3ZhciB2PTA7dGhpcy5faXNEaXJ0eSYmdGhpcy5tZWFzdXJlVGV4dCh0aGlzLmN0eCk7dGhpcy5jdHgudHJhbnNsYXRlKHRoaXMueCx0aGlzLnkrdik7XCJtaWRkbGVcIj09PXRoaXMudGV4dEJhc2VsaW5lJiYodj0tdGhpcy5fbGluZUhlaWdodC8yKTt0aGlzLmN0eC5mb250PXRoaXMuX2dldEZvbnRTdHJpbmcoKTt0aGlzLmN0eC5yb3RhdGUoTWF0aC5QSS8xODAqdGhpcy5hbmdsZSk7dmFyIHk9MCx4PXRoaXMudG9wUGFkZGluZyx6PW51bGw7dGhpcy5jdHgucm91bmRSZWN0fHxDYSh0aGlzLmN0eCk7KDA8dGhpcy5ib3JkZXJUaGlja25lc3MmJnRoaXMuYm9yZGVyQ29sb3J8fHRoaXMuYmFja2dyb3VuZENvbG9yKSYmXHJcbnRoaXMuY3R4LnJvdW5kUmVjdCgwLHYsdGhpcy53aWR0aCx0aGlzLmhlaWdodCx0aGlzLmNvcm5lclJhZGl1cyx0aGlzLmJvcmRlclRoaWNrbmVzcyx0aGlzLmJhY2tncm91bmRDb2xvcix0aGlzLmJvcmRlckNvbG9yKTt0aGlzLmN0eC5maWxsU3R5bGU9dGhpcy5mb250Q29sb3I7Zm9yKHY9MDt2PHRoaXMuX3dyYXBwZWRUZXh0LmxpbmVzLmxlbmd0aDt2Kyspej10aGlzLl93cmFwcGVkVGV4dC5saW5lc1t2XSxcInJpZ2h0XCI9PT10aGlzLmhvcml6b250YWxBbGlnbj95PSh0aGlzLndpZHRoLSh0aGlzLmxlZnRQYWRkaW5nK3RoaXMucmlnaHRQYWRkaW5nKSkvMi16LndpZHRoLzIrdGhpcy5sZWZ0UGFkZGluZzpcImxlZnRcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWduP3k9dGhpcy5sZWZ0UGFkZGluZzpcImNlbnRlclwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ24mJih5PSh0aGlzLndpZHRoLSh0aGlzLmxlZnRQYWRkaW5nK3RoaXMucmlnaHRQYWRkaW5nKSkvMi16LndpZHRoLzIrdGhpcy5sZWZ0UGFkZGluZyksXHJcbnRoaXMuY3R4LmZpbGxUZXh0KHoudGV4dCx5LHgpLHgrPXouaGVpZ2h0O3RoaXMuY3R4LmZvbnQ9czttJiZ0aGlzLmN0eC5yZXN0b3JlKCl9fTtsYS5wcm90b3R5cGUuc2V0VGV4dD1mdW5jdGlvbihtKXt0aGlzLnRleHQ9bTt0aGlzLl9pc0RpcnR5PSEwO3RoaXMuX3dyYXBwZWRUZXh0PW51bGx9O2xhLnByb3RvdHlwZS5tZWFzdXJlVGV4dD1mdW5jdGlvbigpe3RoaXMuX2xpbmVIZWlnaHQ9VWEodGhpcy5mb250RmFtaWx5LHRoaXMuZm9udFNpemUsdGhpcy5mb250V2VpZ2h0KTtpZihudWxsPT09dGhpcy5tYXhXaWR0aCl0aHJvd1wiUGxlYXNlIHNldCBtYXhXaWR0aCBhbmQgaGVpZ2h0IGZvciBUZXh0QmxvY2tcIjt0aGlzLl93cmFwVGV4dCh0aGlzLmN0eCk7dGhpcy5faXNEaXJ0eT0hMTtyZXR1cm57d2lkdGg6dGhpcy53aWR0aCxoZWlnaHQ6dGhpcy5oZWlnaHR9fTtsYS5wcm90b3R5cGUuX2dldExpbmVXaXRoV2lkdGg9ZnVuY3Rpb24obSxzLHYpe209U3RyaW5nKG0pO2lmKCFtKXJldHVybnt0ZXh0OlwiXCIsXHJcbndpZHRoOjB9O3ZhciB5PXY9MCx4PW0ubGVuZ3RoLTEsej1JbmZpbml0eTtmb3IodGhpcy5jdHguZm9udD10aGlzLl9nZXRGb250U3RyaW5nKCk7eTw9eDspe3ZhciB6PU1hdGguZmxvb3IoKHkreCkvMiksRz1tLnN1YnN0cigwLHorMSk7dj10aGlzLmN0eC5tZWFzdXJlVGV4dChHKS53aWR0aDtpZih2PHMpeT16KzE7ZWxzZSBpZih2PnMpeD16LTE7ZWxzZSBicmVha312PnMmJjE8Ry5sZW5ndGgmJihHPUcuc3Vic3RyKDAsRy5sZW5ndGgtMSksdj10aGlzLmN0eC5tZWFzdXJlVGV4dChHKS53aWR0aCk7cz0hMDtpZihHLmxlbmd0aD09PW0ubGVuZ3RofHxcIiBcIj09PW1bRy5sZW5ndGhdKXM9ITE7cyYmKG09Ry5zcGxpdChcIiBcIiksMTxtLmxlbmd0aCYmbS5wb3AoKSxHPW0uam9pbihcIiBcIiksdj10aGlzLmN0eC5tZWFzdXJlVGV4dChHKS53aWR0aCk7cmV0dXJue3RleHQ6Ryx3aWR0aDp2fX07bGEucHJvdG90eXBlLl93cmFwVGV4dD1mdW5jdGlvbigpe3ZhciBtPW5ldyBTdHJpbmcoR2EoU3RyaW5nKHRoaXMudGV4dCkpKSxcclxudj1bXSxxPXRoaXMuY3R4LmZvbnQseT0wLHg9MDt0aGlzLmN0eC5mb250PXRoaXMuX2dldEZvbnRTdHJpbmcoKTtpZigwPT09dGhpcy5mcm9udFNpemUpeD15PTA7ZWxzZSBmb3IoOzA8bS5sZW5ndGg7KXt2YXIgej10aGlzLm1heEhlaWdodC0odGhpcy50b3BQYWRkaW5nK3RoaXMuYm90dG9tUGFkZGluZyksRz10aGlzLl9nZXRMaW5lV2l0aFdpZHRoKG0sdGhpcy5tYXhXaWR0aC0odGhpcy5sZWZ0UGFkZGluZyt0aGlzLnJpZ2h0UGFkZGluZyksITEpO0cuaGVpZ2h0PXRoaXMuX2xpbmVIZWlnaHQ7di5wdXNoKEcpO3ZhciBRPXgseD1NYXRoLm1heCh4LEcud2lkdGgpLHk9eStHLmhlaWdodCxtPUdhKG0uc2xpY2UoRy50ZXh0Lmxlbmd0aCxtLmxlbmd0aCkpO3omJnk+eiYmKEc9di5wb3AoKSx5LT1HLmhlaWdodCx4PVEpfXRoaXMuX3dyYXBwZWRUZXh0PXtsaW5lczp2LHdpZHRoOngsaGVpZ2h0Onl9O3RoaXMud2lkdGg9eCsodGhpcy5sZWZ0UGFkZGluZyt0aGlzLnJpZ2h0UGFkZGluZyk7XHJcbnRoaXMuaGVpZ2h0PXkrKHRoaXMudG9wUGFkZGluZyt0aGlzLmJvdHRvbVBhZGRpbmcpO3RoaXMuY3R4LmZvbnQ9cX07bGEucHJvdG90eXBlLl9nZXRGb250U3RyaW5nPWZ1bmN0aW9uKCl7dmFyIG07bT1cIlwiKyh0aGlzLmZvbnRTdHlsZT90aGlzLmZvbnRTdHlsZStcIiBcIjpcIlwiKTttKz10aGlzLmZvbnRXZWlnaHQ/dGhpcy5mb250V2VpZ2h0K1wiIFwiOlwiXCI7bSs9dGhpcy5mb250U2l6ZT90aGlzLmZvbnRTaXplK1wicHggXCI6XCJcIjt2YXIgcz10aGlzLmZvbnRGYW1pbHk/dGhpcy5mb250RmFtaWx5K1wiXCI6XCJcIjshdiYmcyYmKHM9cy5zcGxpdChcIixcIilbMF0sXCInXCIhPT1zWzBdJiYnXCInIT09c1swXSYmKHM9XCInXCIrcytcIidcIikpO3JldHVybiBtKz1zfTtwYShSYSxYKTtwYShJYSxYKTtJYS5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKCl7aWYodGhpcy50ZXh0KXt2YXIgbT10aGlzLmRvY2tJbnNpZGVQbG90QXJlYT90aGlzLmNoYXJ0LnBsb3RBcmVhOnRoaXMuY2hhcnQsdj1tLmxheW91dE1hbmFnZXIuZ2V0RnJlZVNwYWNlKCksXHJcbnE9di54MSx4PXYueTEsej0wLEc9MCxSPXRoaXMuY2hhcnQuX21lbnVCdXR0b24mJnRoaXMuY2hhcnQuZXhwb3J0RW5hYmxlZCYmXCJ0b3BcIj09PXRoaXMudmVydGljYWxBbGlnbj8yMjowLFEsQztcInRvcFwiPT09dGhpcy52ZXJ0aWNhbEFsaWdufHxcImJvdHRvbVwiPT09dGhpcy52ZXJ0aWNhbEFsaWduPyhudWxsPT09dGhpcy5tYXhXaWR0aCYmKHRoaXMubWF4V2lkdGg9di53aWR0aC00LVIqKFwiY2VudGVyXCI9PT10aGlzLmhvcml6b250YWxBbGlnbj8yOjEpKSxHPTAuNSp2LmhlaWdodC10aGlzLm1hcmdpbi0yLHo9MCk6XCJjZW50ZXJcIj09PXRoaXMudmVydGljYWxBbGlnbiYmKFwibGVmdFwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ258fFwicmlnaHRcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWduPyhudWxsPT09dGhpcy5tYXhXaWR0aCYmKHRoaXMubWF4V2lkdGg9di5oZWlnaHQtNCksRz0wLjUqdi53aWR0aC10aGlzLm1hcmdpbi0yKTpcImNlbnRlclwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ24mJihudWxsPT09XHJcbnRoaXMubWF4V2lkdGgmJih0aGlzLm1heFdpZHRoPXYud2lkdGgtNCksRz0wLjUqdi5oZWlnaHQtNCkpO3ZhciBQO3kodGhpcy5wYWRkaW5nKXx8XCJudW1iZXJcIiE9PXR5cGVvZiB0aGlzLnBhZGRpbmc/eSh0aGlzLnBhZGRpbmcpfHxcIm9iamVjdFwiIT09dHlwZW9mIHRoaXMucGFkZGluZ3x8KFA9dGhpcy5wYWRkaW5nLnRvcD90aGlzLnBhZGRpbmcudG9wOnRoaXMucGFkZGluZy5ib3R0b20/dGhpcy5wYWRkaW5nLmJvdHRvbTowLFArPXRoaXMucGFkZGluZy5ib3R0b20/dGhpcy5wYWRkaW5nLmJvdHRvbTp0aGlzLnBhZGRpbmcudG9wP3RoaXMucGFkZGluZy50b3A6MCxQKj0xLjI1KTpQPTIuNSp0aGlzLnBhZGRpbmc7dGhpcy53cmFwfHwoRz1NYXRoLm1pbihHLE1hdGgubWF4KDEuNSp0aGlzLmZvbnRTaXplLHRoaXMuZm9udFNpemUrUCkpKTtHPW5ldyBsYSh0aGlzLmN0eCx7Zm9udFNpemU6dGhpcy5mb250U2l6ZSxmb250RmFtaWx5OnRoaXMuZm9udEZhbWlseSxmb250Q29sb3I6dGhpcy5mb250Q29sb3IsXHJcbmZvbnRTdHlsZTp0aGlzLmZvbnRTdHlsZSxmb250V2VpZ2h0OnRoaXMuZm9udFdlaWdodCxob3Jpem9udGFsQWxpZ246dGhpcy5ob3Jpem9udGFsQWxpZ24sdmVydGljYWxBbGlnbjp0aGlzLnZlcnRpY2FsQWxpZ24sYm9yZGVyQ29sb3I6dGhpcy5ib3JkZXJDb2xvcixib3JkZXJUaGlja25lc3M6dGhpcy5ib3JkZXJUaGlja25lc3MsYmFja2dyb3VuZENvbG9yOnRoaXMuYmFja2dyb3VuZENvbG9yLG1heFdpZHRoOnRoaXMubWF4V2lkdGgsbWF4SGVpZ2h0OkcsY29ybmVyUmFkaXVzOnRoaXMuY29ybmVyUmFkaXVzLHRleHQ6dGhpcy50ZXh0LHBhZGRpbmc6dGhpcy5wYWRkaW5nLHRleHRCYXNlbGluZTpcInRvcFwifSk7UD1HLm1lYXN1cmVUZXh0KCk7XCJ0b3BcIj09PXRoaXMudmVydGljYWxBbGlnbnx8XCJib3R0b21cIj09PXRoaXMudmVydGljYWxBbGlnbj8oXCJ0b3BcIj09PXRoaXMudmVydGljYWxBbGlnbj8oeD12LnkxKzIsQz1cInRvcFwiKTpcImJvdHRvbVwiPT09dGhpcy52ZXJ0aWNhbEFsaWduJiZcclxuKHg9di55Mi0yLVAuaGVpZ2h0LEM9XCJib3R0b21cIiksXCJsZWZ0XCI9PT10aGlzLmhvcml6b250YWxBbGlnbj9xPXYueDErMjpcImNlbnRlclwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ24/cT12LngxK3Yud2lkdGgvMi1QLndpZHRoLzI6XCJyaWdodFwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ24mJihxPXYueDItMi1QLndpZHRoLVIpLFE9dGhpcy5ob3Jpem9udGFsQWxpZ24sdGhpcy53aWR0aD1QLndpZHRoLHRoaXMuaGVpZ2h0PVAuaGVpZ2h0KTpcImNlbnRlclwiPT09dGhpcy52ZXJ0aWNhbEFsaWduJiYoXCJsZWZ0XCI9PT10aGlzLmhvcml6b250YWxBbGlnbj8ocT12LngxKzIseD12LnkyLTItKHRoaXMubWF4V2lkdGgvMi1QLndpZHRoLzIpLHo9LTkwLEM9XCJsZWZ0XCIsdGhpcy53aWR0aD1QLmhlaWdodCx0aGlzLmhlaWdodD1QLndpZHRoKTpcInJpZ2h0XCI9PT10aGlzLmhvcml6b250YWxBbGlnbj8ocT12LngyLTIseD12LnkxKzIrKHRoaXMubWF4V2lkdGgvMi1QLndpZHRoLzIpLHo9OTAsQz1cInJpZ2h0XCIsXHJcbnRoaXMud2lkdGg9UC5oZWlnaHQsdGhpcy5oZWlnaHQ9UC53aWR0aCk6XCJjZW50ZXJcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWduJiYoeD1tLnkxKyhtLmhlaWdodC8yLVAuaGVpZ2h0LzIpLHE9bS54MSsobS53aWR0aC8yLVAud2lkdGgvMiksQz1cImNlbnRlclwiLHRoaXMud2lkdGg9UC53aWR0aCx0aGlzLmhlaWdodD1QLmhlaWdodCksUT1cImNlbnRlclwiKTtHLng9cTtHLnk9eDtHLmFuZ2xlPXo7Ry5ob3Jpem9udGFsQWxpZ249UTtHLnJlbmRlcighMCk7bS5sYXlvdXRNYW5hZ2VyLnJlZ2lzdGVyU3BhY2UoQyx7d2lkdGg6dGhpcy53aWR0aCsoXCJsZWZ0XCI9PT1DfHxcInJpZ2h0XCI9PT1DP3RoaXMubWFyZ2luKzI6MCksaGVpZ2h0OnRoaXMuaGVpZ2h0KyhcInRvcFwiPT09Q3x8XCJib3R0b21cIj09PUM/dGhpcy5tYXJnaW4rMjowKX0pO3RoaXMuYm91bmRzPXt4MTpxLHkxOngseDI6cSt0aGlzLndpZHRoLHkyOngrdGhpcy5oZWlnaHR9O3RoaXMuY3R4LnRleHRCYXNlbGluZT1cInRvcFwifX07cGEoTmEsXHJcblgpO05hLnByb3RvdHlwZS5yZW5kZXI9SWEucHJvdG90eXBlLnJlbmRlcjtwYShKYSxYKTt4PXthZGRUaGVtZTpmdW5jdGlvbihtLHYpe3lhW21dPXZ9LGFkZENvbG9yU2V0OmZ1bmN0aW9uKG0sdil7QWFbbV09dn0sYWRkQ3VsdHVyZUluZm86ZnVuY3Rpb24obSx2KXtLYVttXT12fSxmb3JtYXROdW1iZXI6ZnVuY3Rpb24obSx2LHEpe3E9cXx8XCJlblwiO2lmKEthW3FdKXJldHVybiBXKG0sdnx8XCIjLCMjMC4jI1wiLG5ldyBKYShxKSk7dGhyb3dcIlVua25vd24gQ3VsdHVyZSBOYW1lXCI7fSxmb3JtYXREYXRlOmZ1bmN0aW9uKG0sdixxKXtxPXF8fFwiZW5cIjtpZihLYVtxXSlyZXR1cm4gQmEobSx2fHxcIkREIE1NTSBZWVlZXCIsbmV3IEphKHEpKTt0aHJvd1wiVW5rbm93biBDdWx0dXJlIE5hbWVcIjt9fTt3aW5kb3cuQ2FudmFzSlM9eDt4LkNoYXJ0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbShhLGYpe3JldHVybiBhLngtZi54fWZ1bmN0aW9uIHMoYSxmLGIpe2lmKGEmJmYmJmIpe2I9YitcIi5cIitmO3ZhciBjPVxyXG5cImltYWdlL1wiK2Y7YT1hLnRvRGF0YVVSTChjKTt2YXIgZT0hMSxnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO2cuZG93bmxvYWQ9YjtnLmhyZWY9YTtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIEJsb2ImJm5ldyBCbG9iKXtmb3IodmFyIGg9YS5yZXBsYWNlKC9eZGF0YTpbYS16XFwvXSo7YmFzZTY0LC8sXCJcIiksaD1hdG9iKGgpLGw9bmV3IEFycmF5QnVmZmVyKGgubGVuZ3RoKSxsPW5ldyBVaW50OEFycmF5KGwpLHQ9MDt0PGgubGVuZ3RoO3QrKylsW3RdPWguY2hhckNvZGVBdCh0KTtmPW5ldyBCbG9iKFtsLmJ1ZmZlcl0se3R5cGU6XCJpbWFnZS9cIitmfSk7dHJ5e3dpbmRvdy5uYXZpZ2F0b3IubXNTYXZlQmxvYihmLGIpLGU9ITB9Y2F0Y2goayl7Zy5kYXRhc2V0LmRvd25sb2FkdXJsPVtjLGcuZG93bmxvYWQsZy5ocmVmXS5qb2luKFwiOlwiKSxnLmhyZWY9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoZil9fWlmKCFlKXRyeXtldmVudD1kb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpLFxyXG5ldmVudC5pbml0TW91c2VFdmVudChcImNsaWNrXCIsITAsITEsd2luZG93LDAsMCwwLDAsMCwhMSwhMSwhMSwhMSwwLG51bGwpLGcuZGlzcGF0Y2hFdmVudD9nLmRpc3BhdGNoRXZlbnQoZXZlbnQpOmcuZmlyZUV2ZW50JiZnLmZpcmVFdmVudChcIm9uY2xpY2tcIil9Y2F0Y2gocil7Zj13aW5kb3cub3BlbigpLGYuZG9jdW1lbnQud3JpdGUoXCI8aW1nIHNyYz0nXCIrYStcIic+PC9pbWc+PGRpdj5QbGVhc2UgcmlnaHQgY2xpY2sgb24gdGhlIGltYWdlIGFuZCBzYXZlIGl0IHRvIHlvdXIgZGV2aWNlPC9kaXY+XCIpLGYuZG9jdW1lbnQuY2xvc2UoKX19fWZ1bmN0aW9uIHEoYSxmKXtmPWZ8fHt9O3RoaXMudGhlbWU9eShmLnRoZW1lKXx8eSh5YVtmLnRoZW1lXSk/XCJsaWdodDFcIjpmLnRoZW1lO3EuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJDaGFydFwiLG51bGwsZixudWxsLG51bGwpO3ZhciBiPXRoaXM7dGhpcy5fY29udGFpbmVySWQ9YTt0aGlzLl9vYmplY3RzSW5pdGlhbGl6ZWQ9ITE7dGhpcy5vdmVybGFpZENhbnZhc0N0eD1cclxudGhpcy5jdHg9bnVsbDt0aGlzLl9pbmRleExhYmVscz1bXTt0aGlzLl9wYW5UaW1lcklkPTA7dGhpcy5fbGFzdFRvdWNoRXZlbnRUeXBlPVwiXCI7dGhpcy5fbGFzdFRvdWNoRGF0YT1udWxsO3RoaXMuaXNBbmltYXRpbmc9ITE7dGhpcy5yZW5kZXJDb3VudD0wO3RoaXMucGFuRW5hYmxlZD10aGlzLmRpc2FibGVUb29sVGlwPXRoaXMuYW5pbWF0ZWRSZW5kZXI9ITE7dGhpcy5fZGVmYXVsdEN1cnNvcj1cImRlZmF1bHRcIjt0aGlzLnBsb3RBcmVhPXtjYW52YXM6bnVsbCxjdHg6bnVsbCx4MTowLHkxOjAseDI6MCx5MjowLHdpZHRoOjAsaGVpZ2h0OjB9O3RoaXMuX2RhdGFJblJlbmRlcmVkT3JkZXI9W107aWYodGhpcy5jb250YWluZXI9XCJzdHJpbmdcIj09PXR5cGVvZiB0aGlzLl9jb250YWluZXJJZD9kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9jb250YWluZXJJZCk6dGhpcy5fY29udGFpbmVySWQpe3RoaXMuY29udGFpbmVyLmlubmVySFRNTD1cIlwiO3ZhciBjPTAsZT0wLGM9dGhpcy5vcHRpb25zLndpZHRoP1xyXG50aGlzLndpZHRoOjA8dGhpcy5jb250YWluZXIuY2xpZW50V2lkdGg/dGhpcy5jb250YWluZXIuY2xpZW50V2lkdGg6dGhpcy53aWR0aCxlPXRoaXMub3B0aW9ucy5oZWlnaHQ/dGhpcy5oZWlnaHQ6MDx0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQ/dGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0OnRoaXMuaGVpZ2h0O3RoaXMud2lkdGg9Yzt0aGlzLmhlaWdodD1lO3RoaXMueDE9dGhpcy55MT0wO3RoaXMueDI9dGhpcy53aWR0aDt0aGlzLnkyPXRoaXMuaGVpZ2h0O3RoaXMuX3NlbGVjdGVkQ29sb3JTZXQ9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBBYVt0aGlzLmNvbG9yU2V0XT9BYVt0aGlzLmNvbG9yU2V0XTpBYS5jb2xvclNldDE7dGhpcy5fY2FudmFzSlNDb250YWluZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0aGlzLl9jYW52YXNKU0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLFwiY2FudmFzanMtY2hhcnQtY29udGFpbmVyXCIpO3RoaXMuX2NhbnZhc0pTQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uPVxyXG5cInJlbGF0aXZlXCI7dGhpcy5fY2FudmFzSlNDb250YWluZXIuc3R5bGUudGV4dEFsaWduPVwibGVmdFwiO3RoaXMuX2NhbnZhc0pTQ29udGFpbmVyLnN0eWxlLmN1cnNvcj1cImF1dG9cIjt2fHwodGhpcy5fY2FudmFzSlNDb250YWluZXIuc3R5bGUuaGVpZ2h0PVwiMHB4XCIpO3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhc0pTQ29udGFpbmVyKTt0aGlzLmNhbnZhcz11YShjLGUpO3RoaXMuX3ByZVJlbmRlckNhbnZhcz11YShjLGUpO3RoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIjt0aGlzLmNhbnZhcy5nZXRDb250ZXh0JiYodGhpcy5fY2FudmFzSlNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpLHRoaXMuY3R4PXRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSx0aGlzLmN0eC50ZXh0QmFzZWxpbmU9XCJ0b3BcIixDYSh0aGlzLmN0eCksdGhpcy5fcHJlUmVuZGVyQ3R4PXRoaXMuX3ByZVJlbmRlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksXHJcbnRoaXMuX3ByZVJlbmRlckN0eC50ZXh0QmFzZWxpbmU9XCJ0b3BcIixDYSh0aGlzLl9wcmVSZW5kZXJDdHgpLHY/dGhpcy5wbG90QXJlYS5jdHg9dGhpcy5jdHg6KHRoaXMucGxvdEFyZWEuY2FudmFzPXVhKGMsZSksdGhpcy5wbG90QXJlYS5jYW52YXMuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLHRoaXMucGxvdEFyZWEuY2FudmFzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsXCJwbG90QXJlYUNhbnZhc1wiKSx0aGlzLl9jYW52YXNKU0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnBsb3RBcmVhLmNhbnZhcyksdGhpcy5wbG90QXJlYS5jdHg9dGhpcy5wbG90QXJlYS5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpKSx0aGlzLm92ZXJsYWlkQ2FudmFzPXVhKGMsZSksdGhpcy5vdmVybGFpZENhbnZhcy5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsdGhpcy5vdmVybGFpZENhbnZhcy5zdHlsZS53ZWJraXRUYXBIaWdobGlnaHRDb2xvcj1cInRyYW5zcGFyZW50XCIsdGhpcy5vdmVybGFpZENhbnZhcy5nZXRDb250ZXh0JiZcclxuKHRoaXMuX2NhbnZhc0pTQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMub3ZlcmxhaWRDYW52YXMpLHRoaXMub3ZlcmxhaWRDYW52YXNDdHg9dGhpcy5vdmVybGFpZENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksdGhpcy5vdmVybGFpZENhbnZhc0N0eC50ZXh0QmFzZWxpbmU9XCJ0b3BcIixDYSh0aGlzLm92ZXJsYWlkQ2FudmFzQ3R4KSksdGhpcy5fZXZlbnRNYW5hZ2VyPW5ldyBmYSh0aGlzKSx0aGlzLndpbmRvd1Jlc2l6ZUhhbmRsZXI9Tih3aW5kb3csXCJyZXNpemVcIixmdW5jdGlvbigpe2IuX3VwZGF0ZVNpemUoKSYmYi5yZW5kZXIoKX0pLHRoaXMuX3Rvb2xCYXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLl90b29sQmFyLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsXCJjYW52YXNqcy1jaGFydC10b29sYmFyXCIpLHRoaXMuX3Rvb2xCYXIuc3R5bGUuY3NzVGV4dD1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgcmlnaHQ6IDFweDsgdG9wOiAxcHg7XCIsdGhpcy5fY2FudmFzSlNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fdG9vbEJhciksXHJcbnRoaXMuYm91bmRzPXt4MTowLHkxOjAseDI6dGhpcy53aWR0aCx5Mjp0aGlzLmhlaWdodH0sTih0aGlzLm92ZXJsYWlkQ2FudmFzLFwiY2xpY2tcIixmdW5jdGlvbihhKXtiLl9tb3VzZUV2ZW50SGFuZGxlcihhKX0pLE4odGhpcy5vdmVybGFpZENhbnZhcyxcIm1vdXNlbW92ZVwiLGZ1bmN0aW9uKGEpe2IuX21vdXNlRXZlbnRIYW5kbGVyKGEpfSksTih0aGlzLm92ZXJsYWlkQ2FudmFzLFwibW91c2V1cFwiLGZ1bmN0aW9uKGEpe2IuX21vdXNlRXZlbnRIYW5kbGVyKGEpfSksTih0aGlzLm92ZXJsYWlkQ2FudmFzLFwibW91c2Vkb3duXCIsZnVuY3Rpb24oYSl7Yi5fbW91c2VFdmVudEhhbmRsZXIoYSk7d2EoYi5fZHJvcGRvd25NZW51KX0pLE4odGhpcy5vdmVybGFpZENhbnZhcyxcIm1vdXNlb3V0XCIsZnVuY3Rpb24oYSl7Yi5fbW91c2VFdmVudEhhbmRsZXIoYSl9KSxOKHRoaXMub3ZlcmxhaWRDYW52YXMsd2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkP1wiTVNQb2ludGVyRG93blwiOlwidG91Y2hzdGFydFwiLFxyXG5mdW5jdGlvbihhKXtiLl90b3VjaEV2ZW50SGFuZGxlcihhKX0pLE4odGhpcy5vdmVybGFpZENhbnZhcyx3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ/XCJNU1BvaW50ZXJNb3ZlXCI6XCJ0b3VjaG1vdmVcIixmdW5jdGlvbihhKXtiLl90b3VjaEV2ZW50SGFuZGxlcihhKX0pLE4odGhpcy5vdmVybGFpZENhbnZhcyx3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ/XCJNU1BvaW50ZXJVcFwiOlwidG91Y2hlbmRcIixmdW5jdGlvbihhKXtiLl90b3VjaEV2ZW50SGFuZGxlcihhKX0pLE4odGhpcy5vdmVybGFpZENhbnZhcyx3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ/XCJNU1BvaW50ZXJDYW5jZWxcIjpcInRvdWNoY2FuY2VsXCIsZnVuY3Rpb24oYSl7Yi5fdG91Y2hFdmVudEhhbmRsZXIoYSl9KSx0aGlzLnRvb2xUaXA9bmV3IFkodGhpcyx0aGlzLm9wdGlvbnMudG9vbFRpcCksdGhpcy5kYXRhPW51bGwsdGhpcy5heGlzWD1bXSx0aGlzLmF4aXNYMj1bXSx0aGlzLmF4aXNZPVxyXG5bXSx0aGlzLmF4aXNZMj1bXSx0aGlzLnNlc3Npb25WYXJpYWJsZXM9e2F4aXNYOltdLGF4aXNYMjpbXSxheGlzWTpbXSxheGlzWTI6W119KX1lbHNlIHdpbmRvdy5jb25zb2xlJiZ3aW5kb3cuY29uc29sZS5sb2coJ0NhbnZhc0pTIEVycm9yOiBDaGFydCBDb250YWluZXIgd2l0aCBpZCBcIicrdGhpcy5fY29udGFpbmVySWQrJ1wiIHdhcyBub3QgZm91bmQnKX1mdW5jdGlvbiB4KGEsZil7Zm9yKHZhciBiPVtdLGMsZT0wO2U8YS5sZW5ndGg7ZSsrKWlmKDA9PWUpYi5wdXNoKGFbMF0pO2Vsc2V7dmFyIGcsaCxsO2w9ZS0xO2c9MD09PWw/MDpsLTE7aD1sPT09YS5sZW5ndGgtMT9sOmwrMTtjPU1hdGguYWJzKChhW2hdLngtYVtnXS54KS8oMD09PWFbaF0ueC1hW2xdLng/MC4wMTphW2hdLngtYVtsXS54KSkqKGYtMSkvMisxO3ZhciB0PShhW2hdLngtYVtnXS54KS9jO2M9KGFbaF0ueS1hW2ddLnkpL2M7YltiLmxlbmd0aF09YVtsXS54PmFbZ10ueCYmMDx0fHxhW2xdLng8YVtnXS54JiYwPlxyXG50P3t4OmFbbF0ueCt0LzMseTphW2xdLnkrYy8zfTp7eDphW2xdLngseTphW2xdLnkrYy85fTtsPWU7Zz0wPT09bD8wOmwtMTtoPWw9PT1hLmxlbmd0aC0xP2w6bCsxO2M9TWF0aC5hYnMoKGFbaF0ueC1hW2ddLngpLygwPT09YVtsXS54LWFbZ10ueD8wLjAxOmFbbF0ueC1hW2ddLngpKSooZi0xKS8yKzE7dD0oYVtoXS54LWFbZ10ueCkvYztjPShhW2hdLnktYVtnXS55KS9jO2JbYi5sZW5ndGhdPWFbbF0ueD5hW2ddLngmJjA8dHx8YVtsXS54PGFbZ10ueCYmMD50P3t4OmFbbF0ueC10LzMseTphW2xdLnktYy8zfTp7eDphW2xdLngseTphW2xdLnktYy85fTtiW2IubGVuZ3RoXT1hW2VdfXJldHVybiBifWZ1bmN0aW9uIHooYSxmLGIsYyxlLGcsaCxsLHQsayl7dmFyIHI9MDtrPyhoLmNvbG9yPWcsbC5jb2xvcj1nKTprPTE7cj10P01hdGguYWJzKGUtYik6TWF0aC5hYnMoYy1mKTtyPTA8aC50cmltTGVuZ3RoP01hdGguYWJzKHIqaC50cmltTGVuZ3RoLzEwMCk6TWF0aC5hYnMoci1oLmxlbmd0aCk7XHJcbnQ/KGIrPXIvMixlLT1yLzIpOihmKz1yLzIsYy09ci8yKTt2YXIgcj0xPT09TWF0aC5yb3VuZChoLnRoaWNrbmVzcyklMj8wLjU6MCxwPTE9PT1NYXRoLnJvdW5kKGwudGhpY2tuZXNzKSUyPzAuNTowO2Euc2F2ZSgpO2EuZ2xvYmFsQWxwaGE9azthLnN0cm9rZVN0eWxlPWwuY29sb3J8fGc7YS5saW5lV2lkdGg9bC50aGlja25lc3N8fDI7YS5zZXRMaW5lRGFzaCYmYS5zZXRMaW5lRGFzaChHKGwuZGFzaFR5cGUsbC50aGlja25lc3MpKTthLmJlZ2luUGF0aCgpO3QmJjA8bC50aGlja25lc3M/KGEubW92ZVRvKGMtaC50aGlja25lc3MvMixNYXRoLnJvdW5kKChiK2UpLzIpLXApLGEubGluZVRvKGYraC50aGlja25lc3MvMixNYXRoLnJvdW5kKChiK2UpLzIpLXApKTowPGwudGhpY2tuZXNzJiYoYS5tb3ZlVG8oTWF0aC5yb3VuZCgoZitjKS8yKS1wLGIraC50aGlja25lc3MvMiksYS5saW5lVG8oTWF0aC5yb3VuZCgoZitjKS8yKS1wLGUtaC50aGlja25lc3MvMikpO2Euc3Ryb2tlKCk7YS5zdHJva2VTdHlsZT1cclxuaC5jb2xvcnx8ZzthLmxpbmVXaWR0aD1oLnRoaWNrbmVzc3x8MjthLnNldExpbmVEYXNoJiZhLnNldExpbmVEYXNoKEcoaC5kYXNoVHlwZSxoLnRoaWNrbmVzcykpO2EuYmVnaW5QYXRoKCk7dCYmMDxoLnRoaWNrbmVzcz8oYS5tb3ZlVG8oYy1yLGIpLGEubGluZVRvKGMtcixlKSxhLm1vdmVUbyhmK3IsYiksYS5saW5lVG8oZityLGUpKTowPGgudGhpY2tuZXNzJiYoYS5tb3ZlVG8oZixiK3IpLGEubGluZVRvKGMsYityKSxhLm1vdmVUbyhmLGUtciksYS5saW5lVG8oYyxlLXIpKTthLnN0cm9rZSgpO2EucmVzdG9yZSgpfWZ1bmN0aW9uIE8oYSxmLGIsYyxlKXtpZihudWxsPT09YXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhKXJldHVyblwidW5kZWZpbmVkXCI9PT10eXBlb2YgYj9mOmI7YT1wYXJzZUZsb2F0KGEudG9TdHJpbmcoKSkqKDA8PWEudG9TdHJpbmcoKS5pbmRleE9mKFwiJVwiKT9mLzEwMDoxKTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGMmJihhPU1hdGgubWluKGMsYSksXCJ1bmRlZmluZWRcIiE9PVxyXG50eXBlb2YgZSYmKGE9TWF0aC5tYXgoZSxhKSkpO3JldHVybiFpc05hTihhKSYmYTw9ZiYmMDw9YT9hOlwidW5kZWZpbmVkXCI9PT10eXBlb2YgYj9mOmJ9ZnVuY3Rpb24gVChhLGYpe1QuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJMZWdlbmRcIixcImxlZ2VuZFwiLGYsbnVsbCxhKTt0aGlzLmNoYXJ0PWE7dGhpcy5jYW52YXM9YS5jYW52YXM7dGhpcy5jdHg9dGhpcy5jaGFydC5jdHg7dGhpcy5naG9zdEN0eD10aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIuZ2hvc3RDdHg7dGhpcy5pdGVtcz1bXTt0aGlzLm9wdGlvbnNOYW1lPVwibGVnZW5kXCI7dGhpcy5oZWlnaHQ9dGhpcy53aWR0aD0wO3RoaXMub3JpZW50YXRpb249bnVsbDt0aGlzLmRhdGFTZXJpZXM9W107dGhpcy5ib3VuZHM9e3gxOm51bGwseTE6bnVsbCx4MjpudWxsLHkyOm51bGx9O1widW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmZvbnRTaXplJiYodGhpcy5mb250U2l6ZT10aGlzLmNoYXJ0LmdldEF1dG9Gb250U2l6ZSh0aGlzLmZvbnRTaXplKSk7XHJcbnRoaXMubGluZUhlaWdodD1VYSh0aGlzLmZvbnRGYW1pbHksdGhpcy5mb250U2l6ZSx0aGlzLmZvbnRXZWlnaHQpO3RoaXMuaG9yaXpvbnRhbFNwYWNpbmc9dGhpcy5mb250U2l6ZX1mdW5jdGlvbiBRKGEsZixiLGMpe1EuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJEYXRhU2VyaWVzXCIsXCJkYXRhXCIsZixiLGEpO3RoaXMuY2hhcnQ9YTt0aGlzLmNhbnZhcz1hLmNhbnZhczt0aGlzLl9jdHg9YS5jYW52YXMuY3R4O3RoaXMuaW5kZXg9Yjt0aGlzLm5vRGF0YVBvaW50c0luUGxvdEFyZWE9MDt0aGlzLmlkPWM7dGhpcy5jaGFydC5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtjXT17aWQ6YyxvYmplY3RUeXBlOlwiZGF0YVNlcmllc1wiLGRhdGFTZXJpZXNJbmRleDpifTthPWYuZGF0YVBvaW50cz9mLmRhdGFQb2ludHMubGVuZ3RoOjA7dGhpcy5kYXRhUG9pbnRFT3M9W107Zm9yKGY9MDtmPGE7ZisrKXRoaXMuZGF0YVBvaW50RU9zW2ZdPXt9O3RoaXMuZGF0YVBvaW50SWRzPVtdO3RoaXMucGxvdFVuaXQ9XHJcbltdO3RoaXMuYXhpc1k9dGhpcy5heGlzWD1udWxsO3RoaXMub3B0aW9uc05hbWU9XCJkYXRhXCI7dGhpcy5pc09wdGlvbnNJbkFycmF5PSEwO251bGw9PT10aGlzLmZpbGxPcGFjaXR5JiYodGhpcy50eXBlLm1hdGNoKC9hcmVhL2kpP3RoaXMuZmlsbE9wYWNpdHk9MC43OnRoaXMuZmlsbE9wYWNpdHk9MSk7dGhpcy5heGlzUGxhY2VtZW50PXRoaXMuZ2V0RGVmYXVsdEF4aXNQbGFjZW1lbnQoKTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5pbmRleExhYmVsRm9udFNpemUmJih0aGlzLmluZGV4TGFiZWxGb250U2l6ZT10aGlzLmNoYXJ0LmdldEF1dG9Gb250U2l6ZSh0aGlzLmluZGV4TGFiZWxGb250U2l6ZSkpfWZ1bmN0aW9uIEMoYSxmLGIsYyxlLGcpe0MuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJBeGlzXCIsZixiLGMsYSk7dGhpcy5jaGFydD1hO3RoaXMuY2FudmFzPWEuY2FudmFzO3RoaXMuY3R4PWEuY3R4O3RoaXMuaW50ZXJ2YWxTdGFydFBvc2l0aW9uPXRoaXMubWF4SGVpZ2h0PVxyXG50aGlzLm1heFdpZHRoPTA7dGhpcy5sYWJlbHM9W107dGhpcy5kYXRhU2VyaWVzPVtdO3RoaXMuX3N0cmlwTGluZUxhYmVscz10aGlzLl90aWNrcz10aGlzLl9sYWJlbHM9bnVsbDt0aGlzLmRhdGFJbmZvPXttaW46SW5maW5pdHksbWF4Oi1JbmZpbml0eSx2aWV3UG9ydE1pbjpJbmZpbml0eSx2aWV3UG9ydE1heDotSW5maW5pdHksbWluRGlmZjpJbmZpbml0eX07dGhpcy5pc09wdGlvbnNJbkFycmF5PSEwO1wiYXhpc1hcIj09PWU/KFwibGVmdFwiPT09Z3x8XCJib3R0b21cIj09PWc/KHRoaXMub3B0aW9uc05hbWU9XCJheGlzWFwiLHkodGhpcy5jaGFydC5zZXNzaW9uVmFyaWFibGVzLmF4aXNYW2NdKSYmKHRoaXMuY2hhcnQuc2Vzc2lvblZhcmlhYmxlcy5heGlzWFtjXT17fSksdGhpcy5zZXNzaW9uVmFyaWFibGVzPXRoaXMuY2hhcnQuc2Vzc2lvblZhcmlhYmxlcy5heGlzWFtjXSk6KHRoaXMub3B0aW9uc05hbWU9XCJheGlzWDJcIix5KHRoaXMuY2hhcnQuc2Vzc2lvblZhcmlhYmxlcy5heGlzWDJbY10pJiZcclxuKHRoaXMuY2hhcnQuc2Vzc2lvblZhcmlhYmxlcy5heGlzWDJbY109e30pLHRoaXMuc2Vzc2lvblZhcmlhYmxlcz10aGlzLmNoYXJ0LnNlc3Npb25WYXJpYWJsZXMuYXhpc1gyW2NdKSx0aGlzLm9wdGlvbnMuaW50ZXJ2YWx8fCh0aGlzLmludGVydmFsVHlwZT1udWxsKSk6XCJsZWZ0XCI9PT1nfHxcImJvdHRvbVwiPT09Zz8odGhpcy5vcHRpb25zTmFtZT1cImF4aXNZXCIseSh0aGlzLmNoYXJ0LnNlc3Npb25WYXJpYWJsZXMuYXhpc1lbY10pJiYodGhpcy5jaGFydC5zZXNzaW9uVmFyaWFibGVzLmF4aXNZW2NdPXt9KSx0aGlzLnNlc3Npb25WYXJpYWJsZXM9dGhpcy5jaGFydC5zZXNzaW9uVmFyaWFibGVzLmF4aXNZW2NdKToodGhpcy5vcHRpb25zTmFtZT1cImF4aXNZMlwiLHkodGhpcy5jaGFydC5zZXNzaW9uVmFyaWFibGVzLmF4aXNZMltjXSkmJih0aGlzLmNoYXJ0LnNlc3Npb25WYXJpYWJsZXMuYXhpc1kyW2NdPXt9KSx0aGlzLnNlc3Npb25WYXJpYWJsZXM9dGhpcy5jaGFydC5zZXNzaW9uVmFyaWFibGVzLmF4aXNZMltjXSk7XHJcblwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLnRpdGxlRm9udFNpemUmJih0aGlzLnRpdGxlRm9udFNpemU9dGhpcy5jaGFydC5nZXRBdXRvRm9udFNpemUodGhpcy50aXRsZUZvbnRTaXplKSk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSYmKHRoaXMubGFiZWxGb250U2l6ZT10aGlzLmNoYXJ0LmdldEF1dG9Gb250U2l6ZSh0aGlzLmxhYmVsRm9udFNpemUpKTt0aGlzLnR5cGU9ZTtcImF4aXNYXCIhPT1lfHxiJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGIuZ3JpZFRoaWNrbmVzc3x8KHRoaXMuZ3JpZFRoaWNrbmVzcz0wKTt0aGlzLl9wb3NpdGlvbj1nO3RoaXMubGluZUNvb3JkaW5hdGVzPXt4MTpudWxsLHkxOm51bGwseDI6bnVsbCx5MjpudWxsLHdpZHRoOm51bGx9O3RoaXMubGFiZWxBbmdsZT0odGhpcy5sYWJlbEFuZ2xlJTM2MCszNjApJTM2MDs5MDx0aGlzLmxhYmVsQW5nbGUmJjI3MD50aGlzLmxhYmVsQW5nbGU/dGhpcy5sYWJlbEFuZ2xlLT1cclxuMTgwOjI3MDw9dGhpcy5sYWJlbEFuZ2xlJiYzNjA+PXRoaXMubGFiZWxBbmdsZSYmKHRoaXMubGFiZWxBbmdsZS09MzYwKTt0aGlzLm9wdGlvbnMuc2NhbGVCcmVha3MmJih0aGlzLnNjYWxlQnJlYWtzPW5ldyBQKHRoaXMuY2hhcnQsdGhpcy5vcHRpb25zLnNjYWxlQnJlYWtzLCsrdGhpcy5jaGFydC5fZXZlbnRNYW5hZ2VyLmxhc3RPYmplY3RJZCx0aGlzKSk7dGhpcy5zdHJpcExpbmVzPVtdO2lmKHRoaXMub3B0aW9ucy5zdHJpcExpbmVzJiYwPHRoaXMub3B0aW9ucy5zdHJpcExpbmVzLmxlbmd0aClmb3IoYT0wO2E8dGhpcy5vcHRpb25zLnN0cmlwTGluZXMubGVuZ3RoO2ErKyl0aGlzLnN0cmlwTGluZXMucHVzaChuZXcgZ2EodGhpcy5jaGFydCx0aGlzLm9wdGlvbnMuc3RyaXBMaW5lc1thXSxhLCsrdGhpcy5jaGFydC5fZXZlbnRNYW5hZ2VyLmxhc3RPYmplY3RJZCx0aGlzKSk7dGhpcy5vcHRpb25zLmNyb3NzaGFpciYmKHRoaXMuY3Jvc3NoYWlyPW5ldyBpYSh0aGlzLmNoYXJ0LFxyXG50aGlzLm9wdGlvbnMuY3Jvc3NoYWlyLHRoaXMpKTt0aGlzLl90aXRsZVRleHRCbG9jaz1udWxsO3RoaXMuaGFzT3B0aW9uQ2hhbmdlZChcInZpZXdwb3J0TWluaW11bVwiKSYmbnVsbD09PXRoaXMudmlld3BvcnRNaW5pbXVtJiYodGhpcy5vcHRpb25zLnZpZXdwb3J0TWluaW11bT12b2lkIDAsdGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWluaW11bT1udWxsKTt0aGlzLmhhc09wdGlvbkNoYW5nZWQoXCJ2aWV3cG9ydE1pbmltdW1cIil8fGlzTmFOKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW0pfHxudWxsPT09dGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bT90aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtPW51bGw6dGhpcy52aWV3cG9ydE1pbmltdW09dGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bTt0aGlzLmhhc09wdGlvbkNoYW5nZWQoXCJ2aWV3cG9ydE1heGltdW1cIikmJm51bGw9PT1cclxudGhpcy52aWV3cG9ydE1heGltdW0mJih0aGlzLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtPXZvaWQgMCx0aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNYXhpbXVtPW51bGwpO3RoaXMuaGFzT3B0aW9uQ2hhbmdlZChcInZpZXdwb3J0TWF4aW11bVwiKXx8aXNOYU4odGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bSl8fG51bGw9PT10aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW09bnVsbDp0aGlzLnZpZXdwb3J0TWF4aW11bT10aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtO251bGwhPT10aGlzLm1pbmltdW0mJm51bGwhPT10aGlzLnZpZXdwb3J0TWluaW11bSYmKHRoaXMudmlld3BvcnRNaW5pbXVtPU1hdGgubWF4KHRoaXMudmlld3BvcnRNaW5pbXVtLHRoaXMubWluaW11bSkpO251bGwhPT10aGlzLm1heGltdW0mJm51bGwhPT10aGlzLnZpZXdwb3J0TWF4aW11bSYmXHJcbih0aGlzLnZpZXdwb3J0TWF4aW11bT1NYXRoLm1pbih0aGlzLnZpZXdwb3J0TWF4aW11bSx0aGlzLm1heGltdW0pKTt0aGlzLnRyYWNrQ2hhbmdlcyhcInZpZXdwb3J0TWluaW11bVwiKTt0aGlzLnRyYWNrQ2hhbmdlcyhcInZpZXdwb3J0TWF4aW11bVwiKX1mdW5jdGlvbiBQKGEsZixiLGMpe1AuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJTY2FsZUJyZWFrc1wiLFwic2NhbGVCcmVha3NcIixmLG51bGwsYyk7dGhpcy5pZD1iO3RoaXMuY2hhcnQ9YTt0aGlzLmN0eD10aGlzLmNoYXJ0LmN0eDt0aGlzLmF4aXM9Yzt0aGlzLm9wdGlvbnNOYW1lPVwic2NhbGVCcmVha3NcIjt0aGlzLmlzT3B0aW9uc0luQXJyYXk9ITE7dGhpcy5fYXBwbGllZEJyZWFrcz1bXTt0aGlzLmN1c3RvbUJyZWFrcz1bXTt0aGlzLmF1dG9CcmVha3M9W107XCJzdHJpbmdcIj09PXR5cGVvZiB0aGlzLnNwYWNpbmc/KHRoaXMuc3BhY2luZz1wYXJzZUZsb2F0KHRoaXMuc3BhY2luZyksdGhpcy5zcGFjaW5nPWlzTmFOKHRoaXMuc3BhY2luZyk/XHJcbjg6KDEwPHRoaXMuc3BhY2luZz8xMDp0aGlzLnNwYWNpbmcpK1wiJVwiKTpcIm51bWJlclwiIT09dHlwZW9mIHRoaXMuc3BhY2luZyYmKHRoaXMuc3BhY2luZz04KTt0aGlzLmF1dG9DYWxjdWxhdGUmJih0aGlzLm1heE51bWJlck9mQXV0b0JyZWFrcz1NYXRoLm1pbih0aGlzLm1heE51bWJlck9mQXV0b0JyZWFrcyw1KSk7aWYodGhpcy5vcHRpb25zLmN1c3RvbUJyZWFrcyYmMDx0aGlzLm9wdGlvbnMuY3VzdG9tQnJlYWtzLmxlbmd0aCl7Zm9yKGE9MDthPHRoaXMub3B0aW9ucy5jdXN0b21CcmVha3MubGVuZ3RoO2ErKyl0aGlzLmN1c3RvbUJyZWFrcy5wdXNoKG5ldyBhYSh0aGlzLmNoYXJ0LFwiY3VzdG9tQnJlYWtzXCIsdGhpcy5vcHRpb25zLmN1c3RvbUJyZWFrc1thXSxhLCsrdGhpcy5jaGFydC5fZXZlbnRNYW5hZ2VyLmxhc3RPYmplY3RJZCx0aGlzKSksXCJudW1iZXJcIj09PXR5cGVvZiB0aGlzLmN1c3RvbUJyZWFrc1thXS5zdGFydFZhbHVlJiYoXCJudW1iZXJcIj09PXR5cGVvZiB0aGlzLmN1c3RvbUJyZWFrc1thXS5lbmRWYWx1ZSYmXHJcbnRoaXMuY3VzdG9tQnJlYWtzW2FdLmVuZFZhbHVlIT09dGhpcy5jdXN0b21CcmVha3NbYV0uc3RhcnRWYWx1ZSkmJnRoaXMuX2FwcGxpZWRCcmVha3MucHVzaCh0aGlzLmN1c3RvbUJyZWFrc1thXSk7dGhpcy5fYXBwbGllZEJyZWFrcy5zb3J0KGZ1bmN0aW9uKGEsYyl7cmV0dXJuIGEuc3RhcnRWYWx1ZS1jLnN0YXJ0VmFsdWV9KTtmb3IoYT0wO2E8dGhpcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgtMTthKyspdGhpcy5fYXBwbGllZEJyZWFrc1thXS5lbmRWYWx1ZT49dGhpcy5fYXBwbGllZEJyZWFrc1thKzFdLnN0YXJ0VmFsdWUmJih0aGlzLl9hcHBsaWVkQnJlYWtzW2FdLmVuZFZhbHVlPU1hdGgubWF4KHRoaXMuX2FwcGxpZWRCcmVha3NbYV0uZW5kVmFsdWUsdGhpcy5fYXBwbGllZEJyZWFrc1thKzFdLmVuZFZhbHVlKSx3aW5kb3cuY29uc29sZSYmd2luZG93LmNvbnNvbGUubG9nKFwiQ2FudmFzSlMgRXJyb3I6IEJyZWFrcyBcIithK1wiIGFuZCBcIisoYSsxKStcIiBhcmUgb3ZlcmxhcHBpbmcuXCIpLFxyXG50aGlzLl9hcHBsaWVkQnJlYWtzLnNwbGljZShhLDIpLGEtLSl9fWZ1bmN0aW9uIGFhKGEsZixiLGMsZSxnKXthYS5iYXNlLmNvbnN0cnVjdG9yLmNhbGwodGhpcyxcIkJyZWFrXCIsZixiLGMsZyk7dGhpcy5pZD1lO3RoaXMuY2hhcnQ9YTt0aGlzLmN0eD10aGlzLmNoYXJ0LmN0eDt0aGlzLnNjYWxlQnJlYWtzPWc7dGhpcy5vcHRpb25zTmFtZT1mO3RoaXMuaXNPcHRpb25zSW5BcnJheT0hMDt0aGlzLnR5cGU9Yi50eXBlP3RoaXMudHlwZTpnLnR5cGU7dGhpcy5maWxsT3BhY2l0eT15KGIuZmlsbE9wYWNpdHkpP2cuZmlsbE9wYWNpdHk6dGhpcy5maWxsT3BhY2l0eTt0aGlzLmxpbmVUaGlja25lc3M9eShiLmxpbmVUaGlja25lc3MpP2cubGluZVRoaWNrbmVzczp0aGlzLmxpbmVUaGlja25lc3M7dGhpcy5jb2xvcj1iLmNvbG9yP3RoaXMuY29sb3I6Zy5jb2xvcjt0aGlzLmxpbmVDb2xvcj1iLmxpbmVDb2xvcj90aGlzLmxpbmVDb2xvcjpnLmxpbmVDb2xvcjt0aGlzLmxpbmVEYXNoVHlwZT1cclxuYi5saW5lRGFzaFR5cGU/dGhpcy5saW5lRGFzaFR5cGU6Zy5saW5lRGFzaFR5cGU7IXkodGhpcy5zdGFydFZhbHVlKSYmdGhpcy5zdGFydFZhbHVlLmdldFRpbWUmJih0aGlzLnN0YXJ0VmFsdWU9dGhpcy5zdGFydFZhbHVlLmdldFRpbWUoKSk7IXkodGhpcy5lbmRWYWx1ZSkmJnRoaXMuZW5kVmFsdWUuZ2V0VGltZSYmKHRoaXMuZW5kVmFsdWU9dGhpcy5lbmRWYWx1ZS5nZXRUaW1lKCkpO1wibnVtYmVyXCI9PT10eXBlb2YgdGhpcy5zdGFydFZhbHVlJiYoXCJudW1iZXJcIj09PXR5cGVvZiB0aGlzLmVuZFZhbHVlJiZ0aGlzLmVuZFZhbHVlPHRoaXMuc3RhcnRWYWx1ZSkmJihhPXRoaXMuc3RhcnRWYWx1ZSx0aGlzLnN0YXJ0VmFsdWU9dGhpcy5lbmRWYWx1ZSx0aGlzLmVuZFZhbHVlPWEpO3RoaXMuc3BhY2luZz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGIuc3BhY2luZz9nLnNwYWNpbmc6Yi5zcGFjaW5nO1wic3RyaW5nXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLnNwYWNpbmc/KHRoaXMuc3BhY2luZz1cclxucGFyc2VGbG9hdCh0aGlzLnNwYWNpbmcpLHRoaXMuc3BhY2luZz1pc05hTih0aGlzLnNwYWNpbmcpPzA6KDEwPHRoaXMuc3BhY2luZz8xMDp0aGlzLnNwYWNpbmcpK1wiJVwiKTpcIm51bWJlclwiIT09dHlwZW9mIHRoaXMub3B0aW9ucy5zcGFjaW5nJiYodGhpcy5zcGFjaW5nPWcuc3BhY2luZyk7dGhpcy5zaXplPWcucGFyZW50LmxvZ2FyaXRobWljPzE6MH1mdW5jdGlvbiBnYShhLGYsYixjLGUpe2dhLmJhc2UuY29uc3RydWN0b3IuY2FsbCh0aGlzLFwiU3RyaXBMaW5lXCIsXCJzdHJpcExpbmVzXCIsZixiLGUpO3RoaXMuaWQ9Yzt0aGlzLmNoYXJ0PWE7dGhpcy5jdHg9dGhpcy5jaGFydC5jdHg7dGhpcy5sYWJlbD10aGlzLmxhYmVsO3RoaXMuYXhpcz1lO3RoaXMub3B0aW9uc05hbWU9XCJzdHJpcExpbmVzXCI7dGhpcy5pc09wdGlvbnNJbkFycmF5PSEwO3RoaXMuX3RoaWNrbmVzc1R5cGU9XCJwaXhlbFwiO251bGwhPT10aGlzLnN0YXJ0VmFsdWUmJm51bGwhPT10aGlzLmVuZFZhbHVlJiYodGhpcy52YWx1ZT1cclxuZS5sb2dhcml0aG1pYz9NYXRoLnNxcnQoKHRoaXMuc3RhcnRWYWx1ZS5nZXRUaW1lP3RoaXMuc3RhcnRWYWx1ZS5nZXRUaW1lKCk6dGhpcy5zdGFydFZhbHVlKSoodGhpcy5lbmRWYWx1ZS5nZXRUaW1lP3RoaXMuZW5kVmFsdWUuZ2V0VGltZSgpOnRoaXMuZW5kVmFsdWUpKTooKHRoaXMuc3RhcnRWYWx1ZS5nZXRUaW1lP3RoaXMuc3RhcnRWYWx1ZS5nZXRUaW1lKCk6dGhpcy5zdGFydFZhbHVlKSsodGhpcy5lbmRWYWx1ZS5nZXRUaW1lP3RoaXMuZW5kVmFsdWUuZ2V0VGltZSgpOnRoaXMuZW5kVmFsdWUpKS8yLHRoaXMuX3RoaWNrbmVzc1R5cGU9bnVsbCl9ZnVuY3Rpb24gaWEoYSxmLGIpe2lhLmJhc2UuY29uc3RydWN0b3IuY2FsbCh0aGlzLFwiQ3Jvc3NoYWlyXCIsXCJjcm9zc2hhaXJcIixmLG51bGwsYik7dGhpcy5jaGFydD1hO3RoaXMuY3R4PXRoaXMuY2hhcnQuY3R4O3RoaXMuYXhpcz1iO3RoaXMub3B0aW9uc05hbWU9XCJjcm9zc2hhaXJcIjt0aGlzLl90aGlja25lc3NUeXBlPVwicGl4ZWxcIn1cclxuZnVuY3Rpb24gWShhLGYpe1kuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJUb29sVGlwXCIsXCJ0b29sVGlwXCIsZixudWxsLGEpO3RoaXMuY2hhcnQ9YTt0aGlzLmNhbnZhcz1hLmNhbnZhczt0aGlzLmN0eD10aGlzLmNoYXJ0LmN0eDt0aGlzLmN1cnJlbnREYXRhUG9pbnRJbmRleD10aGlzLmN1cnJlbnRTZXJpZXNJbmRleD0tMTt0aGlzLl90aW1lcklkPTA7dGhpcy5fcHJldlk9dGhpcy5fcHJldlg9TmFOO3RoaXMuY29udGFpbmVyVHJhbnNpdGlvbkR1cmF0aW9uPTAuMTt0aGlzLm1vekNvbnRhaW5lclRyYW5zaXRpb249dGhpcy5nZXRDb250YWluZXJUcmFuc2l0aW9uKHRoaXMuY29udGFpbmVyVHJhbnNpdGlvbkR1cmF0aW9uKTt0aGlzLm9wdGlvbnNOYW1lPVwidG9vbFRpcFwiO3RoaXMuX2luaXRpYWxpemUoKX1mdW5jdGlvbiBmYShhKXt0aGlzLmNoYXJ0PWE7dGhpcy5sYXN0T2JqZWN0SWQ9MDt0aGlzLm9iamVjdE1hcD1bXTt0aGlzLnJlY3Rhbmd1bGFyUmVnaW9uRXZlbnRTdWJzY3JpcHRpb25zPVxyXG5bXTt0aGlzLnByZXZpb3VzRGF0YVBvaW50RXZlbnRPYmplY3Q9bnVsbDt0aGlzLmdob3N0Q2FudmFzPXVhKHRoaXMuY2hhcnQud2lkdGgsdGhpcy5jaGFydC5oZWlnaHQpO3RoaXMuZ2hvc3RDdHg9dGhpcy5naG9zdENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7dGhpcy5tb3VzZW92ZXJlZE9iamVjdE1hcHM9W119ZnVuY3Rpb24ga2EoYSl7dGhpcy5jaGFydD1hO3RoaXMuY3R4PXRoaXMuY2hhcnQucGxvdEFyZWEuY3R4O3RoaXMuYW5pbWF0aW9ucz1bXTt0aGlzLmFuaW1hdGlvblJlcXVlc3RJZD1udWxsfXBhKHEsWCk7cS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciBhPXdpbmRvdyxmPXRoaXMud2luZG93UmVzaXplSGFuZGxlcjthLnJlbW92ZUV2ZW50TGlzdGVuZXI/YS5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsZik6YS5kZXRhY2hFdmVudCYmYS5kZXRhY2hFdmVudChcIm9ucmVzaXplXCIsZil9O3EucHJvdG90eXBlLl91cGRhdGVPcHRpb25zPWZ1bmN0aW9uKCl7dmFyIGE9XHJcbnRoaXM7dGhpcy51cGRhdGVPcHRpb24oXCJ3aWR0aFwiKTt0aGlzLnVwZGF0ZU9wdGlvbihcImhlaWdodFwiKTt0aGlzLnVwZGF0ZU9wdGlvbihcImRhdGFQb2ludFdpZHRoXCIpO3RoaXMudXBkYXRlT3B0aW9uKFwiZGF0YVBvaW50TWluV2lkdGhcIik7dGhpcy51cGRhdGVPcHRpb24oXCJkYXRhUG9pbnRNYXhXaWR0aFwiKTt0aGlzLnVwZGF0ZU9wdGlvbihcImludGVyYWN0aXZpdHlFbmFibGVkXCIpO3RoaXMudXBkYXRlT3B0aW9uKFwidGhlbWVcIik7dGhpcy51cGRhdGVPcHRpb24oXCJjb2xvclNldFwiKSYmKHRoaXMuX3NlbGVjdGVkQ29sb3JTZXQ9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBBYVt0aGlzLmNvbG9yU2V0XT9BYVt0aGlzLmNvbG9yU2V0XTpBYS5jb2xvclNldDEpO3RoaXMudXBkYXRlT3B0aW9uKFwiYmFja2dyb3VuZENvbG9yXCIpO3RoaXMuYmFja2dyb3VuZENvbG9yfHwodGhpcy5iYWNrZ3JvdW5kQ29sb3I9XCJyZ2JhKDAsMCwwLDApXCIpO3RoaXMudXBkYXRlT3B0aW9uKFwiY3VsdHVyZVwiKTt0aGlzLl9jdWx0dXJlSW5mbz1cclxubmV3IEphKHRoaXMub3B0aW9ucy5jdWx0dXJlKTt0aGlzLnVwZGF0ZU9wdGlvbihcImFuaW1hdGlvbkVuYWJsZWRcIik7dGhpcy5hbmltYXRpb25FbmFibGVkPXRoaXMuYW5pbWF0aW9uRW5hYmxlZCYmdjt0aGlzLnVwZGF0ZU9wdGlvbihcImFuaW1hdGlvbkR1cmF0aW9uXCIpO3RoaXMudXBkYXRlT3B0aW9uKFwicmFuZ2VDaGFuZ2luZ1wiKTt0aGlzLnVwZGF0ZU9wdGlvbihcInJhbmdlQ2hhbmdlZFwiKTt0aGlzLnVwZGF0ZU9wdGlvbihcImV4cG9ydEVuYWJsZWRcIik7dGhpcy51cGRhdGVPcHRpb24oXCJleHBvcnRGaWxlTmFtZVwiKTt0aGlzLnVwZGF0ZU9wdGlvbihcInpvb21UeXBlXCIpO2lmKHRoaXMub3B0aW9ucy56b29tRW5hYmxlZCl7aWYoIXRoaXMuX3pvb21CdXR0b24pe3ZhciBmPSExO3dhKHRoaXMuX3pvb21CdXR0b249ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSk7dmEodGhpcyx0aGlzLl96b29tQnV0dG9uLFwicGFuXCIpO3RoaXMuX3Rvb2xCYXIuYXBwZW5kQ2hpbGQodGhpcy5fem9vbUJ1dHRvbik7XHJcbnRoaXMuX3pvb21CdXR0b24uc3R5bGUuYm9yZGVyUmlnaHQ9dGhpcy50b29sYmFyLmJvcmRlclRoaWNrbmVzcytcInB4IHNvbGlkIFwiK3RoaXMudG9vbGJhci5ib3JkZXJDb2xvcjtOKHRoaXMuX3pvb21CdXR0b24sXCJ0b3VjaHN0YXJ0XCIsZnVuY3Rpb24oYSl7Zj0hMH0pO04odGhpcy5fem9vbUJ1dHRvbixcImNsaWNrXCIsZnVuY3Rpb24oKXthLnpvb21FbmFibGVkPyhhLnpvb21FbmFibGVkPSExLGEucGFuRW5hYmxlZD0hMCx2YShhLGEuX3pvb21CdXR0b24sXCJ6b29tXCIpKTooYS56b29tRW5hYmxlZD0hMCxhLnBhbkVuYWJsZWQ9ITEsdmEoYSxhLl96b29tQnV0dG9uLFwicGFuXCIpKTthLnJlbmRlcigpfSk7Tih0aGlzLl96b29tQnV0dG9uLFwibW91c2VvdmVyXCIsZnVuY3Rpb24oKXtmP2Y9ITE6KHFhKGEsYS5fem9vbUJ1dHRvbix7YmFja2dyb3VuZENvbG9yOmEudG9vbGJhci5iYWNrZ3JvdW5kQ29sb3JPbkhvdmVyLGNvbG9yOmEudG9vbGJhci5mb250Q29sb3JPbkhvdmVyLHRyYW5zaXRpb246XCIwLjRzXCIsXHJcbldlYmtpdFRyYW5zaXRpb246XCIwLjRzXCJ9KSwwPj1uYXZpZ2F0b3IudXNlckFnZW50LnNlYXJjaChcIk1TSUVcIikmJnFhKGEsYS5fem9vbUJ1dHRvbi5jaGlsZE5vZGVzWzBdLHtXZWJraXRGaWx0ZXI6XCJpbnZlcnQoMTAwJSlcIixmaWx0ZXI6XCJpbnZlcnQoMTAwJSlcIn0pKX0pO04odGhpcy5fem9vbUJ1dHRvbixcIm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtmfHwocWEoYSxhLl96b29tQnV0dG9uLHtiYWNrZ3JvdW5kQ29sb3I6YS50b29sYmFyLmJhY2tncm91bmRDb2xvcixjb2xvcjphLnRvb2xiYXIuZm9udENvbG9yLHRyYW5zaXRpb246XCIwLjRzXCIsV2Via2l0VHJhbnNpdGlvbjpcIjAuNHNcIn0pLDA+PW5hdmlnYXRvci51c2VyQWdlbnQuc2VhcmNoKFwiTVNJRVwiKSYmcWEoYSxhLl96b29tQnV0dG9uLmNoaWxkTm9kZXNbMF0se1dlYmtpdEZpbHRlcjpcImludmVydCgwJSlcIixmaWx0ZXI6XCJpbnZlcnQoMCUpXCJ9KSl9KX10aGlzLl9yZXNldEJ1dHRvbnx8KGY9ITEsd2EodGhpcy5fcmVzZXRCdXR0b249XHJcbmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIikpLHZhKHRoaXMsdGhpcy5fcmVzZXRCdXR0b24sXCJyZXNldFwiKSx0aGlzLl9yZXNldEJ1dHRvbi5zdHlsZS5ib3JkZXJSaWdodD0odGhpcy5leHBvcnRFbmFibGVkP3RoaXMudG9vbGJhci5ib3JkZXJUaGlja25lc3M6MCkrXCJweCBzb2xpZCBcIit0aGlzLnRvb2xiYXIuYm9yZGVyQ29sb3IsdGhpcy5fdG9vbEJhci5hcHBlbmRDaGlsZCh0aGlzLl9yZXNldEJ1dHRvbiksTih0aGlzLl9yZXNldEJ1dHRvbixcInRvdWNoc3RhcnRcIixmdW5jdGlvbihhKXtmPSEwfSksTih0aGlzLl9yZXNldEJ1dHRvbixcImNsaWNrXCIsZnVuY3Rpb24oKXthLnRvb2xUaXAuaGlkZSgpO2Euem9vbUVuYWJsZWR8fGEucGFuRW5hYmxlZD8oYS56b29tRW5hYmxlZD0hMCxhLnBhbkVuYWJsZWQ9ITEsdmEoYSxhLl96b29tQnV0dG9uLFwicGFuXCIpLGEuX2RlZmF1bHRDdXJzb3I9XCJkZWZhdWx0XCIsYS5vdmVybGFpZENhbnZhcy5zdHlsZS5jdXJzb3I9YS5fZGVmYXVsdEN1cnNvcik6XHJcbihhLnpvb21FbmFibGVkPSExLGEucGFuRW5hYmxlZD0hMSk7aWYoYS5zZXNzaW9uVmFyaWFibGVzLmF4aXNYKWZvcih2YXIgYz0wO2M8YS5zZXNzaW9uVmFyaWFibGVzLmF4aXNYLmxlbmd0aDtjKyspYS5zZXNzaW9uVmFyaWFibGVzLmF4aXNYW2NdLm5ld1ZpZXdwb3J0TWluaW11bT1udWxsLGEuc2Vzc2lvblZhcmlhYmxlcy5heGlzWFtjXS5uZXdWaWV3cG9ydE1heGltdW09bnVsbDtpZihhLnNlc3Npb25WYXJpYWJsZXMuYXhpc1gyKWZvcihjPTA7YzxhLnNlc3Npb25WYXJpYWJsZXMuYXhpc1gyLmxlbmd0aDtjKyspYS5zZXNzaW9uVmFyaWFibGVzLmF4aXNYMltjXS5uZXdWaWV3cG9ydE1pbmltdW09bnVsbCxhLnNlc3Npb25WYXJpYWJsZXMuYXhpc1gyW2NdLm5ld1ZpZXdwb3J0TWF4aW11bT1udWxsO2lmKGEuc2Vzc2lvblZhcmlhYmxlcy5heGlzWSlmb3IoYz0wO2M8YS5zZXNzaW9uVmFyaWFibGVzLmF4aXNZLmxlbmd0aDtjKyspYS5zZXNzaW9uVmFyaWFibGVzLmF4aXNZW2NdLm5ld1ZpZXdwb3J0TWluaW11bT1cclxubnVsbCxhLnNlc3Npb25WYXJpYWJsZXMuYXhpc1lbY10ubmV3Vmlld3BvcnRNYXhpbXVtPW51bGw7aWYoYS5zZXNzaW9uVmFyaWFibGVzLmF4aXNZMilmb3IoYz0wO2M8YS5zZXNzaW9uVmFyaWFibGVzLmF4aXNZMi5sZW5ndGg7YysrKWEuc2Vzc2lvblZhcmlhYmxlcy5heGlzWTJbY10ubmV3Vmlld3BvcnRNaW5pbXVtPW51bGwsYS5zZXNzaW9uVmFyaWFibGVzLmF4aXNZMltjXS5uZXdWaWV3cG9ydE1heGltdW09bnVsbDthLnJlc2V0T3ZlcmxheWVkQ2FudmFzKCk7d2EoYS5fem9vbUJ1dHRvbixhLl9yZXNldEJ1dHRvbik7YS5fZGlzcGF0Y2hSYW5nZUV2ZW50KFwicmFuZ2VDaGFuZ2luZ1wiLFwicmVzZXRcIik7YS5yZW5kZXIoKTthLl9kaXNwYXRjaFJhbmdlRXZlbnQoXCJyYW5nZUNoYW5nZWRcIixcInJlc2V0XCIpfSksTih0aGlzLl9yZXNldEJ1dHRvbixcIm1vdXNlb3ZlclwiLGZ1bmN0aW9uKCl7Znx8KHFhKGEsYS5fcmVzZXRCdXR0b24se2JhY2tncm91bmRDb2xvcjphLnRvb2xiYXIuYmFja2dyb3VuZENvbG9yT25Ib3ZlcixcclxuY29sb3I6YS50b29sYmFyLmhvdmVyRmZvbnRDb2xvck9uSG92ZXJvbnRDb2xvcix0cmFuc2l0aW9uOlwiMC40c1wiLFdlYmtpdFRyYW5zaXRpb246XCIwLjRzXCJ9KSwwPj1uYXZpZ2F0b3IudXNlckFnZW50LnNlYXJjaChcIk1TSUVcIikmJnFhKGEsYS5fcmVzZXRCdXR0b24uY2hpbGROb2Rlc1swXSx7V2Via2l0RmlsdGVyOlwiaW52ZXJ0KDEwMCUpXCIsZmlsdGVyOlwiaW52ZXJ0KDEwMCUpXCJ9KSl9KSxOKHRoaXMuX3Jlc2V0QnV0dG9uLFwibW91c2VvdXRcIixmdW5jdGlvbigpe2Z8fChxYShhLGEuX3Jlc2V0QnV0dG9uLHtiYWNrZ3JvdW5kQ29sb3I6YS50b29sYmFyLmJhY2tncm91bmRDb2xvcixjb2xvcjphLnRvb2xiYXIuZm9udENvbG9yLHRyYW5zaXRpb246XCIwLjRzXCIsV2Via2l0VHJhbnNpdGlvbjpcIjAuNHNcIn0pLDA+PW5hdmlnYXRvci51c2VyQWdlbnQuc2VhcmNoKFwiTVNJRVwiKSYmcWEoYSxhLl9yZXNldEJ1dHRvbi5jaGlsZE5vZGVzWzBdLHtXZWJraXRGaWx0ZXI6XCJpbnZlcnQoMCUpXCIsZmlsdGVyOlwiaW52ZXJ0KDAlKVwifSkpfSksXHJcbnRoaXMub3ZlcmxhaWRDYW52YXMuc3R5bGUuY3Vyc29yPWEuX2RlZmF1bHRDdXJzb3IpO3RoaXMuem9vbUVuYWJsZWR8fHRoaXMucGFuRW5hYmxlZHx8KHRoaXMuX3pvb21CdXR0b24/KGEuX3pvb21CdXR0b24uZ2V0QXR0cmlidXRlKFwic3RhdGVcIik9PT1hLl9jdWx0dXJlSW5mby56b29tVGV4dD8odGhpcy5wYW5FbmFibGVkPSEwLHRoaXMuem9vbUVuYWJsZWQ9ITEpOih0aGlzLnpvb21FbmFibGVkPSEwLHRoaXMucGFuRW5hYmxlZD0hMSksTWEoYS5fem9vbUJ1dHRvbixhLl9yZXNldEJ1dHRvbikpOih0aGlzLnpvb21FbmFibGVkPSEwLHRoaXMucGFuRW5hYmxlZD0hMSkpfWVsc2UgdGhpcy5wYW5FbmFibGVkPXRoaXMuem9vbUVuYWJsZWQ9ITE7dGhpcy5fbWVudUJ1dHRvbj90aGlzLmV4cG9ydEVuYWJsZWQ/TWEodGhpcy5fbWVudUJ1dHRvbik6d2EodGhpcy5fbWVudUJ1dHRvbik6dGhpcy5leHBvcnRFbmFibGVkJiZ2JiYoZj0hMSx0aGlzLl9tZW51QnV0dG9uPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksXHJcbnZhKHRoaXMsdGhpcy5fbWVudUJ1dHRvbixcIm1lbnVcIiksdGhpcy5fdG9vbEJhci5hcHBlbmRDaGlsZCh0aGlzLl9tZW51QnV0dG9uKSxOKHRoaXMuX21lbnVCdXR0b24sXCJ0b3VjaHN0YXJ0XCIsZnVuY3Rpb24oYSl7Zj0hMH0pLE4odGhpcy5fbWVudUJ1dHRvbixcImNsaWNrXCIsZnVuY3Rpb24oKXtcIm5vbmVcIiE9PWEuX2Ryb3Bkb3duTWVudS5zdHlsZS5kaXNwbGF5fHxhLl9kcm9wRG93bkNsb3NlVGltZSYmNTAwPj0obmV3IERhdGUpLmdldFRpbWUoKS1hLl9kcm9wRG93bkNsb3NlVGltZS5nZXRUaW1lKCl8fChhLl9kcm9wZG93bk1lbnUuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsYS5fbWVudUJ1dHRvbi5ibHVyKCksYS5fZHJvcGRvd25NZW51LmZvY3VzKCkpfSwhMCksTih0aGlzLl9tZW51QnV0dG9uLFwibW91c2VvdmVyXCIsZnVuY3Rpb24oKXtmfHwocWEoYSxhLl9tZW51QnV0dG9uLHtiYWNrZ3JvdW5kQ29sb3I6YS50b29sYmFyLmJhY2tncm91bmRDb2xvck9uSG92ZXIsY29sb3I6YS50b29sYmFyLmZvbnRDb2xvck9uSG92ZXJ9KSxcclxuMD49bmF2aWdhdG9yLnVzZXJBZ2VudC5zZWFyY2goXCJNU0lFXCIpJiZxYShhLGEuX21lbnVCdXR0b24uY2hpbGROb2Rlc1swXSx7V2Via2l0RmlsdGVyOlwiaW52ZXJ0KDEwMCUpXCIsZmlsdGVyOlwiaW52ZXJ0KDEwMCUpXCJ9KSl9LCEwKSxOKHRoaXMuX21lbnVCdXR0b24sXCJtb3VzZW91dFwiLGZ1bmN0aW9uKCl7Znx8KHFhKGEsYS5fbWVudUJ1dHRvbix7YmFja2dyb3VuZENvbG9yOmEudG9vbGJhci5iYWNrZ3JvdW5kQ29sb3IsY29sb3I6YS50b29sYmFyLmZvbnRDb2xvcn0pLDA+PW5hdmlnYXRvci51c2VyQWdlbnQuc2VhcmNoKFwiTVNJRVwiKSYmcWEoYSxhLl9tZW51QnV0dG9uLmNoaWxkTm9kZXNbMF0se1dlYmtpdEZpbHRlcjpcImludmVydCgwJSlcIixmaWx0ZXI6XCJpbnZlcnQoMCUpXCJ9KSl9LCEwKSk7aWYoIXRoaXMuX2Ryb3Bkb3duTWVudSYmdGhpcy5leHBvcnRFbmFibGVkJiZ2KXtmPSExO3RoaXMuX2Ryb3Bkb3duTWVudT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3RoaXMuX2Ryb3Bkb3duTWVudS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLFxyXG4tMSk7dmFyIGI9LTEhPT10aGlzLnRoZW1lLmluZGV4T2YoXCJkYXJrXCIpP1wiYmxhY2tcIjpcIiM4ODg4ODhcIjt0aGlzLl9kcm9wZG93bk1lbnUuc3R5bGUuY3NzVGV4dD1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLW1vei11c2VyLXNlbGVjdDogbm9uZTsgLW1zLXVzZXItc2VsZWN0OiBub25lOyB1c2VyLXNlbGVjdDogbm9uZTsgY3Vyc29yOiBwb2ludGVyO3JpZ2h0OiAwcHg7dG9wOiAyNXB4O21pbi13aWR0aDogMTIwcHg7b3V0bGluZTogMDtmb250LXNpemU6IDE0cHg7IGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO3BhZGRpbmc6IDVweCAwcHggNXB4IDBweDt0ZXh0LWFsaWduOiBsZWZ0O2xpbmUtaGVpZ2h0OiAxMHB4O2JhY2tncm91bmQtY29sb3I6XCIrdGhpcy50b29sYmFyLmJhY2tncm91bmRDb2xvcitcIjtib3gtc2hhZG93OiAycHggMnB4IDEwcHggXCIrYjthLl9kcm9wZG93bk1lbnUuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtcclxudGhpcy5fdG9vbEJhci5hcHBlbmRDaGlsZCh0aGlzLl9kcm9wZG93bk1lbnUpO04odGhpcy5fZHJvcGRvd25NZW51LFwiYmx1clwiLGZ1bmN0aW9uKCl7d2EoYS5fZHJvcGRvd25NZW51KTthLl9kcm9wRG93bkNsb3NlVGltZT1uZXcgRGF0ZX0sITApO2I9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtiLnN0eWxlLmNzc1RleHQ9XCJwYWRkaW5nOiAxMnB4IDhweCAxMnB4IDhweFwiO2IuaW5uZXJIVE1MPXRoaXMuX2N1bHR1cmVJbmZvLnByaW50VGV4dDtiLnN0eWxlLmJhY2tncm91bmRDb2xvcj10aGlzLnRvb2xiYXIuYmFja2dyb3VuZENvbG9yO2Iuc3R5bGUuY29sb3I9dGhpcy50b29sYmFyLmZvbnRDb2xvcjt0aGlzLl9kcm9wZG93bk1lbnUuYXBwZW5kQ2hpbGQoYik7TihiLFwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKGEpe2Y9ITB9KTtOKGIsXCJtb3VzZW92ZXJcIixmdW5jdGlvbigpe2Z8fCh0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcj1hLnRvb2xiYXIuYmFja2dyb3VuZENvbG9yT25Ib3ZlcixcclxudGhpcy5zdHlsZS5jb2xvcj1hLnRvb2xiYXIuZm9udENvbG9yT25Ib3Zlcil9LCEwKTtOKGIsXCJtb3VzZW91dFwiLGZ1bmN0aW9uKCl7Znx8KHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yPWEudG9vbGJhci5iYWNrZ3JvdW5kQ29sb3IsdGhpcy5zdHlsZS5jb2xvcj1hLnRvb2xiYXIuZm9udENvbG9yKX0sITApO04oYixcImNsaWNrXCIsZnVuY3Rpb24oKXthLnByaW50KCk7d2EoYS5fZHJvcGRvd25NZW51KX0sITApO2I9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtiLnN0eWxlLmNzc1RleHQ9XCJwYWRkaW5nOiAxMnB4IDhweCAxMnB4IDhweFwiO2IuaW5uZXJIVE1MPXRoaXMuX2N1bHR1cmVJbmZvLnNhdmVKUEdUZXh0O2Iuc3R5bGUuYmFja2dyb3VuZENvbG9yPXRoaXMudG9vbGJhci5iYWNrZ3JvdW5kQ29sb3I7Yi5zdHlsZS5jb2xvcj10aGlzLnRvb2xiYXIuZm9udENvbG9yO3RoaXMuX2Ryb3Bkb3duTWVudS5hcHBlbmRDaGlsZChiKTtOKGIsXCJ0b3VjaHN0YXJ0XCIsZnVuY3Rpb24oYSl7Zj1cclxuITB9KTtOKGIsXCJtb3VzZW92ZXJcIixmdW5jdGlvbigpe2Z8fCh0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcj1hLnRvb2xiYXIuYmFja2dyb3VuZENvbG9yT25Ib3Zlcix0aGlzLnN0eWxlLmNvbG9yPWEudG9vbGJhci5mb250Q29sb3JPbkhvdmVyKX0sITApO04oYixcIm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtmfHwodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9YS50b29sYmFyLmJhY2tncm91bmRDb2xvcix0aGlzLnN0eWxlLmNvbG9yPWEudG9vbGJhci5mb250Q29sb3IpfSwhMCk7TihiLFwiY2xpY2tcIixmdW5jdGlvbigpe3MoYS5jYW52YXMsXCJqcGVnXCIsYS5leHBvcnRGaWxlTmFtZSk7d2EoYS5fZHJvcGRvd25NZW51KX0sITApO2I9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtiLnN0eWxlLmNzc1RleHQ9XCJwYWRkaW5nOiAxMnB4IDhweCAxMnB4IDhweFwiO2IuaW5uZXJIVE1MPXRoaXMuX2N1bHR1cmVJbmZvLnNhdmVQTkdUZXh0O2Iuc3R5bGUuYmFja2dyb3VuZENvbG9yPXRoaXMudG9vbGJhci5iYWNrZ3JvdW5kQ29sb3I7XHJcbmIuc3R5bGUuY29sb3I9dGhpcy50b29sYmFyLmZvbnRDb2xvcjt0aGlzLl9kcm9wZG93bk1lbnUuYXBwZW5kQ2hpbGQoYik7TihiLFwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKGEpe2Y9ITB9KTtOKGIsXCJtb3VzZW92ZXJcIixmdW5jdGlvbigpe2Z8fCh0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcj1hLnRvb2xiYXIuYmFja2dyb3VuZENvbG9yT25Ib3Zlcix0aGlzLnN0eWxlLmNvbG9yPWEudG9vbGJhci5mb250Q29sb3JPbkhvdmVyKX0sITApO04oYixcIm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtmfHwodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9YS50b29sYmFyLmJhY2tncm91bmRDb2xvcix0aGlzLnN0eWxlLmNvbG9yPWEudG9vbGJhci5mb250Q29sb3IpfSwhMCk7TihiLFwiY2xpY2tcIixmdW5jdGlvbigpe3MoYS5jYW52YXMsXCJwbmdcIixhLmV4cG9ydEZpbGVOYW1lKTt3YShhLl9kcm9wZG93bk1lbnUpfSwhMCl9XCJub25lXCIhPT10aGlzLl90b29sQmFyLnN0eWxlLmRpc3BsYXkmJnRoaXMuX3pvb21CdXR0b24mJlxyXG4odGhpcy5wYW5FbmFibGVkP3ZhKGEsYS5fem9vbUJ1dHRvbixcInpvb21cIik6dmEoYSxhLl96b29tQnV0dG9uLFwicGFuXCIpLGEuX3Jlc2V0QnV0dG9uLmdldEF0dHJpYnV0ZShcInN0YXRlXCIpIT09YS5fY3VsdHVyZUluZm8ucmVzZXRUZXh0JiZ2YShhLGEuX3Jlc2V0QnV0dG9uLFwicmVzZXRcIikpO3RoaXMub3B0aW9ucy50b29sVGlwJiZ0aGlzLnRvb2xUaXAub3B0aW9ucyE9PXRoaXMub3B0aW9ucy50b29sVGlwJiYodGhpcy50b29sVGlwLm9wdGlvbnM9dGhpcy5vcHRpb25zLnRvb2xUaXApO2Zvcih2YXIgYyBpbiB0aGlzLnRvb2xUaXAub3B0aW9ucyl0aGlzLnRvb2xUaXAub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShjKSYmdGhpcy50b29sVGlwLnVwZGF0ZU9wdGlvbihjKX07cS5wcm90b3R5cGUuX3VwZGF0ZVNpemU9ZnVuY3Rpb24oKXt2YXIgYT0wLGY9MDt0aGlzLm9wdGlvbnMud2lkdGg/YT10aGlzLndpZHRoOnRoaXMud2lkdGg9YT0wPHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoP1xyXG50aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDp0aGlzLndpZHRoO3RoaXMub3B0aW9ucy5oZWlnaHQ/Zj10aGlzLmhlaWdodDp0aGlzLmhlaWdodD1mPTA8dGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0P3RoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodDp0aGlzLmhlaWdodDtyZXR1cm4gdGhpcy5jYW52YXMud2lkdGghPT1hKmhhfHx0aGlzLmNhbnZhcy5oZWlnaHQhPT1mKmhhPyhIYSh0aGlzLmNhbnZhcyxhLGYpLEhhKHRoaXMuX3ByZVJlbmRlckNhbnZhcyxhLGYpLEhhKHRoaXMub3ZlcmxhaWRDYW52YXMsYSxmKSxIYSh0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDYW52YXMsYSxmKSx0aGlzLmJvdW5kcz17eDE6MCx5MTowLHgyOnRoaXMud2lkdGgseTI6dGhpcy5oZWlnaHR9LCEwKTohMX07cS5wcm90b3R5cGUuX2luaXRpYWxpemU9ZnVuY3Rpb24oKXt0aGlzLnRvb2xiYXI9bmV3IFJhKHRoaXMsdGhpcy5vcHRpb25zLnRvb2xiYXIpO3RoaXMuX2FuaW1hdG9yP3RoaXMuX2FuaW1hdG9yLmNhbmNlbEFsbEFuaW1hdGlvbnMoKTpcclxudGhpcy5fYW5pbWF0b3I9bmV3IGthKHRoaXMpO3RoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTt0aGlzLmRpc2FibGVUb29sVGlwPSExO3RoaXMuX2F4ZXM9W107dGhpcy5mdW5uZWxQeXJhbWlkQ2xpY2tIYW5kbGVyPXRoaXMucGllRG91Z2hudXRDbGlja0hhbmRsZXI9bnVsbDt0aGlzLmFuaW1hdGlvblJlcXVlc3RJZCYmdGhpcy5jYW5jZWxSZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LHRoaXMuYW5pbWF0aW9uUmVxdWVzdElkKTt0aGlzLl91cGRhdGVPcHRpb25zKCk7dGhpcy5hbmltYXRlZFJlbmRlcj12JiZ0aGlzLmFuaW1hdGlvbkVuYWJsZWQmJjA9PT10aGlzLnJlbmRlckNvdW50O3RoaXMuX3VwZGF0ZVNpemUoKTt0aGlzLmNsZWFyQ2FudmFzKCk7dGhpcy5jdHguYmVnaW5QYXRoKCk7dGhpcy5heGlzWD1bXTt0aGlzLmF4aXNYMj1bXTt0aGlzLmF4aXNZPVtdO3RoaXMuYXhpc1kyPVtdO3RoaXMuX2luZGV4TGFiZWxzPVtdO3RoaXMuX2RhdGFJblJlbmRlcmVkT3JkZXI9XHJcbltdO3RoaXMuX2V2ZW50cz1bXTt0aGlzLl9ldmVudE1hbmFnZXImJnRoaXMuX2V2ZW50TWFuYWdlci5yZXNldCgpO3RoaXMucGxvdEluZm89e2F4aXNQbGFjZW1lbnQ6bnVsbCxwbG90VHlwZXM6W119O3RoaXMubGF5b3V0TWFuYWdlcj1uZXcgRWEoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsMik7dGhpcy5wbG90QXJlYS5sYXlvdXRNYW5hZ2VyJiZ0aGlzLnBsb3RBcmVhLmxheW91dE1hbmFnZXIucmVzZXQoKTt0aGlzLmRhdGE9W107dmFyIGE9MCxmPW51bGw7aWYodGhpcy5vcHRpb25zLmRhdGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5vcHRpb25zLmRhdGEubGVuZ3RoO2IrKylpZihhKyssIXRoaXMub3B0aW9ucy5kYXRhW2JdLnR5cGV8fDA8PXEuX3N1cHBvcnRlZENoYXJ0VHlwZXMuaW5kZXhPZih0aGlzLm9wdGlvbnMuZGF0YVtiXS50eXBlKSl7dmFyIGM9bmV3IFEodGhpcyx0aGlzLm9wdGlvbnMuZGF0YVtiXSxhLTEsKyt0aGlzLl9ldmVudE1hbmFnZXIubGFzdE9iamVjdElkKTtcclxuXCJlcnJvclwiPT09Yy50eXBlJiYoYy5saW5rZWREYXRhU2VyaWVzSW5kZXg9eSh0aGlzLm9wdGlvbnMuZGF0YVtiXS5saW5rZWREYXRhU2VyaWVzSW5kZXgpP2ItMTp0aGlzLm9wdGlvbnMuZGF0YVtiXS5saW5rZWREYXRhU2VyaWVzSW5kZXgsMD5jLmxpbmtlZERhdGFTZXJpZXNJbmRleHx8Yy5saW5rZWREYXRhU2VyaWVzSW5kZXg+PXRoaXMub3B0aW9ucy5kYXRhLmxlbmd0aHx8XCJudW1iZXJcIiE9PXR5cGVvZiBjLmxpbmtlZERhdGFTZXJpZXNJbmRleHx8XCJlcnJvclwiPT09dGhpcy5vcHRpb25zLmRhdGFbYy5saW5rZWREYXRhU2VyaWVzSW5kZXhdLnR5cGUpJiYoYy5saW5rZWREYXRhU2VyaWVzSW5kZXg9bnVsbCk7bnVsbD09PWMubmFtZSYmKGMubmFtZT1cIkRhdGFTZXJpZXMgXCIrYSk7bnVsbD09PWMuY29sb3I/MTx0aGlzLm9wdGlvbnMuZGF0YS5sZW5ndGg/KGMuX2NvbG9yU2V0PVt0aGlzLl9zZWxlY3RlZENvbG9yU2V0W2MuaW5kZXgldGhpcy5fc2VsZWN0ZWRDb2xvclNldC5sZW5ndGhdXSxcclxuYy5jb2xvcj10aGlzLl9zZWxlY3RlZENvbG9yU2V0W2MuaW5kZXgldGhpcy5fc2VsZWN0ZWRDb2xvclNldC5sZW5ndGhdKTpjLl9jb2xvclNldD1cImxpbmVcIj09PWMudHlwZXx8XCJzdGVwTGluZVwiPT09Yy50eXBlfHxcInNwbGluZVwiPT09Yy50eXBlfHxcImFyZWFcIj09PWMudHlwZXx8XCJzdGVwQXJlYVwiPT09Yy50eXBlfHxcInNwbGluZUFyZWFcIj09PWMudHlwZXx8XCJzdGFja2VkQXJlYVwiPT09Yy50eXBlfHxcInN0YWNrZWRBcmVhMTAwXCI9PT1jLnR5cGV8fFwicmFuZ2VBcmVhXCI9PT1jLnR5cGV8fFwicmFuZ2VTcGxpbmVBcmVhXCI9PT1jLnR5cGV8fFwiY2FuZGxlc3RpY2tcIj09PWMudHlwZXx8XCJvaGxjXCI9PT1jLnR5cGV8fFwid2F0ZXJmYWxsXCI9PT1jLnR5cGV8fFwiYm94QW5kV2hpc2tlclwiPT09Yy50eXBlP1t0aGlzLl9zZWxlY3RlZENvbG9yU2V0WzBdXTp0aGlzLl9zZWxlY3RlZENvbG9yU2V0OmMuX2NvbG9yU2V0PVtjLmNvbG9yXTtudWxsPT09Yy5tYXJrZXJTaXplJiYoKFwibGluZVwiPT09Yy50eXBlfHxcclxuXCJzdGVwTGluZVwiPT09Yy50eXBlfHxcInNwbGluZVwiPT09Yy50eXBlfHwwPD1jLnR5cGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiYXJlYVwiKSkmJmMuZGF0YVBvaW50cyYmYy5kYXRhUG9pbnRzLmxlbmd0aDx0aGlzLndpZHRoLzE2fHxcInNjYXR0ZXJcIj09PWMudHlwZSkmJihjLm1hcmtlclNpemU9OCk7XCJidWJibGVcIiE9PWMudHlwZSYmXCJzY2F0dGVyXCIhPT1jLnR5cGV8fCFjLmRhdGFQb2ludHN8fChjLmRhdGFQb2ludHMuc29tZT9jLmRhdGFQb2ludHMuc29tZShmdW5jdGlvbihhKXtyZXR1cm4gYS54fSkmJmMuZGF0YVBvaW50cy5zb3J0KG0pOmMuZGF0YVBvaW50cy5zb3J0KG0pKTt0aGlzLmRhdGEucHVzaChjKTt2YXIgZT1jLmF4aXNQbGFjZW1lbnQsZj1mfHxlLGc7XCJub3JtYWxcIj09PWU/XCJ4eVN3YXBwZWRcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD9nPSdZb3UgY2Fubm90IGNvbWJpbmUgXCInK2MudHlwZSsnXCIgd2l0aCBiYXIgY2hhcnQnOlwibm9uZVwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50P1xyXG5nPSdZb3UgY2Fubm90IGNvbWJpbmUgXCInK2MudHlwZSsnXCIgd2l0aCBwaWUgY2hhcnQnOm51bGw9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQmJih0aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ9XCJub3JtYWxcIik6XCJ4eVN3YXBwZWRcIj09PWU/XCJub3JtYWxcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD9nPSdZb3UgY2Fubm90IGNvbWJpbmUgXCInK2MudHlwZSsnXCIgd2l0aCBsaW5lLCBhcmVhLCBjb2x1bW4gb3IgcGllIGNoYXJ0JzpcIm5vbmVcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD9nPSdZb3UgY2Fubm90IGNvbWJpbmUgXCInK2MudHlwZSsnXCIgd2l0aCBwaWUgY2hhcnQnOm51bGw9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQmJih0aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ9XCJ4eVN3YXBwZWRcIik6XCJub25lXCI9PT1lP1wibm9ybWFsXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/Zz0nWW91IGNhbm5vdCBjb21iaW5lIFwiJytjLnR5cGUrXHJcbidcIiB3aXRoIGxpbmUsIGFyZWEsIGNvbHVtbiBvciBiYXIgY2hhcnQnOlwieHlTd2FwcGVkXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/Zz0nWW91IGNhbm5vdCBjb21iaW5lIFwiJytjLnR5cGUrJ1wiIHdpdGggYmFyIGNoYXJ0JzpudWxsPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50JiYodGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50PVwibm9uZVwiKTpudWxsPT09ZSYmXCJub25lXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQmJihnPSdZb3UgY2Fubm90IGNvbWJpbmUgXCInK2MudHlwZSsnXCIgd2l0aCBwaWUgY2hhcnQnKTtpZihnJiZ3aW5kb3cuY29uc29sZSl7d2luZG93LmNvbnNvbGUubG9nKGcpO3JldHVybn19Zm9yKGI9MDtiPHRoaXMuZGF0YS5sZW5ndGg7YisrKXtpZihcIm5vbmVcIj09ZiYmXCJlcnJvclwiPT09dGhpcy5kYXRhW2JdLnR5cGUmJndpbmRvdy5jb25zb2xlKXt3aW5kb3cuY29uc29sZS5sb2coJ1lvdSBjYW5ub3QgY29tYmluZSBcIicrYy50eXBlKydcIiB3aXRoIGVycm9yIGNoYXJ0Jyk7XHJcbnJldHVybn1cImVycm9yXCI9PT10aGlzLmRhdGFbYl0udHlwZSYmKHRoaXMuZGF0YVtiXS5heGlzUGxhY2VtZW50PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD1mfHxcIm5vcm1hbFwiLHRoaXMuZGF0YVtiXS5fbGlua2VkU2VyaWVzPW51bGw9PT10aGlzLmRhdGFbYl0ubGlua2VkRGF0YVNlcmllc0luZGV4P251bGw6dGhpcy5kYXRhW3RoaXMuZGF0YVtiXS5saW5rZWREYXRhU2VyaWVzSW5kZXhdKX19dGhpcy5fb2JqZWN0c0luaXRpYWxpemVkPSEwfTtxLl9zdXBwb3J0ZWRDaGFydFR5cGVzPURhKFwibGluZSBzdGVwTGluZSBzcGxpbmUgY29sdW1uIGFyZWEgc3RlcEFyZWEgc3BsaW5lQXJlYSBiYXIgYnViYmxlIHNjYXR0ZXIgc3RhY2tlZENvbHVtbiBzdGFja2VkQ29sdW1uMTAwIHN0YWNrZWRCYXIgc3RhY2tlZEJhcjEwMCBzdGFja2VkQXJlYSBzdGFja2VkQXJlYTEwMCBjYW5kbGVzdGljayBvaGxjIGJveEFuZFdoaXNrZXIgcmFuZ2VDb2x1bW4gZXJyb3IgcmFuZ2VCYXIgcmFuZ2VBcmVhIHJhbmdlU3BsaW5lQXJlYSBwaWUgZG91Z2hudXQgZnVubmVsIHB5cmFtaWQgd2F0ZXJmYWxsXCIuc3BsaXQoXCIgXCIpKTtcclxucS5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGEpe2EmJih0aGlzLm9wdGlvbnM9YSk7dGhpcy5faW5pdGlhbGl6ZSgpO2JiKHRoaXMpO2NiKHRoaXMpO3ZhciBmPVtdO2ZvcihhPTA7YTx0aGlzLmRhdGEubGVuZ3RoO2ErKylpZihcIm5vcm1hbFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50fHxcInh5U3dhcHBlZFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50KXtpZighdGhpcy5kYXRhW2FdLmF4aXNZVHlwZXx8XCJwcmltYXJ5XCI9PT10aGlzLmRhdGFbYV0uYXhpc1lUeXBlKWlmKHRoaXMub3B0aW9ucy5heGlzWSYmMDx0aGlzLm9wdGlvbnMuYXhpc1kubGVuZ3RoKXtpZighdGhpcy5heGlzWS5sZW5ndGgpZm9yKHZhciBiPTA7Yjx0aGlzLm9wdGlvbnMuYXhpc1kubGVuZ3RoO2IrKylcIm5vcm1hbFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50P3RoaXMuX2F4ZXMucHVzaCh0aGlzLmF4aXNZW2JdPW5ldyBDKHRoaXMsXCJheGlzWVwiLHRoaXMub3B0aW9ucy5heGlzWVtiXSxcclxuYixcImF4aXNZXCIsXCJsZWZ0XCIpKTpcInh5U3dhcHBlZFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50JiZ0aGlzLl9heGVzLnB1c2godGhpcy5heGlzWVtiXT1uZXcgQyh0aGlzLFwiYXhpc1lcIix0aGlzLm9wdGlvbnMuYXhpc1lbYl0sYixcImF4aXNZXCIsXCJib3R0b21cIikpO3RoaXMuZGF0YVthXS5heGlzWT10aGlzLmF4aXNZWzA8PXRoaXMuZGF0YVthXS5heGlzWUluZGV4JiZ0aGlzLmRhdGFbYV0uYXhpc1lJbmRleDx0aGlzLmF4aXNZLmxlbmd0aD90aGlzLmRhdGFbYV0uYXhpc1lJbmRleDowXTt0aGlzLmF4aXNZWzA8PXRoaXMuZGF0YVthXS5heGlzWUluZGV4JiZ0aGlzLmRhdGFbYV0uYXhpc1lJbmRleDx0aGlzLmF4aXNZLmxlbmd0aD90aGlzLmRhdGFbYV0uYXhpc1lJbmRleDowXS5kYXRhU2VyaWVzLnB1c2godGhpcy5kYXRhW2FdKX1lbHNlIHRoaXMuYXhpc1kubGVuZ3RofHwoXCJub3JtYWxcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD90aGlzLl9heGVzLnB1c2godGhpcy5heGlzWVswXT1cclxubmV3IEModGhpcyxcImF4aXNZXCIsdGhpcy5vcHRpb25zLmF4aXNZLDAsXCJheGlzWVwiLFwibGVmdFwiKSk6XCJ4eVN3YXBwZWRcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCYmdGhpcy5fYXhlcy5wdXNoKHRoaXMuYXhpc1lbMF09bmV3IEModGhpcyxcImF4aXNZXCIsdGhpcy5vcHRpb25zLmF4aXNZLDAsXCJheGlzWVwiLFwiYm90dG9tXCIpKSksdGhpcy5kYXRhW2FdLmF4aXNZPXRoaXMuYXhpc1lbMF0sdGhpcy5heGlzWVswXS5kYXRhU2VyaWVzLnB1c2godGhpcy5kYXRhW2FdKTtpZihcInNlY29uZGFyeVwiPT09dGhpcy5kYXRhW2FdLmF4aXNZVHlwZSlpZih0aGlzLm9wdGlvbnMuYXhpc1kyJiYwPHRoaXMub3B0aW9ucy5heGlzWTIubGVuZ3RoKXtpZighdGhpcy5heGlzWTIubGVuZ3RoKWZvcihiPTA7Yjx0aGlzLm9wdGlvbnMuYXhpc1kyLmxlbmd0aDtiKyspXCJub3JtYWxcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD90aGlzLl9heGVzLnB1c2godGhpcy5heGlzWTJbYl09bmV3IEModGhpcyxcclxuXCJheGlzWTJcIix0aGlzLm9wdGlvbnMuYXhpc1kyW2JdLGIsXCJheGlzWVwiLFwicmlnaHRcIikpOlwieHlTd2FwcGVkXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQmJnRoaXMuX2F4ZXMucHVzaCh0aGlzLmF4aXNZMltiXT1uZXcgQyh0aGlzLFwiYXhpc1kyXCIsdGhpcy5vcHRpb25zLmF4aXNZMltiXSxiLFwiYXhpc1lcIixcInRvcFwiKSk7dGhpcy5kYXRhW2FdLmF4aXNZPXRoaXMuYXhpc1kyWzA8PXRoaXMuZGF0YVthXS5heGlzWUluZGV4JiZ0aGlzLmRhdGFbYV0uYXhpc1lJbmRleDx0aGlzLmF4aXNZMi5sZW5ndGg/dGhpcy5kYXRhW2FdLmF4aXNZSW5kZXg6MF07dGhpcy5heGlzWTJbMDw9dGhpcy5kYXRhW2FdLmF4aXNZSW5kZXgmJnRoaXMuZGF0YVthXS5heGlzWUluZGV4PHRoaXMuYXhpc1kyLmxlbmd0aD90aGlzLmRhdGFbYV0uYXhpc1lJbmRleDowXS5kYXRhU2VyaWVzLnB1c2godGhpcy5kYXRhW2FdKX1lbHNlIHRoaXMuYXhpc1kyLmxlbmd0aHx8KFwibm9ybWFsXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/XHJcbnRoaXMuX2F4ZXMucHVzaCh0aGlzLmF4aXNZMlswXT1uZXcgQyh0aGlzLFwiYXhpc1kyXCIsdGhpcy5vcHRpb25zLmF4aXNZMiwwLFwiYXhpc1lcIixcInJpZ2h0XCIpKTpcInh5U3dhcHBlZFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50JiZ0aGlzLl9heGVzLnB1c2godGhpcy5heGlzWTJbMF09bmV3IEModGhpcyxcImF4aXNZMlwiLHRoaXMub3B0aW9ucy5heGlzWTIsMCxcImF4aXNZXCIsXCJ0b3BcIikpKSx0aGlzLmRhdGFbYV0uYXhpc1k9dGhpcy5heGlzWTJbMF0sdGhpcy5heGlzWTJbMF0uZGF0YVNlcmllcy5wdXNoKHRoaXMuZGF0YVthXSk7aWYoIXRoaXMuZGF0YVthXS5heGlzWFR5cGV8fFwicHJpbWFyeVwiPT09dGhpcy5kYXRhW2FdLmF4aXNYVHlwZSlpZih0aGlzLm9wdGlvbnMuYXhpc1gmJjA8dGhpcy5vcHRpb25zLmF4aXNYLmxlbmd0aCl7aWYoIXRoaXMuYXhpc1gubGVuZ3RoKWZvcihiPTA7Yjx0aGlzLm9wdGlvbnMuYXhpc1gubGVuZ3RoO2IrKylcIm5vcm1hbFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50P1xyXG50aGlzLl9heGVzLnB1c2godGhpcy5heGlzWFtiXT1uZXcgQyh0aGlzLFwiYXhpc1hcIix0aGlzLm9wdGlvbnMuYXhpc1hbYl0sYixcImF4aXNYXCIsXCJib3R0b21cIikpOlwieHlTd2FwcGVkXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQmJnRoaXMuX2F4ZXMucHVzaCh0aGlzLmF4aXNYW2JdPW5ldyBDKHRoaXMsXCJheGlzWFwiLHRoaXMub3B0aW9ucy5heGlzWFtiXSxiLFwiYXhpc1hcIixcImxlZnRcIikpO3RoaXMuZGF0YVthXS5heGlzWD10aGlzLmF4aXNYWzA8PXRoaXMuZGF0YVthXS5heGlzWEluZGV4JiZ0aGlzLmRhdGFbYV0uYXhpc1hJbmRleDx0aGlzLmF4aXNYLmxlbmd0aD90aGlzLmRhdGFbYV0uYXhpc1hJbmRleDowXTt0aGlzLmF4aXNYWzA8PXRoaXMuZGF0YVthXS5heGlzWEluZGV4JiZ0aGlzLmRhdGFbYV0uYXhpc1hJbmRleDx0aGlzLmF4aXNYLmxlbmd0aD90aGlzLmRhdGFbYV0uYXhpc1hJbmRleDowXS5kYXRhU2VyaWVzLnB1c2godGhpcy5kYXRhW2FdKX1lbHNlIHRoaXMuYXhpc1gubGVuZ3RofHxcclxuKFwibm9ybWFsXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/dGhpcy5fYXhlcy5wdXNoKHRoaXMuYXhpc1hbMF09bmV3IEModGhpcyxcImF4aXNYXCIsdGhpcy5vcHRpb25zLmF4aXNYLDAsXCJheGlzWFwiLFwiYm90dG9tXCIpKTpcInh5U3dhcHBlZFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50JiZ0aGlzLl9heGVzLnB1c2godGhpcy5heGlzWFswXT1uZXcgQyh0aGlzLFwiYXhpc1hcIix0aGlzLm9wdGlvbnMuYXhpc1gsMCxcImF4aXNYXCIsXCJsZWZ0XCIpKSksdGhpcy5kYXRhW2FdLmF4aXNYPXRoaXMuYXhpc1hbMF0sdGhpcy5heGlzWFswXS5kYXRhU2VyaWVzLnB1c2godGhpcy5kYXRhW2FdKTtpZihcInNlY29uZGFyeVwiPT09dGhpcy5kYXRhW2FdLmF4aXNYVHlwZSlpZih0aGlzLm9wdGlvbnMuYXhpc1gyJiYwPHRoaXMub3B0aW9ucy5heGlzWDIubGVuZ3RoKXtpZighdGhpcy5heGlzWDIubGVuZ3RoKWZvcihiPTA7Yjx0aGlzLm9wdGlvbnMuYXhpc1gyLmxlbmd0aDtiKyspXCJub3JtYWxcIj09PVxyXG50aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/dGhpcy5fYXhlcy5wdXNoKHRoaXMuYXhpc1gyW2JdPW5ldyBDKHRoaXMsXCJheGlzWDJcIix0aGlzLm9wdGlvbnMuYXhpc1gyW2JdLGIsXCJheGlzWFwiLFwidG9wXCIpKTpcInh5U3dhcHBlZFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50JiZ0aGlzLl9heGVzLnB1c2godGhpcy5heGlzWDJbYl09bmV3IEModGhpcyxcImF4aXNYMlwiLHRoaXMub3B0aW9ucy5heGlzWDJbYl0sYixcImF4aXNYXCIsXCJyaWdodFwiKSk7dGhpcy5kYXRhW2FdLmF4aXNYPXRoaXMuYXhpc1gyWzA8PXRoaXMuZGF0YVthXS5heGlzWEluZGV4JiZ0aGlzLmRhdGFbYV0uYXhpc1hJbmRleDx0aGlzLmF4aXNYMi5sZW5ndGg/dGhpcy5kYXRhW2FdLmF4aXNYSW5kZXg6MF07dGhpcy5heGlzWDJbMDw9dGhpcy5kYXRhW2FdLmF4aXNYSW5kZXgmJnRoaXMuZGF0YVthXS5heGlzWEluZGV4PHRoaXMuYXhpc1gyLmxlbmd0aD90aGlzLmRhdGFbYV0uYXhpc1hJbmRleDowXS5kYXRhU2VyaWVzLnB1c2godGhpcy5kYXRhW2FdKX1lbHNlIHRoaXMuYXhpc1gyLmxlbmd0aHx8XHJcbihcIm5vcm1hbFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50P3RoaXMuX2F4ZXMucHVzaCh0aGlzLmF4aXNYMlswXT1uZXcgQyh0aGlzLFwiYXhpc1gyXCIsdGhpcy5vcHRpb25zLmF4aXNYMiwwLFwiYXhpc1hcIixcInRvcFwiKSk6XCJ4eVN3YXBwZWRcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCYmdGhpcy5fYXhlcy5wdXNoKHRoaXMuYXhpc1gyWzBdPW5ldyBDKHRoaXMsXCJheGlzWDJcIix0aGlzLm9wdGlvbnMuYXhpc1gyLDAsXCJheGlzWFwiLFwicmlnaHRcIikpKSx0aGlzLmRhdGFbYV0uYXhpc1g9dGhpcy5heGlzWDJbMF0sdGhpcy5heGlzWDJbMF0uZGF0YVNlcmllcy5wdXNoKHRoaXMuZGF0YVthXSl9aWYodGhpcy5heGlzWSl7Zm9yKGI9MTtiPHRoaXMuYXhpc1kubGVuZ3RoO2IrKylcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMuYXhpc1lbYl0ub3B0aW9ucy5ncmlkVGhpY2tuZXNzJiYodGhpcy5heGlzWVtiXS5ncmlkVGhpY2tuZXNzPTApO2ZvcihiPTA7Yjx0aGlzLmF4aXNZLmxlbmd0aC1cclxuMTtiKyspXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLmF4aXNZW2JdLm9wdGlvbnMubWFyZ2luJiYodGhpcy5heGlzWVtiXS5tYXJnaW49MTApfWlmKHRoaXMuYXhpc1kyKXtmb3IoYj0xO2I8dGhpcy5heGlzWTIubGVuZ3RoO2IrKylcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMuYXhpc1kyW2JdLm9wdGlvbnMuZ3JpZFRoaWNrbmVzcyYmKHRoaXMuYXhpc1kyW2JdLmdyaWRUaGlja25lc3M9MCk7Zm9yKGI9MDtiPHRoaXMuYXhpc1kyLmxlbmd0aC0xO2IrKylcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMuYXhpc1kyW2JdLm9wdGlvbnMubWFyZ2luJiYodGhpcy5heGlzWTJbYl0ubWFyZ2luPTEwKX10aGlzLmF4aXNZJiYwPHRoaXMuYXhpc1kubGVuZ3RoJiYodGhpcy5heGlzWTImJjA8dGhpcy5heGlzWTIubGVuZ3RoKSYmKDA8dGhpcy5heGlzWVswXS5ncmlkVGhpY2tuZXNzJiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMuYXhpc1kyWzBdLm9wdGlvbnMuZ3JpZFRoaWNrbmVzcz90aGlzLmF4aXNZMlswXS5ncmlkVGhpY2tuZXNzPVxyXG4wOjA8dGhpcy5heGlzWTJbMF0uZ3JpZFRoaWNrbmVzcyYmXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLmF4aXNZWzBdLm9wdGlvbnMuZ3JpZFRoaWNrbmVzcyYmKHRoaXMuYXhpc1lbMF0uZ3JpZFRoaWNrbmVzcz0wKSk7aWYodGhpcy5heGlzWClmb3IoYj0wO2I8dGhpcy5heGlzWC5sZW5ndGg7YisrKVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5heGlzWFtiXS5vcHRpb25zLmdyaWRUaGlja25lc3MmJih0aGlzLmF4aXNYW2JdLmdyaWRUaGlja25lc3M9MCk7aWYodGhpcy5heGlzWDIpZm9yKGI9MDtiPHRoaXMuYXhpc1gyLmxlbmd0aDtiKyspXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLmF4aXNYMltiXS5vcHRpb25zLmdyaWRUaGlja25lc3MmJih0aGlzLmF4aXNYMltiXS5ncmlkVGhpY2tuZXNzPTApO3RoaXMuYXhpc1gmJjA8dGhpcy5heGlzWC5sZW5ndGgmJih0aGlzLmF4aXNYMiYmMDx0aGlzLmF4aXNYMi5sZW5ndGgpJiYoMDx0aGlzLmF4aXNYWzBdLmdyaWRUaGlja25lc3MmJlxyXG5cInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMuYXhpc1gyWzBdLm9wdGlvbnMuZ3JpZFRoaWNrbmVzcz90aGlzLmF4aXNYMlswXS5ncmlkVGhpY2tuZXNzPTA6MDx0aGlzLmF4aXNYMlswXS5ncmlkVGhpY2tuZXNzJiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMuYXhpc1hbMF0ub3B0aW9ucy5ncmlkVGhpY2tuZXNzJiYodGhpcy5heGlzWFswXS5ncmlkVGhpY2tuZXNzPTApKTtiPSExO2lmKDA8dGhpcy5fYXhlcy5sZW5ndGgmJih0aGlzLnpvb21FbmFibGVkfHx0aGlzLnBhbkVuYWJsZWQpKWZvcihhPTA7YTx0aGlzLl9heGVzLmxlbmd0aDthKyspaWYobnVsbCE9PXRoaXMuX2F4ZXNbYV0udmlld3BvcnRNaW5pbXVtfHxudWxsIT09dGhpcy5fYXhlc1thXS52aWV3cG9ydE1heGltdW0pe2I9ITA7YnJlYWt9Yj8oTWEodGhpcy5fem9vbUJ1dHRvbix0aGlzLl9yZXNldEJ1dHRvbiksdGhpcy5fdG9vbEJhci5zdHlsZS5ib3JkZXI9dGhpcy50b29sYmFyLmJvcmRlclRoaWNrbmVzcytcInB4IHNvbGlkIFwiK1xyXG50aGlzLnRvb2xiYXIuYm9yZGVyQ29sb3IsdGhpcy5fem9vbUJ1dHRvbi5zdHlsZS5ib3JkZXJSaWdodD10aGlzLnRvb2xiYXIuYm9yZGVyVGhpY2tuZXNzK1wicHggc29saWQgXCIrdGhpcy50b29sYmFyLmJvcmRlckNvbG9yLHRoaXMuX3Jlc2V0QnV0dG9uLnN0eWxlLmJvcmRlclJpZ2h0PSh0aGlzLmV4cG9ydEVuYWJsZWQ/dGhpcy50b29sYmFyLmJvcmRlclRoaWNrbmVzczowKStcInB4IHNvbGlkIFwiK3RoaXMudG9vbGJhci5ib3JkZXJDb2xvcik6KHdhKHRoaXMuX3pvb21CdXR0b24sdGhpcy5fcmVzZXRCdXR0b24pLHRoaXMuX3Rvb2xCYXIuc3R5bGUuYm9yZGVyPXRoaXMudG9vbGJhci5ib3JkZXJUaGlja25lc3MrXCJweCBzb2xpZCB0cmFuc3BhcmVudFwiLHRoaXMub3B0aW9ucy56b29tRW5hYmxlZCYmKHRoaXMuem9vbUVuYWJsZWQ9ITAsdGhpcy5wYW5FbmFibGVkPSExKSk7dGhpcy5fcHJvY2Vzc0RhdGEoKTt0aGlzLm9wdGlvbnMudGl0bGUmJih0aGlzLnRpdGxlPW5ldyBJYSh0aGlzLFxyXG50aGlzLm9wdGlvbnMudGl0bGUpLHRoaXMudGl0bGUuZG9ja0luc2lkZVBsb3RBcmVhP2YucHVzaCh0aGlzLnRpdGxlKTp0aGlzLnRpdGxlLnJlbmRlcigpKTtpZih0aGlzLm9wdGlvbnMuc3VidGl0bGVzKWZvcih0aGlzLnN1YnRpdGxlcz1bXSxhPTA7YTx0aGlzLm9wdGlvbnMuc3VidGl0bGVzLmxlbmd0aDthKyspYj1uZXcgTmEodGhpcyx0aGlzLm9wdGlvbnMuc3VidGl0bGVzW2FdLGEpLHRoaXMuc3VidGl0bGVzLnB1c2goYiksYi5kb2NrSW5zaWRlUGxvdEFyZWE/Zi5wdXNoKGIpOmIucmVuZGVyKCk7dGhpcy5sZWdlbmQ9bmV3IFQodGhpcyx0aGlzLm9wdGlvbnMubGVnZW5kKTtmb3IoYT0wO2E8dGhpcy5kYXRhLmxlbmd0aDthKyspKHRoaXMuZGF0YVthXS5zaG93SW5MZWdlbmR8fFwicGllXCI9PT10aGlzLmRhdGFbYV0udHlwZXx8XCJkb3VnaG51dFwiPT09dGhpcy5kYXRhW2FdLnR5cGV8fFwiZnVubmVsXCI9PT10aGlzLmRhdGFbYV0udHlwZXx8XCJweXJhbWlkXCI9PT10aGlzLmRhdGFbYV0udHlwZSkmJlxyXG50aGlzLmxlZ2VuZC5kYXRhU2VyaWVzLnB1c2godGhpcy5kYXRhW2FdKTt0aGlzLmxlZ2VuZC5kb2NrSW5zaWRlUGxvdEFyZWE/Zi5wdXNoKHRoaXMubGVnZW5kKTp0aGlzLmxlZ2VuZC5yZW5kZXIoKTtmb3IoYT0wO2E8dGhpcy5fYXhlcy5sZW5ndGg7YSsrKWlmKHRoaXMuX2F4ZXNbYV0uc2NhbGVCcmVha3MmJnRoaXMuX2F4ZXNbYV0uc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MubGVuZ3RoKXt2Pyh0aGlzLl9icmVha3NDYW52YXM9dWEodGhpcy53aWR0aCx0aGlzLmhlaWdodCwhMCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4PXRoaXMuX2JyZWFrc0NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikpOih0aGlzLl9icmVha3NDYW52YXM9dGhpcy5jYW52YXMsdGhpcy5fYnJlYWtzQ2FudmFzQ3R4PXRoaXMuY3R4KTticmVha310aGlzLl9wcmVSZW5kZXJDYW52YXM9dWEodGhpcy53aWR0aCx0aGlzLmhlaWdodCk7dGhpcy5fcHJlUmVuZGVyQ3R4PXRoaXMuX3ByZVJlbmRlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbmlmKFwibm9ybWFsXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnR8fFwieHlTd2FwcGVkXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQpQy5zZXRMYXlvdXRBbmRSZW5kZXIodGhpcy5heGlzWCx0aGlzLmF4aXNYMix0aGlzLmF4aXNZLHRoaXMuYXhpc1kyLHRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCx0aGlzLmxheW91dE1hbmFnZXIuZ2V0RnJlZVNwYWNlKCkpO2Vsc2UgaWYoXCJub25lXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQpdGhpcy5wcmVwYXJlUGxvdEFyZWEoKTtlbHNlIHJldHVybjtmb3IoYT0wO2E8Zi5sZW5ndGg7YSsrKWZbYV0ucmVuZGVyKCk7dmFyIGM9W107aWYodGhpcy5hbmltYXRlZFJlbmRlcil7dmFyIGU9dWEodGhpcy53aWR0aCx0aGlzLmhlaWdodCk7ZS5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKHRoaXMuY2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KX12YXIgZj10aGlzLmN0eC5taXRlckxpbWl0LGc7dGhpcy5jdHgubWl0ZXJMaW1pdD1cclxuMzt2JiZ0aGlzLl9icmVha3NDYW52YXMmJih0aGlzLl9wcmVSZW5kZXJDdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9wcmVSZW5kZXJDdHguZHJhd0ltYWdlKHRoaXMuX2JyZWFrc0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX3ByZVJlbmRlckN0eC5jbGVhclJlY3QoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpKTtmb3IoYT0wO2E8dGhpcy5wbG90SW5mby5wbG90VHlwZXMubGVuZ3RoO2ErKylmb3IodmFyIGg9dGhpcy5wbG90SW5mby5wbG90VHlwZXNbYV0sbD0wO2w8aC5wbG90VW5pdHMubGVuZ3RoO2wrKyl7dmFyIHQ9aC5wbG90VW5pdHNbbF0sXHJcbms9bnVsbDt0LnRhcmdldENhbnZhcz1udWxsO3RoaXMuYW5pbWF0ZWRSZW5kZXImJih0LnRhcmdldENhbnZhcz11YSh0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0LnRhcmdldENhbnZhc0N0eD10LnRhcmdldENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksZz10LnRhcmdldENhbnZhc0N0eC5taXRlckxpbWl0LHQudGFyZ2V0Q2FudmFzQ3R4Lm1pdGVyTGltaXQ9Myk7XCJsaW5lXCI9PT10LnR5cGU/az10aGlzLnJlbmRlckxpbmUodCk6XCJzdGVwTGluZVwiPT09dC50eXBlP2s9dGhpcy5yZW5kZXJTdGVwTGluZSh0KTpcInNwbGluZVwiPT09dC50eXBlP2s9dGhpcy5yZW5kZXJTcGxpbmUodCk6XCJjb2x1bW5cIj09PXQudHlwZT9rPXRoaXMucmVuZGVyQ29sdW1uKHQpOlwiYmFyXCI9PT10LnR5cGU/az10aGlzLnJlbmRlckJhcih0KTpcImFyZWFcIj09PXQudHlwZT9rPXRoaXMucmVuZGVyQXJlYSh0KTpcInN0ZXBBcmVhXCI9PT10LnR5cGU/az10aGlzLnJlbmRlclN0ZXBBcmVhKHQpOlwic3BsaW5lQXJlYVwiPT09dC50eXBlP1xyXG5rPXRoaXMucmVuZGVyU3BsaW5lQXJlYSh0KTpcInN0YWNrZWRDb2x1bW5cIj09PXQudHlwZT9rPXRoaXMucmVuZGVyU3RhY2tlZENvbHVtbih0KTpcInN0YWNrZWRDb2x1bW4xMDBcIj09PXQudHlwZT9rPXRoaXMucmVuZGVyU3RhY2tlZENvbHVtbjEwMCh0KTpcInN0YWNrZWRCYXJcIj09PXQudHlwZT9rPXRoaXMucmVuZGVyU3RhY2tlZEJhcih0KTpcInN0YWNrZWRCYXIxMDBcIj09PXQudHlwZT9rPXRoaXMucmVuZGVyU3RhY2tlZEJhcjEwMCh0KTpcInN0YWNrZWRBcmVhXCI9PT10LnR5cGU/az10aGlzLnJlbmRlclN0YWNrZWRBcmVhKHQpOlwic3RhY2tlZEFyZWExMDBcIj09PXQudHlwZT9rPXRoaXMucmVuZGVyU3RhY2tlZEFyZWExMDAodCk6XCJidWJibGVcIj09PXQudHlwZT9rPWs9dGhpcy5yZW5kZXJCdWJibGUodCk6XCJzY2F0dGVyXCI9PT10LnR5cGU/az10aGlzLnJlbmRlclNjYXR0ZXIodCk6XCJwaWVcIj09PXQudHlwZT90aGlzLnJlbmRlclBpZSh0KTpcImRvdWdobnV0XCI9PT10LnR5cGU/dGhpcy5yZW5kZXJQaWUodCk6XHJcblwiZnVubmVsXCI9PT10LnR5cGU/az10aGlzLnJlbmRlckZ1bm5lbCh0KTpcInB5cmFtaWRcIj09PXQudHlwZT9rPXRoaXMucmVuZGVyRnVubmVsKHQpOlwiY2FuZGxlc3RpY2tcIj09PXQudHlwZT9rPXRoaXMucmVuZGVyQ2FuZGxlc3RpY2sodCk6XCJvaGxjXCI9PT10LnR5cGU/az10aGlzLnJlbmRlckNhbmRsZXN0aWNrKHQpOlwicmFuZ2VDb2x1bW5cIj09PXQudHlwZT9rPXRoaXMucmVuZGVyUmFuZ2VDb2x1bW4odCk6XCJlcnJvclwiPT09dC50eXBlP2s9dGhpcy5yZW5kZXJFcnJvcih0KTpcInJhbmdlQmFyXCI9PT10LnR5cGU/az10aGlzLnJlbmRlclJhbmdlQmFyKHQpOlwicmFuZ2VBcmVhXCI9PT10LnR5cGU/az10aGlzLnJlbmRlclJhbmdlQXJlYSh0KTpcInJhbmdlU3BsaW5lQXJlYVwiPT09dC50eXBlP2s9dGhpcy5yZW5kZXJSYW5nZVNwbGluZUFyZWEodCk6XCJ3YXRlcmZhbGxcIj09PXQudHlwZT9rPXRoaXMucmVuZGVyV2F0ZXJmYWxsKHQpOlwiYm94QW5kV2hpc2tlclwiPT09dC50eXBlJiYoaz10aGlzLnJlbmRlckJveEFuZFdoaXNrZXIodCkpO1xyXG5mb3IoYj0wO2I8dC5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7YisrKXRoaXMuX2RhdGFJblJlbmRlcmVkT3JkZXIucHVzaCh0aGlzLmRhdGFbdC5kYXRhU2VyaWVzSW5kZXhlc1tiXV0pO3RoaXMuYW5pbWF0ZWRSZW5kZXImJih0LnRhcmdldENhbnZhc0N0eC5taXRlckxpbWl0PWcsayYmYy5wdXNoKGspKX10aGlzLmN0eC5taXRlckxpbWl0PWY7dGhpcy5hbmltYXRlZFJlbmRlciYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZjLnB1c2goe3NvdXJjZTp0aGlzLl9icmVha3NDYW52YXNDdHgsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpILmZhZGVJbkFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpILmVhc2luZy5lYXNlSW5RdWFkLGFuaW1hdGlvbkJhc2U6MCxzdGFydFRpbWVQZXJjZW50OjAuN30pO3RoaXMuYW5pbWF0ZWRSZW5kZXImJjA8dGhpcy5faW5kZXhMYWJlbHMubGVuZ3RoJiYoZz11YSh0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KS5nZXRDb250ZXh0KFwiMmRcIiksXHJcbmMucHVzaCh0aGlzLnJlbmRlckluZGV4TGFiZWxzKGcpKSk7dmFyIHI9dGhpcztpZigwPGMubGVuZ3RoKXIuZGlzYWJsZVRvb2xUaXA9ITAsci5fYW5pbWF0b3IuYW5pbWF0ZSgyMDAsci5hbmltYXRpb25EdXJhdGlvbixmdW5jdGlvbihhKXtyLmN0eC5jbGVhclJlY3QoMCwwLHIud2lkdGgsci5oZWlnaHQpO3IuY3R4LmRyYXdJbWFnZShlLDAsMCxNYXRoLmZsb29yKHIud2lkdGgqaGEpLE1hdGguZmxvb3Ioci5oZWlnaHQqaGEpLDAsMCxyLndpZHRoLHIuaGVpZ2h0KTtmb3IodmFyIGI9MDtiPGMubGVuZ3RoO2IrKylrPWNbYl0sMT5hJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGsuc3RhcnRUaW1lUGVyY2VudD9hPj1rLnN0YXJ0VGltZVBlcmNlbnQmJmsuYW5pbWF0aW9uQ2FsbGJhY2soay5lYXNpbmdGdW5jdGlvbihhLWsuc3RhcnRUaW1lUGVyY2VudCwwLDEsMS1rLnN0YXJ0VGltZVBlcmNlbnQpLGspOmsuYW5pbWF0aW9uQ2FsbGJhY2soay5lYXNpbmdGdW5jdGlvbihhLDAsMSwxKSxrKTtcclxuci5kaXNwYXRjaEV2ZW50KFwiZGF0YUFuaW1hdGlvbkl0ZXJhdGlvbkVuZFwiLHtjaGFydDpyfSl9LGZ1bmN0aW9uKCl7Yz1bXTtmb3IodmFyIGE9MDthPHIucGxvdEluZm8ucGxvdFR5cGVzLmxlbmd0aDthKyspZm9yKHZhciBiPXIucGxvdEluZm8ucGxvdFR5cGVzW2FdLGQ9MDtkPGIucGxvdFVuaXRzLmxlbmd0aDtkKyspYi5wbG90VW5pdHNbZF0udGFyZ2V0Q2FudmFzPW51bGw7ZT1udWxsO3IuZGlzYWJsZVRvb2xUaXA9ITF9KTtlbHNle2lmKHIuX2JyZWFrc0NhbnZhcylpZih2KXIucGxvdEFyZWEuY3R4LmRyYXdJbWFnZShyLl9icmVha3NDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpO2Vsc2UgZm9yKGI9MDtiPHIuX2F4ZXMubGVuZ3RoO2IrKylyLl9heGVzW2JdLmNyZWF0ZU1hc2soKTswPHIuX2luZGV4TGFiZWxzLmxlbmd0aCYmci5yZW5kZXJJbmRleExhYmVscygpO3IuZGlzcGF0Y2hFdmVudChcImRhdGFBbmltYXRpb25JdGVyYXRpb25FbmRcIix7Y2hhcnQ6cn0pfXRoaXMuYXR0YWNoUGxvdEFyZWFFdmVudEhhbmRsZXJzKCk7XHJcbnRoaXMuem9vbUVuYWJsZWR8fCh0aGlzLnBhbkVuYWJsZWR8fCF0aGlzLl96b29tQnV0dG9ufHxcIm5vbmVcIj09PXRoaXMuX3pvb21CdXR0b24uc3R5bGUuZGlzcGxheSl8fHdhKHRoaXMuX3pvb21CdXR0b24sdGhpcy5fcmVzZXRCdXR0b24pO3RoaXMudG9vbFRpcC5fdXBkYXRlVG9vbFRpcCgpO3RoaXMucmVuZGVyQ291bnQrKzt0aGlzLl9icmVha3NDYW52YXMmJihkZWxldGUgdGhpcy5fYnJlYWtzQ2FudmFzLGRlbGV0ZSB0aGlzLl9icmVha3NDYW52YXNDdHgpO2ZvcihiPTA7Yjx0aGlzLl9heGVzLmxlbmd0aDtiKyspdGhpcy5fYXhlc1tiXS5tYXNrQ2FudmFzJiYoZGVsZXRlIHRoaXMuX2F4ZXNbYl0ubWFza0NhbnZhcyxkZWxldGUgdGhpcy5fYXhlc1tiXS5tYXNrQ3R4KX07cS5wcm90b3R5cGUuYXR0YWNoUGxvdEFyZWFFdmVudEhhbmRsZXJzPWZ1bmN0aW9uKCl7dGhpcy5hdHRhY2hFdmVudCh7Y29udGV4dDp0aGlzLGNoYXJ0OnRoaXMsbW91c2Vkb3duOnRoaXMuX3Bsb3RBcmVhTW91c2VEb3duLFxyXG5tb3VzZXVwOnRoaXMuX3Bsb3RBcmVhTW91c2VVcCxtb3VzZW1vdmU6dGhpcy5fcGxvdEFyZWFNb3VzZU1vdmUsY3Vyc29yOnRoaXMucGFuRW5hYmxlZD9cIm1vdmVcIjpcImRlZmF1bHRcIixjYXB0dXJlOiEwLGJvdW5kczp0aGlzLnBsb3RBcmVhfSl9O3EucHJvdG90eXBlLmNhdGVnb3Jpc2VEYXRhU2VyaWVzPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVwiXCIsZj0wO2Y8dGhpcy5kYXRhLmxlbmd0aDtmKyspaWYoYT10aGlzLmRhdGFbZl0sYS5kYXRhUG9pbnRzJiYoMCE9PWEuZGF0YVBvaW50cy5sZW5ndGgmJmEudmlzaWJsZSkmJjA8PXEuX3N1cHBvcnRlZENoYXJ0VHlwZXMuaW5kZXhPZihhLnR5cGUpKXtmb3IodmFyIGI9bnVsbCxjPSExLGU9bnVsbCxnPSExLGg9MDtoPHRoaXMucGxvdEluZm8ucGxvdFR5cGVzLmxlbmd0aDtoKyspaWYodGhpcy5wbG90SW5mby5wbG90VHlwZXNbaF0udHlwZT09PWEudHlwZSl7Yz0hMDtiPXRoaXMucGxvdEluZm8ucGxvdFR5cGVzW2hdO2JyZWFrfWN8fChiPXt0eXBlOmEudHlwZSxcclxudG90YWxEYXRhU2VyaWVzOjAscGxvdFVuaXRzOltdfSx0aGlzLnBsb3RJbmZvLnBsb3RUeXBlcy5wdXNoKGIpKTtmb3IoaD0wO2g8Yi5wbG90VW5pdHMubGVuZ3RoO2grKylpZihiLnBsb3RVbml0c1toXS5heGlzWVR5cGU9PT1hLmF4aXNZVHlwZSYmYi5wbG90VW5pdHNbaF0uYXhpc1hUeXBlPT09YS5heGlzWFR5cGUmJmIucGxvdFVuaXRzW2hdLmF4aXNZSW5kZXg9PT1hLmF4aXNZSW5kZXgmJmIucGxvdFVuaXRzW2hdLmF4aXNYSW5kZXg9PT1hLmF4aXNYSW5kZXgpe2c9ITA7ZT1iLnBsb3RVbml0c1toXTticmVha31nfHwoZT17dHlwZTphLnR5cGUscHJldmlvdXNEYXRhU2VyaWVzQ291bnQ6MCxpbmRleDpiLnBsb3RVbml0cy5sZW5ndGgscGxvdFR5cGU6YixheGlzWFR5cGU6YS5heGlzWFR5cGUsYXhpc1lUeXBlOmEuYXhpc1lUeXBlLGF4aXNZSW5kZXg6YS5heGlzWUluZGV4LGF4aXNYSW5kZXg6YS5heGlzWEluZGV4LGF4aXNZOlwicHJpbWFyeVwiPT09YS5heGlzWVR5cGU/dGhpcy5heGlzWVswPD1cclxuYS5heGlzWUluZGV4JiZhLmF4aXNZSW5kZXg8dGhpcy5heGlzWS5sZW5ndGg/YS5heGlzWUluZGV4OjBdOnRoaXMuYXhpc1kyWzA8PWEuYXhpc1lJbmRleCYmYS5heGlzWUluZGV4PHRoaXMuYXhpc1kyLmxlbmd0aD9hLmF4aXNZSW5kZXg6MF0sYXhpc1g6XCJwcmltYXJ5XCI9PT1hLmF4aXNYVHlwZT90aGlzLmF4aXNYWzA8PWEuYXhpc1hJbmRleCYmYS5heGlzWEluZGV4PHRoaXMuYXhpc1gubGVuZ3RoP2EuYXhpc1hJbmRleDowXTp0aGlzLmF4aXNYMlswPD1hLmF4aXNYSW5kZXgmJmEuYXhpc1hJbmRleDx0aGlzLmF4aXNYMi5sZW5ndGg/YS5heGlzWEluZGV4OjBdLGRhdGFTZXJpZXNJbmRleGVzOltdLHlUb3RhbHM6W119LGIucGxvdFVuaXRzLnB1c2goZSkpO2IudG90YWxEYXRhU2VyaWVzKys7ZS5kYXRhU2VyaWVzSW5kZXhlcy5wdXNoKGYpO2EucGxvdFVuaXQ9ZX1mb3IoZj0wO2Y8dGhpcy5wbG90SW5mby5wbG90VHlwZXMubGVuZ3RoO2YrKylmb3IoYj10aGlzLnBsb3RJbmZvLnBsb3RUeXBlc1tmXSxcclxuaD1hPTA7aDxiLnBsb3RVbml0cy5sZW5ndGg7aCsrKWIucGxvdFVuaXRzW2hdLnByZXZpb3VzRGF0YVNlcmllc0NvdW50PWEsYSs9Yi5wbG90VW5pdHNbaF0uZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RofTtxLnByb3RvdHlwZS5hc3NpZ25JZFRvRGF0YVBvaW50cz1mdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8dGhpcy5kYXRhLmxlbmd0aDthKyspe3ZhciBmPXRoaXMuZGF0YVthXTtpZihmLmRhdGFQb2ludHMpZm9yKHZhciBiPWYuZGF0YVBvaW50cy5sZW5ndGgsYz0wO2M8YjtjKyspZi5kYXRhUG9pbnRJZHNbY109Kyt0aGlzLl9ldmVudE1hbmFnZXIubGFzdE9iamVjdElkfX07cS5wcm90b3R5cGUuX3Byb2Nlc3NEYXRhPWZ1bmN0aW9uKCl7dGhpcy5hc3NpZ25JZFRvRGF0YVBvaW50cygpO3RoaXMuY2F0ZWdvcmlzZURhdGFTZXJpZXMoKTtmb3IodmFyIGE9MDthPHRoaXMucGxvdEluZm8ucGxvdFR5cGVzLmxlbmd0aDthKyspZm9yKHZhciBmPXRoaXMucGxvdEluZm8ucGxvdFR5cGVzW2FdLFxyXG5iPTA7YjxmLnBsb3RVbml0cy5sZW5ndGg7YisrKXt2YXIgYz1mLnBsb3RVbml0c1tiXTtcImxpbmVcIj09PWMudHlwZXx8XCJzdGVwTGluZVwiPT09Yy50eXBlfHxcInNwbGluZVwiPT09Yy50eXBlfHxcImNvbHVtblwiPT09Yy50eXBlfHxcImFyZWFcIj09PWMudHlwZXx8XCJzdGVwQXJlYVwiPT09Yy50eXBlfHxcInNwbGluZUFyZWFcIj09PWMudHlwZXx8XCJiYXJcIj09PWMudHlwZXx8XCJidWJibGVcIj09PWMudHlwZXx8XCJzY2F0dGVyXCI9PT1jLnR5cGU/dGhpcy5fcHJvY2Vzc011bHRpc2VyaWVzUGxvdFVuaXQoYyk6XCJzdGFja2VkQ29sdW1uXCI9PT1jLnR5cGV8fFwic3RhY2tlZEJhclwiPT09Yy50eXBlfHxcInN0YWNrZWRBcmVhXCI9PT1jLnR5cGU/dGhpcy5fcHJvY2Vzc1N0YWNrZWRQbG90VW5pdChjKTpcInN0YWNrZWRDb2x1bW4xMDBcIj09PWMudHlwZXx8XCJzdGFja2VkQmFyMTAwXCI9PT1jLnR5cGV8fFwic3RhY2tlZEFyZWExMDBcIj09PWMudHlwZT90aGlzLl9wcm9jZXNzU3RhY2tlZDEwMFBsb3RVbml0KGMpOlwiY2FuZGxlc3RpY2tcIj09PVxyXG5jLnR5cGV8fFwib2hsY1wiPT09Yy50eXBlfHxcInJhbmdlQ29sdW1uXCI9PT1jLnR5cGV8fFwicmFuZ2VCYXJcIj09PWMudHlwZXx8XCJyYW5nZUFyZWFcIj09PWMudHlwZXx8XCJyYW5nZVNwbGluZUFyZWFcIj09PWMudHlwZXx8XCJlcnJvclwiPT09Yy50eXBlfHxcImJveEFuZFdoaXNrZXJcIj09PWMudHlwZT90aGlzLl9wcm9jZXNzTXVsdGlZUGxvdFVuaXQoYyk6XCJ3YXRlcmZhbGxcIj09PWMudHlwZSYmdGhpcy5fcHJvY2Vzc1NwZWNpZmljUGxvdFVuaXQoYyl9dGhpcy5jYWxjdWxhdGVBdXRvQnJlYWtzKCl9O3EucHJvdG90eXBlLl9wcm9jZXNzTXVsdGlzZXJpZXNQbG90VW5pdD1mdW5jdGlvbihhKXtpZihhLmRhdGFTZXJpZXNJbmRleGVzJiYhKDE+YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKWZvcih2YXIgZj1hLmF4aXNZLmRhdGFJbmZvLGI9YS5heGlzWC5kYXRhSW5mbyxjLGUsZz0hMSxoPTA7aDxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtoKyspe3ZhciBsPXRoaXMuZGF0YVthLmRhdGFTZXJpZXNJbmRleGVzW2hdXSxcclxudD0wLGs9ITEscj0hMSxwO2lmKFwibm9ybWFsXCI9PT1sLmF4aXNQbGFjZW1lbnR8fFwieHlTd2FwcGVkXCI9PT1sLmF4aXNQbGFjZW1lbnQpdmFyIG49YS5heGlzWC5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bT9hLmF4aXNYLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtOnRoaXMub3B0aW9ucy5heGlzWCYmdGhpcy5vcHRpb25zLmF4aXNYLnZpZXdwb3J0TWluaW11bT90aGlzLm9wdGlvbnMuYXhpc1gudmlld3BvcnRNaW5pbXVtOnRoaXMub3B0aW9ucy5heGlzWCYmdGhpcy5vcHRpb25zLmF4aXNYLm1pbmltdW0/dGhpcy5vcHRpb25zLmF4aXNYLm1pbmltdW06YS5heGlzWC5sb2dhcml0aG1pYz8wOi1JbmZpbml0eSxkPWEuYXhpc1guc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW0/YS5heGlzWC5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bTp0aGlzLm9wdGlvbnMuYXhpc1gmJnRoaXMub3B0aW9ucy5heGlzWC52aWV3cG9ydE1heGltdW0/XHJcbnRoaXMub3B0aW9ucy5heGlzWC52aWV3cG9ydE1heGltdW06dGhpcy5vcHRpb25zLmF4aXNYJiZ0aGlzLm9wdGlvbnMuYXhpc1gubWF4aW11bT90aGlzLm9wdGlvbnMuYXhpc1gubWF4aW11bTpJbmZpbml0eTtpZihsLmRhdGFQb2ludHNbdF0ueCYmbC5kYXRhUG9pbnRzW3RdLnguZ2V0VGltZXx8XCJkYXRlVGltZVwiPT09bC54VmFsdWVUeXBlKWc9ITA7Zm9yKHQ9MDt0PGwuZGF0YVBvaW50cy5sZW5ndGg7dCsrKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGwuZGF0YVBvaW50c1t0XS54JiYobC5kYXRhUG9pbnRzW3RdLng9dCsoYS5heGlzWC5sb2dhcml0aG1pYz8xOjApKTtsLmRhdGFQb2ludHNbdF0ueC5nZXRUaW1lPyhnPSEwLGM9bC5kYXRhUG9pbnRzW3RdLnguZ2V0VGltZSgpKTpjPWwuZGF0YVBvaW50c1t0XS54O2U9bC5kYXRhUG9pbnRzW3RdLnk7YzxiLm1pbiYmKGIubWluPWMpO2M+Yi5tYXgmJihiLm1heD1jKTtlPGYubWluJiZcIm51bWJlclwiPT09dHlwZW9mIGUmJihmLm1pbj1lKTtcclxuZT5mLm1heCYmXCJudW1iZXJcIj09PXR5cGVvZiBlJiYoZi5tYXg9ZSk7aWYoMDx0KXtpZihhLmF4aXNYLmxvZ2FyaXRobWljKXt2YXIgdz1jL2wuZGF0YVBvaW50c1t0LTFdLng7MT53JiYodz0xL3cpO2IubWluRGlmZj53JiYxIT09dyYmKGIubWluRGlmZj13KX1lbHNlIHc9Yy1sLmRhdGFQb2ludHNbdC0xXS54LDA+dyYmKHcqPS0xKSxiLm1pbkRpZmY+dyYmMCE9PXcmJihiLm1pbkRpZmY9dyk7bnVsbCE9PWUmJm51bGwhPT1sLmRhdGFQb2ludHNbdC0xXS55JiYoYS5heGlzWS5sb2dhcml0aG1pYz8odz1lL2wuZGF0YVBvaW50c1t0LTFdLnksMT53JiYodz0xL3cpLGYubWluRGlmZj53JiYxIT09dyYmKGYubWluRGlmZj13KSk6KHc9ZS1sLmRhdGFQb2ludHNbdC0xXS55LDA+dyYmKHcqPS0xKSxmLm1pbkRpZmY+dyYmMCE9PXcmJihmLm1pbkRpZmY9dykpKX1pZihjPG4mJiFrKW51bGwhPT1lJiYocD1jKTtlbHNle2lmKCFrJiYoaz0hMCwwPHQpKXt0LT0yO2NvbnRpbnVlfWlmKGM+ZCYmXHJcbiFyKXI9ITA7ZWxzZSBpZihjPmQmJnIpY29udGludWU7bC5kYXRhUG9pbnRzW3RdLmxhYmVsJiYoYS5heGlzWC5sYWJlbHNbY109bC5kYXRhUG9pbnRzW3RdLmxhYmVsKTtjPGIudmlld1BvcnRNaW4mJihiLnZpZXdQb3J0TWluPWMpO2M+Yi52aWV3UG9ydE1heCYmKGIudmlld1BvcnRNYXg9Yyk7bnVsbD09PWU/Yi52aWV3UG9ydE1pbj09PWMmJnA8YyYmKGIudmlld1BvcnRNaW49cCk6KGU8Zi52aWV3UG9ydE1pbiYmXCJudW1iZXJcIj09PXR5cGVvZiBlJiYoZi52aWV3UG9ydE1pbj1lKSxlPmYudmlld1BvcnRNYXgmJlwibnVtYmVyXCI9PT10eXBlb2YgZSYmKGYudmlld1BvcnRNYXg9ZSkpfX1sLmF4aXNYLnZhbHVlVHlwZT1sLnhWYWx1ZVR5cGU9Zz9cImRhdGVUaW1lXCI6XCJudW1iZXJcIn19O3EucHJvdG90eXBlLl9wcm9jZXNzU3RhY2tlZFBsb3RVbml0PWZ1bmN0aW9uKGEpe2lmKGEuZGF0YVNlcmllc0luZGV4ZXMmJiEoMT5hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe2Zvcih2YXIgZj1cclxuYS5heGlzWS5kYXRhSW5mbyxiPWEuYXhpc1guZGF0YUluZm8sYyxlLGc9ITEsaD1bXSxsPVtdLHQ9SW5maW5pdHksaz0tSW5maW5pdHkscj0wO3I8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7cisrKXt2YXIgcD10aGlzLmRhdGFbYS5kYXRhU2VyaWVzSW5kZXhlc1tyXV0sbj0wLGQ9ITEsdz0hMSx6YTtpZihcIm5vcm1hbFwiPT09cC5heGlzUGxhY2VtZW50fHxcInh5U3dhcHBlZFwiPT09cC5heGlzUGxhY2VtZW50KXZhciBEPXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5heGlzWC5uZXdWaWV3cG9ydE1pbmltdW0/dGhpcy5zZXNzaW9uVmFyaWFibGVzLmF4aXNYLm5ld1ZpZXdwb3J0TWluaW11bTp0aGlzLm9wdGlvbnMuYXhpc1gmJnRoaXMub3B0aW9ucy5heGlzWC52aWV3cG9ydE1pbmltdW0/dGhpcy5vcHRpb25zLmF4aXNYLnZpZXdwb3J0TWluaW11bTp0aGlzLm9wdGlvbnMuYXhpc1gmJnRoaXMub3B0aW9ucy5heGlzWC5taW5pbXVtP3RoaXMub3B0aW9ucy5heGlzWC5taW5pbXVtOi1JbmZpbml0eSxcclxudT10aGlzLnNlc3Npb25WYXJpYWJsZXMuYXhpc1gubmV3Vmlld3BvcnRNYXhpbXVtP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5heGlzWC5uZXdWaWV3cG9ydE1heGltdW06dGhpcy5vcHRpb25zLmF4aXNYJiZ0aGlzLm9wdGlvbnMuYXhpc1gudmlld3BvcnRNYXhpbXVtP3RoaXMub3B0aW9ucy5heGlzWC52aWV3cG9ydE1heGltdW06dGhpcy5vcHRpb25zLmF4aXNYJiZ0aGlzLm9wdGlvbnMuYXhpc1gubWF4aW11bT90aGlzLm9wdGlvbnMuYXhpc1gubWF4aW11bTpJbmZpbml0eTtpZihwLmRhdGFQb2ludHNbbl0ueCYmcC5kYXRhUG9pbnRzW25dLnguZ2V0VGltZXx8XCJkYXRlVGltZVwiPT09cC54VmFsdWVUeXBlKWc9ITA7Zm9yKG49MDtuPHAuZGF0YVBvaW50cy5sZW5ndGg7bisrKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIHAuZGF0YVBvaW50c1tuXS54JiYocC5kYXRhUG9pbnRzW25dLng9bisoYS5heGlzWC5sb2dhcml0aG1pYz8xOjApKTtwLmRhdGFQb2ludHNbbl0ueC5nZXRUaW1lPyhnPVxyXG4hMCxjPXAuZGF0YVBvaW50c1tuXS54LmdldFRpbWUoKSk6Yz1wLmRhdGFQb2ludHNbbl0ueDtlPXkocC5kYXRhUG9pbnRzW25dLnkpPzA6cC5kYXRhUG9pbnRzW25dLnk7YzxiLm1pbiYmKGIubWluPWMpO2M+Yi5tYXgmJihiLm1heD1jKTtpZigwPG4pe2lmKGEuYXhpc1gubG9nYXJpdGhtaWMpe3ZhciBtPWMvcC5kYXRhUG9pbnRzW24tMV0ueDsxPm0mJihtPTEvbSk7Yi5taW5EaWZmPm0mJjEhPT1tJiYoYi5taW5EaWZmPW0pfWVsc2UgbT1jLXAuZGF0YVBvaW50c1tuLTFdLngsMD5tJiYobSo9LTEpLGIubWluRGlmZj5tJiYwIT09bSYmKGIubWluRGlmZj1tKTtudWxsIT09ZSYmbnVsbCE9PXAuZGF0YVBvaW50c1tuLTFdLnkmJihhLmF4aXNZLmxvZ2FyaXRobWljPzA8ZSYmKG09ZS9wLmRhdGFQb2ludHNbbi0xXS55LDE+bSYmKG09MS9tKSxmLm1pbkRpZmY+bSYmMSE9PW0mJihmLm1pbkRpZmY9bSkpOihtPWUtcC5kYXRhUG9pbnRzW24tMV0ueSwwPm0mJihtKj0tMSksZi5taW5EaWZmPlxyXG5tJiYwIT09bSYmKGYubWluRGlmZj1tKSkpfWlmKGM8RCYmIWQpbnVsbCE9PXAuZGF0YVBvaW50c1tuXS55JiYoemE9Yyk7ZWxzZXtpZighZCYmKGQ9ITAsMDxuKSl7bi09Mjtjb250aW51ZX1pZihjPnUmJiF3KXc9ITA7ZWxzZSBpZihjPnUmJncpY29udGludWU7cC5kYXRhUG9pbnRzW25dLmxhYmVsJiYoYS5heGlzWC5sYWJlbHNbY109cC5kYXRhUG9pbnRzW25dLmxhYmVsKTtjPGIudmlld1BvcnRNaW4mJihiLnZpZXdQb3J0TWluPWMpO2M+Yi52aWV3UG9ydE1heCYmKGIudmlld1BvcnRNYXg9Yyk7bnVsbD09PXAuZGF0YVBvaW50c1tuXS55P2Iudmlld1BvcnRNaW49PT1jJiZ6YTxjJiYoYi52aWV3UG9ydE1pbj16YSk6KGEueVRvdGFsc1tjXT0oYS55VG90YWxzW2NdP2EueVRvdGFsc1tjXTowKStlLDA8PWU/aFtjXT9oW2NdKz1lOihoW2NdPWUsdD1NYXRoLm1pbihlLHQpKTpsW2NdP2xbY10rPWU6KGxbY109ZSxrPU1hdGgubWF4KGUsaykpKX19YS5heGlzWS5zY2FsZUJyZWFrcyYmXHJcbihhLmF4aXNZLnNjYWxlQnJlYWtzLmF1dG9DYWxjdWxhdGUmJjE8PWEuYXhpc1kuc2NhbGVCcmVha3MubWF4TnVtYmVyT2ZBdXRvQnJlYWtzKSYmKGYuZGF0YVBvaW50WVBvc2l0aXZlU3Vtcz8oZi5kYXRhUG9pbnRZUG9zaXRpdmVTdW1zLnB1c2guYXBwbHkoZi5kYXRhUG9pbnRZUG9zaXRpdmVTdW1zLGgpLGYuZGF0YVBvaW50WU5lZ2F0aXZlU3Vtcy5wdXNoLmFwcGx5KGYuZGF0YVBvaW50WVBvc2l0aXZlU3VtcyxsKSk6KGYuZGF0YVBvaW50WVBvc2l0aXZlU3Vtcz1oLGYuZGF0YVBvaW50WU5lZ2F0aXZlU3Vtcz1sKSk7cC5heGlzWC52YWx1ZVR5cGU9cC54VmFsdWVUeXBlPWc/XCJkYXRlVGltZVwiOlwibnVtYmVyXCJ9Zm9yKG4gaW4gaCloLmhhc093blByb3BlcnR5KG4pJiYhaXNOYU4obikmJihhPWhbbl0sYTxmLm1pbiYmKGYubWluPU1hdGgubWluKGEsdCkpLGE+Zi5tYXgmJihmLm1heD1hKSxuPGIudmlld1BvcnRNaW58fG4+Yi52aWV3UG9ydE1heHx8KGE8Zi52aWV3UG9ydE1pbiYmXHJcbihmLnZpZXdQb3J0TWluPU1hdGgubWluKGEsdCkpLGE+Zi52aWV3UG9ydE1heCYmKGYudmlld1BvcnRNYXg9YSkpKTtmb3IobiBpbiBsKWwuaGFzT3duUHJvcGVydHkobikmJiFpc05hTihuKSYmKGE9bFtuXSxhPGYubWluJiYoZi5taW49YSksYT5mLm1heCYmKGYubWF4PU1hdGgubWF4KGEsaykpLG48Yi52aWV3UG9ydE1pbnx8bj5iLnZpZXdQb3J0TWF4fHwoYTxmLnZpZXdQb3J0TWluJiYoZi52aWV3UG9ydE1pbj1hKSxhPmYudmlld1BvcnRNYXgmJihmLnZpZXdQb3J0TWF4PU1hdGgubWF4KGEsaykpKSl9fTtxLnByb3RvdHlwZS5fcHJvY2Vzc1N0YWNrZWQxMDBQbG90VW5pdD1mdW5jdGlvbihhKXtpZihhLmRhdGFTZXJpZXNJbmRleGVzJiYhKDE+YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXtmb3IodmFyIGY9YS5heGlzWS5kYXRhSW5mbyxiPWEuYXhpc1guZGF0YUluZm8sYyxlLGc9ITEsaD0hMSxsPSExLHQ9W10saz0wO2s8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7aysrKXt2YXIgcj1cclxudGhpcy5kYXRhW2EuZGF0YVNlcmllc0luZGV4ZXNba11dLHA9MCxuPSExLGQ9ITEsdztpZihcIm5vcm1hbFwiPT09ci5heGlzUGxhY2VtZW50fHxcInh5U3dhcHBlZFwiPT09ci5heGlzUGxhY2VtZW50KXZhciBtPXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5heGlzWC5uZXdWaWV3cG9ydE1pbmltdW0/dGhpcy5zZXNzaW9uVmFyaWFibGVzLmF4aXNYLm5ld1ZpZXdwb3J0TWluaW11bTp0aGlzLm9wdGlvbnMuYXhpc1gmJnRoaXMub3B0aW9ucy5heGlzWC52aWV3cG9ydE1pbmltdW0/dGhpcy5vcHRpb25zLmF4aXNYLnZpZXdwb3J0TWluaW11bTp0aGlzLm9wdGlvbnMuYXhpc1gmJnRoaXMub3B0aW9ucy5heGlzWC5taW5pbXVtP3RoaXMub3B0aW9ucy5heGlzWC5taW5pbXVtOi1JbmZpbml0eSxEPXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5heGlzWC5uZXdWaWV3cG9ydE1heGltdW0/dGhpcy5zZXNzaW9uVmFyaWFibGVzLmF4aXNYLm5ld1ZpZXdwb3J0TWF4aW11bTp0aGlzLm9wdGlvbnMuYXhpc1gmJlxyXG50aGlzLm9wdGlvbnMuYXhpc1gudmlld3BvcnRNYXhpbXVtP3RoaXMub3B0aW9ucy5heGlzWC52aWV3cG9ydE1heGltdW06dGhpcy5vcHRpb25zLmF4aXNYJiZ0aGlzLm9wdGlvbnMuYXhpc1gubWF4aW11bT90aGlzLm9wdGlvbnMuYXhpc1gubWF4aW11bTpJbmZpbml0eTtpZihyLmRhdGFQb2ludHNbcF0ueCYmci5kYXRhUG9pbnRzW3BdLnguZ2V0VGltZXx8XCJkYXRlVGltZVwiPT09ci54VmFsdWVUeXBlKWc9ITA7Zm9yKHA9MDtwPHIuZGF0YVBvaW50cy5sZW5ndGg7cCsrKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIHIuZGF0YVBvaW50c1twXS54JiYoci5kYXRhUG9pbnRzW3BdLng9cCsoYS5heGlzWC5sb2dhcml0aG1pYz8xOjApKTtyLmRhdGFQb2ludHNbcF0ueC5nZXRUaW1lPyhnPSEwLGM9ci5kYXRhUG9pbnRzW3BdLnguZ2V0VGltZSgpKTpjPXIuZGF0YVBvaW50c1twXS54O2U9eShyLmRhdGFQb2ludHNbcF0ueSk/bnVsbDpyLmRhdGFQb2ludHNbcF0ueTtjPGIubWluJiYoYi5taW49XHJcbmMpO2M+Yi5tYXgmJihiLm1heD1jKTtpZigwPHApe2lmKGEuYXhpc1gubG9nYXJpdGhtaWMpe3ZhciB1PWMvci5kYXRhUG9pbnRzW3AtMV0ueDsxPnUmJih1PTEvdSk7Yi5taW5EaWZmPnUmJjEhPT11JiYoYi5taW5EaWZmPXUpfWVsc2UgdT1jLXIuZGF0YVBvaW50c1twLTFdLngsMD51JiYodSo9LTEpLGIubWluRGlmZj51JiYwIT09dSYmKGIubWluRGlmZj11KTt5KGUpfHxudWxsPT09ci5kYXRhUG9pbnRzW3AtMV0ueXx8KGEuYXhpc1kubG9nYXJpdGhtaWM/MDxlJiYodT1lL3IuZGF0YVBvaW50c1twLTFdLnksMT51JiYodT0xL3UpLGYubWluRGlmZj51JiYxIT09dSYmKGYubWluRGlmZj11KSk6KHU9ZS1yLmRhdGFQb2ludHNbcC0xXS55LDA+dSYmKHUqPS0xKSxmLm1pbkRpZmY+dSYmMCE9PXUmJihmLm1pbkRpZmY9dSkpKX1pZihjPG0mJiFuKW51bGwhPT1lJiYodz1jKTtlbHNle2lmKCFuJiYobj0hMCwwPHApKXtwLT0yO2NvbnRpbnVlfWlmKGM+RCYmIWQpZD0hMDtlbHNlIGlmKGM+XHJcbkQmJmQpY29udGludWU7ci5kYXRhUG9pbnRzW3BdLmxhYmVsJiYoYS5heGlzWC5sYWJlbHNbY109ci5kYXRhUG9pbnRzW3BdLmxhYmVsKTtjPGIudmlld1BvcnRNaW4mJihiLnZpZXdQb3J0TWluPWMpO2M+Yi52aWV3UG9ydE1heCYmKGIudmlld1BvcnRNYXg9Yyk7bnVsbD09PWU/Yi52aWV3UG9ydE1pbj09PWMmJnc8YyYmKGIudmlld1BvcnRNaW49dyk6KGEueVRvdGFsc1tjXT0oYS55VG90YWxzW2NdP2EueVRvdGFsc1tjXTowKStlLDA8PWU/aD0hMDowPmUmJihsPSEwKSx0W2NdPXRbY10/dFtjXStNYXRoLmFicyhlKTpNYXRoLmFicyhlKSl9fXIuYXhpc1gudmFsdWVUeXBlPXIueFZhbHVlVHlwZT1nP1wiZGF0ZVRpbWVcIjpcIm51bWJlclwifWEuYXhpc1kubG9nYXJpdGhtaWM/KGYubWF4PXkoZi52aWV3UG9ydE1heCk/OTkqTWF0aC5wb3coYS5heGlzWS5sb2dhcml0aG1CYXNlLC0wLjA1KTpNYXRoLm1heChmLnZpZXdQb3J0TWF4LDk5Kk1hdGgucG93KGEuYXhpc1kubG9nYXJpdGhtQmFzZSxcclxuLTAuMDUpKSxmLm1pbj15KGYudmlld1BvcnRNaW4pPzE6TWF0aC5taW4oZi52aWV3UG9ydE1pbiwxKSk6aCYmIWw/KGYubWF4PXkoZi52aWV3UG9ydE1heCk/OTk6TWF0aC5tYXgoZi52aWV3UG9ydE1heCw5OSksZi5taW49eShmLnZpZXdQb3J0TWluKT8xOk1hdGgubWluKGYudmlld1BvcnRNaW4sMSkpOmgmJmw/KGYubWF4PXkoZi52aWV3UG9ydE1heCk/OTk6TWF0aC5tYXgoZi52aWV3UG9ydE1heCw5OSksZi5taW49eShmLnZpZXdQb3J0TWluKT8tOTk6TWF0aC5taW4oZi52aWV3UG9ydE1pbiwtOTkpKTohaCYmbCYmKGYubWF4PXkoZi52aWV3UG9ydE1heCk/LTE6TWF0aC5tYXgoZi52aWV3UG9ydE1heCwtMSksZi5taW49eShmLnZpZXdQb3J0TWluKT8tOTk6TWF0aC5taW4oZi52aWV3UG9ydE1pbiwtOTkpKTtmLnZpZXdQb3J0TWluPWYubWluO2Yudmlld1BvcnRNYXg9Zi5tYXg7YS5kYXRhUG9pbnRZU3Vtcz10fX07cS5wcm90b3R5cGUuX3Byb2Nlc3NNdWx0aVlQbG90VW5pdD1mdW5jdGlvbihhKXtpZihhLmRhdGFTZXJpZXNJbmRleGVzJiZcclxuISgxPmEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSlmb3IodmFyIGY9YS5heGlzWS5kYXRhSW5mbyxiPWEuYXhpc1guZGF0YUluZm8sYyxlLGcsaCxsPSExLHQ9MDt0PGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO3QrKyl7dmFyIGs9dGhpcy5kYXRhW2EuZGF0YVNlcmllc0luZGV4ZXNbdF1dLHI9MCxwPSExLG49ITEsZCx3LG07aWYoXCJub3JtYWxcIj09PWsuYXhpc1BsYWNlbWVudHx8XCJ4eVN3YXBwZWRcIj09PWsuYXhpc1BsYWNlbWVudCl2YXIgRD1hLmF4aXNYLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtP2EuYXhpc1guc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW06dGhpcy5vcHRpb25zLmF4aXNYJiZ0aGlzLm9wdGlvbnMuYXhpc1gudmlld3BvcnRNaW5pbXVtP3RoaXMub3B0aW9ucy5heGlzWC52aWV3cG9ydE1pbmltdW06dGhpcy5vcHRpb25zLmF4aXNYJiZ0aGlzLm9wdGlvbnMuYXhpc1gubWluaW11bT90aGlzLm9wdGlvbnMuYXhpc1gubWluaW11bTpcclxuYS5heGlzWC5sb2dhcml0aG1pYz8wOi1JbmZpbml0eSx1PWEuYXhpc1guc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW0/YS5heGlzWC5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bTp0aGlzLm9wdGlvbnMuYXhpc1gmJnRoaXMub3B0aW9ucy5heGlzWC52aWV3cG9ydE1heGltdW0/dGhpcy5vcHRpb25zLmF4aXNYLnZpZXdwb3J0TWF4aW11bTp0aGlzLm9wdGlvbnMuYXhpc1gmJnRoaXMub3B0aW9ucy5heGlzWC5tYXhpbXVtP3RoaXMub3B0aW9ucy5heGlzWC5tYXhpbXVtOkluZmluaXR5O2lmKGsuZGF0YVBvaW50c1tyXS54JiZrLmRhdGFQb2ludHNbcl0ueC5nZXRUaW1lfHxcImRhdGVUaW1lXCI9PT1rLnhWYWx1ZVR5cGUpbD0hMDtmb3Iocj0wO3I8ay5kYXRhUG9pbnRzLmxlbmd0aDtyKyspe1widW5kZWZpbmVkXCI9PT10eXBlb2Ygay5kYXRhUG9pbnRzW3JdLngmJihrLmRhdGFQb2ludHNbcl0ueD1yKyhhLmF4aXNYLmxvZ2FyaXRobWljPzE6MCkpO2suZGF0YVBvaW50c1tyXS54LmdldFRpbWU/XHJcbihsPSEwLGM9ay5kYXRhUG9pbnRzW3JdLnguZ2V0VGltZSgpKTpjPWsuZGF0YVBvaW50c1tyXS54O2lmKChlPWsuZGF0YVBvaW50c1tyXS55KSYmZS5sZW5ndGgpe2c9TWF0aC5taW4uYXBwbHkobnVsbCxlKTtoPU1hdGgubWF4LmFwcGx5KG51bGwsZSk7dz0hMDtmb3IodmFyIHY9MDt2PGUubGVuZ3RoO3YrKyludWxsPT09ZS5rJiYodz0hMSk7dyYmKHB8fChtPWQpLGQ9Yyl9YzxiLm1pbiYmKGIubWluPWMpO2M+Yi5tYXgmJihiLm1heD1jKTtnPGYubWluJiYoZi5taW49Zyk7aD5mLm1heCYmKGYubWF4PWgpOzA8ciYmKGEuYXhpc1gubG9nYXJpdGhtaWM/KHc9Yy9rLmRhdGFQb2ludHNbci0xXS54LDE+dyYmKHc9MS93KSxiLm1pbkRpZmY+dyYmMSE9PXcmJihiLm1pbkRpZmY9dykpOih3PWMtay5kYXRhUG9pbnRzW3ItMV0ueCwwPncmJih3Kj0tMSksYi5taW5EaWZmPncmJjAhPT13JiYoYi5taW5EaWZmPXcpKSxlJiYobnVsbCE9PWVbMF0mJmsuZGF0YVBvaW50c1tyLTFdLnkmJm51bGwhPT1cclxuay5kYXRhUG9pbnRzW3ItMV0ueVswXSkmJihhLmF4aXNZLmxvZ2FyaXRobWljPyh3PWVbMF0vay5kYXRhUG9pbnRzW3ItMV0ueVswXSwxPncmJih3PTEvdyksZi5taW5EaWZmPncmJjEhPT13JiYoZi5taW5EaWZmPXcpKToodz1lWzBdLWsuZGF0YVBvaW50c1tyLTFdLnlbMF0sMD53JiYodyo9LTEpLGYubWluRGlmZj53JiYwIT09dyYmKGYubWluRGlmZj13KSkpKTtpZighKGM8RCl8fHApe2lmKCFwJiYocD0hMCwwPHIpKXtyLT0yO2Q9bTtjb250aW51ZX1pZihjPnUmJiFuKW49ITA7ZWxzZSBpZihjPnUmJm4pY29udGludWU7ay5kYXRhUG9pbnRzW3JdLmxhYmVsJiYoYS5heGlzWC5sYWJlbHNbY109ay5kYXRhUG9pbnRzW3JdLmxhYmVsKTtjPGIudmlld1BvcnRNaW4mJihiLnZpZXdQb3J0TWluPWMpO2M+Yi52aWV3UG9ydE1heCYmKGIudmlld1BvcnRNYXg9Yyk7aWYoYi52aWV3UG9ydE1pbj09PWMmJmUpZm9yKHY9MDt2PGUubGVuZ3RoO3YrKylpZihudWxsPT09ZVt2XSYmZDxjKXtiLnZpZXdQb3J0TWluPVxyXG5kO2JyZWFrfW51bGw9PT1lP2Iudmlld1BvcnRNaW49PT1jJiZkPGMmJihiLnZpZXdQb3J0TWluPWQpOihnPGYudmlld1BvcnRNaW4mJihmLnZpZXdQb3J0TWluPWcpLGg+Zi52aWV3UG9ydE1heCYmKGYudmlld1BvcnRNYXg9aCkpfX1rLmF4aXNYLnZhbHVlVHlwZT1rLnhWYWx1ZVR5cGU9bD9cImRhdGVUaW1lXCI6XCJudW1iZXJcIn19O3EucHJvdG90eXBlLl9wcm9jZXNzU3BlY2lmaWNQbG90VW5pdD1mdW5jdGlvbihhKXtpZihcIndhdGVyZmFsbFwiPT09YS50eXBlJiZhLmRhdGFTZXJpZXNJbmRleGVzJiYhKDE+YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKWZvcih2YXIgZj1hLmF4aXNZLmRhdGFJbmZvLGI9YS5heGlzWC5kYXRhSW5mbyxjLGUsZz0hMSxoPTA7aDxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtoKyspe3ZhciBsPXRoaXMuZGF0YVthLmRhdGFTZXJpZXNJbmRleGVzW2hdXSx0PTAsaz0hMSxyPSExLHA9Yz0wO2lmKFwibm9ybWFsXCI9PT1sLmF4aXNQbGFjZW1lbnR8fFwieHlTd2FwcGVkXCI9PT1cclxubC5heGlzUGxhY2VtZW50KXZhciBuPWEuYXhpc1guc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW0/YS5heGlzWC5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bTp0aGlzLm9wdGlvbnMuYXhpc1gmJnRoaXMub3B0aW9ucy5heGlzWC52aWV3cG9ydE1pbmltdW0/dGhpcy5vcHRpb25zLmF4aXNYLnZpZXdwb3J0TWluaW11bTp0aGlzLm9wdGlvbnMuYXhpc1gmJnRoaXMub3B0aW9ucy5heGlzWC5taW5pbXVtP3RoaXMub3B0aW9ucy5heGlzWC5taW5pbXVtOmEuYXhpc1gubG9nYXJpdGhtaWM/MDotSW5maW5pdHksZD1hLmF4aXNYLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtP2EuYXhpc1guc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW06dGhpcy5vcHRpb25zLmF4aXNYJiZ0aGlzLm9wdGlvbnMuYXhpc1gudmlld3BvcnRNYXhpbXVtP3RoaXMub3B0aW9ucy5heGlzWC52aWV3cG9ydE1heGltdW06dGhpcy5vcHRpb25zLmF4aXNYJiZcclxudGhpcy5vcHRpb25zLmF4aXNYLm1heGltdW0/dGhpcy5vcHRpb25zLmF4aXNYLm1heGltdW06SW5maW5pdHk7aWYobC5kYXRhUG9pbnRzW3RdLngmJmwuZGF0YVBvaW50c1t0XS54LmdldFRpbWV8fFwiZGF0ZVRpbWVcIj09PWwueFZhbHVlVHlwZSlnPSEwO2Zvcih0PTA7dDxsLmRhdGFQb2ludHMubGVuZ3RoO3QrKylcInVuZGVmaW5lZFwiIT09dHlwZW9mIGwuZGF0YVBvaW50c1t0XS5pc0N1bXVsYXRpdmVTdW0mJiEwPT09bC5kYXRhUG9pbnRzW3RdLmlzQ3VtdWxhdGl2ZVN1bT8obC5kYXRhUG9pbnRFT3NbdF0uY3VtdWxhdGl2ZVN1bVlTdGFydFZhbHVlPTAsbC5kYXRhUG9pbnRFT3NbdF0uY3VtdWxhdGl2ZVN1bT0wPT09dD8wOmwuZGF0YVBvaW50RU9zW3QtMV0uY3VtdWxhdGl2ZVN1bSxsLmRhdGFQb2ludHNbdF0ueT0wPT09dD8wOmwuZGF0YVBvaW50RU9zW3QtMV0uY3VtdWxhdGl2ZVN1bSk6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsLmRhdGFQb2ludHNbdF0uaXNJbnRlcm1lZGlhdGVTdW0mJlxyXG4hMD09PWwuZGF0YVBvaW50c1t0XS5pc0ludGVybWVkaWF0ZVN1bT8obC5kYXRhUG9pbnRFT3NbdF0uY3VtdWxhdGl2ZVN1bVlTdGFydFZhbHVlPXAsbC5kYXRhUG9pbnRFT3NbdF0uY3VtdWxhdGl2ZVN1bT0wPT09dD8wOmwuZGF0YVBvaW50RU9zW3QtMV0uY3VtdWxhdGl2ZVN1bSxsLmRhdGFQb2ludHNbdF0ueT0wPT09dD8wOmMscD0wPT09dD8wOmwuZGF0YVBvaW50RU9zW3QtMV0uY3VtdWxhdGl2ZVN1bSxjPTApOihlPVwibnVtYmVyXCIhPT10eXBlb2YgbC5kYXRhUG9pbnRzW3RdLnk/MDpsLmRhdGFQb2ludHNbdF0ueSxsLmRhdGFQb2ludEVPc1t0XS5jdW11bGF0aXZlU3VtWVN0YXJ0VmFsdWU9MD09PXQ/MDpsLmRhdGFQb2ludEVPc1t0LTFdLmN1bXVsYXRpdmVTdW0sbC5kYXRhUG9pbnRFT3NbdF0uY3VtdWxhdGl2ZVN1bT0wPT09dD9lOmwuZGF0YVBvaW50RU9zW3QtMV0uY3VtdWxhdGl2ZVN1bStlLGMrPWUpO2Zvcih0PTA7dDxsLmRhdGFQb2ludHMubGVuZ3RoO3QrKylpZihcInVuZGVmaW5lZFwiPT09XHJcbnR5cGVvZiBsLmRhdGFQb2ludHNbdF0ueCYmKGwuZGF0YVBvaW50c1t0XS54PXQrKGEuYXhpc1gubG9nYXJpdGhtaWM/MTowKSksbC5kYXRhUG9pbnRzW3RdLnguZ2V0VGltZT8oZz0hMCxjPWwuZGF0YVBvaW50c1t0XS54LmdldFRpbWUoKSk6Yz1sLmRhdGFQb2ludHNbdF0ueCxlPWwuZGF0YVBvaW50c1t0XS55LGM8Yi5taW4mJihiLm1pbj1jKSxjPmIubWF4JiYoYi5tYXg9YyksbC5kYXRhUG9pbnRFT3NbdF0uY3VtdWxhdGl2ZVN1bTxmLm1pbiYmKGYubWluPWwuZGF0YVBvaW50RU9zW3RdLmN1bXVsYXRpdmVTdW0pLGwuZGF0YVBvaW50RU9zW3RdLmN1bXVsYXRpdmVTdW0+Zi5tYXgmJihmLm1heD1sLmRhdGFQb2ludEVPc1t0XS5jdW11bGF0aXZlU3VtKSwwPHQmJihhLmF4aXNYLmxvZ2FyaXRobWljPyhwPWMvbC5kYXRhUG9pbnRzW3QtMV0ueCwxPnAmJihwPTEvcCksYi5taW5EaWZmPnAmJjEhPT1wJiYoYi5taW5EaWZmPXApKToocD1jLWwuZGF0YVBvaW50c1t0LTFdLngsMD5wJiZcclxuKHAqPS0xKSxiLm1pbkRpZmY+cCYmMCE9PXAmJihiLm1pbkRpZmY9cCkpLG51bGwhPT1lJiZudWxsIT09bC5kYXRhUG9pbnRzW3QtMV0ueSYmKGEuYXhpc1kubG9nYXJpdGhtaWM/KGU9bC5kYXRhUG9pbnRFT3NbdF0uY3VtdWxhdGl2ZVN1bS9sLmRhdGFQb2ludEVPc1t0LTFdLmN1bXVsYXRpdmVTdW0sMT5lJiYoZT0xL2UpLGYubWluRGlmZj5lJiYxIT09ZSYmKGYubWluRGlmZj1lKSk6KGU9bC5kYXRhUG9pbnRFT3NbdF0uY3VtdWxhdGl2ZVN1bS1sLmRhdGFQb2ludEVPc1t0LTFdLmN1bXVsYXRpdmVTdW0sMD5lJiYoZSo9LTEpLGYubWluRGlmZj5lJiYwIT09ZSYmKGYubWluRGlmZj1lKSkpKSwhKGM8bil8fGspe2lmKCFrJiYoaz0hMCwwPHQpKXt0LT0yO2NvbnRpbnVlfWlmKGM+ZCYmIXIpcj0hMDtlbHNlIGlmKGM+ZCYmciljb250aW51ZTtsLmRhdGFQb2ludHNbdF0ubGFiZWwmJihhLmF4aXNYLmxhYmVsc1tjXT1sLmRhdGFQb2ludHNbdF0ubGFiZWwpO2M8Yi52aWV3UG9ydE1pbiYmXHJcbihiLnZpZXdQb3J0TWluPWMpO2M+Yi52aWV3UG9ydE1heCYmKGIudmlld1BvcnRNYXg9Yyk7MDx0JiYobC5kYXRhUG9pbnRFT3NbdC0xXS5jdW11bGF0aXZlU3VtPGYudmlld1BvcnRNaW4mJihmLnZpZXdQb3J0TWluPWwuZGF0YVBvaW50RU9zW3QtMV0uY3VtdWxhdGl2ZVN1bSksbC5kYXRhUG9pbnRFT3NbdC0xXS5jdW11bGF0aXZlU3VtPmYudmlld1BvcnRNYXgmJihmLnZpZXdQb3J0TWF4PWwuZGF0YVBvaW50RU9zW3QtMV0uY3VtdWxhdGl2ZVN1bSkpO2wuZGF0YVBvaW50RU9zW3RdLmN1bXVsYXRpdmVTdW08Zi52aWV3UG9ydE1pbiYmKGYudmlld1BvcnRNaW49bC5kYXRhUG9pbnRFT3NbdF0uY3VtdWxhdGl2ZVN1bSk7bC5kYXRhUG9pbnRFT3NbdF0uY3VtdWxhdGl2ZVN1bT5mLnZpZXdQb3J0TWF4JiYoZi52aWV3UG9ydE1heD1sLmRhdGFQb2ludEVPc1t0XS5jdW11bGF0aXZlU3VtKX1sLmF4aXNYLnZhbHVlVHlwZT1sLnhWYWx1ZVR5cGU9Zz9cImRhdGVUaW1lXCI6XCJudW1iZXJcIn19O1xyXG5xLnByb3RvdHlwZS5jYWxjdWxhdGVBdXRvQnJlYWtzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGMsYixlKXtpZihlKXJldHVybiBiPU1hdGgucG93KE1hdGgubWluKGIqYS9jLGMvYSksMC4yKSwxPj1iJiYoYj1NYXRoLnBvdygxPmE/MS9hOk1hdGgubWluKGMvYSxhKSwwLjI1KSkse3N0YXJ0VmFsdWU6YSpiLGVuZFZhbHVlOmMvYn07Yj0wLjIqTWF0aC5taW4oYi1jK2EsYy1hKTswPj1iJiYoYj0wLjI1Kk1hdGgubWluKGMtYSxNYXRoLmFicyhhKSkpO3JldHVybntzdGFydFZhbHVlOmErYixlbmRWYWx1ZTpjLWJ9fWZ1bmN0aW9uIGYoYSl7aWYoYS5kYXRhU2VyaWVzSW5kZXhlcyYmISgxPmEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGM9YS5heGlzWC5zY2FsZUJyZWFrcyYmYS5heGlzWC5zY2FsZUJyZWFrcy5hdXRvQ2FsY3VsYXRlJiYxPD1hLmF4aXNYLnNjYWxlQnJlYWtzLm1heE51bWJlck9mQXV0b0JyZWFrcyxiPWEuYXhpc1kuc2NhbGVCcmVha3MmJmEuYXhpc1kuc2NhbGVCcmVha3MuYXV0b0NhbGN1bGF0ZSYmXHJcbjE8PWEuYXhpc1kuc2NhbGVCcmVha3MubWF4TnVtYmVyT2ZBdXRvQnJlYWtzO2lmKGN8fGIpZm9yKHZhciBmPWEuYXhpc1kuZGF0YUluZm8sZz1hLmF4aXNYLmRhdGFJbmZvLGssaD1nLm1pbixuPWcubWF4LGw9Zi5taW4sdD1mLm1heCxnPWcuX2RhdGFSYW5nZXMsZj1mLl9kYXRhUmFuZ2VzLHAscj0wLG09MDttPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO20rKyl7dmFyIHY9ZS5kYXRhW2EuZGF0YVNlcmllc0luZGV4ZXNbbV1dO2lmKCEoND52LmRhdGFQb2ludHMubGVuZ3RoKSlmb3Iocj0wO3I8di5kYXRhUG9pbnRzLmxlbmd0aDtyKyspaWYoYyYmKHA9KG4rMS1oKSpNYXRoLm1heChwYXJzZUZsb2F0KGEuYXhpc1guc2NhbGVCcmVha3MuY29sbGFwc2libGVUaHJlc2hvbGQpfHwxMCwxMCkvMTAwLGs9di5kYXRhUG9pbnRzW3JdLnguZ2V0VGltZT92LmRhdGFQb2ludHNbcl0ueC5nZXRUaW1lKCk6di5kYXRhUG9pbnRzW3JdLngscD1NYXRoLmZsb29yKChrLWgpL3ApLGs8Z1twXS5taW4mJlxyXG4oZ1twXS5taW49ayksaz5nW3BdLm1heCYmKGdbcF0ubWF4PWspKSxiKXt2YXIgcz0odCsxLWwpKk1hdGgubWF4KHBhcnNlRmxvYXQoYS5heGlzWS5zY2FsZUJyZWFrcy5jb2xsYXBzaWJsZVRocmVzaG9sZCl8fDEwLDEwKS8xMDA7aWYoKGs9XCJ3YXRlcmZhbGxcIj09PWEudHlwZT92LmRhdGFQb2ludEVPc1tyXS5jdW11bGF0aXZlU3VtOnYuZGF0YVBvaW50c1tyXS55KSYmay5sZW5ndGgpZm9yKHZhciBxPTA7cTxrLmxlbmd0aDtxKyspcD1NYXRoLmZsb29yKChrW3FdLWwpL3MpLGtbcV08ZltwXS5taW4mJihmW3BdLm1pbj1rW3FdKSxrW3FdPmZbcF0ubWF4JiYoZltwXS5tYXg9a1txXSk7ZWxzZSB5KGspfHwocD1NYXRoLmZsb29yKChrLWwpL3MpLGs8ZltwXS5taW4mJihmW3BdLm1pbj1rKSxrPmZbcF0ubWF4JiYoZltwXS5tYXg9aykpfX19fWZ1bmN0aW9uIGIoYSl7aWYoYS5kYXRhU2VyaWVzSW5kZXhlcyYmISgxPmEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSYmYS5heGlzWC5zY2FsZUJyZWFrcyYmXHJcbmEuYXhpc1guc2NhbGVCcmVha3MuYXV0b0NhbGN1bGF0ZSYmMTw9YS5heGlzWC5zY2FsZUJyZWFrcy5tYXhOdW1iZXJPZkF1dG9CcmVha3MpZm9yKHZhciBjPWEuYXhpc1guZGF0YUluZm8sYj1jLm1pbixmPWMubWF4LGc9Yy5fZGF0YVJhbmdlcyxrLGg9MCxuPTA7bjxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtuKyspe3ZhciBsPWUuZGF0YVthLmRhdGFTZXJpZXNJbmRleGVzW25dXTtpZighKDQ+bC5kYXRhUG9pbnRzLmxlbmd0aCkpZm9yKGg9MDtoPGwuZGF0YVBvaW50cy5sZW5ndGg7aCsrKWs9KGYrMS1iKSpNYXRoLm1heChwYXJzZUZsb2F0KGEuYXhpc1guc2NhbGVCcmVha3MuY29sbGFwc2libGVUaHJlc2hvbGQpfHwxMCwxMCkvMTAwLGM9bC5kYXRhUG9pbnRzW2hdLnguZ2V0VGltZT9sLmRhdGFQb2ludHNbaF0ueC5nZXRUaW1lKCk6bC5kYXRhUG9pbnRzW2hdLngsaz1NYXRoLmZsb29yKChjLWIpL2spLGM8Z1trXS5taW4mJihnW2tdLm1pbj1jKSxjPmdba10ubWF4JiYoZ1trXS5tYXg9XHJcbmMpfX1mb3IodmFyIGMsZT10aGlzLGc9ITEsaD0wO2g8dGhpcy5fYXhlcy5sZW5ndGg7aCsrKWlmKHRoaXMuX2F4ZXNbaF0uc2NhbGVCcmVha3MmJnRoaXMuX2F4ZXNbaF0uc2NhbGVCcmVha3MuYXV0b0NhbGN1bGF0ZSYmMTw9dGhpcy5fYXhlc1toXS5zY2FsZUJyZWFrcy5tYXhOdW1iZXJPZkF1dG9CcmVha3Mpe2c9ITA7dGhpcy5fYXhlc1toXS5kYXRhSW5mby5fZGF0YVJhbmdlcz1bXTtmb3IodmFyIGw9MDtsPDEwMC9NYXRoLm1heChwYXJzZUZsb2F0KHRoaXMuX2F4ZXNbaF0uc2NhbGVCcmVha3MuY29sbGFwc2libGVUaHJlc2hvbGQpfHwxMCwxMCk7bCsrKXRoaXMuX2F4ZXNbaF0uZGF0YUluZm8uX2RhdGFSYW5nZXMucHVzaCh7bWluOkluZmluaXR5LG1heDotSW5maW5pdHl9KX1pZihnKXtmb3IoaD0wO2g8dGhpcy5wbG90SW5mby5wbG90VHlwZXMubGVuZ3RoO2grKylmb3IoZz10aGlzLnBsb3RJbmZvLnBsb3RUeXBlc1toXSxsPTA7bDxnLnBsb3RVbml0cy5sZW5ndGg7bCsrKWM9XHJcbmcucGxvdFVuaXRzW2xdLFwibGluZVwiPT09Yy50eXBlfHxcInN0ZXBMaW5lXCI9PT1jLnR5cGV8fFwic3BsaW5lXCI9PT1jLnR5cGV8fFwiY29sdW1uXCI9PT1jLnR5cGV8fFwiYXJlYVwiPT09Yy50eXBlfHxcInN0ZXBBcmVhXCI9PT1jLnR5cGV8fFwic3BsaW5lQXJlYVwiPT09Yy50eXBlfHxcImJhclwiPT09Yy50eXBlfHxcImJ1YmJsZVwiPT09Yy50eXBlfHxcInNjYXR0ZXJcIj09PWMudHlwZXx8XCJjYW5kbGVzdGlja1wiPT09Yy50eXBlfHxcIm9obGNcIj09PWMudHlwZXx8XCJyYW5nZUNvbHVtblwiPT09Yy50eXBlfHxcInJhbmdlQmFyXCI9PT1jLnR5cGV8fFwicmFuZ2VBcmVhXCI9PT1jLnR5cGV8fFwicmFuZ2VTcGxpbmVBcmVhXCI9PT1jLnR5cGV8fFwid2F0ZXJmYWxsXCI9PT1jLnR5cGV8fFwiZXJyb3JcIj09PWMudHlwZXx8XCJib3hBbmRXaGlza2VyXCI9PT1jLnR5cGU/ZihjKTowPD1jLnR5cGUuaW5kZXhPZihcInN0YWNrZWRcIikmJmIoYyk7Zm9yKGg9MDtoPHRoaXMuX2F4ZXMubGVuZ3RoO2grKylpZih0aGlzLl9heGVzW2hdLmRhdGFJbmZvLl9kYXRhUmFuZ2VzKXt2YXIgdD1cclxudGhpcy5fYXhlc1toXS5kYXRhSW5mby5taW47Yz0odGhpcy5fYXhlc1toXS5kYXRhSW5mby5tYXgrMS10KSpNYXRoLm1heChwYXJzZUZsb2F0KHRoaXMuX2F4ZXNbaF0uc2NhbGVCcmVha3MuY29sbGFwc2libGVUaHJlc2hvbGQpfHwxMCwxMCkvMTAwO3ZhciBrPXRoaXMuX2F4ZXNbaF0uZGF0YUluZm8uX2RhdGFSYW5nZXMscixwLGc9W107aWYodGhpcy5fYXhlc1toXS5kYXRhSW5mby5kYXRhUG9pbnRZUG9zaXRpdmVTdW1zKXt2YXIgbj10aGlzLl9heGVzW2hdLmRhdGFJbmZvLmRhdGFQb2ludFlQb3NpdGl2ZVN1bXM7cj1rO2ZvcihsIGluIG4pbi5oYXNPd25Qcm9wZXJ0eShsKSYmIWlzTmFOKGwpJiYocD1uW2xdLHkocCl8fChpbmRleD1NYXRoLmZsb29yKChwLXQpL2MpLHA8cltpbmRleF0ubWluJiYocltpbmRleF0ubWluPXApLHA+cltpbmRleF0ubWF4JiYocltpbmRleF0ubWF4PXApKSk7ZGVsZXRlIHRoaXMuX2F4ZXNbaF0uZGF0YUluZm8uZGF0YVBvaW50WVBvc2l0aXZlU3Vtc31pZih0aGlzLl9heGVzW2hdLmRhdGFJbmZvLmRhdGFQb2ludFlOZWdhdGl2ZVN1bXMpe249XHJcbnRoaXMuX2F4ZXNbaF0uZGF0YUluZm8uZGF0YVBvaW50WU5lZ2F0aXZlU3VtcztyPWs7Zm9yKGwgaW4gbiluLmhhc093blByb3BlcnR5KGwpJiYhaXNOYU4obCkmJihwPS0xKm5bbF0seShwKXx8KGluZGV4PU1hdGguZmxvb3IoKHAtdCkvYykscDxyW2luZGV4XS5taW4mJihyW2luZGV4XS5taW49cCkscD5yW2luZGV4XS5tYXgmJihyW2luZGV4XS5tYXg9cCkpKTtkZWxldGUgdGhpcy5fYXhlc1toXS5kYXRhSW5mby5kYXRhUG9pbnRZTmVnYXRpdmVTdW1zfWZvcihsPTA7bDxrLmxlbmd0aC0xO2wrKylpZihyPWtbbF0ubWF4LGlzRmluaXRlKHIpKWZvcig7bDxrLmxlbmd0aC0xOylpZih0PWtbbCsxXS5taW4saXNGaW5pdGUodCkpe3A9dC1yO3A+YyYmZy5wdXNoKHtkaWZmOnAsc3RhcnQ6cixlbmQ6dH0pO2JyZWFrfWVsc2UgbCsrO2lmKHRoaXMuX2F4ZXNbaF0uc2NhbGVCcmVha3MuY3VzdG9tQnJlYWtzKWZvcihsPTA7bDx0aGlzLl9heGVzW2hdLnNjYWxlQnJlYWtzLmN1c3RvbUJyZWFrcy5sZW5ndGg7bCsrKWZvcihjPVxyXG4wO2M8Zy5sZW5ndGg7YysrKWlmKHRoaXMuX2F4ZXNbaF0uc2NhbGVCcmVha3MuY3VzdG9tQnJlYWtzW2xdLnN0YXJ0VmFsdWU8PWdbY10uc3RhcnQmJmdbY10uc3RhcnQ8PXRoaXMuX2F4ZXNbaF0uc2NhbGVCcmVha3MuY3VzdG9tQnJlYWtzW2xdLmVuZFZhbHVlfHx0aGlzLl9heGVzW2hdLnNjYWxlQnJlYWtzLmN1c3RvbUJyZWFrc1tsXS5zdGFydFZhbHVlPD1nW2NdLnN0YXJ0JiZnW2NdLnN0YXJ0PD10aGlzLl9heGVzW2hdLnNjYWxlQnJlYWtzLmN1c3RvbUJyZWFrc1tsXS5lbmRWYWx1ZXx8Z1tjXS5zdGFydDw9dGhpcy5fYXhlc1toXS5zY2FsZUJyZWFrcy5jdXN0b21CcmVha3NbbF0uc3RhcnRWYWx1ZSYmdGhpcy5fYXhlc1toXS5zY2FsZUJyZWFrcy5jdXN0b21CcmVha3NbbF0uc3RhcnRWYWx1ZTw9Z1tjXS5lbmR8fGdbY10uc3RhcnQ8PXRoaXMuX2F4ZXNbaF0uc2NhbGVCcmVha3MuY3VzdG9tQnJlYWtzW2xdLmVuZFZhbHVlJiZ0aGlzLl9heGVzW2hdLnNjYWxlQnJlYWtzLmN1c3RvbUJyZWFrc1tsXS5lbmRWYWx1ZTw9XHJcbmdbY10uZW5kKWcuc3BsaWNlKGMsMSksYy0tO2cuc29ydChmdW5jdGlvbihhLGMpe3JldHVybiBjLmRpZmYtYS5kaWZmfSk7Zm9yKGw9MDtsPE1hdGgubWluKGcubGVuZ3RoLHRoaXMuX2F4ZXNbaF0uc2NhbGVCcmVha3MubWF4TnVtYmVyT2ZBdXRvQnJlYWtzKTtsKyspYz1hKGdbbF0uc3RhcnQsZ1tsXS5lbmQsdGhpcy5fYXhlc1toXS5sb2dhcml0aG1pYz90aGlzLl9heGVzW2hdLmRhdGFJbmZvLm1heC90aGlzLl9heGVzW2hdLmRhdGFJbmZvLm1pbjp0aGlzLl9heGVzW2hdLmRhdGFJbmZvLm1heC10aGlzLl9heGVzW2hdLmRhdGFJbmZvLm1pbix0aGlzLl9heGVzW2hdLmxvZ2FyaXRobWljKSx0aGlzLl9heGVzW2hdLnNjYWxlQnJlYWtzLmF1dG9CcmVha3MucHVzaChuZXcgYWEodGhpcyxcImF1dG9CcmVha3NcIixjLGwsKyt0aGlzLl9ldmVudE1hbmFnZXIubGFzdE9iamVjdElkLHRoaXMuX2F4ZXNbaF0uc2NhbGVCcmVha3MpKSx0aGlzLl9heGVzW2hdLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLnB1c2godGhpcy5fYXhlc1toXS5zY2FsZUJyZWFrcy5hdXRvQnJlYWtzW3RoaXMuX2F4ZXNbaF0uc2NhbGVCcmVha3MuYXV0b0JyZWFrcy5sZW5ndGgtXHJcbjFdKTt0aGlzLl9heGVzW2hdLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLnNvcnQoZnVuY3Rpb24oYSxjKXtyZXR1cm4gYS5zdGFydFZhbHVlLWMuc3RhcnRWYWx1ZX0pfX19O3EucHJvdG90eXBlLmdldERhdGFQb2ludEF0WFk9ZnVuY3Rpb24oYSxmLGIpe2I9Ynx8ITE7Zm9yKHZhciBjPVtdLGU9dGhpcy5fZGF0YUluUmVuZGVyZWRPcmRlci5sZW5ndGgtMTswPD1lO2UtLSl7dmFyIGc9bnVsbDsoZz10aGlzLl9kYXRhSW5SZW5kZXJlZE9yZGVyW2VdLmdldERhdGFQb2ludEF0WFkoYSxmLGIpKSYmYy5wdXNoKGcpfWE9bnVsbDtmPSExO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspaWYoXCJsaW5lXCI9PT1jW2JdLmRhdGFTZXJpZXMudHlwZXx8XCJzdGVwTGluZVwiPT09Y1tiXS5kYXRhU2VyaWVzLnR5cGV8fFwiYXJlYVwiPT09Y1tiXS5kYXRhU2VyaWVzLnR5cGV8fFwic3RlcEFyZWFcIj09PWNbYl0uZGF0YVNlcmllcy50eXBlKWlmKGU9bmEoXCJtYXJrZXJTaXplXCIsY1tiXS5kYXRhUG9pbnQsY1tiXS5kYXRhU2VyaWVzKXx8XHJcbjgsY1tiXS5kaXN0YW5jZTw9ZS8yKXtmPSEwO2JyZWFrfWZvcihiPTA7YjxjLmxlbmd0aDtiKyspZiYmXCJsaW5lXCIhPT1jW2JdLmRhdGFTZXJpZXMudHlwZSYmXCJzdGVwTGluZVwiIT09Y1tiXS5kYXRhU2VyaWVzLnR5cGUmJlwiYXJlYVwiIT09Y1tiXS5kYXRhU2VyaWVzLnR5cGUmJlwic3RlcEFyZWFcIiE9PWNbYl0uZGF0YVNlcmllcy50eXBlfHwoYT9jW2JdLmRpc3RhbmNlPD1hLmRpc3RhbmNlJiYoYT1jW2JdKTphPWNbYl0pO3JldHVybiBhfTtxLnByb3RvdHlwZS5nZXRPYmplY3RBdFhZPWZ1bmN0aW9uKGEsZixiKXt2YXIgYz1udWxsO2lmKGI9dGhpcy5nZXREYXRhUG9pbnRBdFhZKGEsZixifHwhMSkpYz1iLmRhdGFTZXJpZXMuZGF0YVBvaW50SWRzW2IuZGF0YVBvaW50SW5kZXhdO2Vsc2UgaWYodiljPVdhKGEsZix0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgpO2Vsc2UgZm9yKGI9MDtiPHRoaXMubGVnZW5kLml0ZW1zLmxlbmd0aDtiKyspe3ZhciBlPXRoaXMubGVnZW5kLml0ZW1zW2JdO1xyXG5hPj1lLngxJiYoYTw9ZS54MiYmZj49ZS55MSYmZjw9ZS55MikmJihjPWUuaWQpfXJldHVybiBjfTtxLnByb3RvdHlwZS5nZXRBdXRvRm9udFNpemU9ZnVuY3Rpb24oYSxmLGIpe2Y9TWF0aC5taW4odGhpcy53aWR0aCx0aGlzLmhlaWdodCk7cmV0dXJuIE1hdGgubWF4KFwidGhlbWU0XCI9PT10aGlzLnRoZW1lPzA6MzAwPD1mPzEyOjEwLE1hdGgucm91bmQoZiooYS80MDApKSl9O3EucHJvdG90eXBlLnJlc2V0T3ZlcmxheWVkQ2FudmFzPWZ1bmN0aW9uKCl7dGhpcy5vdmVybGFpZENhbnZhc0N0eC5jbGVhclJlY3QoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpfTtxLnByb3RvdHlwZS5jbGVhckNhbnZhcz1mdW5jdGlvbigpe3RoaXMuY3R4LmNsZWFyUmVjdCgwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCk7dGhpcy5iYWNrZ3JvdW5kQ29sb3ImJih0aGlzLmN0eC5maWxsU3R5bGU9dGhpcy5iYWNrZ3JvdW5kQ29sb3IsdGhpcy5jdHguZmlsbFJlY3QoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpKX07XHJcbnEucHJvdG90eXBlLmF0dGFjaEV2ZW50PWZ1bmN0aW9uKGEpe3RoaXMuX2V2ZW50cy5wdXNoKGEpfTtxLnByb3RvdHlwZS5fdG91Y2hFdmVudEhhbmRsZXI9ZnVuY3Rpb24oYSl7aWYoYS5jaGFuZ2VkVG91Y2hlcyYmdGhpcy5pbnRlcmFjdGl2aXR5RW5hYmxlZCl7dmFyIGY9W10sYj1hLmNoYW5nZWRUb3VjaGVzLGM9Yj9iWzBdOmEsZT1udWxsO3N3aXRjaChhLnR5cGUpe2Nhc2UgXCJ0b3VjaHN0YXJ0XCI6Y2FzZSBcIk1TUG9pbnRlckRvd25cIjpmPVtcIm1vdXNlbW92ZVwiLFwibW91c2Vkb3duXCJdO3RoaXMuX2xhc3RUb3VjaERhdGE9T2EoYyk7dGhpcy5fbGFzdFRvdWNoRGF0YS50aW1lPW5ldyBEYXRlO2JyZWFrO2Nhc2UgXCJ0b3VjaG1vdmVcIjpjYXNlIFwiTVNQb2ludGVyTW92ZVwiOmY9W1wibW91c2Vtb3ZlXCJdO2JyZWFrO2Nhc2UgXCJ0b3VjaGVuZFwiOmNhc2UgXCJNU1BvaW50ZXJVcFwiOnZhciBnPXRoaXMuX2xhc3RUb3VjaERhdGEmJnRoaXMuX2xhc3RUb3VjaERhdGEudGltZT9uZXcgRGF0ZS10aGlzLl9sYXN0VG91Y2hEYXRhLnRpbWU6XHJcbjAsZj1cInRvdWNoc3RhcnRcIj09PXRoaXMuX2xhc3RUb3VjaEV2ZW50VHlwZXx8XCJNU1BvaW50ZXJEb3duXCI9PT10aGlzLl9sYXN0VG91Y2hFdmVudFR5cGV8fDMwMD5nP1tcIm1vdXNldXBcIixcImNsaWNrXCJdOltcIm1vdXNldXBcIl07YnJlYWs7ZGVmYXVsdDpyZXR1cm59aWYoIShiJiYxPGIubGVuZ3RoKSl7ZT1PYShjKTtlLnRpbWU9bmV3IERhdGU7dHJ5e3ZhciBoPWUueS10aGlzLl9sYXN0VG91Y2hEYXRhLnksZz1lLnRpbWUtdGhpcy5fbGFzdFRvdWNoRGF0YS50aW1lO2lmKDE1PE1hdGguYWJzKGgpJiYodGhpcy5fbGFzdFRvdWNoRGF0YS5zY3JvbGx8fDMwMD5nKSl7dGhpcy5fbGFzdFRvdWNoRGF0YS5zY3JvbGw9ITA7dmFyIGw9d2luZG93LnBhcmVudHx8d2luZG93O2wmJmwuc2Nyb2xsQnkmJmwuc2Nyb2xsQnkoMCwtaCl9fWNhdGNoKHQpe310aGlzLl9sYXN0VG91Y2hFdmVudFR5cGU9YS50eXBlO2lmKHRoaXMuX2xhc3RUb3VjaERhdGEuc2Nyb2xsJiZ0aGlzLnpvb21FbmFibGVkKXRoaXMuaXNEcmFnJiZcclxudGhpcy5yZXNldE92ZXJsYXllZENhbnZhcygpLHRoaXMuaXNEcmFnPSExO2Vsc2UgZm9yKGI9MDtiPGYubGVuZ3RoO2IrKyllPWZbYl0sZz1kb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIiksZy5pbml0TW91c2VFdmVudChlLCEwLCEwLHdpbmRvdywxLGMuc2NyZWVuWCxjLnNjcmVlblksYy5jbGllbnRYLGMuY2xpZW50WSwhMSwhMSwhMSwhMSwwLG51bGwpLGMudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZyksYS5wcmV2ZW50TWFuaXB1bGF0aW9uJiZhLnByZXZlbnRNYW5pcHVsYXRpb24oKSxhLnByZXZlbnREZWZhdWx0JiZhLnByZXZlbnREZWZhdWx0KCl9fX07cS5wcm90b3R5cGUuX2Rpc3BhdGNoUmFuZ2VFdmVudD1mdW5jdGlvbihhLGYpe3ZhciBiPXtjaGFydDp0aGlzfTtiLnR5cGU9YTtiLnRyaWdnZXI9Zjt2YXIgYz1bXTt0aGlzLmF4aXNYJiYwPHRoaXMuYXhpc1gubGVuZ3RoJiZjLnB1c2goXCJheGlzWFwiKTt0aGlzLmF4aXNYMiYmMDx0aGlzLmF4aXNYMi5sZW5ndGgmJlxyXG5jLnB1c2goXCJheGlzWDJcIik7dGhpcy5heGlzWSYmMDx0aGlzLmF4aXNZLmxlbmd0aCYmYy5wdXNoKFwiYXhpc1lcIik7dGhpcy5heGlzWTImJjA8dGhpcy5heGlzWTIubGVuZ3RoJiZjLnB1c2goXCJheGlzWTJcIik7Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspaWYoeShiW2NbZV1dKSYmKGJbY1tlXV09W10pLFwiYXhpc1lcIj09PWNbZV0pZm9yKHZhciBnPTA7Zzx0aGlzLmF4aXNZLmxlbmd0aDtnKyspYltjW2VdXS5wdXNoKHt2aWV3cG9ydE1pbmltdW06dGhpc1tjW2VdXVtnXS5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bSx2aWV3cG9ydE1heGltdW06dGhpc1tjW2VdXVtnXS5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bX0pO2Vsc2UgaWYoXCJheGlzWTJcIj09PWNbZV0pZm9yKGc9MDtnPHRoaXMuYXhpc1kyLmxlbmd0aDtnKyspYltjW2VdXS5wdXNoKHt2aWV3cG9ydE1pbmltdW06dGhpc1tjW2VdXVtnXS5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bSxcclxudmlld3BvcnRNYXhpbXVtOnRoaXNbY1tlXV1bZ10uc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW19KTtlbHNlIGlmKFwiYXhpc1hcIj09PWNbZV0pZm9yKGc9MDtnPHRoaXMuYXhpc1gubGVuZ3RoO2crKyliW2NbZV1dLnB1c2goe3ZpZXdwb3J0TWluaW11bTp0aGlzW2NbZV1dW2ddLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtLHZpZXdwb3J0TWF4aW11bTp0aGlzW2NbZV1dW2ddLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtfSk7ZWxzZSBpZihcImF4aXNYMlwiPT09Y1tlXSlmb3IoZz0wO2c8dGhpcy5heGlzWDIubGVuZ3RoO2crKyliW2NbZV1dLnB1c2goe3ZpZXdwb3J0TWluaW11bTp0aGlzW2NbZV1dW2ddLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtLHZpZXdwb3J0TWF4aW11bTp0aGlzW2NbZV1dW2ddLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtfSk7dGhpcy5kaXNwYXRjaEV2ZW50KGEsYix0aGlzKX07XHJcbnEucHJvdG90eXBlLl9tb3VzZUV2ZW50SGFuZGxlcj1mdW5jdGlvbihhKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEudGFyZ2V0JiZhLnNyY0VsZW1lbnQmJihhLnRhcmdldD1hLnNyY0VsZW1lbnQpO3ZhciBmPU9hKGEpLGI9YS50eXBlLGMsZTthLndoaWNoP2U9Mz09YS53aGljaDphLmJ1dHRvbiYmKGU9Mj09YS5idXR0b24pO3EuY2FwdHVyZWRFdmVudFBhcmFtJiYoYz1xLmNhcHR1cmVkRXZlbnRQYXJhbSxcIm1vdXNldXBcIj09PWImJihxLmNhcHR1cmVkRXZlbnRQYXJhbT1udWxsLGMuY2hhcnQub3ZlcmxhaWRDYW52YXMucmVsZWFzZUNhcHR1cmU/Yy5jaGFydC5vdmVybGFpZENhbnZhcy5yZWxlYXNlQ2FwdHVyZSgpOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLGMuY2hhcnQuX21vdXNlRXZlbnRIYW5kbGVyLCExKSksYy5oYXNPd25Qcm9wZXJ0eShiKSYmKFwibW91c2V1cFwiIT09Ynx8Yy5jaGFydC5vdmVybGFpZENhbnZhcy5yZWxlYXNlQ2FwdHVyZT9cclxuYS50YXJnZXQhPT1jLmNoYXJ0Lm92ZXJsYWlkQ2FudmFzJiZ2fHxjW2JdLmNhbGwoYy5jb250ZXh0LGYueCxmLnkpOmEudGFyZ2V0IT09Yy5jaGFydC5vdmVybGFpZENhbnZhcyYmKGMuY2hhcnQuaXNEcmFnPSExKSkpO2lmKHRoaXMuaW50ZXJhY3Rpdml0eUVuYWJsZWQpaWYodGhpcy5faWdub3JlTmV4dEV2ZW50KXRoaXMuX2lnbm9yZU5leHRFdmVudD0hMTtlbHNlIGlmKGEucHJldmVudE1hbmlwdWxhdGlvbiYmYS5wcmV2ZW50TWFuaXB1bGF0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCYmYS5wcmV2ZW50RGVmYXVsdCgpLCFlKXtpZighcS5jYXB0dXJlZEV2ZW50UGFyYW0mJnRoaXMuX2V2ZW50cyl7Zm9yKHZhciBnPTA7Zzx0aGlzLl9ldmVudHMubGVuZ3RoO2crKylpZih0aGlzLl9ldmVudHNbZ10uaGFzT3duUHJvcGVydHkoYikpaWYoYz10aGlzLl9ldmVudHNbZ10sZT1jLmJvdW5kcyxmLng+PWUueDEmJmYueDw9ZS54MiYmZi55Pj1lLnkxJiZmLnk8PWUueTIpe2NbYl0uY2FsbChjLmNvbnRleHQsXHJcbmYueCxmLnkpO1wibW91c2Vkb3duXCI9PT1iJiYhMD09PWMuY2FwdHVyZT8ocS5jYXB0dXJlZEV2ZW50UGFyYW09Yyx0aGlzLm92ZXJsYWlkQ2FudmFzLnNldENhcHR1cmU/dGhpcy5vdmVybGFpZENhbnZhcy5zZXRDYXB0dXJlKCk6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5fbW91c2VFdmVudEhhbmRsZXIsITEpKTpcIm1vdXNldXBcIj09PWImJihjLmNoYXJ0Lm92ZXJsYWlkQ2FudmFzLnJlbGVhc2VDYXB0dXJlP2MuY2hhcnQub3ZlcmxhaWRDYW52YXMucmVsZWFzZUNhcHR1cmUoKTpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0aGlzLl9tb3VzZUV2ZW50SGFuZGxlciwhMSkpO2JyZWFrfWVsc2UgYz1udWxsO2EudGFyZ2V0LnN0eWxlLmN1cnNvcj1jJiZjLmN1cnNvcj9jLmN1cnNvcjp0aGlzLl9kZWZhdWx0Q3Vyc29yfWI9dGhpcy5wbG90QXJlYTtpZihmLng8Yi54MXx8Zi54PlxyXG5iLngyfHxmLnk8Yi55MXx8Zi55PmIueTIpdGhpcy50b29sVGlwJiZ0aGlzLnRvb2xUaXAuZW5hYmxlZD90aGlzLnRvb2xUaXAuaGlkZSgpOnRoaXMucmVzZXRPdmVybGF5ZWRDYW52YXMoKTt0aGlzLmlzRHJhZyYmdGhpcy56b29tRW5hYmxlZHx8IXRoaXMuX2V2ZW50TWFuYWdlcnx8dGhpcy5fZXZlbnRNYW5hZ2VyLm1vdXNlRXZlbnRIYW5kbGVyKGEpfX07cS5wcm90b3R5cGUuX3Bsb3RBcmVhTW91c2VEb3duPWZ1bmN0aW9uKGEsZil7dGhpcy5pc0RyYWc9ITA7dGhpcy5kcmFnU3RhcnRQb2ludD17eDphLHk6Zn19O3EucHJvdG90eXBlLl9wbG90QXJlYU1vdXNlVXA9ZnVuY3Rpb24oYSxmKXtpZigoXCJub3JtYWxcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudHx8XCJ4eVN3YXBwZWRcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCkmJnRoaXMuaXNEcmFnKXt2YXIgYj1mLXRoaXMuZHJhZ1N0YXJ0UG9pbnQueSxjPWEtdGhpcy5kcmFnU3RhcnRQb2ludC54LGU9MDw9dGhpcy56b29tVHlwZS5pbmRleE9mKFwieFwiKSxcclxuZz0wPD10aGlzLnpvb21UeXBlLmluZGV4T2YoXCJ5XCIpLGg9ITE7dGhpcy5yZXNldE92ZXJsYXllZENhbnZhcygpO2lmKFwieHlTd2FwcGVkXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQpdmFyIGw9ZyxnPWUsZT1sO2lmKHRoaXMucGFuRW5hYmxlZHx8dGhpcy56b29tRW5hYmxlZCl7aWYodGhpcy5wYW5FbmFibGVkKWZvcihlPWc9MDtlPHRoaXMuX2F4ZXMubGVuZ3RoO2UrKyliPXRoaXMuX2F4ZXNbZV0sYi5sb2dhcml0aG1pYz9iLnZpZXdwb3J0TWluaW11bTxiLm1pbmltdW0/KGc9Yi5taW5pbXVtL2Iudmlld3BvcnRNaW5pbXVtLGIuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW09Yi52aWV3cG9ydE1pbmltdW0qZyxiLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtPWIudmlld3BvcnRNYXhpbXVtKmcsaD0hMCk6Yi52aWV3cG9ydE1heGltdW0+Yi5tYXhpbXVtJiYoZz1iLnZpZXdwb3J0TWF4aW11bS9iLm1heGltdW0sYi5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bT1cclxuYi52aWV3cG9ydE1pbmltdW0vZyxiLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtPWIudmlld3BvcnRNYXhpbXVtL2csaD0hMCk6Yi52aWV3cG9ydE1pbmltdW08Yi5taW5pbXVtPyhnPWIubWluaW11bS1iLnZpZXdwb3J0TWluaW11bSxiLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtPWIudmlld3BvcnRNaW5pbXVtK2csYi5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bT1iLnZpZXdwb3J0TWF4aW11bStnLGg9ITApOmIudmlld3BvcnRNYXhpbXVtPmIubWF4aW11bSYmKGc9Yi52aWV3cG9ydE1heGltdW0tYi5tYXhpbXVtLGIuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW09Yi52aWV3cG9ydE1pbmltdW0tZyxiLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtPWIudmlld3BvcnRNYXhpbXVtLWcsaD0hMCk7ZWxzZSBpZigoIWV8fDI8TWF0aC5hYnMoYykpJiYoIWd8fDI8TWF0aC5hYnMoYikpJiZ0aGlzLnpvb21FbmFibGVkKXtpZighdGhpcy5kcmFnU3RhcnRQb2ludClyZXR1cm47XHJcbmI9ZT90aGlzLmRyYWdTdGFydFBvaW50Lng6dGhpcy5wbG90QXJlYS54MTtjPWc/dGhpcy5kcmFnU3RhcnRQb2ludC55OnRoaXMucGxvdEFyZWEueTE7ZT1lP2E6dGhpcy5wbG90QXJlYS54MjtnPWc/Zjp0aGlzLnBsb3RBcmVhLnkyOzI8TWF0aC5hYnMoYi1lKSYmMjxNYXRoLmFicyhjLWcpJiZ0aGlzLl96b29tUGFuVG9TZWxlY3RlZFJlZ2lvbihiLGMsZSxnKSYmKGg9ITApfWgmJih0aGlzLl9pZ25vcmVOZXh0RXZlbnQ9ITAsdGhpcy5fZGlzcGF0Y2hSYW5nZUV2ZW50KFwicmFuZ2VDaGFuZ2luZ1wiLFwiem9vbVwiKSx0aGlzLnJlbmRlcigpLHRoaXMuX2Rpc3BhdGNoUmFuZ2VFdmVudChcInJhbmdlQ2hhbmdlZFwiLFwiem9vbVwiKSxoJiYodGhpcy56b29tRW5hYmxlZCYmXCJub25lXCI9PT10aGlzLl96b29tQnV0dG9uLnN0eWxlLmRpc3BsYXkpJiYoTWEodGhpcy5fem9vbUJ1dHRvbix0aGlzLl9yZXNldEJ1dHRvbiksdmEodGhpcyx0aGlzLl96b29tQnV0dG9uLFwicGFuXCIpLHZhKHRoaXMsdGhpcy5fcmVzZXRCdXR0b24sXHJcblwicmVzZXRcIikpKX19dGhpcy5pc0RyYWc9ITE7aWYoXCJub25lXCIhPT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQpe3RoaXMucmVzZXRPdmVybGF5ZWRDYW52YXMoKTtpZih0aGlzLmF4aXNYJiYwPHRoaXMuYXhpc1gubGVuZ3RoKWZvcihoPTA7aDx0aGlzLmF4aXNYLmxlbmd0aDtoKyspdGhpcy5heGlzWFtoXS5jcm9zc2hhaXImJnRoaXMuYXhpc1hbaF0uY3Jvc3NoYWlyLmVuYWJsZWQmJnRoaXMuYXhpc1hbaF0ucmVuZGVyQ3Jvc3NoYWlyKGEsZik7aWYodGhpcy5heGlzWDImJjA8dGhpcy5heGlzWDIubGVuZ3RoKWZvcihoPTA7aDx0aGlzLmF4aXNYMi5sZW5ndGg7aCsrKXRoaXMuYXhpc1gyW2hdLmNyb3NzaGFpciYmdGhpcy5heGlzWDJbaF0uY3Jvc3NoYWlyLmVuYWJsZWQmJnRoaXMuYXhpc1gyW2hdLnJlbmRlckNyb3NzaGFpcihhLGYpO2lmKHRoaXMuYXhpc1kmJjA8dGhpcy5heGlzWS5sZW5ndGgpZm9yKGg9MDtoPHRoaXMuYXhpc1kubGVuZ3RoO2grKyl0aGlzLmF4aXNZW2hdLmNyb3NzaGFpciYmXHJcbnRoaXMuYXhpc1lbaF0uY3Jvc3NoYWlyLmVuYWJsZWQmJnRoaXMuYXhpc1lbaF0ucmVuZGVyQ3Jvc3NoYWlyKGEsZik7aWYodGhpcy5heGlzWTImJjA8dGhpcy5heGlzWTIubGVuZ3RoKWZvcihoPTA7aDx0aGlzLmF4aXNZMi5sZW5ndGg7aCsrKXRoaXMuYXhpc1kyW2hdLmNyb3NzaGFpciYmdGhpcy5heGlzWTJbaF0uY3Jvc3NoYWlyLmVuYWJsZWQmJnRoaXMuYXhpc1kyW2hdLnJlbmRlckNyb3NzaGFpcihhLGYpfX07cS5wcm90b3R5cGUuX3Bsb3RBcmVhTW91c2VNb3ZlPWZ1bmN0aW9uKGEsZil7aWYodGhpcy5pc0RyYWcmJlwibm9uZVwiIT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50KXt2YXIgYj0wLGM9MCxlPWI9bnVsbCxlPTA8PXRoaXMuem9vbVR5cGUuaW5kZXhPZihcInhcIiksZz0wPD10aGlzLnpvb21UeXBlLmluZGV4T2YoXCJ5XCIpLGg9dGhpcztcInh5U3dhcHBlZFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50JiYoYj1nLGc9ZSxlPWIpO2I9dGhpcy5kcmFnU3RhcnRQb2ludC54LVxyXG5hO2M9dGhpcy5kcmFnU3RhcnRQb2ludC55LWY7MjxNYXRoLmFicyhiKSYmOD5NYXRoLmFicyhiKSYmKHRoaXMucGFuRW5hYmxlZHx8dGhpcy56b29tRW5hYmxlZCk/dGhpcy50b29sVGlwLmhpZGUoKTp0aGlzLnBhbkVuYWJsZWR8fHRoaXMuem9vbUVuYWJsZWR8fHRoaXMudG9vbFRpcC5tb3VzZU1vdmVIYW5kbGVyKGEsZik7aWYoKCFlfHwyPE1hdGguYWJzKGIpfHwhZ3x8MjxNYXRoLmFicyhjKSkmJih0aGlzLnBhbkVuYWJsZWR8fHRoaXMuem9vbUVuYWJsZWQpKWlmKHRoaXMucGFuRW5hYmxlZCllPXt4MTplP3RoaXMucGxvdEFyZWEueDErYjp0aGlzLnBsb3RBcmVhLngxLHkxOmc/dGhpcy5wbG90QXJlYS55MStjOnRoaXMucGxvdEFyZWEueTEseDI6ZT90aGlzLnBsb3RBcmVhLngyK2I6dGhpcy5wbG90QXJlYS54Mix5MjpnP3RoaXMucGxvdEFyZWEueTIrYzp0aGlzLnBsb3RBcmVhLnkyfSxjbGVhclRpbWVvdXQoaC5fcGFuVGltZXJJZCksaC5fcGFuVGltZXJJZD1zZXRUaW1lb3V0KGZ1bmN0aW9uKGMsXHJcbmIsZSxkKXtyZXR1cm4gZnVuY3Rpb24oKXtoLl96b29tUGFuVG9TZWxlY3RlZFJlZ2lvbihjLGIsZSxkLCEwKSYmKGguX2Rpc3BhdGNoUmFuZ2VFdmVudChcInJhbmdlQ2hhbmdpbmdcIixcInBhblwiKSxoLnJlbmRlcigpLGguX2Rpc3BhdGNoUmFuZ2VFdmVudChcInJhbmdlQ2hhbmdlZFwiLFwicGFuXCIpLGguZHJhZ1N0YXJ0UG9pbnQueD1hLGguZHJhZ1N0YXJ0UG9pbnQueT1mKX19KGUueDEsZS55MSxlLngyLGUueTIpLDApO2Vsc2UgaWYodGhpcy56b29tRW5hYmxlZCl7dGhpcy5yZXNldE92ZXJsYXllZENhbnZhcygpO2I9dGhpcy5vdmVybGFpZENhbnZhc0N0eC5nbG9iYWxBbHBoYTt0aGlzLm92ZXJsYWlkQ2FudmFzQ3R4LmZpbGxTdHlsZT1cIiNBODk4OTZcIjt2YXIgYz1lP3RoaXMuZHJhZ1N0YXJ0UG9pbnQueDp0aGlzLnBsb3RBcmVhLngxLGw9Zz90aGlzLmRyYWdTdGFydFBvaW50Lnk6dGhpcy5wbG90QXJlYS55MSx0PWU/YS10aGlzLmRyYWdTdGFydFBvaW50Lng6dGhpcy5wbG90QXJlYS54Mi1cclxudGhpcy5wbG90QXJlYS54MSxrPWc/Zi10aGlzLmRyYWdTdGFydFBvaW50Lnk6dGhpcy5wbG90QXJlYS55Mi10aGlzLnBsb3RBcmVhLnkxO3RoaXMudmFsaWRhdGVSZWdpb24oYyxsLGU/YTp0aGlzLnBsb3RBcmVhLngyLXRoaXMucGxvdEFyZWEueDEsZz9mOnRoaXMucGxvdEFyZWEueTItdGhpcy5wbG90QXJlYS55MSxcInh5XCIhPT10aGlzLnpvb21UeXBlKS5pc1ZhbGlkJiYodGhpcy5yZXNldE92ZXJsYXllZENhbnZhcygpLHRoaXMub3ZlcmxhaWRDYW52YXNDdHguZmlsbFN0eWxlPVwiIzk5QjJCNVwiKTt0aGlzLm92ZXJsYWlkQ2FudmFzQ3R4Lmdsb2JhbEFscGhhPTAuNzt0aGlzLm92ZXJsYWlkQ2FudmFzQ3R4LmZpbGxSZWN0KGMsbCx0LGspO3RoaXMub3ZlcmxhaWRDYW52YXNDdHguZ2xvYmFsQWxwaGE9Yn19ZWxzZSBpZih0aGlzLnRvb2xUaXAubW91c2VNb3ZlSGFuZGxlcihhLGYpLFwibm9uZVwiIT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50KXtpZih0aGlzLmF4aXNYJiYwPHRoaXMuYXhpc1gubGVuZ3RoKWZvcihlPVxyXG4wO2U8dGhpcy5heGlzWC5sZW5ndGg7ZSsrKXRoaXMuYXhpc1hbZV0uY3Jvc3NoYWlyJiZ0aGlzLmF4aXNYW2VdLmNyb3NzaGFpci5lbmFibGVkJiZ0aGlzLmF4aXNYW2VdLnJlbmRlckNyb3NzaGFpcihhLGYpO2lmKHRoaXMuYXhpc1gyJiYwPHRoaXMuYXhpc1gyLmxlbmd0aClmb3IoZT0wO2U8dGhpcy5heGlzWDIubGVuZ3RoO2UrKyl0aGlzLmF4aXNYMltlXS5jcm9zc2hhaXImJnRoaXMuYXhpc1gyW2VdLmNyb3NzaGFpci5lbmFibGVkJiZ0aGlzLmF4aXNYMltlXS5yZW5kZXJDcm9zc2hhaXIoYSxmKTtpZih0aGlzLmF4aXNZJiYwPHRoaXMuYXhpc1kubGVuZ3RoKWZvcihlPTA7ZTx0aGlzLmF4aXNZLmxlbmd0aDtlKyspdGhpcy5heGlzWVtlXS5jcm9zc2hhaXImJnRoaXMuYXhpc1lbZV0uY3Jvc3NoYWlyLmVuYWJsZWQmJnRoaXMuYXhpc1lbZV0ucmVuZGVyQ3Jvc3NoYWlyKGEsZik7aWYodGhpcy5heGlzWTImJjA8dGhpcy5heGlzWTIubGVuZ3RoKWZvcihlPTA7ZTx0aGlzLmF4aXNZMi5sZW5ndGg7ZSsrKXRoaXMuYXhpc1kyW2VdLmNyb3NzaGFpciYmXHJcbnRoaXMuYXhpc1kyW2VdLmNyb3NzaGFpci5lbmFibGVkJiZ0aGlzLmF4aXNZMltlXS5yZW5kZXJDcm9zc2hhaXIoYSxmKX19O3EucHJvdG90eXBlLl96b29tUGFuVG9TZWxlY3RlZFJlZ2lvbj1mdW5jdGlvbihhLGYsYixjLGUpe2E9dGhpcy52YWxpZGF0ZVJlZ2lvbihhLGYsYixjLGUpO2Y9YS5heGVzV2l0aFZhbGlkUmFuZ2U7Yj1hLmF4ZXNSYW5nZXM7aWYoYS5pc1ZhbGlkKWZvcihjPTA7YzxmLmxlbmd0aDtjKyspZT1iW2NdLGZbY10uc2V0Vmlld1BvcnRSYW5nZShlLnZhbDEsZS52YWwyKTtyZXR1cm4gYS5pc1ZhbGlkfTtxLnByb3RvdHlwZS52YWxpZGF0ZVJlZ2lvbj1mdW5jdGlvbihhLGYsYixjLGUpe2U9ZXx8ITE7Zm9yKHZhciBnPTA8PXRoaXMuem9vbVR5cGUuaW5kZXhPZihcInhcIiksaD0wPD10aGlzLnpvb21UeXBlLmluZGV4T2YoXCJ5XCIpLGw9ITEsdD1bXSxrPVtdLHI9W10scD0wO3A8dGhpcy5fYXhlcy5sZW5ndGg7cCsrKShcImF4aXNYXCI9PT10aGlzLl9heGVzW3BdLnR5cGUmJlxyXG5nfHxcImF4aXNZXCI9PT10aGlzLl9heGVzW3BdLnR5cGUmJmgpJiZrLnB1c2godGhpcy5fYXhlc1twXSk7Zm9yKGg9MDtoPGsubGVuZ3RoO2grKyl7dmFyIHA9a1toXSxnPSExLG49cC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKHt4OmEseTpmfSksZD1wLmNvbnZlcnRQaXhlbFRvVmFsdWUoe3g6Yix5OmN9KTtpZihuPmQpdmFyIHc9ZCxkPW4sbj13O2lmKHAuc2NhbGVCcmVha3MpZm9yKHc9MDshZyYmdzxwLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aDt3KyspZz1wLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW3ddLnN0YXJ0VmFsdWU8PW4mJnAuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3Nbd10uZW5kVmFsdWU+PWQ7aWYoaXNGaW5pdGUocC5kYXRhSW5mby5taW5EaWZmKSlpZih3PXAuZ2V0QXBwYXJlbnREaWZmZXJlbmNlKG4sZCxudWxsLCEwKSwhKGd8fCEodGhpcy5wYW5FbmFibGVkJiZwLnNjYWxlQnJlYWtzJiZwLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aCkmJlxyXG4ocC5sb2dhcml0aG1pYyYmdzxNYXRoLnBvdyhwLmRhdGFJbmZvLm1pbkRpZmYsMyl8fCFwLmxvZ2FyaXRobWljJiZ3PDMqTWF0aC5hYnMocC5kYXRhSW5mby5taW5EaWZmKSl8fG48cC5taW5pbXVtfHxkPnAubWF4aW11bSkpdC5wdXNoKHApLHIucHVzaCh7dmFsMTpuLHZhbDI6ZH0pLGw9ITA7ZWxzZSBpZighZSl7bD0hMTticmVha319cmV0dXJue2lzVmFsaWQ6bCxheGVzV2l0aFZhbGlkUmFuZ2U6dCxheGVzUmFuZ2VzOnJ9fTtxLnByb3RvdHlwZS5wcmVwYXJlUGxvdEFyZWE9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnBsb3RBcmVhOyF2JiYoMDxhLngxfHwwPGEueTEpJiZhLmN0eC50cmFuc2xhdGUoYS54MSxhLnkxKTtpZigodGhpcy5heGlzWFswXXx8dGhpcy5heGlzWDJbMF0pJiYodGhpcy5heGlzWVswXXx8dGhpcy5heGlzWTJbMF0pKXt2YXIgZj10aGlzLmF4aXNYWzBdP3RoaXMuYXhpc1hbMF0ubGluZUNvb3JkaW5hdGVzOnRoaXMuYXhpc1gyWzBdLmxpbmVDb29yZGluYXRlcztcclxuaWYodGhpcy5heGlzWSYmMDx0aGlzLmF4aXNZLmxlbmd0aCYmdGhpcy5heGlzWVswXSl7dmFyIGI9dGhpcy5heGlzWVswXTthLngxPWYueDE8Zi54Mj9mLngxOmIubGluZUNvb3JkaW5hdGVzLngxO2EueTE9Zi55MTxiLmxpbmVDb29yZGluYXRlcy55MT9mLnkxOmIubGluZUNvb3JkaW5hdGVzLnkxO2EueDI9Zi54Mj5iLmxpbmVDb29yZGluYXRlcy54Mj9mLngyOmIubGluZUNvb3JkaW5hdGVzLngyO2EueTI9Zi55Mj5mLnkxP2YueTI6Yi5saW5lQ29vcmRpbmF0ZXMueTI7YS53aWR0aD1hLngyLWEueDE7YS5oZWlnaHQ9YS55Mi1hLnkxfXRoaXMuYXhpc1kyJiYwPHRoaXMuYXhpc1kyLmxlbmd0aCYmdGhpcy5heGlzWTJbMF0mJihiPXRoaXMuYXhpc1kyWzBdLGEueDE9Zi54MTxmLngyP2YueDE6Yi5saW5lQ29vcmRpbmF0ZXMueDEsYS55MT1mLnkxPGIubGluZUNvb3JkaW5hdGVzLnkxP2YueTE6Yi5saW5lQ29vcmRpbmF0ZXMueTEsYS54Mj1mLngyPmIubGluZUNvb3JkaW5hdGVzLngyP1xyXG5mLngyOmIubGluZUNvb3JkaW5hdGVzLngyLGEueTI9Zi55Mj5mLnkxP2YueTI6Yi5saW5lQ29vcmRpbmF0ZXMueTIsYS53aWR0aD1hLngyLWEueDEsYS5oZWlnaHQ9YS55Mi1hLnkxKX1lbHNlIGY9dGhpcy5sYXlvdXRNYW5hZ2VyLmdldEZyZWVTcGFjZSgpLGEueDE9Zi54MSxhLngyPWYueDIsYS55MT1mLnkxLGEueTI9Zi55MixhLndpZHRoPWYud2lkdGgsYS5oZWlnaHQ9Zi5oZWlnaHQ7dnx8KGEuY2FudmFzLndpZHRoPWEud2lkdGgsYS5jYW52YXMuaGVpZ2h0PWEuaGVpZ2h0LGEuY2FudmFzLnN0eWxlLmxlZnQ9YS54MStcInB4XCIsYS5jYW52YXMuc3R5bGUudG9wPWEueTErXCJweFwiLCgwPGEueDF8fDA8YS55MSkmJmEuY3R4LnRyYW5zbGF0ZSgtYS54MSwtYS55MSkpO2EubGF5b3V0TWFuYWdlcj1uZXcgRWEoYS54MSxhLnkxLGEueDIsYS55MiwyKX07cS5wcm90b3R5cGUucmVuZGVySW5kZXhMYWJlbHM9ZnVuY3Rpb24oYSl7dmFyIGY9YXx8dGhpcy5wbG90QXJlYS5jdHgsYj10aGlzLnBsb3RBcmVhLFxyXG5jPTAsZT0wLGc9MCxoPTAsbD1jPWg9ZT1nPTAsdD0wO2ZvcihhPTA7YTx0aGlzLl9pbmRleExhYmVscy5sZW5ndGg7YSsrKXt2YXIgaz10aGlzLl9pbmRleExhYmVsc1thXSxyPWsuY2hhcnRUeXBlLnRvTG93ZXJDYXNlKCkscCxuLGw9bmEoXCJpbmRleExhYmVsRm9udENvbG9yXCIsay5kYXRhUG9pbnQsay5kYXRhU2VyaWVzKSx0PW5hKFwiaW5kZXhMYWJlbEZvbnRTaXplXCIsay5kYXRhUG9pbnQsay5kYXRhU2VyaWVzKTtwPW5hKFwiaW5kZXhMYWJlbEZvbnRGYW1pbHlcIixrLmRhdGFQb2ludCxrLmRhdGFTZXJpZXMpO249bmEoXCJpbmRleExhYmVsRm9udFN0eWxlXCIsay5kYXRhUG9pbnQsay5kYXRhU2VyaWVzKTt2YXIgaD1uYShcImluZGV4TGFiZWxGb250V2VpZ2h0XCIsay5kYXRhUG9pbnQsay5kYXRhU2VyaWVzKSxkPW5hKFwiaW5kZXhMYWJlbEJhY2tncm91bmRDb2xvclwiLGsuZGF0YVBvaW50LGsuZGF0YVNlcmllcyksZT1uYShcImluZGV4TGFiZWxNYXhXaWR0aFwiLGsuZGF0YVBvaW50LGsuZGF0YVNlcmllcyksXHJcbmc9bmEoXCJpbmRleExhYmVsV3JhcFwiLGsuZGF0YVBvaW50LGsuZGF0YVNlcmllcyksdz1uYShcImluZGV4TGFiZWxMaW5lRGFzaFR5cGVcIixrLmRhdGFQb2ludCxrLmRhdGFTZXJpZXMpLG09bmEoXCJpbmRleExhYmVsTGluZUNvbG9yXCIsay5kYXRhUG9pbnQsay5kYXRhU2VyaWVzKSxEPXkoay5kYXRhUG9pbnQuaW5kZXhMYWJlbExpbmVUaGlja25lc3MpP3koay5kYXRhU2VyaWVzLm9wdGlvbnMuaW5kZXhMYWJlbExpbmVUaGlja25lc3MpPzA6ay5kYXRhU2VyaWVzLm9wdGlvbnMuaW5kZXhMYWJlbExpbmVUaGlja25lc3M6ay5kYXRhUG9pbnQuaW5kZXhMYWJlbExpbmVUaGlja25lc3MsYz0wPEQ/TWF0aC5taW4oMTAsKFwibm9ybWFsXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/dGhpcy5wbG90QXJlYS5oZWlnaHQ6dGhpcy5wbG90QXJlYS53aWR0aCk8PDApOjAsdT17cGVyY2VudDpudWxsLHRvdGFsOm51bGx9LFM9bnVsbDtpZigwPD1rLmRhdGFTZXJpZXMudHlwZS5pbmRleE9mKFwic3RhY2tlZFwiKXx8XHJcblwicGllXCI9PT1rLmRhdGFTZXJpZXMudHlwZXx8XCJkb3VnaG51dFwiPT09ay5kYXRhU2VyaWVzLnR5cGUpdT10aGlzLmdldFBlcmNlbnRBbmRUb3RhbChrLmRhdGFTZXJpZXMsay5kYXRhUG9pbnQpO2lmKGsuZGF0YVNlcmllcy5pbmRleExhYmVsRm9ybWF0dGVyfHxrLmRhdGFQb2ludC5pbmRleExhYmVsRm9ybWF0dGVyKVM9e2NoYXJ0OnRoaXMsZGF0YVNlcmllczprLmRhdGFTZXJpZXMsZGF0YVBvaW50OmsuZGF0YVBvaW50LGluZGV4OmsuaW5kZXhLZXl3b3JkLHRvdGFsOnUudG90YWwscGVyY2VudDp1LnBlcmNlbnR9O3ZhciBjYT1rLmRhdGFQb2ludC5pbmRleExhYmVsRm9ybWF0dGVyP2suZGF0YVBvaW50LmluZGV4TGFiZWxGb3JtYXR0ZXIoUyk6ay5kYXRhUG9pbnQuaW5kZXhMYWJlbD90aGlzLnJlcGxhY2VLZXl3b3Jkc1dpdGhWYWx1ZShrLmRhdGFQb2ludC5pbmRleExhYmVsLGsuZGF0YVBvaW50LGsuZGF0YVNlcmllcyxudWxsLGsuaW5kZXhLZXl3b3JkKTprLmRhdGFTZXJpZXMuaW5kZXhMYWJlbEZvcm1hdHRlcj9cclxuay5kYXRhU2VyaWVzLmluZGV4TGFiZWxGb3JtYXR0ZXIoUyk6ay5kYXRhU2VyaWVzLmluZGV4TGFiZWw/dGhpcy5yZXBsYWNlS2V5d29yZHNXaXRoVmFsdWUoay5kYXRhU2VyaWVzLmluZGV4TGFiZWwsay5kYXRhUG9pbnQsay5kYXRhU2VyaWVzLG51bGwsay5pbmRleEtleXdvcmQpOm51bGw7aWYobnVsbCE9PWNhJiZcIlwiIT09Y2Epe3ZhciB1PW5hKFwiaW5kZXhMYWJlbFBsYWNlbWVudFwiLGsuZGF0YVBvaW50LGsuZGF0YVNlcmllcyksUz1uYShcImluZGV4TGFiZWxPcmllbnRhdGlvblwiLGsuZGF0YVBvaW50LGsuZGF0YVNlcmllcykscz1rLmRpcmVjdGlvbixxPWsuZGF0YVNlcmllcy5heGlzWCxBPWsuZGF0YVNlcmllcy5heGlzWSx4PSExLGQ9bmV3IGxhKGYse3g6MCx5OjAsbWF4V2lkdGg6ZT9lOjAuNSp0aGlzLndpZHRoLG1heEhlaWdodDpnPzUqdDoxLjUqdCxhbmdsZTpcImhvcml6b250YWxcIj09PVM/MDotOTAsdGV4dDpjYSxwYWRkaW5nOjAsYmFja2dyb3VuZENvbG9yOmQsaG9yaXpvbnRhbEFsaWduOlwibGVmdFwiLFxyXG5mb250U2l6ZTp0LGZvbnRGYW1pbHk6cCxmb250V2VpZ2h0OmgsZm9udENvbG9yOmwsZm9udFN0eWxlOm4sdGV4dEJhc2VsaW5lOlwidG9wXCJ9KTtkLm1lYXN1cmVUZXh0KCk7ay5kYXRhU2VyaWVzLmluZGV4TGFiZWxNYXhXaWR0aD1kLm1heFdpZHRoO2lmKFwic3RhY2tlZGFyZWExMDBcIj09PXIpe2lmKGsucG9pbnQueDxiLngxfHxrLnBvaW50Lng+Yi54Mnx8ay5wb2ludC55PGIueTEtMXx8ay5wb2ludC55PmIueTIrMSljb250aW51ZX1lbHNlIGlmKFwicmFuZ2VhcmVhXCI9PT1yfHxcInJhbmdlc3BsaW5lYXJlYVwiPT09cil7aWYoay5kYXRhUG9pbnQueDxxLnZpZXdwb3J0TWluaW11bXx8ay5kYXRhUG9pbnQueD5xLnZpZXdwb3J0TWF4aW11bXx8TWF0aC5tYXguYXBwbHkobnVsbCxrLmRhdGFQb2ludC55KTxBLnZpZXdwb3J0TWluaW11bXx8TWF0aC5taW4uYXBwbHkobnVsbCxrLmRhdGFQb2ludC55KT5BLnZpZXdwb3J0TWF4aW11bSljb250aW51ZX1lbHNlIGlmKDA8PXIuaW5kZXhPZihcImxpbmVcIil8fFxyXG4wPD1yLmluZGV4T2YoXCJhcmVhXCIpfHwwPD1yLmluZGV4T2YoXCJidWJibGVcIil8fDA8PXIuaW5kZXhPZihcInNjYXR0ZXJcIikpe2lmKGsuZGF0YVBvaW50Lng8cS52aWV3cG9ydE1pbmltdW18fGsuZGF0YVBvaW50Lng+cS52aWV3cG9ydE1heGltdW18fGsuZGF0YVBvaW50Lnk8QS52aWV3cG9ydE1pbmltdW18fGsuZGF0YVBvaW50Lnk+QS52aWV3cG9ydE1heGltdW0pY29udGludWV9ZWxzZSBpZigwPD1yLmluZGV4T2YoXCJjb2x1bW5cIil8fFwid2F0ZXJmYWxsXCI9PT1yfHxcImVycm9yXCI9PT1yJiYhay5heGlzU3dhcHBlZCl7aWYoay5kYXRhUG9pbnQueDxxLnZpZXdwb3J0TWluaW11bXx8ay5kYXRhUG9pbnQueD5xLnZpZXdwb3J0TWF4aW11bXx8ay5ib3VuZHMueTE+Yi55Mnx8ay5ib3VuZHMueTI8Yi55MSljb250aW51ZX1lbHNlIGlmKDA8PXIuaW5kZXhPZihcImJhclwiKXx8XCJlcnJvclwiPT09cil7aWYoay5kYXRhUG9pbnQueDxxLnZpZXdwb3J0TWluaW11bXx8ay5kYXRhUG9pbnQueD5xLnZpZXdwb3J0TWF4aW11bXx8XHJcbmsuYm91bmRzLngxPmIueDJ8fGsuYm91bmRzLngyPGIueDEpY29udGludWV9ZWxzZSBpZihcImNhbmRsZXN0aWNrXCI9PT1yfHxcIm9obGNcIj09PXIpe2lmKGsuZGF0YVBvaW50Lng8cS52aWV3cG9ydE1pbmltdW18fGsuZGF0YVBvaW50Lng+cS52aWV3cG9ydE1heGltdW18fE1hdGgubWF4LmFwcGx5KG51bGwsay5kYXRhUG9pbnQueSk8QS52aWV3cG9ydE1pbmltdW18fE1hdGgubWluLmFwcGx5KG51bGwsay5kYXRhUG9pbnQueSk+QS52aWV3cG9ydE1heGltdW0pY29udGludWV9ZWxzZSBpZihrLmRhdGFQb2ludC54PHEudmlld3BvcnRNaW5pbXVtfHxrLmRhdGFQb2ludC54PnEudmlld3BvcnRNYXhpbXVtKWNvbnRpbnVlO2U9aD0yO1wiaG9yaXpvbnRhbFwiPT09Uz8obD1kLndpZHRoLHQ9ZC5oZWlnaHQpOih0PWQud2lkdGgsbD1kLmhlaWdodCk7aWYoXCJub3JtYWxcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCl7aWYoMDw9ci5pbmRleE9mKFwibGluZVwiKXx8MDw9ci5pbmRleE9mKFwiYXJlYVwiKSl1PVxyXG5cImF1dG9cIixoPTQ7ZWxzZSBpZigwPD1yLmluZGV4T2YoXCJzdGFja2VkXCIpKVwiYXV0b1wiPT09dSYmKHU9XCJpbnNpZGVcIik7ZWxzZSBpZihcImJ1YmJsZVwiPT09cnx8XCJzY2F0dGVyXCI9PT1yKXU9XCJpbnNpZGVcIjtwPWsucG9pbnQueC1sLzI7XCJpbnNpZGVcIiE9PXU/KGU9Yi55MSxnPWIueTIsMDxzPyhuPWsucG9pbnQueS10LWgtYyxuPGUmJihuPVwiYXV0b1wiPT09dT9NYXRoLm1heChrLnBvaW50LnksZSkraCtjOmUraCtjLHg9bit0PmsucG9pbnQueSkpOihuPWsucG9pbnQueStoK2Msbj5nLXQtaC1jJiYobj1cImF1dG9cIj09PXU/TWF0aC5taW4oay5wb2ludC55LGcpLXQtaC1jOmctdC1oLWMseD1uPGsucG9pbnQueSkpKTooZT1NYXRoLm1heChrLmJvdW5kcy55MSxiLnkxKSxnPU1hdGgubWluKGsuYm91bmRzLnkyLGIueTIpLGM9MDw9ci5pbmRleE9mKFwicmFuZ2VcIil8fFwiZXJyb3JcIj09PXI/MDxzP01hdGgubWF4KGsuYm91bmRzLnkxLGIueTEpK3QvMitoOk1hdGgubWluKGsuYm91bmRzLnkyLGIueTIpLVxyXG50LzItaDooTWF0aC5tYXgoay5ib3VuZHMueTEsYi55MSkrTWF0aC5taW4oay5ib3VuZHMueTIsYi55MikpLzIsMDxzPyhuPU1hdGgubWF4KGsucG9pbnQueSxjKS10LzIsbjxlJiYoXCJidWJibGVcIj09PXJ8fFwic2NhdHRlclwiPT09cikmJihuPU1hdGgubWF4KGsucG9pbnQueS10LWgsYi55MStoKSkpOihuPU1hdGgubWluKGsucG9pbnQueSxjKS10LzIsbj5nLXQtaCYmKFwiYnViYmxlXCI9PT1yfHxcInNjYXR0ZXJcIj09PXIpJiYobj1NYXRoLm1pbihrLnBvaW50LnkraCxiLnkyLXQtaCkpKSxuPU1hdGgubWluKG4sZy10KSl9ZWxzZSAwPD1yLmluZGV4T2YoXCJsaW5lXCIpfHwwPD1yLmluZGV4T2YoXCJhcmVhXCIpfHwwPD1yLmluZGV4T2YoXCJzY2F0dGVyXCIpPyh1PVwiYXV0b1wiLGU9NCk6MDw9ci5pbmRleE9mKFwic3RhY2tlZFwiKT9cImF1dG9cIj09PXUmJih1PVwiaW5zaWRlXCIpOlwiYnViYmxlXCI9PT1yJiYodT1cImluc2lkZVwiKSxuPWsucG9pbnQueS10LzIsXCJpbnNpZGVcIiE9PXU/KGg9Yi54MSxnPWIueDIsXHJcbjA+cz8ocD1rLnBvaW50LngtbC1lLWMscDxoJiYocD1cImF1dG9cIj09PXU/TWF0aC5tYXgoay5wb2ludC54LGgpK2UrYzpoK2UrYyx4PXArbD5rLnBvaW50LngpKToocD1rLnBvaW50LngrZStjLHA+Zy1sLWUtYyYmKHA9XCJhdXRvXCI9PT11P01hdGgubWluKGsucG9pbnQueCxnKS1sLWUtYzpnLWwtZS1jLHg9cDxrLnBvaW50LngpKSk6KGg9TWF0aC5tYXgoay5ib3VuZHMueDEsYi54MSksTWF0aC5taW4oay5ib3VuZHMueDIsYi54MiksYz0wPD1yLmluZGV4T2YoXCJyYW5nZVwiKXx8XCJlcnJvclwiPT09cj8wPnM/TWF0aC5tYXgoay5ib3VuZHMueDEsYi54MSkrbC8yK2U6TWF0aC5taW4oay5ib3VuZHMueDIsYi54MiktbC8yLWU6KE1hdGgubWF4KGsuYm91bmRzLngxLGIueDEpK01hdGgubWluKGsuYm91bmRzLngyLGIueDIpKS8yLHA9MD5zP01hdGgubWF4KGsucG9pbnQueCxjKS1sLzI6TWF0aC5taW4oay5wb2ludC54LGMpLWwvMixwPU1hdGgubWF4KHAsaCkpO1widmVydGljYWxcIj09PVMmJihuKz1cclxudCk7ZC54PXA7ZC55PW47ZC5yZW5kZXIoITApO0QmJihcImluc2lkZVwiIT09dSYmKDA+ci5pbmRleE9mKFwiYmFyXCIpJiYoXCJlcnJvclwiIT09cnx8IWsuYXhpc1N3YXBwZWQpJiZrLnBvaW50Lng+Yi54MSYmay5wb2ludC54PGIueDJ8fCF4KSYmKDA+ci5pbmRleE9mKFwiY29sdW1uXCIpJiYoXCJlcnJvclwiIT09cnx8ay5heGlzU3dhcHBlZCkmJmsucG9pbnQueT5iLnkxJiZrLnBvaW50Lnk8Yi55Mnx8IXgpKSYmKGYubGluZVdpZHRoPUQsZi5zdHJva2VTdHlsZT1tP206XCJncmF5XCIsZi5zZXRMaW5lRGFzaCYmZi5zZXRMaW5lRGFzaChHKHcsRCkpLGYuYmVnaW5QYXRoKCksZi5tb3ZlVG8oay5wb2ludC54LGsucG9pbnQueSksMDw9ci5pbmRleE9mKFwiYmFyXCIpfHxcImVycm9yXCI9PT1yJiZrLmF4aXNTd2FwcGVkP2YubGluZVRvKHArKDA8ay5kaXJlY3Rpb24/MDpsKSxuKyhcImhvcml6b250YWxcIj09PVM/dDotdCkvMik6MDw9ci5pbmRleE9mKFwiY29sdW1uXCIpfHxcImVycm9yXCI9PT1yJiYhay5heGlzU3dhcHBlZD9cclxuZi5saW5lVG8ocCtsLzIsbisoKDA8ay5kaXJlY3Rpb24/dDotdCkrKFwiaG9yaXpvbnRhbFwiPT09Uz90Oi10KSkvMik6Zi5saW5lVG8ocCtsLzIsbisoKG48ay5wb2ludC55P3Q6LXQpKyhcImhvcml6b250YWxcIj09PVM/dDotdCkpLzIpLGYuc3Ryb2tlKCkpfX1mPXtzb3VyY2U6ZixkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOkguZmFkZUluQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmVhc2VJblF1YWQsYW5pbWF0aW9uQmFzZTowLHN0YXJ0VGltZVBlcmNlbnQ6MC43fTtmb3IoYT0wO2E8dGhpcy5faW5kZXhMYWJlbHMubGVuZ3RoO2ErKylrPXRoaXMuX2luZGV4TGFiZWxzW2FdLGQ9bmEoXCJpbmRleExhYmVsQmFja2dyb3VuZENvbG9yXCIsay5kYXRhUG9pbnQsay5kYXRhU2VyaWVzKSxrLmRhdGFTZXJpZXMuaW5kZXhMYWJlbEJhY2tncm91bmRDb2xvcj15KGQpP3Y/XCJ0cmFuc3BhcmVudFwiOm51bGw6ZDtyZXR1cm4gZn07cS5wcm90b3R5cGUucmVuZGVyTGluZT1cclxuZnVuY3Rpb24oYSl7dmFyIGY9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGI9dj90aGlzLl9wcmVSZW5kZXJDdHg6ZjtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGM9dGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4O2Iuc2F2ZSgpO3ZhciBlPXRoaXMucGxvdEFyZWE7Yi5iZWdpblBhdGgoKTtiLnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpO2IuY2xpcCgpO2Zvcih2YXIgZz1bXSxoLGw9MDtsPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO2wrKyl7dmFyIHQ9YS5kYXRhU2VyaWVzSW5kZXhlc1tsXSxrPXRoaXMuZGF0YVt0XTtiLmxpbmVXaWR0aD1rLmxpbmVUaGlja25lc3M7dmFyIHI9ay5kYXRhUG9pbnRzLHA9XCJzb2xpZFwiO2lmKGIuc2V0TGluZURhc2gpe3ZhciBuPUcoay5udWxsRGF0YUxpbmVEYXNoVHlwZSxrLmxpbmVUaGlja25lc3MpLHA9ay5saW5lRGFzaFR5cGUsZD1HKHAsay5saW5lVGhpY2tuZXNzKTtiLnNldExpbmVEYXNoKGQpfXZhciB3PVxyXG5rLmlkO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbd109e29iamVjdFR5cGU6XCJkYXRhU2VyaWVzXCIsZGF0YVNlcmllc0luZGV4OnR9O3c9Uih3KTtjLnN0cm9rZVN0eWxlPXc7Yy5saW5lV2lkdGg9MDxrLmxpbmVUaGlja25lc3M/TWF0aC5tYXgoay5saW5lVGhpY2tuZXNzLDQpOjA7dmFyIHc9ay5fY29sb3JTZXQsbT13PWsubGluZUNvbG9yPWsub3B0aW9ucy5saW5lQ29sb3I/ay5vcHRpb25zLmxpbmVDb2xvcjp3WzBdO2Iuc3Ryb2tlU3R5bGU9dzt2YXIgRD0hMCx1PTAsUyxjYTtiLmJlZ2luUGF0aCgpO2lmKDA8ci5sZW5ndGgpe2Zvcih2YXIgcz0hMSx1PTA7dTxyLmxlbmd0aDt1KyspaWYoUz1yW3VdLnguZ2V0VGltZT9yW3VdLnguZ2V0VGltZSgpOnJbdV0ueCwhKFM8YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1pbnx8Uz5hLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWF4JiYoIWsuY29ubmVjdE51bGxEYXRhfHwhcykpKWlmKFwibnVtYmVyXCIhPT10eXBlb2Ygclt1XS55KTA8XHJcbnUmJiEoay5jb25uZWN0TnVsbERhdGF8fHN8fEQpJiYoYi5zdHJva2UoKSx2JiZjLnN0cm9rZSgpKSxzPSEwO2Vsc2V7Uz1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoUyk7Y2E9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHJbdV0ueSk7dmFyIHE9ay5kYXRhUG9pbnRJZHNbdV07dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtxXT17aWQ6cSxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4OnQsZGF0YVBvaW50SW5kZXg6dSx4MTpTLHkxOmNhfTtEfHxzPyghRCYmay5jb25uZWN0TnVsbERhdGE/KGIuc2V0TGluZURhc2gmJihrLm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fHA9PT1rLmxpbmVEYXNoVHlwZSYmay5saW5lRGFzaFR5cGUhPT1rLm51bGxEYXRhTGluZURhc2hUeXBlKSYmKGIuc3Ryb2tlKCksYi5iZWdpblBhdGgoKSxiLm1vdmVUbyhoLngsaC55KSxwPWsubnVsbERhdGFMaW5lRGFzaFR5cGUsYi5zZXRMaW5lRGFzaChuKSksYi5saW5lVG8oUyxcclxuY2EpLHYmJmMubGluZVRvKFMsY2EpKTooYi5iZWdpblBhdGgoKSxiLm1vdmVUbyhTLGNhKSx2JiYoYy5iZWdpblBhdGgoKSxjLm1vdmVUbyhTLGNhKSkpLHM9RD0hMSk6KGIubGluZVRvKFMsY2EpLHYmJmMubGluZVRvKFMsY2EpLDA9PXUlNTAwJiYoYi5zdHJva2UoKSxiLmJlZ2luUGF0aCgpLGIubW92ZVRvKFMsY2EpLHYmJihjLnN0cm9rZSgpLGMuYmVnaW5QYXRoKCksYy5tb3ZlVG8oUyxjYSkpKSk7aD17eDpTLHk6Y2F9O3U8ci5sZW5ndGgtMSYmKG0hPT0oclt1XS5saW5lQ29sb3J8fHcpfHxwIT09KHJbdV0ubGluZURhc2hUeXBlfHxrLmxpbmVEYXNoVHlwZSkpJiYoYi5zdHJva2UoKSxiLmJlZ2luUGF0aCgpLGIubW92ZVRvKFMsY2EpLG09clt1XS5saW5lQ29sb3J8fHcsYi5zdHJva2VTdHlsZT1tLGIuc2V0TGluZURhc2gmJihyW3VdLmxpbmVEYXNoVHlwZT8ocD1yW3VdLmxpbmVEYXNoVHlwZSxiLnNldExpbmVEYXNoKEcocCxrLmxpbmVUaGlja25lc3MpKSk6KHA9ay5saW5lRGFzaFR5cGUsXHJcbmIuc2V0TGluZURhc2goZCkpKSk7aWYoMDxyW3VdLm1hcmtlclNpemV8fDA8ay5tYXJrZXJTaXplKXt2YXIgQT1rLmdldE1hcmtlclByb3BlcnRpZXModSxTLGNhLGIpO2cucHVzaChBKTtxPVIocSk7diYmZy5wdXNoKHt4OlMseTpjYSxjdHg6Yyx0eXBlOkEudHlwZSxzaXplOkEuc2l6ZSxjb2xvcjpxLGJvcmRlckNvbG9yOnEsYm9yZGVyVGhpY2tuZXNzOkEuYm9yZGVyVGhpY2tuZXNzfSl9KHJbdV0uaW5kZXhMYWJlbHx8ay5pbmRleExhYmVsfHxyW3VdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fGsuaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcImxpbmVcIixkYXRhUG9pbnQ6clt1XSxkYXRhU2VyaWVzOmsscG9pbnQ6e3g6Uyx5OmNhfSxkaXJlY3Rpb246MD5yW3VdLnk9PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsY29sb3I6d30pfWIuc3Ryb2tlKCk7diYmYy5zdHJva2UoKX19amEuZHJhd01hcmtlcnMoZyk7diYmKGYuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcyxcclxuMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGIuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmIuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGIuY2xlYXJSZWN0KGUueDEsZS55MSxlLndpZHRoLGUuaGVpZ2h0KSxjLmJlZ2luUGF0aCgpKTtiLnJlc3RvcmUoKTtiLmJlZ2luUGF0aCgpO3JldHVybntzb3VyY2U6ZixkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOkgueENsaXBBbmltYXRpb24sZWFzaW5nRnVuY3Rpb246SC5lYXNpbmcubGluZWFyLFxyXG5hbmltYXRpb25CYXNlOjB9fX07cS5wcm90b3R5cGUucmVuZGVyU3RlcExpbmU9ZnVuY3Rpb24oYSl7dmFyIGY9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGI9dj90aGlzLl9wcmVSZW5kZXJDdHg6ZjtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGM9dGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4O2Iuc2F2ZSgpO3ZhciBlPXRoaXMucGxvdEFyZWE7Yi5iZWdpblBhdGgoKTtiLnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpO2IuY2xpcCgpO2Zvcih2YXIgZz1bXSxoLGw9MDtsPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO2wrKyl7dmFyIHQ9YS5kYXRhU2VyaWVzSW5kZXhlc1tsXSxrPXRoaXMuZGF0YVt0XTtiLmxpbmVXaWR0aD1rLmxpbmVUaGlja25lc3M7dmFyIHI9ay5kYXRhUG9pbnRzLHA9XCJzb2xpZFwiO2lmKGIuc2V0TGluZURhc2gpe3ZhciBuPUcoay5udWxsRGF0YUxpbmVEYXNoVHlwZSxrLmxpbmVUaGlja25lc3MpLFxyXG5wPWsubGluZURhc2hUeXBlLGQ9RyhwLGsubGluZVRoaWNrbmVzcyk7Yi5zZXRMaW5lRGFzaChkKX12YXIgdz1rLmlkO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbd109e29iamVjdFR5cGU6XCJkYXRhU2VyaWVzXCIsZGF0YVNlcmllc0luZGV4OnR9O3c9Uih3KTtjLnN0cm9rZVN0eWxlPXc7Yy5saW5lV2lkdGg9MDxrLmxpbmVUaGlja25lc3M/TWF0aC5tYXgoay5saW5lVGhpY2tuZXNzLDQpOjA7dmFyIHc9ay5fY29sb3JTZXQsbT13PWsubGluZUNvbG9yPWsub3B0aW9ucy5saW5lQ29sb3I/ay5vcHRpb25zLmxpbmVDb2xvcjp3WzBdO2Iuc3Ryb2tlU3R5bGU9dzt2YXIgRD0hMCx1PTAsUyxjYTtiLmJlZ2luUGF0aCgpO2lmKDA8ci5sZW5ndGgpe2Zvcih2YXIgcz0hMSx1PTA7dTxyLmxlbmd0aDt1KyspaWYoUz1yW3VdLmdldFRpbWU/clt1XS54LmdldFRpbWUoKTpyW3VdLngsIShTPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fFM+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCYmXHJcbighay5jb25uZWN0TnVsbERhdGF8fCFzKSkpaWYoXCJudW1iZXJcIiE9PXR5cGVvZiByW3VdLnkpMDx1JiYhKGsuY29ubmVjdE51bGxEYXRhfHxzfHxEKSYmKGIuc3Ryb2tlKCksdiYmYy5zdHJva2UoKSkscz0hMDtlbHNle3ZhciBxPWNhO1M9YS5heGlzWC5jb252ZXJ0VmFsdWVUb1BpeGVsKFMpO2NhPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChyW3VdLnkpO3ZhciBBPWsuZGF0YVBvaW50SWRzW3VdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbQV09e2lkOkEsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDp0LGRhdGFQb2ludEluZGV4OnUseDE6Uyx5MTpjYX07RHx8cz8oIUQmJmsuY29ubmVjdE51bGxEYXRhPyhiLnNldExpbmVEYXNoJiYoay5vcHRpb25zLm51bGxEYXRhTGluZURhc2hUeXBlfHxwPT09ay5saW5lRGFzaFR5cGUmJmsubGluZURhc2hUeXBlIT09ay5udWxsRGF0YUxpbmVEYXNoVHlwZSkmJihiLnN0cm9rZSgpLGIuYmVnaW5QYXRoKCksXHJcbmIubW92ZVRvKGgueCxoLnkpLHA9ay5udWxsRGF0YUxpbmVEYXNoVHlwZSxiLnNldExpbmVEYXNoKG4pKSxiLmxpbmVUbyhTLHEpLGIubGluZVRvKFMsY2EpLHYmJihjLmxpbmVUbyhTLHEpLGMubGluZVRvKFMsY2EpKSk6KGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8oUyxjYSksdiYmKGMuYmVnaW5QYXRoKCksYy5tb3ZlVG8oUyxjYSkpKSxzPUQ9ITEpOihiLmxpbmVUbyhTLHEpLHYmJmMubGluZVRvKFMscSksYi5saW5lVG8oUyxjYSksdiYmYy5saW5lVG8oUyxjYSksMD09dSU1MDAmJihiLnN0cm9rZSgpLGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8oUyxjYSksdiYmKGMuc3Ryb2tlKCksYy5iZWdpblBhdGgoKSxjLm1vdmVUbyhTLGNhKSkpKTtoPXt4OlMseTpjYX07dTxyLmxlbmd0aC0xJiYobSE9PShyW3VdLmxpbmVDb2xvcnx8dyl8fHAhPT0oclt1XS5saW5lRGFzaFR5cGV8fGsubGluZURhc2hUeXBlKSkmJihiLnN0cm9rZSgpLGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8oUyxjYSksbT1yW3VdLmxpbmVDb2xvcnx8XHJcbncsYi5zdHJva2VTdHlsZT1tLGIuc2V0TGluZURhc2gmJihyW3VdLmxpbmVEYXNoVHlwZT8ocD1yW3VdLmxpbmVEYXNoVHlwZSxiLnNldExpbmVEYXNoKEcocCxrLmxpbmVUaGlja25lc3MpKSk6KHA9ay5saW5lRGFzaFR5cGUsYi5zZXRMaW5lRGFzaChkKSkpKTtpZigwPHJbdV0ubWFya2VyU2l6ZXx8MDxrLm1hcmtlclNpemUpcT1rLmdldE1hcmtlclByb3BlcnRpZXModSxTLGNhLGIpLGcucHVzaChxKSxBPVIoQSksdiYmZy5wdXNoKHt4OlMseTpjYSxjdHg6Yyx0eXBlOnEudHlwZSxzaXplOnEuc2l6ZSxjb2xvcjpBLGJvcmRlckNvbG9yOkEsYm9yZGVyVGhpY2tuZXNzOnEuYm9yZGVyVGhpY2tuZXNzfSk7KHJbdV0uaW5kZXhMYWJlbHx8ay5pbmRleExhYmVsfHxyW3VdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fGsuaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcInN0ZXBMaW5lXCIsZGF0YVBvaW50OnJbdV0sZGF0YVNlcmllczprLHBvaW50Ont4OlMsXHJcbnk6Y2F9LGRpcmVjdGlvbjowPnJbdV0ueT09PWEuYXhpc1kucmV2ZXJzZWQ/MTotMSxjb2xvcjp3fSl9Yi5zdHJva2UoKTt2JiZjLnN0cm9rZSgpfX1qYS5kcmF3TWFya2VycyhnKTt2JiYoZi5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmNsZWFyUmVjdChlLngxLGUueTEsZS53aWR0aCxcclxuZS5oZWlnaHQpLGMuYmVnaW5QYXRoKCkpO2IucmVzdG9yZSgpO2IuYmVnaW5QYXRoKCk7cmV0dXJue3NvdXJjZTpmLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6SC54Q2xpcEFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpILmVhc2luZy5saW5lYXIsYW5pbWF0aW9uQmFzZTowfX19O3EucHJvdG90eXBlLnJlbmRlclNwbGluZT1mdW5jdGlvbihhKXtmdW5jdGlvbiBmKGEpe2E9eChhLDIpO2lmKDA8YS5sZW5ndGgpe2MuYmVnaW5QYXRoKCk7diYmZS5iZWdpblBhdGgoKTtjLm1vdmVUbyhhWzBdLngsYVswXS55KTthWzBdLm5ld1N0cm9rZVN0eWxlJiYoYy5zdHJva2VTdHlsZT1hWzBdLm5ld1N0cm9rZVN0eWxlKTthWzBdLm5ld0xpbmVEYXNoQXJyYXkmJmMuc2V0TGluZURhc2goYVswXS5uZXdMaW5lRGFzaEFycmF5KTt2JiZlLm1vdmVUbyhhWzBdLngsYVswXS55KTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoLTM7Yis9MylpZihjLmJlemllckN1cnZlVG8oYVtiK1xyXG4xXS54LGFbYisxXS55LGFbYisyXS54LGFbYisyXS55LGFbYiszXS54LGFbYiszXS55KSx2JiZlLmJlemllckN1cnZlVG8oYVtiKzFdLngsYVtiKzFdLnksYVtiKzJdLngsYVtiKzJdLnksYVtiKzNdLngsYVtiKzNdLnkpLDA8YiYmMD09PWIlM0UzfHxhW2IrM10ubmV3U3Ryb2tlU3R5bGV8fGFbYiszXS5uZXdMaW5lRGFzaEFycmF5KWMuc3Ryb2tlKCksYy5iZWdpblBhdGgoKSxjLm1vdmVUbyhhW2IrM10ueCxhW2IrM10ueSksYVtiKzNdLm5ld1N0cm9rZVN0eWxlJiYoYy5zdHJva2VTdHlsZT1hW2IrM10ubmV3U3Ryb2tlU3R5bGUpLGFbYiszXS5uZXdMaW5lRGFzaEFycmF5JiZjLnNldExpbmVEYXNoKGFbYiszXS5uZXdMaW5lRGFzaEFycmF5KSx2JiYoZS5zdHJva2UoKSxlLmJlZ2luUGF0aCgpLGUubW92ZVRvKGFbYiszXS54LGFbYiszXS55KSk7Yy5zdHJva2UoKTt2JiZlLnN0cm9rZSgpfX12YXIgYj1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYz12P3RoaXMuX3ByZVJlbmRlckN0eDpcclxuYjtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGU9dGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4O2Muc2F2ZSgpO3ZhciBnPXRoaXMucGxvdEFyZWE7Yy5iZWdpblBhdGgoKTtjLnJlY3QoZy54MSxnLnkxLGcud2lkdGgsZy5oZWlnaHQpO2MuY2xpcCgpO2Zvcih2YXIgaD1bXSxsPTA7bDxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtsKyspe3ZhciB0PWEuZGF0YVNlcmllc0luZGV4ZXNbbF0saz10aGlzLmRhdGFbdF07Yy5saW5lV2lkdGg9ay5saW5lVGhpY2tuZXNzO3ZhciByPWsuZGF0YVBvaW50cyxwPVwic29saWRcIjtpZihjLnNldExpbmVEYXNoKXt2YXIgbj1HKGsubnVsbERhdGFMaW5lRGFzaFR5cGUsay5saW5lVGhpY2tuZXNzKSxwPWsubGluZURhc2hUeXBlLGQ9RyhwLGsubGluZVRoaWNrbmVzcyk7Yy5zZXRMaW5lRGFzaChkKX12YXIgdz1rLmlkO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbd109e29iamVjdFR5cGU6XCJkYXRhU2VyaWVzXCIsXHJcbmRhdGFTZXJpZXNJbmRleDp0fTt3PVIodyk7ZS5zdHJva2VTdHlsZT13O2UubGluZVdpZHRoPTA8ay5saW5lVGhpY2tuZXNzP01hdGgubWF4KGsubGluZVRoaWNrbmVzcyw0KTowO3ZhciB3PWsuX2NvbG9yU2V0LG09dz1rLmxpbmVDb2xvcj1rLm9wdGlvbnMubGluZUNvbG9yP2sub3B0aW9ucy5saW5lQ29sb3I6d1swXTtjLnN0cm9rZVN0eWxlPXc7dmFyIEQ9MCx1LFMscT1bXTtjLmJlZ2luUGF0aCgpO2lmKDA8ci5sZW5ndGgpZm9yKFM9ITEsRD0wO0Q8ci5sZW5ndGg7RCsrKWlmKHU9cltEXS5nZXRUaW1lP3JbRF0ueC5nZXRUaW1lKCk6cltEXS54LCEodTxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHx1PmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgmJighay5jb25uZWN0TnVsbERhdGF8fCFTKSkpaWYoXCJudW1iZXJcIiE9PXR5cGVvZiByW0RdLnkpMDxEJiYhUyYmKGsuY29ubmVjdE51bGxEYXRhP2Muc2V0TGluZURhc2gmJigwPHEubGVuZ3RoJiYoay5vcHRpb25zLm51bGxEYXRhTGluZURhc2hUeXBlfHxcclxuIXJbRC0xXS5saW5lRGFzaFR5cGUpKSYmKHFbcS5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheT1uLHA9ay5udWxsRGF0YUxpbmVEYXNoVHlwZSk6KGYocSkscT1bXSkpLFM9ITA7ZWxzZXt1PWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbCh1KTtTPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChyW0RdLnkpO3ZhciBzPWsuZGF0YVBvaW50SWRzW0RdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbc109e2lkOnMsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDp0LGRhdGFQb2ludEluZGV4OkQseDE6dSx5MTpTfTtxW3EubGVuZ3RoXT17eDp1LHk6U307RDxyLmxlbmd0aC0xJiYobSE9PShyW0RdLmxpbmVDb2xvcnx8dyl8fHAhPT0ocltEXS5saW5lRGFzaFR5cGV8fGsubGluZURhc2hUeXBlKSkmJihtPXJbRF0ubGluZUNvbG9yfHx3LHFbcS5sZW5ndGgtMV0ubmV3U3Ryb2tlU3R5bGU9bSxjLnNldExpbmVEYXNoJiYocltEXS5saW5lRGFzaFR5cGU/KHA9XHJcbnJbRF0ubGluZURhc2hUeXBlLHFbcS5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheT1HKHAsay5saW5lVGhpY2tuZXNzKSk6KHA9ay5saW5lRGFzaFR5cGUscVtxLmxlbmd0aC0xXS5uZXdMaW5lRGFzaEFycmF5PWQpKSk7aWYoMDxyW0RdLm1hcmtlclNpemV8fDA8ay5tYXJrZXJTaXplKXt2YXIgeT1rLmdldE1hcmtlclByb3BlcnRpZXMoRCx1LFMsYyk7aC5wdXNoKHkpO3M9UihzKTt2JiZoLnB1c2goe3g6dSx5OlMsY3R4OmUsdHlwZTp5LnR5cGUsc2l6ZTp5LnNpemUsY29sb3I6cyxib3JkZXJDb2xvcjpzLGJvcmRlclRoaWNrbmVzczp5LmJvcmRlclRoaWNrbmVzc30pfShyW0RdLmluZGV4TGFiZWx8fGsuaW5kZXhMYWJlbHx8cltEXS5pbmRleExhYmVsRm9ybWF0dGVyfHxrLmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJzcGxpbmVcIixkYXRhUG9pbnQ6cltEXSxkYXRhU2VyaWVzOmsscG9pbnQ6e3g6dSx5OlN9LGRpcmVjdGlvbjowPlxyXG5yW0RdLnk9PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsY29sb3I6d30pO1M9ITF9ZihxKX1qYS5kcmF3TWFya2VycyhoKTt2JiYoYi5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmNsZWFyUmVjdChnLngxLGcueTEsZy53aWR0aCxnLmhlaWdodCksZS5iZWdpblBhdGgoKSk7Yy5yZXN0b3JlKCk7XHJcbmMuYmVnaW5QYXRoKCk7cmV0dXJue3NvdXJjZTpiLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6SC54Q2xpcEFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpILmVhc2luZy5saW5lYXIsYW5pbWF0aW9uQmFzZTowfX19O3ZhciBWPWZ1bmN0aW9uKGEsZixiLGMsZSxnLGgsbCx0LGsscixwLG4pe1widW5kZWZpbmVkXCI9PT10eXBlb2YgbiYmKG49MSk7aD1ofHwwO2w9bHx8XCJibGFja1wiO3ZhciBkPTE1PGMtZiYmMTU8ZS1iPzg6MC4zNSpNYXRoLm1pbihjLWYsZS1iKTthLmJlZ2luUGF0aCgpO2EubW92ZVRvKGYsYik7YS5zYXZlKCk7YS5maWxsU3R5bGU9ZzthLmdsb2JhbEFscGhhPW47YS5maWxsUmVjdChmLGIsYy1mLGUtYik7YS5nbG9iYWxBbHBoYT0xOzA8aCYmKG49MD09PWglMj8wOjAuNSxhLmJlZ2luUGF0aCgpLGEubGluZVdpZHRoPWgsYS5zdHJva2VTdHlsZT1sLGEubW92ZVRvKGYsYiksYS5yZWN0KGYtbixiLW4sYy1mKzIqbixlLWIrMipuKSxhLnN0cm9rZSgpKTtcclxuYS5yZXN0b3JlKCk7ITA9PT10JiYoYS5zYXZlKCksYS5iZWdpblBhdGgoKSxhLm1vdmVUbyhmLGIpLGEubGluZVRvKGYrZCxiK2QpLGEubGluZVRvKGMtZCxiK2QpLGEubGluZVRvKGMsYiksYS5jbG9zZVBhdGgoKSxoPWEuY3JlYXRlTGluZWFyR3JhZGllbnQoKGMrZikvMixiK2QsKGMrZikvMixiKSxoLmFkZENvbG9yU3RvcCgwLGcpLGguYWRkQ29sb3JTdG9wKDEsXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIC40KVwiKSxhLmZpbGxTdHlsZT1oLGEuZmlsbCgpLGEucmVzdG9yZSgpKTshMD09PWsmJihhLnNhdmUoKSxhLmJlZ2luUGF0aCgpLGEubW92ZVRvKGYsZSksYS5saW5lVG8oZitkLGUtZCksYS5saW5lVG8oYy1kLGUtZCksYS5saW5lVG8oYyxlKSxhLmNsb3NlUGF0aCgpLGg9YS5jcmVhdGVMaW5lYXJHcmFkaWVudCgoYytmKS8yLGUtZCwoYytmKS8yLGUpLGguYWRkQ29sb3JTdG9wKDAsZyksaC5hZGRDb2xvclN0b3AoMSxcInJnYmEoMjU1LCAyNTUsIDI1NSwgLjQpXCIpLGEuZmlsbFN0eWxlPVxyXG5oLGEuZmlsbCgpLGEucmVzdG9yZSgpKTshMD09PXImJihhLnNhdmUoKSxhLmJlZ2luUGF0aCgpLGEubW92ZVRvKGYsYiksYS5saW5lVG8oZitkLGIrZCksYS5saW5lVG8oZitkLGUtZCksYS5saW5lVG8oZixlKSxhLmNsb3NlUGF0aCgpLGg9YS5jcmVhdGVMaW5lYXJHcmFkaWVudChmK2QsKGUrYikvMixmLChlK2IpLzIpLGguYWRkQ29sb3JTdG9wKDAsZyksaC5hZGRDb2xvclN0b3AoMSxcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKVwiKSxhLmZpbGxTdHlsZT1oLGEuZmlsbCgpLGEucmVzdG9yZSgpKTshMD09PXAmJihhLnNhdmUoKSxhLmJlZ2luUGF0aCgpLGEubW92ZVRvKGMsYiksYS5saW5lVG8oYy1kLGIrZCksYS5saW5lVG8oYy1kLGUtZCksYS5saW5lVG8oYyxlKSxoPWEuY3JlYXRlTGluZWFyR3JhZGllbnQoYy1kLChlK2IpLzIsYywoZStiKS8yKSxoLmFkZENvbG9yU3RvcCgwLGcpLGguYWRkQ29sb3JTdG9wKDEsXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSlcIiksYS5maWxsU3R5bGU9XHJcbmgsaC5hZGRDb2xvclN0b3AoMCxnKSxoLmFkZENvbG9yU3RvcCgxLFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpXCIpLGEuZmlsbFN0eWxlPWgsYS5maWxsKCksYS5jbG9zZVBhdGgoKSxhLnJlc3RvcmUoKSl9O3EucHJvdG90eXBlLnJlbmRlckNvbHVtbj1mdW5jdGlvbihhKXt2YXIgZj1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYj12P3RoaXMuX3ByZVJlbmRlckN0eDpmO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgYz1udWxsLGU9dGhpcy5wbG90QXJlYSxnPTAsaCxsLHQsaz1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoYS5heGlzWS5sb2dhcml0aG1pYz9hLmF4aXNZLnZpZXdwb3J0TWluaW11bTowKSxnPXRoaXMuZGF0YVBvaW50TWluV2lkdGg9dGhpcy5kYXRhUG9pbnRNaW5XaWR0aD90aGlzLmRhdGFQb2ludE1pbldpZHRoOnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDoxLHI9dGhpcy5kYXRhUG9pbnRNYXhXaWR0aD1cclxudGhpcy5kYXRhUG9pbnRNYXhXaWR0aD90aGlzLmRhdGFQb2ludE1heFdpZHRoOnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpNYXRoLm1pbigwLjE1KnRoaXMud2lkdGgsMC45Kih0aGlzLnBsb3RBcmVhLndpZHRoL2EucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKSk8PDAscD1hLmF4aXNYLmRhdGFJbmZvLm1pbkRpZmY7aXNGaW5pdGUocCl8fChwPTAuMypNYXRoLmFicyhhLmF4aXNYLnJhbmdlKSk7cD10aGlzLmRhdGFQb2ludFdpZHRoPXRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDowLjkqKGUud2lkdGgqKGEuYXhpc1gubG9nYXJpdGhtaWM/TWF0aC5sb2cocCkvTWF0aC5sb2coYS5heGlzWC5yYW5nZSk6TWF0aC5hYnMocCkvTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpL2EucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKTw8MDt0aGlzLmRhdGFQb2ludE1heFdpZHRoJiZnPnImJihnPU1hdGgubWluKHRoaXMuZGF0YVBvaW50V2lkdGg/XHJcbnRoaXMuZGF0YVBvaW50V2lkdGg6SW5maW5pdHkscikpOyF0aGlzLmRhdGFQb2ludE1heFdpZHRoJiYodGhpcy5kYXRhUG9pbnRNaW5XaWR0aCYmcjxnKSYmKHI9TWF0aC5tYXgodGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOi1JbmZpbml0eSxnKSk7cDxnJiYocD1nKTtwPnImJihwPXIpO2Iuc2F2ZSgpO3YmJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yi5iZWdpblBhdGgoKTtiLnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpO2IuY2xpcCgpO3YmJih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguYmVnaW5QYXRoKCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5jbGlwKCkpO2ZvcihyPTA7cjxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtyKyspe3ZhciBuPWEuZGF0YVNlcmllc0luZGV4ZXNbcl0sZD10aGlzLmRhdGFbbl0sXHJcbnc9ZC5kYXRhUG9pbnRzO2lmKDA8dy5sZW5ndGgpZm9yKHZhciBtPTU8cCYmZC5iZXZlbEVuYWJsZWQ/ITA6ITEsZz0wO2c8dy5sZW5ndGg7ZysrKWlmKHdbZ10uZ2V0VGltZT90PXdbZ10ueC5nZXRUaW1lKCk6dD13W2ddLngsISh0PGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fHQ+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCkmJlwibnVtYmVyXCI9PT10eXBlb2Ygd1tnXS55KXtoPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbCh0KTtsPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbCh3W2ddLnkpO2g9YS5heGlzWC5yZXZlcnNlZD9oK2EucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKnAvMi0oYS5wcmV2aW91c0RhdGFTZXJpZXNDb3VudCtyKSpwPDwwOmgtYS5wbG90VHlwZS50b3RhbERhdGFTZXJpZXMqcC8yKyhhLnByZXZpb3VzRGF0YVNlcmllc0NvdW50K3IpKnA8PDA7dmFyIEQ9YS5heGlzWC5yZXZlcnNlZD9oLXA8PDA6aCtwPDwwLHU7MDw9d1tnXS55P3U9azoodT1cclxubCxsPWspO2w+dSYmKGM9bCxsPXUsdT1jKTtjPXdbZ10uY29sb3I/d1tnXS5jb2xvcjpkLl9jb2xvclNldFtnJWQuX2NvbG9yU2V0Lmxlbmd0aF07VihiLGgsbCxELHUsYywwLG51bGwsbSYmMDw9d1tnXS55LDA+d1tnXS55JiZtLCExLCExLGQuZmlsbE9wYWNpdHkpO2M9ZC5kYXRhUG9pbnRJZHNbZ107dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtjXT17aWQ6YyxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4Om4sZGF0YVBvaW50SW5kZXg6Zyx4MTpoLHkxOmwseDI6RCx5Mjp1fTtjPVIoYyk7diYmVih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsaCxsLEQsdSxjLDAsbnVsbCwhMSwhMSwhMSwhMSk7KHdbZ10uaW5kZXhMYWJlbHx8ZC5pbmRleExhYmVsfHx3W2ddLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fGQuaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcImNvbHVtblwiLGRhdGFQb2ludDp3W2ddLGRhdGFTZXJpZXM6ZCxcclxucG9pbnQ6e3g6aCsoRC1oKS8yLHk6MD53W2ddLnk9PT1hLmF4aXNZLnJldmVyc2VkP2w6dX0sZGlyZWN0aW9uOjA+d1tnXS55PT09YS5heGlzWS5yZXZlcnNlZD8xOi0xLGJvdW5kczp7eDE6aCx5MTpNYXRoLm1pbihsLHUpLHgyOkQseTI6TWF0aC5tYXgobCx1KX0sY29sb3I6Y30pfX12JiYoZi5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLFxyXG4wLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5jbGVhclJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2IucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZixkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOkgueVNjYWxlQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmVhc2VPdXRRdWFydCxhbmltYXRpb25CYXNlOms8YS5heGlzWS5ib3VuZHMueTE/YS5heGlzWS5ib3VuZHMueTE6az5hLmF4aXNZLmJvdW5kcy55Mj9hLmF4aXNZLmJvdW5kcy55MjprfX19O3EucHJvdG90eXBlLnJlbmRlclN0YWNrZWRDb2x1bW49ZnVuY3Rpb24oYSl7dmFyIGY9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGI9dj90aGlzLl9wcmVSZW5kZXJDdHg6ZjtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGM9bnVsbCxlPXRoaXMucGxvdEFyZWEsXHJcbmc9W10saD1bXSxsPVtdLHQ9W10saz0wLHIscCxuPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP2EuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLGs9dGhpcy5kYXRhUG9pbnRNaW5XaWR0aD90aGlzLmRhdGFQb2ludE1pbldpZHRoOnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDoxO3I9dGhpcy5kYXRhUG9pbnRNYXhXaWR0aD90aGlzLmRhdGFQb2ludE1heFdpZHRoOnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDowLjE1KnRoaXMud2lkdGg8PDA7dmFyIGQ9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKGQpfHwoZD0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO2Q9dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuOSooZS53aWR0aCooYS5heGlzWC5sb2dhcml0aG1pYz9NYXRoLmxvZyhkKS9NYXRoLmxvZyhhLmF4aXNYLnJhbmdlKTpNYXRoLmFicyhkKS9cclxuTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpL2EucGxvdFR5cGUucGxvdFVuaXRzLmxlbmd0aCk8PDA7dGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmaz5yJiYoaz1NYXRoLm1pbih0aGlzLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6SW5maW5pdHkscikpOyF0aGlzLmRhdGFQb2ludE1heFdpZHRoJiYodGhpcy5kYXRhUG9pbnRNaW5XaWR0aCYmcjxrKSYmKHI9TWF0aC5tYXgodGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOi1JbmZpbml0eSxrKSk7ZDxrJiYoZD1rKTtkPnImJihkPXIpO2Iuc2F2ZSgpO3YmJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yi5iZWdpblBhdGgoKTtiLnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpO2IuY2xpcCgpO3YmJih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguYmVnaW5QYXRoKCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLFxyXG50aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguY2xpcCgpKTtmb3IodmFyIHc9MDt3PGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO3crKyl7dmFyIG09YS5kYXRhU2VyaWVzSW5kZXhlc1t3XSxEPXRoaXMuZGF0YVttXSx1PUQuZGF0YVBvaW50cztpZigwPHUubGVuZ3RoKXt2YXIgcT01PGQmJkQuYmV2ZWxFbmFibGVkPyEwOiExO2Iuc3Ryb2tlU3R5bGU9XCIjNDU3MkE3IFwiO2ZvcihrPTA7azx1Lmxlbmd0aDtrKyspaWYoYz11W2tdLnguZ2V0VGltZT91W2tdLnguZ2V0VGltZSgpOnVba10ueCwhKGM8YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1pbnx8Yz5hLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWF4KSYmXCJudW1iZXJcIj09PXR5cGVvZiB1W2tdLnkpe3I9YS5heGlzWC5jb252ZXJ0VmFsdWVUb1BpeGVsKGMpO3ZhciBzPXItYS5wbG90VHlwZS5wbG90VW5pdHMubGVuZ3RoKmQvMithLmluZGV4KmQ8PDAseT1zK2Q8PDAsQjtpZihhLmF4aXNZLmxvZ2FyaXRobWljfHxhLmF4aXNZLnNjYWxlQnJlYWtzJiZcclxuMDxhLmF4aXNZLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aCYmMDx1W2tdLnkpbFtjXT11W2tdLnkrKGxbY10/bFtjXTowKSwwPGxbY10mJihwPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChsW2NdKSxCPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgZ1tjXT9nW2NdOm4sZ1tjXT1wKTtlbHNlIGlmKGEuYXhpc1kuc2NhbGVCcmVha3MmJjA8YS5heGlzWS5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgmJjA+PXVba10ueSl0W2NdPXVba10ueSsodFtjXT90W2NdOjApLEI9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHRbY10pLHA9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBoW2NdP2hbY106bixoW2NdPUI7ZWxzZSBpZihwPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbCh1W2tdLnkpLDA8PXVba10ueSl7dmFyIEE9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBnW2NdP2dbY106MDtwLT1BO0I9bi1BO2dbY109QSsoQi1wKX1lbHNlIEE9aFtjXT9oW2NdOjAsQj1wK0EsXHJcbnA9bitBLGhbY109QSsoQi1wKTtjPXVba10uY29sb3I/dVtrXS5jb2xvcjpELl9jb2xvclNldFtrJUQuX2NvbG9yU2V0Lmxlbmd0aF07VihiLHMscCx5LEIsYywwLG51bGwscSYmMDw9dVtrXS55LDA+dVtrXS55JiZxLCExLCExLEQuZmlsbE9wYWNpdHkpO2M9RC5kYXRhUG9pbnRJZHNba107dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtjXT17aWQ6YyxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4Om0sZGF0YVBvaW50SW5kZXg6ayx4MTpzLHkxOnAseDI6eSx5MjpCfTtjPVIoYyk7diYmVih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgscyxwLHksQixjLDAsbnVsbCwhMSwhMSwhMSwhMSk7KHVba10uaW5kZXhMYWJlbHx8RC5pbmRleExhYmVsfHx1W2tdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fEQuaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcInN0YWNrZWRDb2x1bW5cIixkYXRhUG9pbnQ6dVtrXSxkYXRhU2VyaWVzOkQsXHJcbnBvaW50Ont4OnIseTowPD11W2tdLnk/cDpCfSxkaXJlY3Rpb246MD51W2tdLnk9PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsYm91bmRzOnt4MTpzLHkxOk1hdGgubWluKHAsQikseDI6eSx5MjpNYXRoLm1heChwLEIpfSxjb2xvcjpjfSl9fX12JiYoZi5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxcclxuYi5jbGVhclJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2IucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZixkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOkgueVNjYWxlQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmVhc2VPdXRRdWFydCxhbmltYXRpb25CYXNlOm48YS5heGlzWS5ib3VuZHMueTE/YS5heGlzWS5ib3VuZHMueTE6bj5hLmF4aXNZLmJvdW5kcy55Mj9hLmF4aXNZLmJvdW5kcy55MjpufX19O3EucHJvdG90eXBlLnJlbmRlclN0YWNrZWRDb2x1bW4xMDA9ZnVuY3Rpb24oYSl7dmFyIGY9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGI9dj90aGlzLl9wcmVSZW5kZXJDdHg6ZjtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGM9bnVsbCxlPXRoaXMucGxvdEFyZWEsZz1bXSxoPVtdLGw9W10sdD1bXSxrPTAsXHJcbnIscCxuPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP2EuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLGs9dGhpcy5kYXRhUG9pbnRNaW5XaWR0aD90aGlzLmRhdGFQb2ludE1pbldpZHRoOnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDoxO3I9dGhpcy5kYXRhUG9pbnRNYXhXaWR0aD90aGlzLmRhdGFQb2ludE1heFdpZHRoOnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDowLjE1KnRoaXMud2lkdGg8PDA7dmFyIGQ9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKGQpfHwoZD0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO2Q9dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuOSooZS53aWR0aCooYS5heGlzWC5sb2dhcml0aG1pYz9NYXRoLmxvZyhkKS9NYXRoLmxvZyhhLmF4aXNYLnJhbmdlKTpNYXRoLmFicyhkKS9NYXRoLmFicyhhLmF4aXNYLnJhbmdlKSkvXHJcbmEucGxvdFR5cGUucGxvdFVuaXRzLmxlbmd0aCk8PDA7dGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmaz5yJiYoaz1NYXRoLm1pbih0aGlzLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6SW5maW5pdHkscikpOyF0aGlzLmRhdGFQb2ludE1heFdpZHRoJiYodGhpcy5kYXRhUG9pbnRNaW5XaWR0aCYmcjxrKSYmKHI9TWF0aC5tYXgodGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOi1JbmZpbml0eSxrKSk7ZDxrJiYoZD1rKTtkPnImJihkPXIpO2Iuc2F2ZSgpO3YmJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yi5iZWdpblBhdGgoKTtiLnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpO2IuY2xpcCgpO3YmJih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguYmVnaW5QYXRoKCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5jbGlwKCkpO1xyXG5mb3IodmFyIHc9MDt3PGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO3crKyl7dmFyIG09YS5kYXRhU2VyaWVzSW5kZXhlc1t3XSxEPXRoaXMuZGF0YVttXSx1PUQuZGF0YVBvaW50cztpZigwPHUubGVuZ3RoKWZvcih2YXIgcT01PGQmJkQuYmV2ZWxFbmFibGVkPyEwOiExLGs9MDtrPHUubGVuZ3RoO2srKylpZihjPXVba10ueC5nZXRUaW1lP3Vba10ueC5nZXRUaW1lKCk6dVtrXS54LCEoYzxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxjPmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgpJiZcIm51bWJlclwiPT09dHlwZW9mIHVba10ueSl7cj1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoYyk7cD0wIT09YS5kYXRhUG9pbnRZU3Vtc1tjXT8xMDAqKHVba10ueS9hLmRhdGFQb2ludFlTdW1zW2NdKTowO3ZhciBzPXItYS5wbG90VHlwZS5wbG90VW5pdHMubGVuZ3RoKmQvMithLmluZGV4KmQ8PDAseT1zK2Q8PDAsQjtpZihhLmF4aXNZLmxvZ2FyaXRobWljfHxhLmF4aXNZLnNjYWxlQnJlYWtzJiZcclxuMDxhLmF4aXNZLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aCYmMDx1W2tdLnkpe2xbY109cCsoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsW2NdP2xbY106MCk7aWYoMD49bFtjXSljb250aW51ZTtwPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChsW2NdKTtCPWdbY10/Z1tjXTpuO2dbY109cH1lbHNlIGlmKGEuYXhpc1kuc2NhbGVCcmVha3MmJjA8YS5heGlzWS5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgmJjA+PXVba10ueSl0W2NdPXArKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgdFtjXT90W2NdOjApLEI9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHRbY10pLHA9aFtjXT9oW2NdOm4saFtjXT1CO2Vsc2UgaWYocD1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwocCksMDw9dVtrXS55KXt2YXIgQT1cInVuZGVmaW5lZFwiIT09dHlwZW9mIGdbY10/Z1tjXTowO3AtPUE7Qj1uLUE7Z1tjXT1BKyhCLXApfWVsc2UgQT1cInVuZGVmaW5lZFwiIT09dHlwZW9mIGhbY10/XHJcbmhbY106MCxCPXArQSxwPW4rQSxoW2NdPUErKEItcCk7Yz11W2tdLmNvbG9yP3Vba10uY29sb3I6RC5fY29sb3JTZXRbayVELl9jb2xvclNldC5sZW5ndGhdO1YoYixzLHAseSxCLGMsMCxudWxsLHEmJjA8PXVba10ueSwwPnVba10ueSYmcSwhMSwhMSxELmZpbGxPcGFjaXR5KTtjPUQuZGF0YVBvaW50SWRzW2tdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbY109e2lkOmMsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDptLGRhdGFQb2ludEluZGV4OmsseDE6cyx5MTpwLHgyOnkseTI6Qn07Yz1SKGMpO3YmJlYodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LHMscCx5LEIsYywwLG51bGwsITEsITEsITEsITEpOyh1W2tdLmluZGV4TGFiZWx8fEQuaW5kZXhMYWJlbHx8dVtrXS5pbmRleExhYmVsRm9ybWF0dGVyfHxELmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJzdGFja2VkQ29sdW1uMTAwXCIsZGF0YVBvaW50OnVba10sXHJcbmRhdGFTZXJpZXM6RCxwb2ludDp7eDpyLHk6MDw9dVtrXS55P3A6Qn0sZGlyZWN0aW9uOjA+dVtrXS55PT09YS5heGlzWS5yZXZlcnNlZD8xOi0xLGJvdW5kczp7eDE6cyx5MTpNYXRoLm1pbihwLEIpLHgyOnkseTI6TWF0aC5tYXgocCxCKX0sY29sb3I6Y30pfX12JiYoZi5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLFxyXG50aGlzLmhlaWdodCksYi5jbGVhclJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2IucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZixkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOkgueVNjYWxlQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmVhc2VPdXRRdWFydCxhbmltYXRpb25CYXNlOm48YS5heGlzWS5ib3VuZHMueTE/YS5heGlzWS5ib3VuZHMueTE6bj5hLmF4aXNZLmJvdW5kcy55Mj9hLmF4aXNZLmJvdW5kcy55MjpufX19O3EucHJvdG90eXBlLnJlbmRlckJhcj1mdW5jdGlvbihhKXt2YXIgZj1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYj12P3RoaXMuX3ByZVJlbmRlckN0eDpmO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgYz1udWxsLGU9dGhpcy5wbG90QXJlYSxnPTAsaCxsLHQsaz1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoYS5heGlzWS5sb2dhcml0aG1pYz9cclxuYS5heGlzWS52aWV3cG9ydE1pbmltdW06MCksZz10aGlzLmRhdGFQb2ludE1pbldpZHRoP3RoaXMuZGF0YVBvaW50TWluV2lkdGg6dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjEscj10aGlzLmRhdGFQb2ludE1heFdpZHRoP3RoaXMuZGF0YVBvaW50TWF4V2lkdGg6dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOk1hdGgubWluKDAuMTUqdGhpcy5oZWlnaHQsMC45Kih0aGlzLnBsb3RBcmVhLmhlaWdodC9hLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcykpPDwwLHA9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKHApfHwocD0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO3A9dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuOSooZS5oZWlnaHQqKGEuYXhpc1gubG9nYXJpdGhtaWM/TWF0aC5sb2cocCkvTWF0aC5sb2coYS5heGlzWC5yYW5nZSk6TWF0aC5hYnMocCkvTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpL1xyXG5hLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcyk8PDA7dGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmZz5yJiYoZz1NYXRoLm1pbih0aGlzLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6SW5maW5pdHkscikpOyF0aGlzLmRhdGFQb2ludE1heFdpZHRoJiYodGhpcy5kYXRhUG9pbnRNaW5XaWR0aCYmcjxnKSYmKHI9TWF0aC5tYXgodGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOi1JbmZpbml0eSxnKSk7cDxnJiYocD1nKTtwPnImJihwPXIpO2Iuc2F2ZSgpO3YmJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yi5iZWdpblBhdGgoKTtiLnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpO2IuY2xpcCgpO3YmJih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguYmVnaW5QYXRoKCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5jbGlwKCkpO1xyXG5mb3Iocj0wO3I8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7cisrKXt2YXIgbj1hLmRhdGFTZXJpZXNJbmRleGVzW3JdLGQ9dGhpcy5kYXRhW25dLHc9ZC5kYXRhUG9pbnRzO2lmKDA8dy5sZW5ndGgpe3ZhciBtPTU8cCYmZC5iZXZlbEVuYWJsZWQ/ITA6ITE7Yi5zdHJva2VTdHlsZT1cIiM0NTcyQTcgXCI7Zm9yKGc9MDtnPHcubGVuZ3RoO2crKylpZih3W2ddLmdldFRpbWU/dD13W2ddLnguZ2V0VGltZSgpOnQ9d1tnXS54LCEodDxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHx0PmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgpJiZcIm51bWJlclwiPT09dHlwZW9mIHdbZ10ueSl7bD1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwodCk7aD1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwod1tnXS55KTtsPWEuYXhpc1gucmV2ZXJzZWQ/bCthLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcypwLzItKGEucHJldmlvdXNEYXRhU2VyaWVzQ291bnQrcikqcDw8MDpsLWEucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKlxyXG5wLzIrKGEucHJldmlvdXNEYXRhU2VyaWVzQ291bnQrcikqcDw8MDt2YXIgRD1hLmF4aXNYLnJldmVyc2VkP2wtcDw8MDpsK3A8PDAsdTswPD13W2ddLnk/dT1rOih1PWgsaD1rKTtjPXdbZ10uY29sb3I/d1tnXS5jb2xvcjpkLl9jb2xvclNldFtnJWQuX2NvbG9yU2V0Lmxlbmd0aF07VihiLHUsbCxoLEQsYywwLG51bGwsbSwhMSwhMSwhMSxkLmZpbGxPcGFjaXR5KTtjPWQuZGF0YVBvaW50SWRzW2ddO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbY109e2lkOmMsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpuLGRhdGFQb2ludEluZGV4OmcseDE6dSx5MTpsLHgyOmgseTI6RH07Yz1SKGMpO3YmJlYodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LHUsbCxoLEQsYywwLG51bGwsITEsITEsITEsITEpOyh3W2ddLmluZGV4TGFiZWx8fGQuaW5kZXhMYWJlbHx8d1tnXS5pbmRleExhYmVsRm9ybWF0dGVyfHxkLmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJiYXJcIixcclxuZGF0YVBvaW50OndbZ10sZGF0YVNlcmllczpkLHBvaW50Ont4OjA8PXdbZ10ueT9oOnUseTpsKyhELWwpLzJ9LGRpcmVjdGlvbjowPndbZ10ueT09PWEuYXhpc1kucmV2ZXJzZWQ/MTotMSxib3VuZHM6e3gxOk1hdGgubWluKHUsaCkseTE6bCx4MjpNYXRoLm1heCh1LGgpLHkyOkR9LGNvbG9yOmN9KX19fXYmJihmLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGIuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmIuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsXHJcbjAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmNsZWFyUmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlc3RvcmUoKSk7Yi5yZXN0b3JlKCk7cmV0dXJue3NvdXJjZTpmLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6SC54U2NhbGVBbmltYXRpb24sZWFzaW5nRnVuY3Rpb246SC5lYXNpbmcuZWFzZU91dFF1YXJ0LGFuaW1hdGlvbkJhc2U6azxhLmF4aXNZLmJvdW5kcy54MT9hLmF4aXNZLmJvdW5kcy54MTprPmEuYXhpc1kuYm91bmRzLngyP2EuYXhpc1kuYm91bmRzLngyOmt9fX07cS5wcm90b3R5cGUucmVuZGVyU3RhY2tlZEJhcj1mdW5jdGlvbihhKXt2YXIgZj1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYj12P3RoaXMuX3ByZVJlbmRlckN0eDpmO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgYz1udWxsLGU9dGhpcy5wbG90QXJlYSxnPVxyXG5bXSxoPVtdLGw9W10sdD1bXSxrPTAscixwLG49YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKGEuYXhpc1kubG9nYXJpdGhtaWM/YS5heGlzWS52aWV3cG9ydE1pbmltdW06MCksaz10aGlzLmRhdGFQb2ludE1pbldpZHRoP3RoaXMuZGF0YVBvaW50TWluV2lkdGg6dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjE7cD10aGlzLmRhdGFQb2ludE1heFdpZHRoP3RoaXMuZGF0YVBvaW50TWF4V2lkdGg6dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuMTUqdGhpcy5oZWlnaHQ8PDA7dmFyIGQ9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKGQpfHwoZD0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO2Q9dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuOSooZS5oZWlnaHQqKGEuYXhpc1gubG9nYXJpdGhtaWM/TWF0aC5sb2coZCkvTWF0aC5sb2coYS5heGlzWC5yYW5nZSk6TWF0aC5hYnMoZCkvXHJcbk1hdGguYWJzKGEuYXhpc1gucmFuZ2UpKS9hLnBsb3RUeXBlLnBsb3RVbml0cy5sZW5ndGgpPDwwO3RoaXMuZGF0YVBvaW50TWF4V2lkdGgmJms+cCYmKGs9TWF0aC5taW4odGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOkluZmluaXR5LHApKTshdGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmKHRoaXMuZGF0YVBvaW50TWluV2lkdGgmJnA8aykmJihwPU1hdGgubWF4KHRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDotSW5maW5pdHksaykpO2Q8ayYmKGQ9ayk7ZD5wJiYoZD1wKTtiLnNhdmUoKTt2JiZ0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguc2F2ZSgpO2IuYmVnaW5QYXRoKCk7Yi5yZWN0KGUueDEsZS55MSxlLndpZHRoLGUuaGVpZ2h0KTtiLmNsaXAoKTt2JiYodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmJlZ2luUGF0aCgpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZWN0KGUueDEsZS55MSxlLndpZHRoLGUuaGVpZ2h0KSxcclxudGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmNsaXAoKSk7Zm9yKHZhciB3PTA7dzxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDt3Kyspe3ZhciBtPWEuZGF0YVNlcmllc0luZGV4ZXNbd10sRD10aGlzLmRhdGFbbV0sdT1ELmRhdGFQb2ludHM7aWYoMDx1Lmxlbmd0aCl7dmFyIHE9NTxkJiZELmJldmVsRW5hYmxlZD8hMDohMTtiLnN0cm9rZVN0eWxlPVwiIzQ1NzJBNyBcIjtmb3Ioaz0wO2s8dS5sZW5ndGg7aysrKWlmKGM9dVtrXS54LmdldFRpbWU/dVtrXS54LmdldFRpbWUoKTp1W2tdLngsIShjPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fGM+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCkmJlwibnVtYmVyXCI9PT10eXBlb2YgdVtrXS55KXtwPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChjKTt2YXIgcz1wLWEucGxvdFR5cGUucGxvdFVuaXRzLmxlbmd0aCpkLzIrYS5pbmRleCpkPDwwLHk9cytkPDwwLEI7aWYoYS5heGlzWS5sb2dhcml0aG1pY3x8YS5heGlzWS5zY2FsZUJyZWFrcyYmXHJcbjA8YS5heGlzWS5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgmJjA8dVtrXS55KWxbY109dVtrXS55KyhsW2NdP2xbY106MCksMDxsW2NdJiYoQj1nW2NdP2dbY106bixnW2NdPXI9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKGxbY10pKTtlbHNlIGlmKGEuYXhpc1kuc2NhbGVCcmVha3MmJjA8YS5heGlzWS5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgmJjA+PXVba10ueSl0W2NdPXVba10ueSsodFtjXT90W2NdOjApLHI9aFtjXT9oW2NdOm4saFtjXT1CPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbCh0W2NdKTtlbHNlIGlmKHI9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHVba10ueSksMDw9dVtrXS55KXt2YXIgQT1nW2NdP2dbY106MDtCPW4rQTtyKz1BO2dbY109QSsoci1CKX1lbHNlIEE9aFtjXT9oW2NdOjAsQj1yLUEscj1uLUEsaFtjXT1BKyhyLUIpO2M9dVtrXS5jb2xvcj91W2tdLmNvbG9yOkQuX2NvbG9yU2V0W2slRC5fY29sb3JTZXQubGVuZ3RoXTtcclxuVihiLEIscyxyLHksYywwLG51bGwscSwhMSwhMSwhMSxELmZpbGxPcGFjaXR5KTtjPUQuZGF0YVBvaW50SWRzW2tdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbY109e2lkOmMsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDptLGRhdGFQb2ludEluZGV4OmsseDE6Qix5MTpzLHgyOnIseTI6eX07Yz1SKGMpO3YmJlYodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LEIscyxyLHksYywwLG51bGwsITEsITEsITEsITEpOyh1W2tdLmluZGV4TGFiZWx8fEQuaW5kZXhMYWJlbHx8dVtrXS5pbmRleExhYmVsRm9ybWF0dGVyfHxELmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJzdGFja2VkQmFyXCIsZGF0YVBvaW50OnVba10sZGF0YVNlcmllczpELHBvaW50Ont4OjA8PXVba10ueT9yOkIseTpwfSxkaXJlY3Rpb246MD51W2tdLnk9PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsYm91bmRzOnt4MTpNYXRoLm1pbihCLFxyXG5yKSx5MTpzLHgyOk1hdGgubWF4KEIscikseTI6eX0sY29sb3I6Y30pfX19diYmKGYuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmIuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZ0aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5jbGVhclJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2IucmVzdG9yZSgpO1xyXG5yZXR1cm57c291cmNlOmYsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpILnhTY2FsZUFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpILmVhc2luZy5lYXNlT3V0UXVhcnQsYW5pbWF0aW9uQmFzZTpuPGEuYXhpc1kuYm91bmRzLngxP2EuYXhpc1kuYm91bmRzLngxOm4+YS5heGlzWS5ib3VuZHMueDI/YS5heGlzWS5ib3VuZHMueDI6bn19fTtxLnByb3RvdHlwZS5yZW5kZXJTdGFja2VkQmFyMTAwPWZ1bmN0aW9uKGEpe3ZhciBmPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxiPXY/dGhpcy5fcHJlUmVuZGVyQ3R4OmY7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBjPW51bGwsZT10aGlzLnBsb3RBcmVhLGc9W10saD1bXSxsPVtdLHQ9W10saz0wLHIscCxuPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP2EuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLGs9dGhpcy5kYXRhUG9pbnRNaW5XaWR0aD9cclxudGhpcy5kYXRhUG9pbnRNaW5XaWR0aDp0aGlzLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MTtwPXRoaXMuZGF0YVBvaW50TWF4V2lkdGg/dGhpcy5kYXRhUG9pbnRNYXhXaWR0aDp0aGlzLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MC4xNSp0aGlzLmhlaWdodDw8MDt2YXIgZD1hLmF4aXNYLmRhdGFJbmZvLm1pbkRpZmY7aXNGaW5pdGUoZCl8fChkPTAuMypNYXRoLmFicyhhLmF4aXNYLnJhbmdlKSk7ZD10aGlzLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MC45KihlLmhlaWdodCooYS5heGlzWC5sb2dhcml0aG1pYz9NYXRoLmxvZyhkKS9NYXRoLmxvZyhhLmF4aXNYLnJhbmdlKTpNYXRoLmFicyhkKS9NYXRoLmFicyhhLmF4aXNYLnJhbmdlKSkvYS5wbG90VHlwZS5wbG90VW5pdHMubGVuZ3RoKTw8MDt0aGlzLmRhdGFQb2ludE1heFdpZHRoJiZrPnAmJihrPU1hdGgubWluKHRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpcclxuSW5maW5pdHkscCkpOyF0aGlzLmRhdGFQb2ludE1heFdpZHRoJiYodGhpcy5kYXRhUG9pbnRNaW5XaWR0aCYmcDxrKSYmKHA9TWF0aC5tYXgodGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOi1JbmZpbml0eSxrKSk7ZDxrJiYoZD1rKTtkPnAmJihkPXApO2Iuc2F2ZSgpO3YmJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yi5iZWdpblBhdGgoKTtiLnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpO2IuY2xpcCgpO3YmJih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguYmVnaW5QYXRoKCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5jbGlwKCkpO2Zvcih2YXIgdz0wO3c8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7dysrKXt2YXIgbT1hLmRhdGFTZXJpZXNJbmRleGVzW3ddLEQ9dGhpcy5kYXRhW21dLHU9RC5kYXRhUG9pbnRzO1xyXG5pZigwPHUubGVuZ3RoKXt2YXIgcT01PGQmJkQuYmV2ZWxFbmFibGVkPyEwOiExO2Iuc3Ryb2tlU3R5bGU9XCIjNDU3MkE3IFwiO2ZvcihrPTA7azx1Lmxlbmd0aDtrKyspaWYoYz11W2tdLnguZ2V0VGltZT91W2tdLnguZ2V0VGltZSgpOnVba10ueCwhKGM8YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1pbnx8Yz5hLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWF4KSYmXCJudW1iZXJcIj09PXR5cGVvZiB1W2tdLnkpe3A9YS5heGlzWC5jb252ZXJ0VmFsdWVUb1BpeGVsKGMpO3ZhciBzO3M9MCE9PWEuZGF0YVBvaW50WVN1bXNbY10/MTAwKih1W2tdLnkvYS5kYXRhUG9pbnRZU3Vtc1tjXSk6MDt2YXIgeT1wLWEucGxvdFR5cGUucGxvdFVuaXRzLmxlbmd0aCpkLzIrYS5pbmRleCpkPDwwLEI9eStkPDwwO2lmKGEuYXhpc1kubG9nYXJpdGhtaWN8fGEuYXhpc1kuc2NhbGVCcmVha3MmJjA8YS5heGlzWS5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgmJjA8dVtrXS55KXtsW2NdPXMrXHJcbihsW2NdP2xbY106MCk7aWYoMD49bFtjXSljb250aW51ZTtzPWdbY10/Z1tjXTpuO2dbY109cj1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwobFtjXSl9ZWxzZSBpZihhLmF4aXNZLnNjYWxlQnJlYWtzJiYwPGEuYXhpc1kuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MubGVuZ3RoJiYwPj11W2tdLnkpdFtjXT1zKyh0W2NdP3RbY106MCkscj1oW2NdP2hbY106bixoW2NdPXM9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHRbY10pO2Vsc2UgaWYocj1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwocyksMDw9dVtrXS55KXt2YXIgQT1nW2NdP2dbY106MDtzPW4rQTtyKz1BO2dbY109QSsoci1zKX1lbHNlIEE9aFtjXT9oW2NdOjAscz1yLUEscj1uLUEsaFtjXT1BKyhyLXMpO2M9dVtrXS5jb2xvcj91W2tdLmNvbG9yOkQuX2NvbG9yU2V0W2slRC5fY29sb3JTZXQubGVuZ3RoXTtWKGIscyx5LHIsQixjLDAsbnVsbCxxLCExLCExLCExLEQuZmlsbE9wYWNpdHkpO2M9RC5kYXRhUG9pbnRJZHNba107XHJcbnRoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbY109e2lkOmMsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDptLGRhdGFQb2ludEluZGV4OmsseDE6cyx5MTp5LHgyOnIseTI6Qn07Yz1SKGMpO3YmJlYodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LHMseSxyLEIsYywwLG51bGwsITEsITEsITEsITEpOyh1W2tdLmluZGV4TGFiZWx8fEQuaW5kZXhMYWJlbHx8dVtrXS5pbmRleExhYmVsRm9ybWF0dGVyfHxELmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJzdGFja2VkQmFyMTAwXCIsZGF0YVBvaW50OnVba10sZGF0YVNlcmllczpELHBvaW50Ont4OjA8PXVba10ueT9yOnMseTpwfSxkaXJlY3Rpb246MD51W2tdLnk9PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsYm91bmRzOnt4MTpNYXRoLm1pbihzLHIpLHkxOnkseDI6TWF0aC5tYXgocyxyKSx5MjpCfSxjb2xvcjpjfSl9fX12JiYoZi5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLFxyXG4wLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmIuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZ0aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5jbGVhclJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2IucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZixkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOkgueFNjYWxlQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmVhc2VPdXRRdWFydCxcclxuYW5pbWF0aW9uQmFzZTpuPGEuYXhpc1kuYm91bmRzLngxP2EuYXhpc1kuYm91bmRzLngxOm4+YS5heGlzWS5ib3VuZHMueDI/YS5heGlzWS5ib3VuZHMueDI6bn19fTtxLnByb3RvdHlwZS5yZW5kZXJBcmVhPWZ1bmN0aW9uKGEpe3ZhciBmLGI7ZnVuY3Rpb24gYygpe0EmJigwPHcubGluZVRoaWNrbmVzcyYmZy5zdHJva2UoKSxhLmF4aXNZLmxvZ2FyaXRobWljfHwwPj1hLmF4aXNZLnZpZXdwb3J0TWluaW11bSYmMDw9YS5heGlzWS52aWV3cG9ydE1heGltdW0/Qj15OjA+YS5heGlzWS52aWV3cG9ydE1heGltdW0/Qj10LnkxOjA8YS5heGlzWS52aWV3cG9ydE1pbmltdW0mJihCPWwueTIpLGcubGluZVRvKHUsQiksZy5saW5lVG8oQS54LEIpLGcuY2xvc2VQYXRoKCksZy5nbG9iYWxBbHBoYT13LmZpbGxPcGFjaXR5LGcuZmlsbCgpLGcuZ2xvYmFsQWxwaGE9MSx2JiYoaC5saW5lVG8odSxCKSxoLmxpbmVUbyhBLngsQiksaC5jbG9zZVBhdGgoKSxoLmZpbGwoKSksZy5iZWdpblBhdGgoKSxcclxuZy5tb3ZlVG8odSxzKSxoLmJlZ2luUGF0aCgpLGgubW92ZVRvKHUscyksQT17eDp1LHk6c30pfXZhciBlPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxnPXY/dGhpcy5fcHJlUmVuZGVyQ3R4OmU7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBoPXRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eCxsPWEuYXhpc1gubGluZUNvb3JkaW5hdGVzLHQ9YS5heGlzWS5saW5lQ29vcmRpbmF0ZXMsaz1bXSxyPXRoaXMucGxvdEFyZWEscDtnLnNhdmUoKTt2JiZoLnNhdmUoKTtnLmJlZ2luUGF0aCgpO2cucmVjdChyLngxLHIueTEsci53aWR0aCxyLmhlaWdodCk7Zy5jbGlwKCk7diYmKGguYmVnaW5QYXRoKCksaC5yZWN0KHIueDEsci55MSxyLndpZHRoLHIuaGVpZ2h0KSxoLmNsaXAoKSk7Zm9yKHZhciBuPTA7bjxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtuKyspe3ZhciBkPWEuZGF0YVNlcmllc0luZGV4ZXNbbl0sdz10aGlzLmRhdGFbZF0sXHJcbm09dy5kYXRhUG9pbnRzLGs9dy5pZDt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2tdPXtvYmplY3RUeXBlOlwiZGF0YVNlcmllc1wiLGRhdGFTZXJpZXNJbmRleDpkfTtrPVIoayk7aC5maWxsU3R5bGU9aztrPVtdO2Y9ITA7dmFyIEQ9MCx1LHMscSx5PWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP2EuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLEIsQT1udWxsO2lmKDA8bS5sZW5ndGgpe3ZhciB4PXcuX2NvbG9yU2V0W0Qldy5fY29sb3JTZXQubGVuZ3RoXSx6PXcubGluZUNvbG9yPXcub3B0aW9ucy5saW5lQ29sb3J8fHgsSj16O2cuZmlsbFN0eWxlPXg7Zy5zdHJva2VTdHlsZT16O2cubGluZVdpZHRoPXcubGluZVRoaWNrbmVzcztiPVwic29saWRcIjtpZihnLnNldExpbmVEYXNoKXt2YXIgST1HKHcubnVsbERhdGFMaW5lRGFzaFR5cGUsdy5saW5lVGhpY2tuZXNzKTtiPXcubGluZURhc2hUeXBlO3ZhciBkYT1HKGIsdy5saW5lVGhpY2tuZXNzKTtcclxuZy5zZXRMaW5lRGFzaChkYSl9Zm9yKHZhciBlYT0hMDtEPG0ubGVuZ3RoO0QrKylpZihxPW1bRF0ueC5nZXRUaW1lP21bRF0ueC5nZXRUaW1lKCk6bVtEXS54LCEocTxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxxPmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgmJighdy5jb25uZWN0TnVsbERhdGF8fCFlYSkpKWlmKFwibnVtYmVyXCIhPT10eXBlb2YgbVtEXS55KXcuY29ubmVjdE51bGxEYXRhfHwoZWF8fGYpfHxjKCksZWE9ITA7ZWxzZXt1PWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChxKTtzPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChtW0RdLnkpO2Z8fGVhPyghZiYmdy5jb25uZWN0TnVsbERhdGE/KGcuc2V0TGluZURhc2gmJih3Lm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fGI9PT13LmxpbmVEYXNoVHlwZSYmdy5saW5lRGFzaFR5cGUhPT13Lm51bGxEYXRhTGluZURhc2hUeXBlKSYmKGY9dSxiPXMsdT1wLngscz1wLnksYygpLGcubW92ZVRvKHAueCxcclxucC55KSx1PWYscz1iLEE9cCxiPXcubnVsbERhdGFMaW5lRGFzaFR5cGUsZy5zZXRMaW5lRGFzaChJKSksZy5saW5lVG8odSxzKSx2JiZoLmxpbmVUbyh1LHMpKTooZy5iZWdpblBhdGgoKSxnLm1vdmVUbyh1LHMpLHYmJihoLmJlZ2luUGF0aCgpLGgubW92ZVRvKHUscykpLEE9e3g6dSx5OnN9KSxlYT1mPSExKTooZy5saW5lVG8odSxzKSx2JiZoLmxpbmVUbyh1LHMpLDA9PUQlMjUwJiZjKCkpO3A9e3g6dSx5OnN9O0Q8bS5sZW5ndGgtMSYmKEohPT0obVtEXS5saW5lQ29sb3J8fHopfHxiIT09KG1bRF0ubGluZURhc2hUeXBlfHx3LmxpbmVEYXNoVHlwZSkpJiYoYygpLEo9bVtEXS5saW5lQ29sb3J8fHosZy5zdHJva2VTdHlsZT1KLGcuc2V0TGluZURhc2gmJihtW0RdLmxpbmVEYXNoVHlwZT8oYj1tW0RdLmxpbmVEYXNoVHlwZSxnLnNldExpbmVEYXNoKEcoYix3LmxpbmVUaGlja25lc3MpKSk6KGI9dy5saW5lRGFzaFR5cGUsZy5zZXRMaW5lRGFzaChkYSkpKSk7dmFyICQ9dy5kYXRhUG9pbnRJZHNbRF07XHJcbnRoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbJF09e2lkOiQsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpkLGRhdGFQb2ludEluZGV4OkQseDE6dSx5MTpzfTswIT09bVtEXS5tYXJrZXJTaXplJiYoMDxtW0RdLm1hcmtlclNpemV8fDA8dy5tYXJrZXJTaXplKSYmKHE9dy5nZXRNYXJrZXJQcm9wZXJ0aWVzKEQsdSxzLGcpLGsucHVzaChxKSwkPVIoJCksdiYmay5wdXNoKHt4OnUseTpzLGN0eDpoLHR5cGU6cS50eXBlLHNpemU6cS5zaXplLGNvbG9yOiQsYm9yZGVyQ29sb3I6JCxib3JkZXJUaGlja25lc3M6cS5ib3JkZXJUaGlja25lc3N9KSk7KG1bRF0uaW5kZXhMYWJlbHx8dy5pbmRleExhYmVsfHxtW0RdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fHcuaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcImFyZWFcIixkYXRhUG9pbnQ6bVtEXSxkYXRhU2VyaWVzOncscG9pbnQ6e3g6dSx5OnN9LGRpcmVjdGlvbjowPlxyXG5tW0RdLnk9PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsY29sb3I6eH0pfWMoKTtqYS5kcmF3TWFya2VycyhrKX19diYmKGUuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksZy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmZy5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmcuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZ0aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksZy5jbGVhclJlY3Qoci54MSxyLnkxLHIud2lkdGgsci5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO1xyXG5nLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmUsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpILnhDbGlwQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmxpbmVhcixhbmltYXRpb25CYXNlOjB9fX07cS5wcm90b3R5cGUucmVuZGVyU3BsaW5lQXJlYT1mdW5jdGlvbihhKXtmdW5jdGlvbiBmKCl7dmFyIGI9eChxLDIpO2lmKDA8Yi5sZW5ndGgpe2lmKDA8cC5saW5lVGhpY2tuZXNzKXtjLmJlZ2luUGF0aCgpO2MubW92ZVRvKGJbMF0ueCxiWzBdLnkpO2JbMF0ubmV3U3Ryb2tlU3R5bGUmJihjLnN0cm9rZVN0eWxlPWJbMF0ubmV3U3Ryb2tlU3R5bGUpO2JbMF0ubmV3TGluZURhc2hBcnJheSYmYy5zZXRMaW5lRGFzaChiWzBdLm5ld0xpbmVEYXNoQXJyYXkpO2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGgtMztkKz0zKWlmKGMuYmV6aWVyQ3VydmVUbyhiW2QrMV0ueCxiW2QrMV0ueSxiW2QrMl0ueCxiW2QrMl0ueSxiW2QrM10ueCxiW2QrM10ueSksdiYmXHJcbmUuYmV6aWVyQ3VydmVUbyhiW2QrMV0ueCxiW2QrMV0ueSxiW2QrMl0ueCxiW2QrMl0ueSxiW2QrM10ueCxiW2QrM10ueSksYltkKzNdLm5ld1N0cm9rZVN0eWxlfHxiW2QrM10ubmV3TGluZURhc2hBcnJheSljLnN0cm9rZSgpLGMuYmVnaW5QYXRoKCksYy5tb3ZlVG8oYltkKzNdLngsYltkKzNdLnkpLGJbZCszXS5uZXdTdHJva2VTdHlsZSYmKGMuc3Ryb2tlU3R5bGU9YltkKzNdLm5ld1N0cm9rZVN0eWxlKSxiW2QrM10ubmV3TGluZURhc2hBcnJheSYmYy5zZXRMaW5lRGFzaChiW2QrM10ubmV3TGluZURhc2hBcnJheSk7Yy5zdHJva2UoKX1jLmJlZ2luUGF0aCgpO2MubW92ZVRvKGJbMF0ueCxiWzBdLnkpO3YmJihlLmJlZ2luUGF0aCgpLGUubW92ZVRvKGJbMF0ueCxiWzBdLnkpKTtmb3IoZD0wO2Q8Yi5sZW5ndGgtMztkKz0zKWMuYmV6aWVyQ3VydmVUbyhiW2QrMV0ueCxiW2QrMV0ueSxiW2QrMl0ueCxiW2QrMl0ueSxiW2QrM10ueCxiW2QrM10ueSksdiYmZS5iZXppZXJDdXJ2ZVRvKGJbZCtcclxuMV0ueCxiW2QrMV0ueSxiW2QrMl0ueCxiW2QrMl0ueSxiW2QrM10ueCxiW2QrM10ueSk7YS5heGlzWS5sb2dhcml0aG1pY3x8MD49YS5heGlzWS52aWV3cG9ydE1pbmltdW0mJjA8PWEuYXhpc1kudmlld3BvcnRNYXhpbXVtP3U9RDowPmEuYXhpc1kudmlld3BvcnRNYXhpbXVtP3U9aC55MTowPGEuYXhpc1kudmlld3BvcnRNaW5pbXVtJiYodT1nLnkyKTtzPXt4OmJbMF0ueCx5OmJbMF0ueX07Yy5saW5lVG8oYltiLmxlbmd0aC0xXS54LHUpO2MubGluZVRvKHMueCx1KTtjLmNsb3NlUGF0aCgpO2MuZ2xvYmFsQWxwaGE9cC5maWxsT3BhY2l0eTtjLmZpbGwoKTtjLmdsb2JhbEFscGhhPTE7diYmKGUubGluZVRvKGJbYi5sZW5ndGgtMV0ueCx1KSxlLmxpbmVUbyhzLngsdSksZS5jbG9zZVBhdGgoKSxlLmZpbGwoKSl9fXZhciBiPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxjPXY/dGhpcy5fcHJlUmVuZGVyQ3R4OmI7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBlPVxyXG50aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsZz1hLmF4aXNYLmxpbmVDb29yZGluYXRlcyxoPWEuYXhpc1kubGluZUNvb3JkaW5hdGVzLGw9W10sdD10aGlzLnBsb3RBcmVhO2Muc2F2ZSgpO3YmJmUuc2F2ZSgpO2MuYmVnaW5QYXRoKCk7Yy5yZWN0KHQueDEsdC55MSx0LndpZHRoLHQuaGVpZ2h0KTtjLmNsaXAoKTt2JiYoZS5iZWdpblBhdGgoKSxlLnJlY3QodC54MSx0LnkxLHQud2lkdGgsdC5oZWlnaHQpLGUuY2xpcCgpKTtmb3IodmFyIGs9MDtrPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO2srKyl7dmFyIHI9YS5kYXRhU2VyaWVzSW5kZXhlc1trXSxwPXRoaXMuZGF0YVtyXSxuPXAuZGF0YVBvaW50cyxsPXAuaWQ7dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtsXT17b2JqZWN0VHlwZTpcImRhdGFTZXJpZXNcIixkYXRhU2VyaWVzSW5kZXg6cn07bD1SKGwpO2UuZmlsbFN0eWxlPWw7dmFyIGw9W10sZD0wLHcsbSxEPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP1xyXG5hLmF4aXNZLnZpZXdwb3J0TWluaW11bTowKSx1LHM9bnVsbCxxPVtdO2lmKDA8bi5sZW5ndGgpe3ZhciB5PXAuX2NvbG9yU2V0W2QlcC5fY29sb3JTZXQubGVuZ3RoXSxCPXAubGluZUNvbG9yPXAub3B0aW9ucy5saW5lQ29sb3J8fHksQT1CO2MuZmlsbFN0eWxlPXk7Yy5zdHJva2VTdHlsZT1CO2MubGluZVdpZHRoPXAubGluZVRoaWNrbmVzczt2YXIgej1cInNvbGlkXCI7aWYoYy5zZXRMaW5lRGFzaCl7dmFyIEw9RyhwLm51bGxEYXRhTGluZURhc2hUeXBlLHAubGluZVRoaWNrbmVzcyksej1wLmxpbmVEYXNoVHlwZSxKPUcoeixwLmxpbmVUaGlja25lc3MpO2Muc2V0TGluZURhc2goSil9Zm9yKG09ITE7ZDxuLmxlbmd0aDtkKyspaWYodz1uW2RdLnguZ2V0VGltZT9uW2RdLnguZ2V0VGltZSgpOm5bZF0ueCwhKHc8YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1pbnx8dz5hLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWF4JiYoIXAuY29ubmVjdE51bGxEYXRhfHwhbSkpKWlmKFwibnVtYmVyXCIhPT1cclxudHlwZW9mIG5bZF0ueSkwPGQmJiFtJiYocC5jb25uZWN0TnVsbERhdGE/Yy5zZXRMaW5lRGFzaCYmKDA8cS5sZW5ndGgmJihwLm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fCFuW2QtMV0ubGluZURhc2hUeXBlKSkmJihxW3EubGVuZ3RoLTFdLm5ld0xpbmVEYXNoQXJyYXk9TCx6PXAubnVsbERhdGFMaW5lRGFzaFR5cGUpOihmKCkscT1bXSkpLG09ITA7ZWxzZXt3PWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbCh3KTttPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChuW2RdLnkpO3ZhciBJPXAuZGF0YVBvaW50SWRzW2RdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbSV09e2lkOkksb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpyLGRhdGFQb2ludEluZGV4OmQseDE6dyx5MTptfTtxW3EubGVuZ3RoXT17eDp3LHk6bX07ZDxuLmxlbmd0aC0xJiYoQSE9PShuW2RdLmxpbmVDb2xvcnx8Qil8fHohPT0obltkXS5saW5lRGFzaFR5cGV8fHAubGluZURhc2hUeXBlKSkmJlxyXG4oQT1uW2RdLmxpbmVDb2xvcnx8QixxW3EubGVuZ3RoLTFdLm5ld1N0cm9rZVN0eWxlPUEsYy5zZXRMaW5lRGFzaCYmKG5bZF0ubGluZURhc2hUeXBlPyh6PW5bZF0ubGluZURhc2hUeXBlLHFbcS5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheT1HKHoscC5saW5lVGhpY2tuZXNzKSk6KHo9cC5saW5lRGFzaFR5cGUscVtxLmxlbmd0aC0xXS5uZXdMaW5lRGFzaEFycmF5PUopKSk7aWYoMCE9PW5bZF0ubWFya2VyU2l6ZSYmKDA8bltkXS5tYXJrZXJTaXplfHwwPHAubWFya2VyU2l6ZSkpe3ZhciBkYT1wLmdldE1hcmtlclByb3BlcnRpZXMoZCx3LG0sYyk7bC5wdXNoKGRhKTtJPVIoSSk7diYmbC5wdXNoKHt4OncseTptLGN0eDplLHR5cGU6ZGEudHlwZSxzaXplOmRhLnNpemUsY29sb3I6SSxib3JkZXJDb2xvcjpJLGJvcmRlclRoaWNrbmVzczpkYS5ib3JkZXJUaGlja25lc3N9KX0obltkXS5pbmRleExhYmVsfHxwLmluZGV4TGFiZWx8fG5bZF0uaW5kZXhMYWJlbEZvcm1hdHRlcnx8cC5pbmRleExhYmVsRm9ybWF0dGVyKSYmXHJcbnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcInNwbGluZUFyZWFcIixkYXRhUG9pbnQ6bltkXSxkYXRhU2VyaWVzOnAscG9pbnQ6e3g6dyx5Om19LGRpcmVjdGlvbjowPm5bZF0ueT09PWEuYXhpc1kucmV2ZXJzZWQ/MTotMSxjb2xvcjp5fSk7bT0hMX1mKCk7amEuZHJhd01hcmtlcnMobCl9fXYmJihiLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsXHJcbjAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmNsZWFyUmVjdCh0LngxLHQueTEsdC53aWR0aCx0LmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlc3RvcmUoKSk7Yy5yZXN0b3JlKCk7cmV0dXJue3NvdXJjZTpiLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6SC54Q2xpcEFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpILmVhc2luZy5saW5lYXIsYW5pbWF0aW9uQmFzZTowfX19O3EucHJvdG90eXBlLnJlbmRlclN0ZXBBcmVhPWZ1bmN0aW9uKGEpe3ZhciBmLGI7ZnVuY3Rpb24gYygpe0EmJigwPHcubGluZVRoaWNrbmVzcyYmZy5zdHJva2UoKSxhLmF4aXNZLmxvZ2FyaXRobWljfHwwPj1hLmF4aXNZLnZpZXdwb3J0TWluaW11bSYmMDw9YS5heGlzWS52aWV3cG9ydE1heGltdW0/Qj15OjA+YS5heGlzWS52aWV3cG9ydE1heGltdW0/Qj10LnkxOjA8YS5heGlzWS52aWV3cG9ydE1pbmltdW0mJihCPWwueTIpLGcubGluZVRvKHUsQiksZy5saW5lVG8oQS54LFxyXG5CKSxnLmNsb3NlUGF0aCgpLGcuZ2xvYmFsQWxwaGE9dy5maWxsT3BhY2l0eSxnLmZpbGwoKSxnLmdsb2JhbEFscGhhPTEsdiYmKGgubGluZVRvKHUsQiksaC5saW5lVG8oQS54LEIpLGguY2xvc2VQYXRoKCksaC5maWxsKCkpLGcuYmVnaW5QYXRoKCksZy5tb3ZlVG8odSxzKSxoLmJlZ2luUGF0aCgpLGgubW92ZVRvKHUscyksQT17eDp1LHk6c30pfXZhciBlPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxnPXY/dGhpcy5fcHJlUmVuZGVyQ3R4OmU7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBoPXRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eCxsPWEuYXhpc1gubGluZUNvb3JkaW5hdGVzLHQ9YS5heGlzWS5saW5lQ29vcmRpbmF0ZXMsaz1bXSxyPXRoaXMucGxvdEFyZWEscDtnLnNhdmUoKTt2JiZoLnNhdmUoKTtnLmJlZ2luUGF0aCgpO2cucmVjdChyLngxLHIueTEsci53aWR0aCxyLmhlaWdodCk7Zy5jbGlwKCk7diYmKGguYmVnaW5QYXRoKCksXHJcbmgucmVjdChyLngxLHIueTEsci53aWR0aCxyLmhlaWdodCksaC5jbGlwKCkpO2Zvcih2YXIgbj0wO248YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7bisrKXt2YXIgZD1hLmRhdGFTZXJpZXNJbmRleGVzW25dLHc9dGhpcy5kYXRhW2RdLG09dy5kYXRhUG9pbnRzLGs9dy5pZDt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2tdPXtvYmplY3RUeXBlOlwiZGF0YVNlcmllc1wiLGRhdGFTZXJpZXNJbmRleDpkfTtrPVIoayk7aC5maWxsU3R5bGU9aztrPVtdO2Y9ITA7dmFyIEQ9MCx1LHMscSx5PWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP2EuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLEIsQT1udWxsO2I9ITE7aWYoMDxtLmxlbmd0aCl7dmFyIHg9dy5fY29sb3JTZXRbRCV3Ll9jb2xvclNldC5sZW5ndGhdLHo9dy5saW5lQ29sb3I9dy5vcHRpb25zLmxpbmVDb2xvcnx8eCxKPXo7Zy5maWxsU3R5bGU9eDtnLnN0cm9rZVN0eWxlPXo7Zy5saW5lV2lkdGg9XHJcbncubGluZVRoaWNrbmVzczt2YXIgST1cInNvbGlkXCI7aWYoZy5zZXRMaW5lRGFzaCl7dmFyIGRhPUcody5udWxsRGF0YUxpbmVEYXNoVHlwZSx3LmxpbmVUaGlja25lc3MpLEk9dy5saW5lRGFzaFR5cGUsZWE9RyhJLHcubGluZVRoaWNrbmVzcyk7Zy5zZXRMaW5lRGFzaChlYSl9Zm9yKDtEPG0ubGVuZ3RoO0QrKylpZihxPW1bRF0ueC5nZXRUaW1lP21bRF0ueC5nZXRUaW1lKCk6bVtEXS54LCEocTxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxxPmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgmJighdy5jb25uZWN0TnVsbERhdGF8fCFiKSkpe3ZhciAkPXM7XCJudW1iZXJcIiE9PXR5cGVvZiBtW0RdLnk/KHcuY29ubmVjdE51bGxEYXRhfHwoYnx8Zil8fGMoKSxiPSEwKToodT1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwocSkscz1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwobVtEXS55KSxmfHxiPyghZiYmdy5jb25uZWN0TnVsbERhdGE/KGcuc2V0TGluZURhc2gmJih3Lm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fFxyXG5JPT09dy5saW5lRGFzaFR5cGUmJncubGluZURhc2hUeXBlIT09dy5udWxsRGF0YUxpbmVEYXNoVHlwZSkmJihmPXUsYj1zLHU9cC54LHM9cC55LGMoKSxnLm1vdmVUbyhwLngscC55KSx1PWYscz1iLEE9cCxJPXcubnVsbERhdGFMaW5lRGFzaFR5cGUsZy5zZXRMaW5lRGFzaChkYSkpLGcubGluZVRvKHUsJCksZy5saW5lVG8odSxzKSx2JiYoaC5saW5lVG8odSwkKSxoLmxpbmVUbyh1LHMpKSk6KGcuYmVnaW5QYXRoKCksZy5tb3ZlVG8odSxzKSx2JiYoaC5iZWdpblBhdGgoKSxoLm1vdmVUbyh1LHMpKSxBPXt4OnUseTpzfSksYj1mPSExKTooZy5saW5lVG8odSwkKSx2JiZoLmxpbmVUbyh1LCQpLGcubGluZVRvKHUscyksdiYmaC5saW5lVG8odSxzKSwwPT1EJTI1MCYmYygpKSxwPXt4OnUseTpzfSxEPG0ubGVuZ3RoLTEmJihKIT09KG1bRF0ubGluZUNvbG9yfHx6KXx8SSE9PShtW0RdLmxpbmVEYXNoVHlwZXx8dy5saW5lRGFzaFR5cGUpKSYmKGMoKSxKPW1bRF0ubGluZUNvbG9yfHxcclxueixnLnN0cm9rZVN0eWxlPUosZy5zZXRMaW5lRGFzaCYmKG1bRF0ubGluZURhc2hUeXBlPyhJPW1bRF0ubGluZURhc2hUeXBlLGcuc2V0TGluZURhc2goRyhJLHcubGluZVRoaWNrbmVzcykpKTooST13LmxpbmVEYXNoVHlwZSxnLnNldExpbmVEYXNoKGVhKSkpKSxxPXcuZGF0YVBvaW50SWRzW0RdLHRoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbcV09e2lkOnEsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpkLGRhdGFQb2ludEluZGV4OkQseDE6dSx5MTpzfSwwIT09bVtEXS5tYXJrZXJTaXplJiYoMDxtW0RdLm1hcmtlclNpemV8fDA8dy5tYXJrZXJTaXplKSYmKCQ9dy5nZXRNYXJrZXJQcm9wZXJ0aWVzKEQsdSxzLGcpLGsucHVzaCgkKSxxPVIocSksdiYmay5wdXNoKHt4OnUseTpzLGN0eDpoLHR5cGU6JC50eXBlLHNpemU6JC5zaXplLGNvbG9yOnEsYm9yZGVyQ29sb3I6cSxib3JkZXJUaGlja25lc3M6JC5ib3JkZXJUaGlja25lc3N9KSksKG1bRF0uaW5kZXhMYWJlbHx8XHJcbncuaW5kZXhMYWJlbHx8bVtEXS5pbmRleExhYmVsRm9ybWF0dGVyfHx3LmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJzdGVwQXJlYVwiLGRhdGFQb2ludDptW0RdLGRhdGFTZXJpZXM6dyxwb2ludDp7eDp1LHk6c30sZGlyZWN0aW9uOjA+bVtEXS55PT09YS5heGlzWS5yZXZlcnNlZD8xOi0xLGNvbG9yOnh9KSl9YygpO2phLmRyYXdNYXJrZXJzKGspfX12JiYoZS5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxnLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZnLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmZy5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJlxyXG50aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksZy5jbGVhclJlY3Qoci54MSxyLnkxLHIud2lkdGgsci5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2cucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZSxkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOkgueENsaXBBbmltYXRpb24sZWFzaW5nRnVuY3Rpb246SC5lYXNpbmcubGluZWFyLGFuaW1hdGlvbkJhc2U6MH19fTtxLnByb3RvdHlwZS5yZW5kZXJTdGFja2VkQXJlYT1mdW5jdGlvbihhKXtmdW5jdGlvbiBmKCl7aWYoISgxPnQubGVuZ3RoKSl7Zm9yKDA8QS5saW5lVGhpY2tuZXNzJiZjLnN0cm9rZSgpOzA8dC5sZW5ndGg7KXt2YXIgYT10LnBvcCgpO2MubGluZVRvKGEueCxhLnkpO3YmJnMubGluZVRvKGEueCxhLnkpfWMuY2xvc2VQYXRoKCk7Yy5nbG9iYWxBbHBoYT1BLmZpbGxPcGFjaXR5O1xyXG5jLmZpbGwoKTtjLmdsb2JhbEFscGhhPTE7Yy5iZWdpblBhdGgoKTt2JiYocy5jbG9zZVBhdGgoKSxzLmZpbGwoKSxzLmJlZ2luUGF0aCgpKTt0PVtdfX12YXIgYj1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYz12P3RoaXMuX3ByZVJlbmRlckN0eDpiO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgZT1udWxsLGc9W10saD10aGlzLnBsb3RBcmVhLGw9W10sdD1bXSxrPVtdLHI9W10scD0wLG4sZCx3LG09YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKGEuYXhpc1kubG9nYXJpdGhtaWM/YS5heGlzWS52aWV3cG9ydE1pbmltdW06MCkscz10aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsdSxxLHk7diYmcy5iZWdpblBhdGgoKTtjLnNhdmUoKTt2JiZzLnNhdmUoKTtjLmJlZ2luUGF0aCgpO2MucmVjdChoLngxLGgueTEsaC53aWR0aCxoLmhlaWdodCk7Yy5jbGlwKCk7diYmKHMuYmVnaW5QYXRoKCkscy5yZWN0KGgueDEsaC55MSxoLndpZHRoLFxyXG5oLmhlaWdodCkscy5jbGlwKCkpO2Zvcih2YXIgZT1bXSx4PTA7eDxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDt4Kyspe3ZhciBCPWEuZGF0YVNlcmllc0luZGV4ZXNbeF0sQT10aGlzLmRhdGFbQl0sej1BLmRhdGFQb2ludHM7QS5kYXRhUG9pbnRJbmRleGVzPVtdO2ZvcihwPTA7cDx6Lmxlbmd0aDtwKyspQj16W3BdLnguZ2V0VGltZT96W3BdLnguZ2V0VGltZSgpOnpbcF0ueCxBLmRhdGFQb2ludEluZGV4ZXNbQl09cCxlW0JdfHwoay5wdXNoKEIpLGVbQl09ITApO2suc29ydChQYSl9Zm9yKHg9MDt4PGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO3grKyl7Qj1hLmRhdGFTZXJpZXNJbmRleGVzW3hdO0E9dGhpcy5kYXRhW0JdO3o9QS5kYXRhUG9pbnRzO3E9ITA7dD1bXTtwPUEuaWQ7dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtwXT17b2JqZWN0VHlwZTpcImRhdGFTZXJpZXNcIixkYXRhU2VyaWVzSW5kZXg6Qn07cD1SKHApO3MuZmlsbFN0eWxlPXA7aWYoMDxrLmxlbmd0aCl7dmFyIGU9XHJcbkEuX2NvbG9yU2V0WzBdLEw9QS5saW5lQ29sb3I9QS5vcHRpb25zLmxpbmVDb2xvcnx8ZSxKPUw7Yy5maWxsU3R5bGU9ZTtjLnN0cm9rZVN0eWxlPUw7Yy5saW5lV2lkdGg9QS5saW5lVGhpY2tuZXNzO3k9XCJzb2xpZFwiO2lmKGMuc2V0TGluZURhc2gpe3ZhciBJPUcoQS5udWxsRGF0YUxpbmVEYXNoVHlwZSxBLmxpbmVUaGlja25lc3MpO3k9QS5saW5lRGFzaFR5cGU7dmFyIGRhPUcoeSxBLmxpbmVUaGlja25lc3MpO2Muc2V0TGluZURhc2goZGEpfWZvcih2YXIgZWE9ITAscD0wO3A8ay5sZW5ndGg7cCsrKXt3PWtbcF07dmFyICQ9bnVsbCwkPTA8PUEuZGF0YVBvaW50SW5kZXhlc1t3XT96W0EuZGF0YVBvaW50SW5kZXhlc1t3XV06e3g6dyx5Om51bGx9O2lmKCEodzxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHx3PmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgmJighQS5jb25uZWN0TnVsbERhdGF8fCFlYSkpKWlmKFwibnVtYmVyXCIhPT10eXBlb2YgJC55KUEuY29ubmVjdE51bGxEYXRhfHxcclxuKGVhfHxxKXx8ZigpLGVhPSEwO2Vsc2V7bj1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwodyk7dmFyIHhhPWxbd10/bFt3XTowO2lmKGEuYXhpc1kubG9nYXJpdGhtaWN8fGEuYXhpc1kuc2NhbGVCcmVha3MmJjA8YS5heGlzWS5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgpe3Jbd109JC55KyhyW3ddP3Jbd106MCk7aWYoMD49clt3XSYmYS5heGlzWS5sb2dhcml0aG1pYyljb250aW51ZTtkPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChyW3ddKX1lbHNlIGQ9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKCQueSksZC09eGE7dC5wdXNoKHt4Om4seTptLXhhfSk7bFt3XT1tLWQ7cXx8ZWE/KCFxJiZBLmNvbm5lY3ROdWxsRGF0YT8oYy5zZXRMaW5lRGFzaCYmKEEub3B0aW9ucy5udWxsRGF0YUxpbmVEYXNoVHlwZXx8eT09PUEubGluZURhc2hUeXBlJiZBLmxpbmVEYXNoVHlwZSE9PUEubnVsbERhdGFMaW5lRGFzaFR5cGUpJiYocT10LnBvcCgpLHk9dFt0Lmxlbmd0aC1cclxuMV0sZigpLGMubW92ZVRvKHUueCx1LnkpLHQucHVzaCh5KSx0LnB1c2gocSkseT1BLm51bGxEYXRhTGluZURhc2hUeXBlLGMuc2V0TGluZURhc2goSSkpLGMubGluZVRvKG4sZCksdiYmcy5saW5lVG8obixkKSk6KGMuYmVnaW5QYXRoKCksYy5tb3ZlVG8obixkKSx2JiYocy5iZWdpblBhdGgoKSxzLm1vdmVUbyhuLGQpKSksZWE9cT0hMSk6KGMubGluZVRvKG4sZCksdiYmcy5saW5lVG8obixkKSwwPT1wJTI1MCYmKGYoKSxjLm1vdmVUbyhuLGQpLHYmJnMubW92ZVRvKG4sZCksdC5wdXNoKHt4Om4seTptLXhhfSkpKTt1PXt4Om4seTpkfTtwPHoubGVuZ3RoLTEmJihKIT09KHpbcF0ubGluZUNvbG9yfHxMKXx8eSE9PSh6W3BdLmxpbmVEYXNoVHlwZXx8QS5saW5lRGFzaFR5cGUpKSYmKGYoKSxjLmJlZ2luUGF0aCgpLGMubW92ZVRvKG4sZCksdC5wdXNoKHt4Om4seTptLXhhfSksSj16W3BdLmxpbmVDb2xvcnx8TCxjLnN0cm9rZVN0eWxlPUosYy5zZXRMaW5lRGFzaCYmKHpbcF0ubGluZURhc2hUeXBlP1xyXG4oeT16W3BdLmxpbmVEYXNoVHlwZSxjLnNldExpbmVEYXNoKEcoeSxBLmxpbmVUaGlja25lc3MpKSk6KHk9QS5saW5lRGFzaFR5cGUsYy5zZXRMaW5lRGFzaChkYSkpKSk7aWYoMDw9QS5kYXRhUG9pbnRJbmRleGVzW3ddKXt2YXIgb2E9QS5kYXRhUG9pbnRJZHNbQS5kYXRhUG9pbnRJbmRleGVzW3ddXTt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW29hXT17aWQ6b2Esb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpCLGRhdGFQb2ludEluZGV4OkEuZGF0YVBvaW50SW5kZXhlc1t3XSx4MTpuLHkxOmR9fTA8PUEuZGF0YVBvaW50SW5kZXhlc1t3XSYmMCE9PSQubWFya2VyU2l6ZSYmKDA8JC5tYXJrZXJTaXplfHwwPEEubWFya2VyU2l6ZSkmJih3PUEuZ2V0TWFya2VyUHJvcGVydGllcyhBLmRhdGFQb2ludEluZGV4ZXNbd10sbixkLGMpLGcucHVzaCh3KSxtYXJrZXJDb2xvcj1SKG9hKSx2JiZnLnB1c2goe3g6bix5OmQsY3R4OnMsdHlwZTp3LnR5cGUsc2l6ZTp3LnNpemUsXHJcbmNvbG9yOm1hcmtlckNvbG9yLGJvcmRlckNvbG9yOm1hcmtlckNvbG9yLGJvcmRlclRoaWNrbmVzczp3LmJvcmRlclRoaWNrbmVzc30pKTsoJC5pbmRleExhYmVsfHxBLmluZGV4TGFiZWx8fCQuaW5kZXhMYWJlbEZvcm1hdHRlcnx8QS5pbmRleExhYmVsRm9ybWF0dGVyKSYmdGhpcy5faW5kZXhMYWJlbHMucHVzaCh7Y2hhcnRUeXBlOlwic3RhY2tlZEFyZWFcIixkYXRhUG9pbnQ6JCxkYXRhU2VyaWVzOkEscG9pbnQ6e3g6bix5OmR9LGRpcmVjdGlvbjowPnpbcF0ueT09PWEuYXhpc1kucmV2ZXJzZWQ/MTotMSxjb2xvcjplfSl9fWYoKTtjLm1vdmVUbyhuLGQpO3YmJnMubW92ZVRvKG4sZCl9ZGVsZXRlIEEuZGF0YVBvaW50SW5kZXhlc31qYS5kcmF3TWFya2VycyhnKTt2JiYoYi5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZcclxuYy5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZ0aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5jbGVhclJlY3QoaC54MSxoLnkxLGgud2lkdGgsaC5oZWlnaHQpLHMucmVzdG9yZSgpKTtjLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmIsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpILnhDbGlwQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmxpbmVhcixhbmltYXRpb25CYXNlOjB9fX07cS5wcm90b3R5cGUucmVuZGVyU3RhY2tlZEFyZWExMDA9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZigpe2ZvcigwPEEubGluZVRoaWNrbmVzcyYmXHJcbmMuc3Ryb2tlKCk7MDx0Lmxlbmd0aDspe3ZhciBhPXQucG9wKCk7Yy5saW5lVG8oYS54LGEueSk7diYmeS5saW5lVG8oYS54LGEueSl9Yy5jbG9zZVBhdGgoKTtjLmdsb2JhbEFscGhhPUEuZmlsbE9wYWNpdHk7Yy5maWxsKCk7Yy5nbG9iYWxBbHBoYT0xO2MuYmVnaW5QYXRoKCk7diYmKHkuY2xvc2VQYXRoKCkseS5maWxsKCkseS5iZWdpblBhdGgoKSk7dD1bXX12YXIgYj1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYz12P3RoaXMuX3ByZVJlbmRlckN0eDpiO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgZT1udWxsLGc9dGhpcy5wbG90QXJlYSxoPVtdLGw9W10sdD1bXSxrPVtdLHI9W10scD0wLG4sZCx3LG0scyx1LHE9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKGEuYXhpc1kubG9nYXJpdGhtaWM/YS5heGlzWS52aWV3cG9ydE1pbmltdW06MCkseT10aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHg7Yy5zYXZlKCk7diYmeS5zYXZlKCk7XHJcbmMuYmVnaW5QYXRoKCk7Yy5yZWN0KGcueDEsZy55MSxnLndpZHRoLGcuaGVpZ2h0KTtjLmNsaXAoKTt2JiYoeS5iZWdpblBhdGgoKSx5LnJlY3QoZy54MSxnLnkxLGcud2lkdGgsZy5oZWlnaHQpLHkuY2xpcCgpKTtmb3IodmFyIGU9W10seD0wO3g8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7eCsrKXt2YXIgQj1hLmRhdGFTZXJpZXNJbmRleGVzW3hdLEE9dGhpcy5kYXRhW0JdLHo9QS5kYXRhUG9pbnRzO0EuZGF0YVBvaW50SW5kZXhlcz1bXTtmb3IocD0wO3A8ei5sZW5ndGg7cCsrKUI9eltwXS54LmdldFRpbWU/eltwXS54LmdldFRpbWUoKTp6W3BdLngsQS5kYXRhUG9pbnRJbmRleGVzW0JdPXAsZVtCXXx8KGsucHVzaChCKSxlW0JdPSEwKTtrLnNvcnQoUGEpfWZvcih4PTA7eDxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDt4Kyspe0I9YS5kYXRhU2VyaWVzSW5kZXhlc1t4XTtBPXRoaXMuZGF0YVtCXTt6PUEuZGF0YVBvaW50cztzPSEwO2U9QS5pZDt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2VdPVxyXG57b2JqZWN0VHlwZTpcImRhdGFTZXJpZXNcIixkYXRhU2VyaWVzSW5kZXg6Qn07ZT1SKGUpO3kuZmlsbFN0eWxlPWU7dD1bXTtpZigwPGsubGVuZ3RoKXt2YXIgZT1BLl9jb2xvclNldFtwJUEuX2NvbG9yU2V0Lmxlbmd0aF0sTD1BLmxpbmVDb2xvcj1BLm9wdGlvbnMubGluZUNvbG9yfHxlLEo9TDtjLmZpbGxTdHlsZT1lO2Muc3Ryb2tlU3R5bGU9TDtjLmxpbmVXaWR0aD1BLmxpbmVUaGlja25lc3M7dT1cInNvbGlkXCI7aWYoYy5zZXRMaW5lRGFzaCl7dmFyIEk9RyhBLm51bGxEYXRhTGluZURhc2hUeXBlLEEubGluZVRoaWNrbmVzcyk7dT1BLmxpbmVEYXNoVHlwZTt2YXIgZGE9Ryh1LEEubGluZVRoaWNrbmVzcyk7Yy5zZXRMaW5lRGFzaChkYSl9Zm9yKHZhciBlYT0hMCxwPTA7cDxrLmxlbmd0aDtwKyspe3c9a1twXTt2YXIgJD1udWxsLCQ9MDw9QS5kYXRhUG9pbnRJbmRleGVzW3ddP3pbQS5kYXRhUG9pbnRJbmRleGVzW3ddXTp7eDp3LHk6bnVsbH07aWYoISh3PGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fFxyXG53PmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgmJighQS5jb25uZWN0TnVsbERhdGF8fCFlYSkpKWlmKFwibnVtYmVyXCIhPT10eXBlb2YgJC55KUEuY29ubmVjdE51bGxEYXRhfHwoZWF8fHMpfHxmKCksZWE9ITA7ZWxzZXt2YXIgeGE7eGE9MCE9PWEuZGF0YVBvaW50WVN1bXNbd10/MTAwKigkLnkvYS5kYXRhUG9pbnRZU3Vtc1t3XSk6MDtuPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbCh3KTt2YXIgb2E9bFt3XT9sW3ddOjA7aWYoYS5heGlzWS5sb2dhcml0aG1pY3x8YS5heGlzWS5zY2FsZUJyZWFrcyYmMDxhLmF4aXNZLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aCl7clt3XT14YSsoclt3XT9yW3ddOjApO2lmKDA+PXJbd10mJmEuYXhpc1kubG9nYXJpdGhtaWMpY29udGludWU7ZD1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoclt3XSl9ZWxzZSBkPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbCh4YSksZC09b2E7dC5wdXNoKHt4Om4seTpxLW9hfSk7bFt3XT1cclxucS1kO3N8fGVhPyghcyYmQS5jb25uZWN0TnVsbERhdGE/KGMuc2V0TGluZURhc2gmJihBLm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fHU9PT1BLmxpbmVEYXNoVHlwZSYmQS5saW5lRGFzaFR5cGUhPT1BLm51bGxEYXRhTGluZURhc2hUeXBlKSYmKHM9dC5wb3AoKSx1PXRbdC5sZW5ndGgtMV0sZigpLGMubW92ZVRvKG0ueCxtLnkpLHQucHVzaCh1KSx0LnB1c2gocyksdT1BLm51bGxEYXRhTGluZURhc2hUeXBlLGMuc2V0TGluZURhc2goSSkpLGMubGluZVRvKG4sZCksdiYmeS5saW5lVG8obixkKSk6KGMuYmVnaW5QYXRoKCksYy5tb3ZlVG8obixkKSx2JiYoeS5iZWdpblBhdGgoKSx5Lm1vdmVUbyhuLGQpKSksZWE9cz0hMSk6KGMubGluZVRvKG4sZCksdiYmeS5saW5lVG8obixkKSwwPT1wJTI1MCYmKGYoKSxjLm1vdmVUbyhuLGQpLHYmJnkubW92ZVRvKG4sZCksdC5wdXNoKHt4Om4seTpxLW9hfSkpKTttPXt4Om4seTpkfTtwPHoubGVuZ3RoLTEmJihKIT09KHpbcF0ubGluZUNvbG9yfHxcclxuTCl8fHUhPT0oeltwXS5saW5lRGFzaFR5cGV8fEEubGluZURhc2hUeXBlKSkmJihmKCksYy5iZWdpblBhdGgoKSxjLm1vdmVUbyhuLGQpLHQucHVzaCh7eDpuLHk6cS1vYX0pLEo9eltwXS5saW5lQ29sb3J8fEwsYy5zdHJva2VTdHlsZT1KLGMuc2V0TGluZURhc2gmJih6W3BdLmxpbmVEYXNoVHlwZT8odT16W3BdLmxpbmVEYXNoVHlwZSxjLnNldExpbmVEYXNoKEcodSxBLmxpbmVUaGlja25lc3MpKSk6KHU9QS5saW5lRGFzaFR5cGUsYy5zZXRMaW5lRGFzaChkYSkpKSk7aWYoMDw9QS5kYXRhUG9pbnRJbmRleGVzW3ddKXt2YXIgRT1BLmRhdGFQb2ludElkc1tBLmRhdGFQb2ludEluZGV4ZXNbd11dO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbRV09e2lkOkUsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpCLGRhdGFQb2ludEluZGV4OkEuZGF0YVBvaW50SW5kZXhlc1t3XSx4MTpuLHkxOmR9fTA8PUEuZGF0YVBvaW50SW5kZXhlc1t3XSYmMCE9PSQubWFya2VyU2l6ZSYmXHJcbigwPCQubWFya2VyU2l6ZXx8MDxBLm1hcmtlclNpemUpJiYodz1BLmdldE1hcmtlclByb3BlcnRpZXMocCxuLGQsYyksaC5wdXNoKHcpLG1hcmtlckNvbG9yPVIoRSksdiYmaC5wdXNoKHt4Om4seTpkLGN0eDp5LHR5cGU6dy50eXBlLHNpemU6dy5zaXplLGNvbG9yOm1hcmtlckNvbG9yLGJvcmRlckNvbG9yOm1hcmtlckNvbG9yLGJvcmRlclRoaWNrbmVzczp3LmJvcmRlclRoaWNrbmVzc30pKTsoJC5pbmRleExhYmVsfHxBLmluZGV4TGFiZWx8fCQuaW5kZXhMYWJlbEZvcm1hdHRlcnx8QS5pbmRleExhYmVsRm9ybWF0dGVyKSYmdGhpcy5faW5kZXhMYWJlbHMucHVzaCh7Y2hhcnRUeXBlOlwic3RhY2tlZEFyZWExMDBcIixkYXRhUG9pbnQ6JCxkYXRhU2VyaWVzOkEscG9pbnQ6e3g6bix5OmR9LGRpcmVjdGlvbjowPnpbcF0ueT09PWEuYXhpc1kucmV2ZXJzZWQ/MTotMSxjb2xvcjplfSl9fWYoKTtjLm1vdmVUbyhuLGQpO3YmJnkubW92ZVRvKG4sZCl9ZGVsZXRlIEEuZGF0YVBvaW50SW5kZXhlc31qYS5kcmF3TWFya2VycyhoKTtcclxudiYmKGIuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZ0aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5jbGVhclJlY3QoZy54MSxnLnkxLGcud2lkdGgsZy5oZWlnaHQpLHkucmVzdG9yZSgpKTtjLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmIsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpILnhDbGlwQW5pbWF0aW9uLFxyXG5lYXNpbmdGdW5jdGlvbjpILmVhc2luZy5saW5lYXIsYW5pbWF0aW9uQmFzZTowfX19O3EucHJvdG90eXBlLnJlbmRlckJ1YmJsZT1mdW5jdGlvbihhKXt2YXIgZj1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYj12P3RoaXMuX3ByZVJlbmRlckN0eDpmO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgYz10aGlzLnBsb3RBcmVhLGU9MCxnLGg7Yi5zYXZlKCk7diYmdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnNhdmUoKTtiLmJlZ2luUGF0aCgpO2IucmVjdChjLngxLGMueTEsYy53aWR0aCxjLmhlaWdodCk7Yi5jbGlwKCk7diYmKHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5iZWdpblBhdGgoKSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVjdChjLngxLGMueTEsYy53aWR0aCxjLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmNsaXAoKSk7Zm9yKHZhciBsPS1JbmZpbml0eSx0PUluZmluaXR5LGs9MDtrPFxyXG5hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtrKyspZm9yKHZhciByPWEuZGF0YVNlcmllc0luZGV4ZXNba10scD10aGlzLmRhdGFbcl0sbj1wLmRhdGFQb2ludHMsZD0wLGU9MDtlPG4ubGVuZ3RoO2UrKylnPW5bZV0uZ2V0VGltZT9nPW5bZV0ueC5nZXRUaW1lKCk6Zz1uW2VdLngsZzxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxnPmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXh8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgbltlXS56fHwoZD1uW2VdLnosZD5sJiYobD1kKSxkPHQmJih0PWQpKTtmb3IodmFyIHc9MjUqTWF0aC5QSSxtPU1hdGgubWF4KE1hdGgucG93KDAuMjUqTWF0aC5taW4oYy5oZWlnaHQsYy53aWR0aCkvMiwyKSpNYXRoLlBJLHcpLGs9MDtrPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO2srKylpZihyPWEuZGF0YVNlcmllc0luZGV4ZXNba10scD10aGlzLmRhdGFbcl0sbj1wLmRhdGFQb2ludHMsMDxuLmxlbmd0aClmb3IoYi5zdHJva2VTdHlsZT1cIiM0NTcyQTcgXCIsXHJcbmU9MDtlPG4ubGVuZ3RoO2UrKylpZihnPW5bZV0uZ2V0VGltZT9nPW5bZV0ueC5nZXRUaW1lKCk6Zz1uW2VdLngsIShnPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fGc+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCkmJlwibnVtYmVyXCI9PT10eXBlb2YgbltlXS55KXtnPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChnKTtoPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChuW2VdLnkpO3ZhciBkPW5bZV0ueixzPTIqTWF0aC5tYXgoTWF0aC5zcXJ0KChsPT09dD9tLzI6dysobS13KS8obC10KSooZC10KSkvTWF0aC5QSSk8PDAsMSksZD1wLmdldE1hcmtlclByb3BlcnRpZXMoZSxiKTtkLnNpemU9cztiLmdsb2JhbEFscGhhPXAuZmlsbE9wYWNpdHk7amEuZHJhd01hcmtlcihnLGgsYixkLnR5cGUsZC5zaXplLGQuY29sb3IsZC5ib3JkZXJDb2xvcixkLmJvcmRlclRoaWNrbmVzcyk7Yi5nbG9iYWxBbHBoYT0xO3ZhciB1PXAuZGF0YVBvaW50SWRzW2VdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbdV09XHJcbntpZDp1LG9iamVjdFR5cGU6XCJkYXRhUG9pbnRcIixkYXRhU2VyaWVzSW5kZXg6cixkYXRhUG9pbnRJbmRleDplLHgxOmcseTE6aCxzaXplOnN9O3M9Uih1KTt2JiZqYS5kcmF3TWFya2VyKGcsaCx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsZC50eXBlLGQuc2l6ZSxzLHMsZC5ib3JkZXJUaGlja25lc3MpOyhuW2VdLmluZGV4TGFiZWx8fHAuaW5kZXhMYWJlbHx8bltlXS5pbmRleExhYmVsRm9ybWF0dGVyfHxwLmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJidWJibGVcIixkYXRhUG9pbnQ6bltlXSxkYXRhU2VyaWVzOnAscG9pbnQ6e3g6Zyx5Omh9LGRpcmVjdGlvbjoxLGJvdW5kczp7eDE6Zy1kLnNpemUvMix5MTpoLWQuc2l6ZS8yLHgyOmcrZC5zaXplLzIseTI6aCtkLnNpemUvMn0sY29sb3I6bnVsbH0pfXYmJihmLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGIuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVxyXG5cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmNsZWFyUmVjdChjLngxLGMueTEsYy53aWR0aCxjLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlc3RvcmUoKSk7Yi5yZXN0b3JlKCk7cmV0dXJue3NvdXJjZTpmLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6SC5mYWRlSW5BbmltYXRpb24sZWFzaW5nRnVuY3Rpb246SC5lYXNpbmcuZWFzZUluUXVhZCxhbmltYXRpb25CYXNlOjB9fX07cS5wcm90b3R5cGUucmVuZGVyU2NhdHRlcj1cclxuZnVuY3Rpb24oYSl7dmFyIGY9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGI9dj90aGlzLl9wcmVSZW5kZXJDdHg6ZjtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGM9dGhpcy5wbG90QXJlYSxlPTAsZyxoO2Iuc2F2ZSgpO3YmJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yi5iZWdpblBhdGgoKTtiLnJlY3QoYy54MSxjLnkxLGMud2lkdGgsYy5oZWlnaHQpO2IuY2xpcCgpO3YmJih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguYmVnaW5QYXRoKCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlY3QoYy54MSxjLnkxLGMud2lkdGgsYy5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5jbGlwKCkpO2Zvcih2YXIgbD0wO2w8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7bCsrKXt2YXIgdD1hLmRhdGFTZXJpZXNJbmRleGVzW2xdLGs9dGhpcy5kYXRhW3RdLHI9ay5kYXRhUG9pbnRzO2lmKDA8XHJcbnIubGVuZ3RoKXtiLnN0cm9rZVN0eWxlPVwiIzQ1NzJBNyBcIjtNYXRoLnBvdygwLjMqTWF0aC5taW4oYy5oZWlnaHQsYy53aWR0aCkvMiwyKTtmb3IodmFyIHA9MCxuPTAsZT0wO2U8ci5sZW5ndGg7ZSsrKWlmKGc9cltlXS5nZXRUaW1lP2c9cltlXS54LmdldFRpbWUoKTpnPXJbZV0ueCwhKGc8YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1pbnx8Zz5hLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWF4KSYmXCJudW1iZXJcIj09PXR5cGVvZiByW2VdLnkpe2c9YS5heGlzWC5jb252ZXJ0VmFsdWVUb1BpeGVsKGcpO2g9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHJbZV0ueSk7dmFyIGQ9ay5nZXRNYXJrZXJQcm9wZXJ0aWVzKGUsZyxoLGIpO2IuZ2xvYmFsQWxwaGE9ay5maWxsT3BhY2l0eTtqYS5kcmF3TWFya2VyKGQueCxkLnksZC5jdHgsZC50eXBlLGQuc2l6ZSxkLmNvbG9yLGQuYm9yZGVyQ29sb3IsZC5ib3JkZXJUaGlja25lc3MpO2IuZ2xvYmFsQWxwaGE9MTtNYXRoLnNxcnQoKHAtXHJcbmcpKihwLWcpKyhuLWgpKihuLWgpKTxNYXRoLm1pbihkLnNpemUsNSkmJnIubGVuZ3RoPk1hdGgubWluKHRoaXMucGxvdEFyZWEud2lkdGgsdGhpcy5wbG90QXJlYS5oZWlnaHQpfHwocD1rLmRhdGFQb2ludElkc1tlXSx0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW3BdPXtpZDpwLG9iamVjdFR5cGU6XCJkYXRhUG9pbnRcIixkYXRhU2VyaWVzSW5kZXg6dCxkYXRhUG9pbnRJbmRleDplLHgxOmcseTE6aH0scD1SKHApLHYmJmphLmRyYXdNYXJrZXIoZC54LGQueSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsZC50eXBlLGQuc2l6ZSxwLHAsZC5ib3JkZXJUaGlja25lc3MpLChyW2VdLmluZGV4TGFiZWx8fGsuaW5kZXhMYWJlbHx8cltlXS5pbmRleExhYmVsRm9ybWF0dGVyfHxrLmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJzY2F0dGVyXCIsZGF0YVBvaW50OnJbZV0sZGF0YVNlcmllczprLHBvaW50Ont4OmcseTpofSxkaXJlY3Rpb246MSxcclxuYm91bmRzOnt4MTpnLWQuc2l6ZS8yLHkxOmgtZC5zaXplLzIseDI6ZytkLnNpemUvMix5MjpoK2Quc2l6ZS8yfSxjb2xvcjpudWxsfSkscD1nLG49aCl9fX12JiYoZi5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmNsZWFyUmVjdChjLngxLGMueTEsYy53aWR0aCxjLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlc3RvcmUoKSk7XHJcbmIucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZixkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOkguZmFkZUluQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmVhc2VJblF1YWQsYW5pbWF0aW9uQmFzZTowfX19O3EucHJvdG90eXBlLnJlbmRlckNhbmRsZXN0aWNrPWZ1bmN0aW9uKGEpe3ZhciBmPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxiPXY/dGhpcy5fcHJlUmVuZGVyQ3R4OmYsYz10aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHg7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBlPW51bGwsZz1udWxsLGg9dGhpcy5wbG90QXJlYSxsPTAsdCxrLHIscCxuLGQsZT10aGlzLmRhdGFQb2ludE1pbldpZHRoP3RoaXMuZGF0YVBvaW50TWluV2lkdGg6dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjEsZz10aGlzLmRhdGFQb2ludE1heFdpZHRoP3RoaXMuZGF0YVBvaW50TWF4V2lkdGg6XHJcbnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDowLjAxNSp0aGlzLndpZHRoLHc9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKHcpfHwodz0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO3c9dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuNypoLndpZHRoKihhLmF4aXNYLmxvZ2FyaXRobWljP01hdGgubG9nKHcpL01hdGgubG9nKGEuYXhpc1gucmFuZ2UpOk1hdGguYWJzKHcpL01hdGguYWJzKGEuYXhpc1gucmFuZ2UpKTw8MDt0aGlzLmRhdGFQb2ludE1heFdpZHRoJiZlPmcmJihlPU1hdGgubWluKHRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpJbmZpbml0eSxnKSk7IXRoaXMuZGF0YVBvaW50TWF4V2lkdGgmJih0aGlzLmRhdGFQb2ludE1pbldpZHRoJiZnPGUpJiYoZz1NYXRoLm1heCh0aGlzLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6LUluZmluaXR5LGUpKTt3PGUmJlxyXG4odz1lKTt3PmcmJih3PWcpO2Iuc2F2ZSgpO3YmJmMuc2F2ZSgpO2IuYmVnaW5QYXRoKCk7Yi5yZWN0KGgueDEsaC55MSxoLndpZHRoLGguaGVpZ2h0KTtiLmNsaXAoKTt2JiYoYy5iZWdpblBhdGgoKSxjLnJlY3QoaC54MSxoLnkxLGgud2lkdGgsaC5oZWlnaHQpLGMuY2xpcCgpKTtmb3IodmFyIG09MDttPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO20rKyl7dmFyIHM9YS5kYXRhU2VyaWVzSW5kZXhlc1ttXSx1PXRoaXMuZGF0YVtzXSxxPXUuZGF0YVBvaW50cztpZigwPHEubGVuZ3RoKWZvcih2YXIgY2E9NTx3JiZ1LmJldmVsRW5hYmxlZD8hMDohMSxsPTA7bDxxLmxlbmd0aDtsKyspaWYocVtsXS5nZXRUaW1lP2Q9cVtsXS54LmdldFRpbWUoKTpkPXFbbF0ueCwhKGQ8YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1pbnx8ZD5hLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWF4KSYmIXkocVtsXS55KSYmcVtsXS55Lmxlbmd0aCYmXCJudW1iZXJcIj09PXR5cGVvZiBxW2xdLnlbMF0mJlxyXG5cIm51bWJlclwiPT09dHlwZW9mIHFbbF0ueVsxXSYmXCJudW1iZXJcIj09PXR5cGVvZiBxW2xdLnlbMl0mJlwibnVtYmVyXCI9PT10eXBlb2YgcVtsXS55WzNdKXt0PWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChkKTtrPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChxW2xdLnlbMF0pO3I9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHFbbF0ueVsxXSk7cD1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwocVtsXS55WzJdKTtuPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChxW2xdLnlbM10pO3ZhciB4PXQtdy8yPDwwLEI9eCt3PDwwLGc9dS5vcHRpb25zLmZhbGxpbmdDb2xvcj91LmZhbGxpbmdDb2xvcjp1Ll9jb2xvclNldFswXSxlPXFbbF0uY29sb3I/cVtsXS5jb2xvcjp1Ll9jb2xvclNldFswXSxBPU1hdGgucm91bmQoTWF0aC5tYXgoMSwwLjE1KncpKSx6PTA9PT1BJTI/MDowLjUsTD11LmRhdGFQb2ludElkc1tsXTt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW0xdPVxyXG57aWQ6TCxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4OnMsZGF0YVBvaW50SW5kZXg6bCx4MTp4LHkxOmsseDI6Qix5MjpyLHgzOnQseTM6cCx4NDp0LHk0Om4sYm9yZGVyVGhpY2tuZXNzOkEsY29sb3I6ZX07Yi5zdHJva2VTdHlsZT1lO2IuYmVnaW5QYXRoKCk7Yi5saW5lV2lkdGg9QTtjLmxpbmVXaWR0aD1NYXRoLm1heChBLDQpO1wiY2FuZGxlc3RpY2tcIj09PXUudHlwZT8oYi5tb3ZlVG8odC16LHIpLGIubGluZVRvKHQteixNYXRoLm1pbihrLG4pKSxiLnN0cm9rZSgpLGIubW92ZVRvKHQteixNYXRoLm1heChrLG4pKSxiLmxpbmVUbyh0LXoscCksYi5zdHJva2UoKSxWKGIseCxNYXRoLm1pbihrLG4pLEIsTWF0aC5tYXgoayxuKSxxW2xdLnlbMF08PXFbbF0ueVszXT91LnJpc2luZ0NvbG9yOmcsQSxlLGNhLGNhLCExLCExLHUuZmlsbE9wYWNpdHkpLHYmJihlPVIoTCksYy5zdHJva2VTdHlsZT1lLGMubW92ZVRvKHQteixyKSxjLmxpbmVUbyh0LXosTWF0aC5taW4oayxcclxubikpLGMuc3Ryb2tlKCksYy5tb3ZlVG8odC16LE1hdGgubWF4KGssbikpLGMubGluZVRvKHQteixwKSxjLnN0cm9rZSgpLFYoYyx4LE1hdGgubWluKGssbiksQixNYXRoLm1heChrLG4pLGUsMCxudWxsLCExLCExLCExLCExKSkpOlwib2hsY1wiPT09dS50eXBlJiYoYi5tb3ZlVG8odC16LHIpLGIubGluZVRvKHQteixwKSxiLnN0cm9rZSgpLGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8odCxrKSxiLmxpbmVUbyh4LGspLGIuc3Ryb2tlKCksYi5iZWdpblBhdGgoKSxiLm1vdmVUbyh0LG4pLGIubGluZVRvKEIsbiksYi5zdHJva2UoKSx2JiYoZT1SKEwpLGMuc3Ryb2tlU3R5bGU9ZSxjLm1vdmVUbyh0LXosciksYy5saW5lVG8odC16LHApLGMuc3Ryb2tlKCksYy5iZWdpblBhdGgoKSxjLm1vdmVUbyh0LGspLGMubGluZVRvKHgsayksYy5zdHJva2UoKSxjLmJlZ2luUGF0aCgpLGMubW92ZVRvKHQsbiksYy5saW5lVG8oQixuKSxjLnN0cm9rZSgpKSk7KHFbbF0uaW5kZXhMYWJlbHx8dS5pbmRleExhYmVsfHxcclxucVtsXS5pbmRleExhYmVsRm9ybWF0dGVyfHx1LmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6dS50eXBlLGRhdGFQb2ludDpxW2xdLGRhdGFTZXJpZXM6dSxwb2ludDp7eDp4KyhCLXgpLzIseTphLmF4aXNZLnJldmVyc2VkP3A6cn0sZGlyZWN0aW9uOjEsYm91bmRzOnt4MTp4LHkxOk1hdGgubWluKHIscCkseDI6Qix5MjpNYXRoLm1heChyLHApfSxjb2xvcjplfSl9fXYmJihmLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGIuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmIuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLFxyXG50aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmNsZWFyUmVjdChoLngxLGgueTEsaC53aWR0aCxoLmhlaWdodCksYy5yZXN0b3JlKCkpO2IucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZixkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOkguZmFkZUluQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmVhc2VJblF1YWQsYW5pbWF0aW9uQmFzZTowfX19O3EucHJvdG90eXBlLnJlbmRlckJveEFuZFdoaXNrZXI9ZnVuY3Rpb24oYSl7dmFyIGY9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGI9dj90aGlzLl9wcmVSZW5kZXJDdHg6ZixjPXRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eDtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGU9bnVsbCxnPXRoaXMucGxvdEFyZWEsXHJcbmg9MCxsLHQsayxyLHAsbixkLGU9dGhpcy5kYXRhUG9pbnRNaW5XaWR0aD90aGlzLmRhdGFQb2ludE1pbldpZHRoOnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDoxLGg9dGhpcy5kYXRhUG9pbnRNYXhXaWR0aD90aGlzLmRhdGFQb2ludE1heFdpZHRoOnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDowLjAxNSp0aGlzLndpZHRoLHc9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKHcpfHwodz0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO3c9dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuNypnLndpZHRoKihhLmF4aXNYLmxvZ2FyaXRobWljP01hdGgubG9nKHcpL01hdGgubG9nKGEuYXhpc1gucmFuZ2UpOk1hdGguYWJzKHcpL01hdGguYWJzKGEuYXhpc1gucmFuZ2UpKTw8MDt0aGlzLmRhdGFQb2ludE1heFdpZHRoJiZlPmgmJihlPU1hdGgubWluKHRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpcclxuSW5maW5pdHksaCkpOyF0aGlzLmRhdGFQb2ludE1heFdpZHRoJiYodGhpcy5kYXRhUG9pbnRNaW5XaWR0aCYmaDxlKSYmKGg9TWF0aC5tYXgodGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOi1JbmZpbml0eSxlKSk7dzxlJiYodz1lKTt3PmgmJih3PWgpO2Iuc2F2ZSgpO3YmJmMuc2F2ZSgpO2IuYmVnaW5QYXRoKCk7Yi5yZWN0KGcueDEsZy55MSxnLndpZHRoLGcuaGVpZ2h0KTtiLmNsaXAoKTt2JiYoYy5iZWdpblBhdGgoKSxjLnJlY3QoZy54MSxnLnkxLGcud2lkdGgsZy5oZWlnaHQpLGMuY2xpcCgpKTtmb3IodmFyIG09ITEsbT0hIWEuYXhpc1kucmV2ZXJzZWQscz0wO3M8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7cysrKXt2YXIgdT1hLmRhdGFTZXJpZXNJbmRleGVzW3NdLHE9dGhpcy5kYXRhW3VdLHg9cS5kYXRhUG9pbnRzO2lmKDA8eC5sZW5ndGgpZm9yKHZhciB6PTU8dyYmcS5iZXZlbEVuYWJsZWQ/ITA6ITEsaD0wO2g8eC5sZW5ndGg7aCsrKWlmKHhbaF0uZ2V0VGltZT9cclxuZD14W2hdLnguZ2V0VGltZSgpOmQ9eFtoXS54LCEoZDxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxkPmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgpJiYheSh4W2hdLnkpJiZ4W2hdLnkubGVuZ3RoJiZcIm51bWJlclwiPT09dHlwZW9mIHhbaF0ueVswXSYmXCJudW1iZXJcIj09PXR5cGVvZiB4W2hdLnlbMV0mJlwibnVtYmVyXCI9PT10eXBlb2YgeFtoXS55WzJdJiZcIm51bWJlclwiPT09dHlwZW9mIHhbaF0ueVszXSYmXCJudW1iZXJcIj09PXR5cGVvZiB4W2hdLnlbNF0mJjU9PT14W2hdLnkubGVuZ3RoKXtsPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChkKTt0PWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbCh4W2hdLnlbMF0pO2s9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHhbaF0ueVsxXSk7cj1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeFtoXS55WzJdKTtwPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbCh4W2hdLnlbM10pO249YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHhbaF0ueVs0XSk7XHJcbnZhciBCPWwtdy8yPDwwLEE9bCt3LzI8PDAsZT14W2hdLmNvbG9yP3hbaF0uY29sb3I6cS5fY29sb3JTZXRbMF0sQz1NYXRoLnJvdW5kKE1hdGgubWF4KDEsMC4xNSp3KSksTD0wPT09QyUyPzA6MC41LEo9eFtoXS53aGlza2VyQ29sb3I/eFtoXS53aGlza2VyQ29sb3I6eFtoXS5jb2xvcj9xLndoaXNrZXJDb2xvcj9xLndoaXNrZXJDb2xvcjp4W2hdLmNvbG9yOnEud2hpc2tlckNvbG9yP3Eud2hpc2tlckNvbG9yOmUsST1cIm51bWJlclwiPT09dHlwZW9mIHhbaF0ud2hpc2tlclRoaWNrbmVzcz94W2hdLndoaXNrZXJUaGlja25lc3M6XCJudW1iZXJcIj09PXR5cGVvZiBxLm9wdGlvbnMud2hpc2tlclRoaWNrbmVzcz9xLndoaXNrZXJUaGlja25lc3M6QyxkYT14W2hdLndoaXNrZXJEYXNoVHlwZT94W2hdLndoaXNrZXJEYXNoVHlwZTpxLndoaXNrZXJEYXNoVHlwZSxlYT15KHhbaF0ud2hpc2tlckxlbmd0aCk/eShxLm9wdGlvbnMud2hpc2tlckxlbmd0aCk/dzpxLndoaXNrZXJMZW5ndGg6eFtoXS53aGlza2VyTGVuZ3RoLFxyXG5lYT1cIm51bWJlclwiPT09dHlwZW9mIGVhPzA+PWVhPzA6ZWE+PXc/dzplYTpcInN0cmluZ1wiPT09dHlwZW9mIGVhP3BhcnNlSW50KGVhKSp3LzEwMD53P3c6cGFyc2VJbnQoZWEpKncvMTAwOncsJD0xPT09TWF0aC5yb3VuZChJKSUyPzAuNTowLHhhPXhbaF0uc3RlbUNvbG9yP3hbaF0uc3RlbUNvbG9yOnhbaF0uY29sb3I/cS5zdGVtQ29sb3I/cS5zdGVtQ29sb3I6eFtoXS5jb2xvcjpxLnN0ZW1Db2xvcj9xLnN0ZW1Db2xvcjplLG9hPVwibnVtYmVyXCI9PT10eXBlb2YgeFtoXS5zdGVtVGhpY2tuZXNzP3hbaF0uc3RlbVRoaWNrbmVzczpcIm51bWJlclwiPT09dHlwZW9mIHEub3B0aW9ucy5zdGVtVGhpY2tuZXNzP3Euc3RlbVRoaWNrbmVzczpDLEU9MT09PU1hdGgucm91bmQob2EpJTI/MC41OjAsZWI9eFtoXS5zdGVtRGFzaFR5cGU/eFtoXS5zdGVtRGFzaFR5cGU6cS5zdGVtRGFzaFR5cGUsUD14W2hdLmxpbmVDb2xvcj94W2hdLmxpbmVDb2xvcjp4W2hdLmNvbG9yP3EubGluZUNvbG9yP3EubGluZUNvbG9yOlxyXG54W2hdLmNvbG9yOnEubGluZUNvbG9yP3EubGluZUNvbG9yOmUsTz1cIm51bWJlclwiPT09dHlwZW9mIHhbaF0ubGluZVRoaWNrbmVzcz94W2hdLmxpbmVUaGlja25lc3M6XCJudW1iZXJcIj09PXR5cGVvZiBxLm9wdGlvbnMubGluZVRoaWNrbmVzcz9xLmxpbmVUaGlja25lc3M6QyxRPXhbaF0ubGluZURhc2hUeXBlP3hbaF0ubGluZURhc2hUeXBlOnEubGluZURhc2hUeXBlLEs9MT09PU1hdGgucm91bmQoTyklMj8wLjU6MCxOPXEudXBwZXJCb3hDb2xvcixVPXEubG93ZXJCb3hDb2xvcix0YT15KHEub3B0aW9ucy5maWxsT3BhY2l0eSk/MTpxLmZpbGxPcGFjaXR5LE09cS5kYXRhUG9pbnRJZHNbaF07dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtNXT17aWQ6TSxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4OnUsZGF0YVBvaW50SW5kZXg6aCx4MTpCLHkxOnQseDI6QSx5MjprLHgzOmwseTM6cix4NDpsLHk0OnAseTU6bixib3JkZXJUaGlja25lc3M6Qyxjb2xvcjplLFxyXG5zdGVtVGhpY2tuZXNzOm9hLHN0ZW1Db2xvcjp4YSx3aGlza2VyVGhpY2tuZXNzOkksd2hpc2tlckxlbmd0aDplYSx3aGlza2VyQ29sb3I6SixsaW5lVGhpY2tuZXNzOk8sbGluZUNvbG9yOlB9O2Iuc2F2ZSgpOzA8b2EmJihiLmJlZ2luUGF0aCgpLGIuc3Ryb2tlU3R5bGU9eGEsYi5saW5lV2lkdGg9b2EsYi5zZXRMaW5lRGFzaCYmYi5zZXRMaW5lRGFzaChHKGViLG9hKSksYi5tb3ZlVG8obC1FLGspLGIubGluZVRvKGwtRSx0KSxiLnN0cm9rZSgpLGIubW92ZVRvKGwtRSxwKSxiLmxpbmVUbyhsLUUsciksYi5zdHJva2UoKSk7Yi5yZXN0b3JlKCk7Yy5saW5lV2lkdGg9TWF0aC5tYXgoQyw0KTtiLmJlZ2luUGF0aCgpO1YoYixCLE1hdGgubWluKG4sayksQSxNYXRoLm1heChrLG4pLFUsMCxlLG0/ejohMSxtPyExOnosITEsITEsdGEpO2IuYmVnaW5QYXRoKCk7VihiLEIsTWF0aC5taW4ocixuKSxBLE1hdGgubWF4KG4sciksTiwwLGUsbT8hMTp6LG0/ejohMSwhMSwhMSx0YSk7Yi5iZWdpblBhdGgoKTtcclxuYi5saW5lV2lkdGg9QztiLnN0cm9rZVN0eWxlPWU7Yi5yZWN0KEItTCxNYXRoLm1pbihrLHIpLUwsQS1CKzIqTCxNYXRoLm1heChrLHIpLU1hdGgubWluKGsscikrMipMKTtiLnN0cm9rZSgpO2Iuc2F2ZSgpOzA8TyYmKGIuYmVnaW5QYXRoKCksYi5nbG9iYWxBbHBoYT0xLGIuc2V0TGluZURhc2gmJmIuc2V0TGluZURhc2goRyhRLE8pKSxiLnN0cm9rZVN0eWxlPVAsYi5saW5lV2lkdGg9TyxiLm1vdmVUbyhCLG4tSyksYi5saW5lVG8oQSxuLUspLGIuc3Ryb2tlKCkpO2IucmVzdG9yZSgpO2Iuc2F2ZSgpOzA8SSYmKGIuYmVnaW5QYXRoKCksYi5zZXRMaW5lRGFzaCYmYi5zZXRMaW5lRGFzaChHKGRhLEkpKSxiLnN0cm9rZVN0eWxlPUosYi5saW5lV2lkdGg9SSxiLm1vdmVUbyhsLWVhLzI8PDAscC0kKSxiLmxpbmVUbyhsK2VhLzI8PDAscC0kKSxiLnN0cm9rZSgpLGIubW92ZVRvKGwtZWEvMjw8MCx0KyQpLGIubGluZVRvKGwrZWEvMjw8MCx0KyQpLGIuc3Ryb2tlKCkpO2IucmVzdG9yZSgpO1xyXG52JiYoZT1SKE0pLGMuc3Ryb2tlU3R5bGU9ZSxjLmxpbmVXaWR0aD1vYSwwPG9hJiYoYy5tb3ZlVG8obC1MLUUsayksYy5saW5lVG8obC1MLUUsTWF0aC5tYXgodCxwKSksYy5zdHJva2UoKSxjLm1vdmVUbyhsLUwtRSxNYXRoLm1pbih0LHApKSxjLmxpbmVUbyhsLUwtRSxyKSxjLnN0cm9rZSgpKSxWKGMsQixNYXRoLm1heChrLHIpLEEsTWF0aC5taW4oayxyKSxlLDAsbnVsbCwhMSwhMSwhMSwhMSksMDxJJiYoYy5iZWdpblBhdGgoKSxjLmxpbmVXaWR0aD1JLGMubW92ZVRvKGwrZWEvMixwLSQpLGMubGluZVRvKGwtZWEvMixwLSQpLGMuc3Ryb2tlKCksYy5tb3ZlVG8obCtlYS8yLHQrJCksYy5saW5lVG8obC1lYS8yLHQrJCksYy5zdHJva2UoKSkpOyh4W2hdLmluZGV4TGFiZWx8fHEuaW5kZXhMYWJlbHx8eFtoXS5pbmRleExhYmVsRm9ybWF0dGVyfHxxLmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6cS50eXBlLGRhdGFQb2ludDp4W2hdLFxyXG5kYXRhU2VyaWVzOnEscG9pbnQ6e3g6QisoQS1CKS8yLHk6YS5heGlzWS5yZXZlcnNlZD90OnB9LGRpcmVjdGlvbjoxLGJvdW5kczp7eDE6Qix5MTpNYXRoLm1pbih0LHApLHgyOkEseTI6TWF0aC5tYXgodCxwKX0sY29sb3I6ZX0pfX12JiYoZi5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxcclxuYi5jbGVhclJlY3QoZy54MSxnLnkxLGcud2lkdGgsZy5oZWlnaHQpLGMucmVzdG9yZSgpKTtiLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmYsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpILmZhZGVJbkFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpILmVhc2luZy5lYXNlSW5RdWFkLGFuaW1hdGlvbkJhc2U6MH19fTtxLnByb3RvdHlwZS5yZW5kZXJSYW5nZUNvbHVtbj1mdW5jdGlvbihhKXt2YXIgZj1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYj12P3RoaXMuX3ByZVJlbmRlckN0eDpmO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgYz1udWxsLGU9dGhpcy5wbG90QXJlYSxnPTAsaCxsLHQsZz10aGlzLmRhdGFQb2ludE1pbldpZHRoP3RoaXMuZGF0YVBvaW50TWluV2lkdGg6dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjE7aD10aGlzLmRhdGFQb2ludE1heFdpZHRoP3RoaXMuZGF0YVBvaW50TWF4V2lkdGg6XHJcbnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDowLjAzKnRoaXMud2lkdGg7dmFyIGs9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKGspfHwoaz0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO2s9dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuOSooZS53aWR0aCooYS5heGlzWC5sb2dhcml0aG1pYz9NYXRoLmxvZyhrKS9NYXRoLmxvZyhhLmF4aXNYLnJhbmdlKTpNYXRoLmFicyhrKS9NYXRoLmFicyhhLmF4aXNYLnJhbmdlKSkvYS5wbG90VHlwZS50b3RhbERhdGFTZXJpZXMpPDwwO3RoaXMuZGF0YVBvaW50TWF4V2lkdGgmJmc+aCYmKGc9TWF0aC5taW4odGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOkluZmluaXR5LGgpKTshdGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmKHRoaXMuZGF0YVBvaW50TWluV2lkdGgmJmg8ZykmJihoPU1hdGgubWF4KHRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpcclxuLUluZmluaXR5LGcpKTtrPGcmJihrPWcpO2s+aCYmKGs9aCk7Yi5zYXZlKCk7diYmdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnNhdmUoKTtiLmJlZ2luUGF0aCgpO2IucmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCk7Yi5jbGlwKCk7diYmKHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5iZWdpblBhdGgoKSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmNsaXAoKSk7Zm9yKHZhciByPTA7cjxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtyKyspe3ZhciBwPWEuZGF0YVNlcmllc0luZGV4ZXNbcl0sbj10aGlzLmRhdGFbcF0sZD1uLmRhdGFQb2ludHM7aWYoMDxkLmxlbmd0aClmb3IodmFyIHc9NTxrJiZuLmJldmVsRW5hYmxlZD8hMDohMSxnPTA7ZzxkLmxlbmd0aDtnKyspaWYoZFtnXS5nZXRUaW1lP3Q9ZFtnXS54LmdldFRpbWUoKTp0PWRbZ10ueCwhKHQ8XHJcbmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fHQ+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCkmJiF5KGRbZ10ueSkmJmRbZ10ueS5sZW5ndGgmJlwibnVtYmVyXCI9PT10eXBlb2YgZFtnXS55WzBdJiZcIm51bWJlclwiPT09dHlwZW9mIGRbZ10ueVsxXSl7Yz1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwodCk7aD1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoZFtnXS55WzBdKTtsPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChkW2ddLnlbMV0pO3ZhciBtPWEuYXhpc1gucmV2ZXJzZWQ/YythLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcyprLzItKGEucHJldmlvdXNEYXRhU2VyaWVzQ291bnQrcikqazw8MDpjLWEucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKmsvMisoYS5wcmV2aW91c0RhdGFTZXJpZXNDb3VudCtyKSprPDwwLHE9YS5heGlzWC5yZXZlcnNlZD9tLWs8PDA6bStrPDwwLGM9ZFtnXS5jb2xvcj9kW2ddLmNvbG9yOm4uX2NvbG9yU2V0W2clbi5fY29sb3JTZXQubGVuZ3RoXTtcclxuaWYoaD5sKXt2YXIgdT1oO2g9bDtsPXV9dT1uLmRhdGFQb2ludElkc1tnXTt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW3VdPXtpZDp1LG9iamVjdFR5cGU6XCJkYXRhUG9pbnRcIixkYXRhU2VyaWVzSW5kZXg6cCxkYXRhUG9pbnRJbmRleDpnLHgxOm0seTE6aCx4MjpxLHkyOmx9O1YoYixtLGgscSxsLGMsMCxjLHcsdywhMSwhMSxuLmZpbGxPcGFjaXR5KTtjPVIodSk7diYmVih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsbSxoLHEsbCxjLDAsbnVsbCwhMSwhMSwhMSwhMSk7aWYoZFtnXS5pbmRleExhYmVsfHxuLmluZGV4TGFiZWx8fGRbZ10uaW5kZXhMYWJlbEZvcm1hdHRlcnx8bi5pbmRleExhYmVsRm9ybWF0dGVyKXRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcInJhbmdlQ29sdW1uXCIsZGF0YVBvaW50OmRbZ10sZGF0YVNlcmllczpuLGluZGV4S2V5d29yZDowLHBvaW50Ont4Om0rKHEtbSkvMix5OmRbZ10ueVsxXT49ZFtnXS55WzBdP2w6aH0sZGlyZWN0aW9uOmRbZ10ueVsxXT49XHJcbmRbZ10ueVswXT8tMToxLGJvdW5kczp7eDE6bSx5MTpNYXRoLm1pbihoLGwpLHgyOnEseTI6TWF0aC5tYXgoaCxsKX0sY29sb3I6Y30pLHRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcInJhbmdlQ29sdW1uXCIsZGF0YVBvaW50OmRbZ10sZGF0YVNlcmllczpuLGluZGV4S2V5d29yZDoxLHBvaW50Ont4Om0rKHEtbSkvMix5OmRbZ10ueVsxXT49ZFtnXS55WzBdP2g6bH0sZGlyZWN0aW9uOmRbZ10ueVsxXT49ZFtnXS55WzBdPzE6LTEsYm91bmRzOnt4MTptLHkxOk1hdGgubWluKGgsbCkseDI6cSx5MjpNYXRoLm1heChoLGwpfSxjb2xvcjpjfSl9fXYmJihmLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGIuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmIuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksXHJcbmEuYXhpc1kubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmNsZWFyUmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlc3RvcmUoKSk7Yi5yZXN0b3JlKCk7cmV0dXJue3NvdXJjZTpmLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6SC5mYWRlSW5BbmltYXRpb24sZWFzaW5nRnVuY3Rpb246SC5lYXNpbmcuZWFzZUluUXVhZCxhbmltYXRpb25CYXNlOjB9fX07cS5wcm90b3R5cGUucmVuZGVyRXJyb3I9ZnVuY3Rpb24oYSl7dmFyIGY9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGI9dj90aGlzLl9wcmVSZW5kZXJDdHg6XHJcbmYsYz1hLmF4aXNZLl9wb3NpdGlvbj9cImxlZnRcIj09PWEuYXhpc1kuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT1hLmF4aXNZLl9wb3NpdGlvbj8hMTohMDohMTtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGU9bnVsbCxnPSExLGg9dGhpcy5wbG90QXJlYSxsPTAsdCxrLHIscCxuLGQsdyxtPWEuYXhpc1guZGF0YUluZm8ubWluRGlmZjtpc0Zpbml0ZShtKXx8KG09MC4zKk1hdGguYWJzKGEuYXhpc1gucmFuZ2UpKTtiLnNhdmUoKTt2JiZ0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguc2F2ZSgpO2IuYmVnaW5QYXRoKCk7Yi5yZWN0KGgueDEsaC55MSxoLndpZHRoLGguaGVpZ2h0KTtiLmNsaXAoKTt2JiYodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmJlZ2luUGF0aCgpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZWN0KGgueDEsaC55MSxoLndpZHRoLGguaGVpZ2h0KSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguY2xpcCgpKTtmb3IodmFyIHE9XHJcbjAsdT0wO3U8dGhpcy5kYXRhLmxlbmd0aDt1KyspIXRoaXMuZGF0YVt1XS50eXBlLm1hdGNoKC8oYmFyfGNvbHVtbikvaWcpfHwhdGhpcy5kYXRhW3VdLnZpc2libGV8fHRoaXMuZGF0YVt1XS50eXBlLm1hdGNoKC8oc3RhY2tlZCkvaWcpJiZxfHxxKys7Zm9yKHZhciBzPTA7czxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtzKyspe3ZhciB4PWEuZGF0YVNlcmllc0luZGV4ZXNbc10sYmE9dGhpcy5kYXRhW3hdLEI9YmEuZGF0YVBvaW50cyxBPXkoYmEuX2xpbmtlZFNlcmllcyk/ITE6YmEuX2xpbmtlZFNlcmllcy50eXBlLm1hdGNoKC8oYmFyfGNvbHVtbikvaWcpJiZiYS5fbGlua2VkU2VyaWVzLnZpc2libGU/ITA6ITEsQz0wO2lmKEEpZm9yKGU9YmEuX2xpbmtlZFNlcmllcy5pZCx1PTA7dTxlO3UrKykhdGhpcy5kYXRhW3VdLnR5cGUubWF0Y2goLyhiYXJ8Y29sdW1uKS9pZyl8fCF0aGlzLmRhdGFbdV0udmlzaWJsZXx8dGhpcy5kYXRhW3VdLnR5cGUubWF0Y2goLyhzdGFja2VkKS9pZykmJlxyXG5DfHwodGhpcy5kYXRhW3VdLnR5cGUubWF0Y2goLyhyYW5nZSkvaWcpJiYoZz0hMCksQysrKTtlPXRoaXMuZGF0YVBvaW50TWluV2lkdGg/dGhpcy5kYXRhUG9pbnRNaW5XaWR0aDp0aGlzLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MTtsPXRoaXMuZGF0YVBvaW50TWF4V2lkdGg/dGhpcy5kYXRhUG9pbnRNYXhXaWR0aDp0aGlzLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6Yz9NYXRoLm1pbigwLjE1KnRoaXMuaGVpZ2h0LDAuOSoodGhpcy5wbG90QXJlYS5oZWlnaHQvKEE/cToxKSkpPDwwOjAuMyp0aGlzLndpZHRoO2cmJihsPXRoaXMuZGF0YVBvaW50TWF4V2lkdGg/dGhpcy5kYXRhUG9pbnRNYXhXaWR0aDp0aGlzLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6Yz9NYXRoLm1pbigwLjE1KnRoaXMuaGVpZ2h0LDAuOSoodGhpcy5wbG90QXJlYS5oZWlnaHQvKEE/cToxKSkpPDwwOjAuMDMqdGhpcy53aWR0aCk7dT10aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/XHJcbnRoaXMuZGF0YVBvaW50V2lkdGg6MC45KigoYz9oLmhlaWdodDpoLndpZHRoKSooYS5heGlzWC5sb2dhcml0aG1pYz9NYXRoLmxvZyhtKS9NYXRoLmxvZyhhLmF4aXNYLnJhbmdlKTpNYXRoLmFicyhtKS9NYXRoLmFicyhhLmF4aXNYLnJhbmdlKSkvKEE/cToxKSk8PDA7dGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmZT5sJiYoZT1NYXRoLm1pbih0aGlzLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6SW5maW5pdHksbCkpOyF0aGlzLmRhdGFQb2ludE1heFdpZHRoJiYodGhpcy5kYXRhUG9pbnRNaW5XaWR0aCYmbDxlKSYmKGw9TWF0aC5tYXgodGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOi1JbmZpbml0eSxlKSk7dTxlJiYodT1lKTt1PmwmJih1PWwpO2lmKDA8Qi5sZW5ndGgpZm9yKHZhciBMPWJhLl9jb2xvclNldCxsPTA7bDxCLmxlbmd0aDtsKyspe3ZhciBlPWJhLmxpbmVDb2xvcj1iYS5vcHRpb25zLmNvbG9yP2JhLm9wdGlvbnMuY29sb3I6TFswXSxcclxuSj17Y29sb3I6QltsXS53aGlza2VyQ29sb3I/QltsXS53aGlza2VyQ29sb3I6QltsXS5jb2xvcj9iYS53aGlza2VyQ29sb3I/YmEud2hpc2tlckNvbG9yOkJbbF0uY29sb3I6YmEud2hpc2tlckNvbG9yP2JhLndoaXNrZXJDb2xvcjplLHRoaWNrbmVzczp5KEJbbF0ud2hpc2tlclRoaWNrbmVzcyk/YmEud2hpc2tlclRoaWNrbmVzczpCW2xdLndoaXNrZXJUaGlja25lc3MsZGFzaFR5cGU6QltsXS53aGlza2VyRGFzaFR5cGU/QltsXS53aGlza2VyRGFzaFR5cGU6YmEud2hpc2tlckRhc2hUeXBlLGxlbmd0aDp5KEJbbF0ud2hpc2tlckxlbmd0aCk/eShiYS5vcHRpb25zLndoaXNrZXJMZW5ndGgpP3U6YmEub3B0aW9ucy53aGlza2VyTGVuZ3RoOkJbbF0ud2hpc2tlckxlbmd0aCx0cmltTGVuZ3RoOnkoQltsXS53aGlza2VyTGVuZ3RoKT95KGJhLm9wdGlvbnMud2hpc2tlckxlbmd0aCk/NTA6MDowfTtKLmxlbmd0aD1cIm51bWJlclwiPT09dHlwZW9mIEoubGVuZ3RoPzA+PUoubGVuZ3RoPzA6XHJcbkoubGVuZ3RoPj11P3U6Si5sZW5ndGg6XCJzdHJpbmdcIj09PXR5cGVvZiBKLmxlbmd0aD9wYXJzZUludChKLmxlbmd0aCkqdS8xMDA+dT91OnBhcnNlSW50KEoubGVuZ3RoKSp1LzEwMD51OnU7Si50aGlja25lc3M9XCJudW1iZXJcIj09PXR5cGVvZiBKLnRoaWNrbmVzcz8wPkoudGhpY2tuZXNzPzA6TWF0aC5yb3VuZChKLnRoaWNrbmVzcyk6Mjt2YXIgST17Y29sb3I6QltsXS5zdGVtQ29sb3I/QltsXS5zdGVtQ29sb3I6QltsXS5jb2xvcj9iYS5zdGVtQ29sb3I/YmEuc3RlbUNvbG9yOkJbbF0uY29sb3I6YmEuc3RlbUNvbG9yP2JhLnN0ZW1Db2xvcjplLHRoaWNrbmVzczpCW2xdLnN0ZW1UaGlja25lc3M/QltsXS5zdGVtVGhpY2tuZXNzOmJhLnN0ZW1UaGlja25lc3MsZGFzaFR5cGU6QltsXS5zdGVtRGFzaFR5cGU/QltsXS5zdGVtRGFzaFR5cGU6YmEuc3RlbURhc2hUeXBlfTtJLnRoaWNrbmVzcz1cIm51bWJlclwiPT09dHlwZW9mIEkudGhpY2tuZXNzPzA+SS50aGlja25lc3M/MDpNYXRoLnJvdW5kKEkudGhpY2tuZXNzKTpcclxuMjtCW2xdLmdldFRpbWU/dz1CW2xdLnguZ2V0VGltZSgpOnc9QltsXS54O2lmKCEodzxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHx3PmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgpJiYheShCW2xdLnkpJiZCW2xdLnkubGVuZ3RoJiZcIm51bWJlclwiPT09dHlwZW9mIEJbbF0ueVswXSYmXCJudW1iZXJcIj09PXR5cGVvZiBCW2xdLnlbMV0pe3ZhciBkYT1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwodyk7Yz9rPWRhOnQ9ZGE7ZGE9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKEJbbF0ueVswXSk7Yz9yPWRhOm49ZGE7ZGE9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKEJbbF0ueVsxXSk7Yz9wPWRhOmQ9ZGE7Yz8obj1hLmF4aXNYLnJldmVyc2VkP2srKEE/cToxKSp1LzItKEE/Qy0xOjApKnU8PDA6ay0oQT9xOjEpKnUvMisoQT9DLTE6MCkqdTw8MCxkPWEuYXhpc1gucmV2ZXJzZWQ/bi11PDwwOm4rdTw8MCk6KHI9YS5heGlzWC5yZXZlcnNlZD90KyhBP3E6MSkqdS9cclxuMi0oQT9DLTE6MCkqdTw8MDp0LShBP3E6MSkqdS8yKyhBP0MtMTowKSp1PDwwLHA9YS5heGlzWC5yZXZlcnNlZD9yLXU8PDA6cit1PDwwKTshYyYmbj5kJiYoZGE9bixuPWQsZD1kYSk7YyYmcj5wJiYoZGE9cixyPXAscD1kYSk7ZGE9YmEuZGF0YVBvaW50SWRzW2xdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbZGFdPXtpZDpkYSxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4OngsZGF0YVBvaW50SW5kZXg6bCx4MTpNYXRoLm1pbihyLHApLHkxOk1hdGgubWluKG4sZCkseDI6TWF0aC5tYXgocCxyKSx5MjpNYXRoLm1heChkLG4pLGlzWFlTd2FwcGVkOmMsc3RlbVByb3BlcnRpZXM6SSx3aGlza2VyUHJvcGVydGllczpKfTt6KGIsTWF0aC5taW4ocixwKSxNYXRoLm1pbihuLGQpLE1hdGgubWF4KHAsciksTWF0aC5tYXgoZCxuKSxlLEosSSxjKTt2JiZ6KHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eCxyLG4scCxkLGUsSixJLGMpO2lmKEJbbF0uaW5kZXhMYWJlbHx8XHJcbmJhLmluZGV4TGFiZWx8fEJbbF0uaW5kZXhMYWJlbEZvcm1hdHRlcnx8YmEuaW5kZXhMYWJlbEZvcm1hdHRlcil0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJlcnJvclwiLGRhdGFQb2ludDpCW2xdLGRhdGFTZXJpZXM6YmEsaW5kZXhLZXl3b3JkOjAscG9pbnQ6e3g6Yz9CW2xdLnlbMV0+PUJbbF0ueVswXT9yOnA6cisocC1yKS8yLHk6Yz9uKyhkLW4pLzI6QltsXS55WzFdPj1CW2xdLnlbMF0/ZDpufSxkaXJlY3Rpb246QltsXS55WzFdPj1CW2xdLnlbMF0/LTE6MSxib3VuZHM6e3gxOmM/TWF0aC5taW4ocixwKTpyLHkxOmM/bjpNYXRoLm1pbihuLGQpLHgyOmM/TWF0aC5tYXgocixwKTpwLHkyOmM/ZDpNYXRoLm1heChuLGQpfSxjb2xvcjplLGF4aXNTd2FwcGVkOmN9KSx0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJlcnJvclwiLGRhdGFQb2ludDpCW2xdLGRhdGFTZXJpZXM6YmEsaW5kZXhLZXl3b3JkOjEscG9pbnQ6e3g6Yz9CW2xdLnlbMV0+PUJbbF0ueVswXT9cclxucDpyOnIrKHAtcikvMix5OmM/bisoZC1uKS8yOkJbbF0ueVsxXT49QltsXS55WzBdP246ZH0sZGlyZWN0aW9uOkJbbF0ueVsxXT49QltsXS55WzBdPzE6LTEsYm91bmRzOnt4MTpjP01hdGgubWluKHIscCk6cix5MTpjP246TWF0aC5taW4obixkKSx4MjpjP01hdGgubWF4KHIscCk6cCx5MjpjP2Q6TWF0aC5tYXgobixkKX0sY29sb3I6ZSxheGlzU3dhcHBlZDpjfSl9fX12JiYoZi5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLFxyXG4wLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5jbGVhclJlY3QoaC54MSxoLnkxLGgud2lkdGgsaC5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2IucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZixkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOkguZmFkZUluQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmVhc2VJblF1YWQsYW5pbWF0aW9uQmFzZTowfX19O3EucHJvdG90eXBlLnJlbmRlclJhbmdlQmFyPWZ1bmN0aW9uKGEpe3ZhciBmPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxiPXY/dGhpcy5fcHJlUmVuZGVyQ3R4OmY7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBjPW51bGwsZT10aGlzLnBsb3RBcmVhLGc9MCxoLGwsdCxrLGc9dGhpcy5kYXRhUG9pbnRNaW5XaWR0aD90aGlzLmRhdGFQb2ludE1pbldpZHRoOnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpcclxuMTtoPXRoaXMuZGF0YVBvaW50TWF4V2lkdGg/dGhpcy5kYXRhUG9pbnRNYXhXaWR0aDp0aGlzLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6TWF0aC5taW4oMC4xNSp0aGlzLmhlaWdodCwwLjkqKHRoaXMucGxvdEFyZWEuaGVpZ2h0L2EucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKSk8PDA7dmFyIHI9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKHIpfHwocj0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO3I9dGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuOSooZS5oZWlnaHQqKGEuYXhpc1gubG9nYXJpdGhtaWM/TWF0aC5sb2cocikvTWF0aC5sb2coYS5heGlzWC5yYW5nZSk6TWF0aC5hYnMocikvTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpL2EucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKTw8MDt0aGlzLmRhdGFQb2ludE1heFdpZHRoJiZnPmgmJihnPU1hdGgubWluKHRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpcclxuSW5maW5pdHksaCkpOyF0aGlzLmRhdGFQb2ludE1heFdpZHRoJiYodGhpcy5kYXRhUG9pbnRNaW5XaWR0aCYmaDxnKSYmKGg9TWF0aC5tYXgodGhpcy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOi1JbmZpbml0eSxnKSk7cjxnJiYocj1nKTtyPmgmJihyPWgpO2Iuc2F2ZSgpO3YmJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yi5iZWdpblBhdGgoKTtiLnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpO2IuY2xpcCgpO3YmJih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguYmVnaW5QYXRoKCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5jbGlwKCkpO2Zvcih2YXIgcD0wO3A8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7cCsrKXt2YXIgbj1hLmRhdGFTZXJpZXNJbmRleGVzW3BdLGQ9dGhpcy5kYXRhW25dLHc9ZC5kYXRhUG9pbnRzO1xyXG5pZigwPHcubGVuZ3RoKXt2YXIgbT01PHImJmQuYmV2ZWxFbmFibGVkPyEwOiExO2Iuc3Ryb2tlU3R5bGU9XCIjNDU3MkE3IFwiO2ZvcihnPTA7Zzx3Lmxlbmd0aDtnKyspaWYod1tnXS5nZXRUaW1lP2s9d1tnXS54LmdldFRpbWUoKTprPXdbZ10ueCwhKGs8YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1pbnx8az5hLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWF4KSYmIXkod1tnXS55KSYmd1tnXS55Lmxlbmd0aCYmXCJudW1iZXJcIj09PXR5cGVvZiB3W2ddLnlbMF0mJlwibnVtYmVyXCI9PT10eXBlb2Ygd1tnXS55WzFdKXtoPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbCh3W2ddLnlbMF0pO2w9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHdbZ10ueVsxXSk7dD1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoayk7dD1hLmF4aXNYLnJldmVyc2VkP3QrYS5wbG90VHlwZS50b3RhbERhdGFTZXJpZXMqci8yLShhLnByZXZpb3VzRGF0YVNlcmllc0NvdW50K3ApKnI8PDA6dC1hLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcypcclxuci8yKyhhLnByZXZpb3VzRGF0YVNlcmllc0NvdW50K3ApKnI8PDA7dmFyIHE9YS5heGlzWC5yZXZlcnNlZD90LXI8PDA6dCtyPDwwO2g+bCYmKGM9aCxoPWwsbD1jKTtjPXdbZ10uY29sb3I/d1tnXS5jb2xvcjpkLl9jb2xvclNldFtnJWQuX2NvbG9yU2V0Lmxlbmd0aF07VihiLGgsdCxsLHEsYywwLG51bGwsbSwhMSwhMSwhMSxkLmZpbGxPcGFjaXR5KTtjPWQuZGF0YVBvaW50SWRzW2ddO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbY109e2lkOmMsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpuLGRhdGFQb2ludEluZGV4OmcseDE6aCx5MTp0LHgyOmwseTI6cX07Yz1SKGMpO3YmJlYodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LGgsdCxsLHEsYywwLG51bGwsITEsITEsITEsITEpO2lmKHdbZ10uaW5kZXhMYWJlbHx8ZC5pbmRleExhYmVsfHx3W2ddLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fGQuaW5kZXhMYWJlbEZvcm1hdHRlcil0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJyYW5nZUJhclwiLFxyXG5kYXRhUG9pbnQ6d1tnXSxkYXRhU2VyaWVzOmQsaW5kZXhLZXl3b3JkOjAscG9pbnQ6e3g6d1tnXS55WzFdPj13W2ddLnlbMF0/aDpsLHk6dCsocS10KS8yfSxkaXJlY3Rpb246d1tnXS55WzFdPj13W2ddLnlbMF0/LTE6MSxib3VuZHM6e3gxOk1hdGgubWluKGgsbCkseTE6dCx4MjpNYXRoLm1heChoLGwpLHkyOnF9LGNvbG9yOmN9KSx0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJyYW5nZUJhclwiLGRhdGFQb2ludDp3W2ddLGRhdGFTZXJpZXM6ZCxpbmRleEtleXdvcmQ6MSxwb2ludDp7eDp3W2ddLnlbMV0+PXdbZ10ueVswXT9sOmgseTp0KyhxLXQpLzJ9LGRpcmVjdGlvbjp3W2ddLnlbMV0+PXdbZ10ueVswXT8xOi0xLGJvdW5kczp7eDE6TWF0aC5taW4oaCxsKSx5MTp0LHgyOk1hdGgubWF4KGgsbCkseTI6cX0sY29sb3I6Y30pfX19diYmKGYuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XHJcblwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmIuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGIuY2xlYXJSZWN0KGUueDEsZS55MSxlLndpZHRoLGUuaGVpZ2h0KSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVzdG9yZSgpKTtiLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmYsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpILmZhZGVJbkFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpILmVhc2luZy5lYXNlSW5RdWFkLGFuaW1hdGlvbkJhc2U6MH19fTtxLnByb3RvdHlwZS5yZW5kZXJSYW5nZUFyZWE9XHJcbmZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGYoKXtpZihzKXt2YXIgYT1udWxsOzA8ci5saW5lVGhpY2tuZXNzJiZjLnN0cm9rZSgpO2Zvcih2YXIgYj10Lmxlbmd0aC0xOzA8PWI7Yi0tKWE9dFtiXSxjLmxpbmVUbyhhLngsYS55KSxlLmxpbmVUbyhhLngsYS55KTtjLmNsb3NlUGF0aCgpO2MuZ2xvYmFsQWxwaGE9ci5maWxsT3BhY2l0eTtjLmZpbGwoKTtjLmdsb2JhbEFscGhhPTE7ZS5maWxsKCk7aWYoMDxyLmxpbmVUaGlja25lc3Mpe2MuYmVnaW5QYXRoKCk7Yy5tb3ZlVG8oYS54LGEueSk7Zm9yKGI9MDtiPHQubGVuZ3RoO2IrKylhPXRbYl0sYy5saW5lVG8oYS54LGEueSk7Yy5zdHJva2UoKX1jLmJlZ2luUGF0aCgpO2MubW92ZVRvKHcsbSk7ZS5iZWdpblBhdGgoKTtlLm1vdmVUbyh3LG0pO3M9e3g6dyx5Om19O3Q9W107dC5wdXNoKHt4OncseTpxfSl9fXZhciBiPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxjPXY/dGhpcy5fcHJlUmVuZGVyQ3R4OmI7aWYoISgwPj1cclxuYS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgZT10aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsZz1bXSxoPXRoaXMucGxvdEFyZWE7Yy5zYXZlKCk7diYmZS5zYXZlKCk7Yy5iZWdpblBhdGgoKTtjLnJlY3QoaC54MSxoLnkxLGgud2lkdGgsaC5oZWlnaHQpO2MuY2xpcCgpO3YmJihlLmJlZ2luUGF0aCgpLGUucmVjdChoLngxLGgueTEsaC53aWR0aCxoLmhlaWdodCksZS5jbGlwKCkpO2Zvcih2YXIgbD0wO2w8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7bCsrKXt2YXIgdD1bXSxrPWEuZGF0YVNlcmllc0luZGV4ZXNbbF0scj10aGlzLmRhdGFba10scD1yLmRhdGFQb2ludHMsZz1yLmlkO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbZ109e29iamVjdFR5cGU6XCJkYXRhU2VyaWVzXCIsZGF0YVNlcmllc0luZGV4Omt9O2c9UihnKTtlLmZpbGxTdHlsZT1nO3ZhciBnPVtdLG49ITAsZD0wLHcsbSxxLHUscz1udWxsO2lmKDA8cC5sZW5ndGgpe3ZhciB5PXIuX2NvbG9yU2V0W2QlXHJcbnIuX2NvbG9yU2V0Lmxlbmd0aF0seD1yLmxpbmVDb2xvcj1yLm9wdGlvbnMubGluZUNvbG9yfHx5LEI9eDtjLmZpbGxTdHlsZT15O2Muc3Ryb2tlU3R5bGU9eDtjLmxpbmVXaWR0aD1yLmxpbmVUaGlja25lc3M7dmFyIEE9XCJzb2xpZFwiO2lmKGMuc2V0TGluZURhc2gpe3ZhciB6PUcoci5udWxsRGF0YUxpbmVEYXNoVHlwZSxyLmxpbmVUaGlja25lc3MpLEE9ci5saW5lRGFzaFR5cGUsQz1HKEEsci5saW5lVGhpY2tuZXNzKTtjLnNldExpbmVEYXNoKEMpfWZvcih2YXIgSj0hMDtkPHAubGVuZ3RoO2QrKylpZih1PXBbZF0ueC5nZXRUaW1lP3BbZF0ueC5nZXRUaW1lKCk6cFtkXS54LCEodTxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHx1PmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgmJighci5jb25uZWN0TnVsbERhdGF8fCFKKSkpaWYobnVsbCE9PXBbZF0ueSYmcFtkXS55Lmxlbmd0aCYmXCJudW1iZXJcIj09PXR5cGVvZiBwW2RdLnlbMF0mJlwibnVtYmVyXCI9PT10eXBlb2YgcFtkXS55WzFdKXt3PVxyXG5hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwodSk7bT1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwocFtkXS55WzBdKTtxPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChwW2RdLnlbMV0pO258fEo/KHIuY29ubmVjdE51bGxEYXRhJiYhbj8oYy5zZXRMaW5lRGFzaCYmKHIub3B0aW9ucy5udWxsRGF0YUxpbmVEYXNoVHlwZXx8QT09PXIubGluZURhc2hUeXBlJiZyLmxpbmVEYXNoVHlwZSE9PXIubnVsbERhdGFMaW5lRGFzaFR5cGUpJiYodFt0Lmxlbmd0aC0xXS5uZXdMaW5lRGFzaEFycmF5PUMsQT1yLm51bGxEYXRhTGluZURhc2hUeXBlLGMuc2V0TGluZURhc2goeikpLGMubGluZVRvKHcsbSksdiYmZS5saW5lVG8odyxtKSx0LnB1c2goe3g6dyx5OnF9KSk6KGMuYmVnaW5QYXRoKCksYy5tb3ZlVG8odyxtKSxzPXt4OncseTptfSx0PVtdLHQucHVzaCh7eDp3LHk6cX0pLHYmJihlLmJlZ2luUGF0aCgpLGUubW92ZVRvKHcsbSkpKSxKPW49ITEpOihjLmxpbmVUbyh3LG0pLHQucHVzaCh7eDp3LFxyXG55OnF9KSx2JiZlLmxpbmVUbyh3LG0pLDA9PWQlMjUwJiZmKCkpO3U9ci5kYXRhUG9pbnRJZHNbZF07dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFt1XT17aWQ6dSxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4OmssZGF0YVBvaW50SW5kZXg6ZCx4MTp3LHkxOm0seTI6cX07ZDxwLmxlbmd0aC0xJiYoQiE9PShwW2RdLmxpbmVDb2xvcnx8eCl8fEEhPT0ocFtkXS5saW5lRGFzaFR5cGV8fHIubGluZURhc2hUeXBlKSkmJihmKCksQj1wW2RdLmxpbmVDb2xvcnx8eCx0W3QubGVuZ3RoLTFdLm5ld1N0cm9rZVN0eWxlPUIsYy5zdHJva2VTdHlsZT1CLGMuc2V0TGluZURhc2gmJihwW2RdLmxpbmVEYXNoVHlwZT8oQT1wW2RdLmxpbmVEYXNoVHlwZSx0W3QubGVuZ3RoLTFdLm5ld0xpbmVEYXNoQXJyYXk9RyhBLHIubGluZVRoaWNrbmVzcyksYy5zZXRMaW5lRGFzaCh0W3QubGVuZ3RoLTFdLm5ld0xpbmVEYXNoQXJyYXkpKTooQT1yLmxpbmVEYXNoVHlwZSx0W3QubGVuZ3RoLVxyXG4xXS5uZXdMaW5lRGFzaEFycmF5PUMsYy5zZXRMaW5lRGFzaChDKSkpKTtpZigwIT09cFtkXS5tYXJrZXJTaXplJiYoMDxwW2RdLm1hcmtlclNpemV8fDA8ci5tYXJrZXJTaXplKSl7dmFyIEk9ci5nZXRNYXJrZXJQcm9wZXJ0aWVzKGQsdyxxLGMpO2cucHVzaChJKTt2YXIgZGE9Uih1KTt2JiZnLnB1c2goe3g6dyx5OnEsY3R4OmUsdHlwZTpJLnR5cGUsc2l6ZTpJLnNpemUsY29sb3I6ZGEsYm9yZGVyQ29sb3I6ZGEsYm9yZGVyVGhpY2tuZXNzOkkuYm9yZGVyVGhpY2tuZXNzfSk7ST1yLmdldE1hcmtlclByb3BlcnRpZXMoZCx3LG0sYyk7Zy5wdXNoKEkpO2RhPVIodSk7diYmZy5wdXNoKHt4OncseTptLGN0eDplLHR5cGU6SS50eXBlLHNpemU6SS5zaXplLGNvbG9yOmRhLGJvcmRlckNvbG9yOmRhLGJvcmRlclRoaWNrbmVzczpJLmJvcmRlclRoaWNrbmVzc30pfWlmKHBbZF0uaW5kZXhMYWJlbHx8ci5pbmRleExhYmVsfHxwW2RdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fHIuaW5kZXhMYWJlbEZvcm1hdHRlcil0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJyYW5nZUFyZWFcIixcclxuZGF0YVBvaW50OnBbZF0sZGF0YVNlcmllczpyLGluZGV4S2V5d29yZDowLHBvaW50Ont4OncseTptfSxkaXJlY3Rpb246cFtkXS55WzBdPnBbZF0ueVsxXT09PWEuYXhpc1kucmV2ZXJzZWQ/LTE6MSxjb2xvcjp5fSksdGhpcy5faW5kZXhMYWJlbHMucHVzaCh7Y2hhcnRUeXBlOlwicmFuZ2VBcmVhXCIsZGF0YVBvaW50OnBbZF0sZGF0YVNlcmllczpyLGluZGV4S2V5d29yZDoxLHBvaW50Ont4OncseTpxfSxkaXJlY3Rpb246cFtkXS55WzBdPnBbZF0ueVsxXT09PWEuYXhpc1kucmV2ZXJzZWQ/MTotMSxjb2xvcjp5fSl9ZWxzZSBKfHxufHxmKCksSj0hMDtmKCk7amEuZHJhd01hcmtlcnMoZyl9fXYmJihiLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCxcclxudGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmNsZWFyUmVjdChoLngxLGgueTEsaC53aWR0aCxoLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlc3RvcmUoKSk7Yy5yZXN0b3JlKCk7cmV0dXJue3NvdXJjZTpiLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6SC54Q2xpcEFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpILmVhc2luZy5saW5lYXIsYW5pbWF0aW9uQmFzZTowfX19O3EucHJvdG90eXBlLnJlbmRlclJhbmdlU3BsaW5lQXJlYT1mdW5jdGlvbihhKXtmdW5jdGlvbiBmKGEsYil7dmFyIGQ9eChtLDIpO2lmKDA8ZC5sZW5ndGgpe2lmKDA8XHJcbmsubGluZVRoaWNrbmVzcyl7Yy5zdHJva2VTdHlsZT1iO2Muc2V0TGluZURhc2gmJmMuc2V0TGluZURhc2goYSk7Yy5iZWdpblBhdGgoKTtjLm1vdmVUbyhkWzBdLngsZFswXS55KTtmb3IodmFyIGY9MDtmPGQubGVuZ3RoLTM7Zis9Myl7aWYoZFtmXS5uZXdTdHJva2VTdHlsZXx8ZFtmXS5uZXdMaW5lRGFzaEFycmF5KWMuc3Ryb2tlKCksYy5iZWdpblBhdGgoKSxjLm1vdmVUbyhkW2ZdLngsZFtmXS55KSxkW2ZdLm5ld1N0cm9rZVN0eWxlJiYoYy5zdHJva2VTdHlsZT1kW2ZdLm5ld1N0cm9rZVN0eWxlKSxkW2ZdLm5ld0xpbmVEYXNoQXJyYXkmJmMuc2V0TGluZURhc2goZFtmXS5uZXdMaW5lRGFzaEFycmF5KTtjLmJlemllckN1cnZlVG8oZFtmKzFdLngsZFtmKzFdLnksZFtmKzJdLngsZFtmKzJdLnksZFtmKzNdLngsZFtmKzNdLnkpfWMuc3Ryb2tlKCl9Yy5iZWdpblBhdGgoKTtjLm1vdmVUbyhkWzBdLngsZFswXS55KTt2JiYoZS5iZWdpblBhdGgoKSxlLm1vdmVUbyhkWzBdLngsZFswXS55KSk7XHJcbmZvcihmPTA7ZjxkLmxlbmd0aC0zO2YrPTMpYy5iZXppZXJDdXJ2ZVRvKGRbZisxXS54LGRbZisxXS55LGRbZisyXS54LGRbZisyXS55LGRbZiszXS54LGRbZiszXS55KSx2JiZlLmJlemllckN1cnZlVG8oZFtmKzFdLngsZFtmKzFdLnksZFtmKzJdLngsZFtmKzJdLnksZFtmKzNdLngsZFtmKzNdLnkpO2Q9eChxLDIpO2MubGluZVRvKHFbcS5sZW5ndGgtMV0ueCxxW3EubGVuZ3RoLTFdLnkpO2ZvcihmPWQubGVuZ3RoLTE7MjxmO2YtPTMpYy5iZXppZXJDdXJ2ZVRvKGRbZi0xXS54LGRbZi0xXS55LGRbZi0yXS54LGRbZi0yXS55LGRbZi0zXS54LGRbZi0zXS55KSx2JiZlLmJlemllckN1cnZlVG8oZFtmLTFdLngsZFtmLTFdLnksZFtmLTJdLngsZFtmLTJdLnksZFtmLTNdLngsZFtmLTNdLnkpO2MuY2xvc2VQYXRoKCk7Yy5nbG9iYWxBbHBoYT1rLmZpbGxPcGFjaXR5O2MuZmlsbCgpO3YmJihlLmNsb3NlUGF0aCgpLGUuZmlsbCgpKTtjLmdsb2JhbEFscGhhPTE7aWYoMDxrLmxpbmVUaGlja25lc3Mpe2Muc3Ryb2tlU3R5bGU9XHJcbmI7Yy5zZXRMaW5lRGFzaCYmYy5zZXRMaW5lRGFzaChhKTtjLmJlZ2luUGF0aCgpO2MubW92ZVRvKGRbMF0ueCxkWzBdLnkpO2Zvcih2YXIgZz1mPTA7ZjxkLmxlbmd0aC0zO2YrPTMsZysrKXtpZihtW2ddLm5ld1N0cm9rZVN0eWxlfHxtW2ddLm5ld0xpbmVEYXNoQXJyYXkpYy5zdHJva2UoKSxjLmJlZ2luUGF0aCgpLGMubW92ZVRvKGRbZl0ueCxkW2ZdLnkpLG1bZ10ubmV3U3Ryb2tlU3R5bGUmJihjLnN0cm9rZVN0eWxlPW1bZ10ubmV3U3Ryb2tlU3R5bGUpLG1bZ10ubmV3TGluZURhc2hBcnJheSYmYy5zZXRMaW5lRGFzaChtW2ddLm5ld0xpbmVEYXNoQXJyYXkpO2MuYmV6aWVyQ3VydmVUbyhkW2YrMV0ueCxkW2YrMV0ueSxkW2YrMl0ueCxkW2YrMl0ueSxkW2YrM10ueCxkW2YrM10ueSl9Yy5zdHJva2UoKX1jLmJlZ2luUGF0aCgpfX12YXIgYj1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYz12P3RoaXMuX3ByZVJlbmRlckN0eDpiO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgZT1cclxudGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LGc9W10saD10aGlzLnBsb3RBcmVhO2Muc2F2ZSgpO3YmJmUuc2F2ZSgpO2MuYmVnaW5QYXRoKCk7Yy5yZWN0KGgueDEsaC55MSxoLndpZHRoLGguaGVpZ2h0KTtjLmNsaXAoKTt2JiYoZS5iZWdpblBhdGgoKSxlLnJlY3QoaC54MSxoLnkxLGgud2lkdGgsaC5oZWlnaHQpLGUuY2xpcCgpKTtmb3IodmFyIGw9MDtsPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO2wrKyl7dmFyIHQ9YS5kYXRhU2VyaWVzSW5kZXhlc1tsXSxrPXRoaXMuZGF0YVt0XSxyPWsuZGF0YVBvaW50cyxnPWsuaWQ7dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtnXT17b2JqZWN0VHlwZTpcImRhdGFTZXJpZXNcIixkYXRhU2VyaWVzSW5kZXg6dH07Zz1SKGcpO2UuZmlsbFN0eWxlPWc7dmFyIGc9W10scD0wLG4sZCx3LG09W10scT1bXTtpZigwPHIubGVuZ3RoKXt2YXIgdT1rLl9jb2xvclNldFtwJWsuX2NvbG9yU2V0Lmxlbmd0aF0scz1rLmxpbmVDb2xvcj1rLm9wdGlvbnMubGluZUNvbG9yfHxcclxudSx5PXM7Yy5maWxsU3R5bGU9dTtjLmxpbmVXaWR0aD1rLmxpbmVUaGlja25lc3M7dmFyIHo9XCJzb2xpZFwiLEI7aWYoYy5zZXRMaW5lRGFzaCl7dmFyIEE9RyhrLm51bGxEYXRhTGluZURhc2hUeXBlLGsubGluZVRoaWNrbmVzcyksej1rLmxpbmVEYXNoVHlwZTtCPUcoeixrLmxpbmVUaGlja25lc3MpfWZvcihkPSExO3A8ci5sZW5ndGg7cCsrKWlmKG49cltwXS54LmdldFRpbWU/cltwXS54LmdldFRpbWUoKTpyW3BdLngsIShuPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fG4+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCYmKCFrLmNvbm5lY3ROdWxsRGF0YXx8IWQpKSlpZihudWxsIT09cltwXS55JiZyW3BdLnkubGVuZ3RoJiZcIm51bWJlclwiPT09dHlwZW9mIHJbcF0ueVswXSYmXCJudW1iZXJcIj09PXR5cGVvZiByW3BdLnlbMV0pe249YS5heGlzWC5jb252ZXJ0VmFsdWVUb1BpeGVsKG4pO2Q9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHJbcF0ueVswXSk7dz1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwocltwXS55WzFdKTtcclxudmFyIEM9ay5kYXRhUG9pbnRJZHNbcF07dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtDXT17aWQ6QyxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4OnQsZGF0YVBvaW50SW5kZXg6cCx4MTpuLHkxOmQseTI6d307bVttLmxlbmd0aF09e3g6bix5OmR9O3FbcS5sZW5ndGhdPXt4Om4seTp3fTtwPHIubGVuZ3RoLTEmJih5IT09KHJbcF0ubGluZUNvbG9yfHxzKXx8eiE9PShyW3BdLmxpbmVEYXNoVHlwZXx8ay5saW5lRGFzaFR5cGUpKSYmKHk9cltwXS5saW5lQ29sb3J8fHMsbVttLmxlbmd0aC0xXS5uZXdTdHJva2VTdHlsZT15LGMuc2V0TGluZURhc2gmJihyW3BdLmxpbmVEYXNoVHlwZT8oej1yW3BdLmxpbmVEYXNoVHlwZSxtW20ubGVuZ3RoLTFdLm5ld0xpbmVEYXNoQXJyYXk9Ryh6LGsubGluZVRoaWNrbmVzcykpOih6PWsubGluZURhc2hUeXBlLG1bbS5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheT1CKSkpO2lmKDAhPT1yW3BdLm1hcmtlclNpemUmJigwPFxyXG5yW3BdLm1hcmtlclNpemV8fDA8ay5tYXJrZXJTaXplKSl7dmFyIEw9ay5nZXRNYXJrZXJQcm9wZXJ0aWVzKHAsbixkLGMpO2cucHVzaChMKTt2YXIgSj1SKEMpO3YmJmcucHVzaCh7eDpuLHk6ZCxjdHg6ZSx0eXBlOkwudHlwZSxzaXplOkwuc2l6ZSxjb2xvcjpKLGJvcmRlckNvbG9yOkosYm9yZGVyVGhpY2tuZXNzOkwuYm9yZGVyVGhpY2tuZXNzfSk7TD1rLmdldE1hcmtlclByb3BlcnRpZXMocCxuLHcsYyk7Zy5wdXNoKEwpO0o9UihDKTt2JiZnLnB1c2goe3g6bix5OncsY3R4OmUsdHlwZTpMLnR5cGUsc2l6ZTpMLnNpemUsY29sb3I6Sixib3JkZXJDb2xvcjpKLGJvcmRlclRoaWNrbmVzczpMLmJvcmRlclRoaWNrbmVzc30pfWlmKHJbcF0uaW5kZXhMYWJlbHx8ay5pbmRleExhYmVsfHxyW3BdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fGsuaW5kZXhMYWJlbEZvcm1hdHRlcil0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJyYW5nZVNwbGluZUFyZWFcIixkYXRhUG9pbnQ6cltwXSxcclxuZGF0YVNlcmllczprLGluZGV4S2V5d29yZDowLHBvaW50Ont4Om4seTpkfSxkaXJlY3Rpb246cltwXS55WzBdPD1yW3BdLnlbMV0/LTE6MSxjb2xvcjp1fSksdGhpcy5faW5kZXhMYWJlbHMucHVzaCh7Y2hhcnRUeXBlOlwicmFuZ2VTcGxpbmVBcmVhXCIsZGF0YVBvaW50OnJbcF0sZGF0YVNlcmllczprLGluZGV4S2V5d29yZDoxLHBvaW50Ont4Om4seTp3fSxkaXJlY3Rpb246cltwXS55WzBdPD1yW3BdLnlbMV0/MTotMSxjb2xvcjp1fSk7ZD0hMX1lbHNlIDA8cCYmIWQmJihrLmNvbm5lY3ROdWxsRGF0YT9jLnNldExpbmVEYXNoJiYoMDxtLmxlbmd0aCYmKGsub3B0aW9ucy5udWxsRGF0YUxpbmVEYXNoVHlwZXx8IXJbcC0xXS5saW5lRGFzaFR5cGUpKSYmKG1bbS5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheT1BLHo9ay5udWxsRGF0YUxpbmVEYXNoVHlwZSk6KGYoQixzKSxtPVtdLHE9W10pKSxkPSEwO2YoQixzKTtqYS5kcmF3TWFya2VycyhnKX19diYmKGIuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcyxcclxuMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuY2xlYXJSZWN0KGgueDEsaC55MSxoLndpZHRoLGguaGVpZ2h0KSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVzdG9yZSgpKTtjLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmIsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpILnhDbGlwQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmxpbmVhcixcclxuYW5pbWF0aW9uQmFzZTowfX19O3EucHJvdG90eXBlLnJlbmRlcldhdGVyZmFsbD1mdW5jdGlvbihhKXt2YXIgZj1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYj12P3RoaXMuX3ByZVJlbmRlckN0eDpmO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgYz10aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsZT1udWxsLGc9dGhpcy5wbG90QXJlYSxoPTAsbCx0LGsscixwPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP2EuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLGg9dGhpcy5kYXRhUG9pbnRNaW5XaWR0aD90aGlzLmRhdGFQb2ludE1pbldpZHRoOnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDoxO3Q9dGhpcy5kYXRhUG9pbnRNYXhXaWR0aD90aGlzLmRhdGFQb2ludE1heFdpZHRoOnRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpNYXRoLm1pbigwLjE1KlxyXG50aGlzLndpZHRoLDAuOSoodGhpcy5wbG90QXJlYS53aWR0aC9hLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcykpPDwwO3ZhciBuPWEuYXhpc1guZGF0YUluZm8ubWluRGlmZjtpc0Zpbml0ZShuKXx8KG49MC4zKk1hdGguYWJzKGEuYXhpc1gucmFuZ2UpKTtuPXRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDowLjYqKGcud2lkdGgqKGEuYXhpc1gubG9nYXJpdGhtaWM/TWF0aC5sb2cobikvTWF0aC5sb2coYS5heGlzWC5yYW5nZSk6TWF0aC5hYnMobikvTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpL2EucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKTw8MDt0aGlzLmRhdGFQb2ludE1heFdpZHRoJiZoPnQmJihoPU1hdGgubWluKHRoaXMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpJbmZpbml0eSx0KSk7IXRoaXMuZGF0YVBvaW50TWF4V2lkdGgmJih0aGlzLmRhdGFQb2ludE1pbldpZHRoJiZ0PGgpJiYodD1NYXRoLm1heCh0aGlzLmRhdGFQb2ludFdpZHRoP1xyXG50aGlzLmRhdGFQb2ludFdpZHRoOi1JbmZpbml0eSxoKSk7bjxoJiYobj1oKTtuPnQmJihuPXQpO2Iuc2F2ZSgpO3YmJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yi5iZWdpblBhdGgoKTtiLnJlY3QoZy54MSxnLnkxLGcud2lkdGgsZy5oZWlnaHQpO2IuY2xpcCgpO3YmJih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguYmVnaW5QYXRoKCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlY3QoZy54MSxnLnkxLGcud2lkdGgsZy5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5jbGlwKCkpO2Zvcih2YXIgZD0wO2Q8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7ZCsrKXt2YXIgdz1hLmRhdGFTZXJpZXNJbmRleGVzW2RdLG09dGhpcy5kYXRhW3ddLHE9bS5kYXRhUG9pbnRzLGU9bS5fY29sb3JTZXRbMF07bS5yaXNpbmdDb2xvcj1tLm9wdGlvbnMucmlzaW5nQ29sb3I/bS5vcHRpb25zLnJpc2luZ0NvbG9yOmU7bS5mYWxsaW5nQ29sb3I9bS5vcHRpb25zLmZhbGxpbmdDb2xvcj9cclxubS5vcHRpb25zLmZhbGxpbmdDb2xvcjpcIiNlNDBhMGFcIjt2YXIgdT1cIm51bWJlclwiPT09dHlwZW9mIG0ub3B0aW9ucy5saW5lVGhpY2tuZXNzP01hdGgucm91bmQobS5saW5lVGhpY2tuZXNzKToxLHM9MT09PU1hdGgucm91bmQodSklMj8tMC41OjA7aWYoMDxxLmxlbmd0aClmb3IodmFyIHk9NTxuJiZtLmJldmVsRW5hYmxlZD8hMDohMSx4PSExLEI9bnVsbCxBPW51bGwsaD0wO2g8cS5sZW5ndGg7aCsrKWlmKHFbaF0uZ2V0VGltZT9yPXFbaF0ueC5nZXRUaW1lKCk6cj1xW2hdLngsXCJudW1iZXJcIiE9PXR5cGVvZiBxW2hdLnkpe2lmKDA8aCYmIXgmJm0uY29ubmVjdE51bGxEYXRhKXZhciB6PW0ub3B0aW9ucy5udWxsRGF0YUxpbmVEYXNoVHlwZXx8IXFbaC0xXS5saW5lRGFzaFR5cGU/bS5udWxsRGF0YUxpbmVEYXNoVHlwZTpxW2gtMV0ubGluZURhc2hUeXBlO3g9ITB9ZWxzZXtsPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChyKTt0PTA9PT1tLmRhdGFQb2ludEVPc1toXS5jdW11bGF0aXZlU3VtP1xyXG5wOmEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChtLmRhdGFQb2ludEVPc1toXS5jdW11bGF0aXZlU3VtKTtrPTA9PT1tLmRhdGFQb2ludEVPc1toXS5jdW11bGF0aXZlU3VtWVN0YXJ0VmFsdWU/cDphLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwobS5kYXRhUG9pbnRFT3NbaF0uY3VtdWxhdGl2ZVN1bVlTdGFydFZhbHVlKTtsPWEuYXhpc1gucmV2ZXJzZWQ/bCthLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcypuLzItKGEucHJldmlvdXNEYXRhU2VyaWVzQ291bnQrZCkqbjw8MDpsLWEucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKm4vMisoYS5wcmV2aW91c0RhdGFTZXJpZXNDb3VudCtkKSpuPDwwO3ZhciBDPWEuYXhpc1gucmV2ZXJzZWQ/bC1uPDwwOmwrbjw8MDt0PmsmJihlPXQsdD1rLGs9ZSk7YS5heGlzWS5yZXZlcnNlZCYmKGU9dCx0PWssaz1lKTtlPW0uZGF0YVBvaW50SWRzW2hdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbZV09e2lkOmUsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLFxyXG5kYXRhU2VyaWVzSW5kZXg6dyxkYXRhUG9pbnRJbmRleDpoLHgxOmwseTE6dCx4MjpDLHkyOmt9O3ZhciBKPXFbaF0uY29sb3I/cVtoXS5jb2xvcjotMTxxW2hdLnk/bS5yaXNpbmdDb2xvcjptLmZhbGxpbmdDb2xvcjtWKGIsbCx0LEMsayxKLDAsSix5LHksITEsITEsbS5maWxsT3BhY2l0eSk7ZT1SKGUpO3YmJlYodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LGwsdCxDLGssZSwwLG51bGwsITEsITEsITEsITEpO3ZhciBJLEo9bDtJPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgcVtoXS5pc0ludGVybWVkaWF0ZVN1bSYmITA9PT1xW2hdLmlzSW50ZXJtZWRpYXRlU3VtfHxcInVuZGVmaW5lZFwiIT09dHlwZW9mIHFbaF0uaXNDdW11bGF0aXZlU3VtJiYhMD09PXFbaF0uaXNDdW11bGF0aXZlU3VtPy0xPHFbaF0ueT90Oms6LTE8cVtoXS55P2s6dDswPGgmJkImJigheHx8bS5jb25uZWN0TnVsbERhdGEpJiYoeCYmYi5zZXRMaW5lRGFzaCYmYi5zZXRMaW5lRGFzaChHKHosdSkpLGIuYmVnaW5QYXRoKCksXHJcbmIubW92ZVRvKEIsQS1zKSxiLmxpbmVUbyhKLEktcyksMDx1JiZiLnN0cm9rZSgpLHYmJihjLmJlZ2luUGF0aCgpLGMubW92ZVRvKEIsQS1zKSxjLmxpbmVUbyhKLEktcyksMDx1JiZjLnN0cm9rZSgpKSk7eD0hMTtCPUM7QT0tMTxxW2hdLnk/dDprO0o9cVtoXS5saW5lRGFzaFR5cGU/cVtoXS5saW5lRGFzaFR5cGU6bS5vcHRpb25zLmxpbmVEYXNoVHlwZT9tLm9wdGlvbnMubGluZURhc2hUeXBlOlwic2hvcnREYXNoXCI7Yi5zdHJva2VTdHlsZT1xW2hdLmxpbmVDb2xvcj9xW2hdLmxpbmVDb2xvcjptLm9wdGlvbnMubGluZUNvbG9yP20ub3B0aW9ucy5saW5lQ29sb3I6XCIjOWU5ZTllXCI7Yi5saW5lV2lkdGg9dTtiLnNldExpbmVEYXNoJiYoSj1HKEosdSksYi5zZXRMaW5lRGFzaChKKSk7KHFbaF0uaW5kZXhMYWJlbHx8bS5pbmRleExhYmVsfHxxW2hdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fG0uaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcIndhdGVyZmFsbFwiLFxyXG5kYXRhUG9pbnQ6cVtoXSxkYXRhU2VyaWVzOm0scG9pbnQ6e3g6bCsoQy1sKS8yLHk6MDw9cVtoXS55P3Q6a30sZGlyZWN0aW9uOjA+cVtoXS55PT09YS5heGlzWS5yZXZlcnNlZD8xOi0xLGJvdW5kczp7eDE6bCx5MTpNYXRoLm1pbih0LGspLHgyOkMseTI6TWF0aC5tYXgodCxrKX0sY29sb3I6ZX0pfX12JiYoZi5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLFxyXG4wLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5jbGVhclJlY3QoZy54MSxnLnkxLGcud2lkdGgsZy5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2IucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZixkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOkguZmFkZUluQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmVhc2VJblF1YWQsYW5pbWF0aW9uQmFzZTowfX19O3ZhciByYT1mdW5jdGlvbihhLGYsYixjLGUsZyxoLGwsdCl7aWYoISgwPmIpKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGwmJihsPTEpO2lmKCF2KXt2YXIgaz1OdW1iZXIoKGglKDIqTWF0aC5QSSkpLnRvRml4ZWQoOCkpO051bWJlcigoZyUoMipNYXRoLlBJKSkudG9GaXhlZCg4KSk9PT1rJiYoaC09MUUtNCl9YS5zYXZlKCk7YS5nbG9iYWxBbHBoYT1sO1wicGllXCI9PT1lPyhhLmJlZ2luUGF0aCgpLGEubW92ZVRvKGYueCxmLnkpLGEuYXJjKGYueCxmLnksXHJcbmIsZyxoLCExKSxhLmZpbGxTdHlsZT1jLGEuc3Ryb2tlU3R5bGU9XCJ3aGl0ZVwiLGEubGluZVdpZHRoPTIsYS5jbG9zZVBhdGgoKSxhLmZpbGwoKSk6XCJkb3VnaG51dFwiPT09ZSYmKGEuYmVnaW5QYXRoKCksYS5hcmMoZi54LGYueSxiLGcsaCwhMSksMDw9dCYmYS5hcmMoZi54LGYueSx0KmIsaCxnLCEwKSxhLmNsb3NlUGF0aCgpLGEuZmlsbFN0eWxlPWMsYS5zdHJva2VTdHlsZT1cIndoaXRlXCIsYS5saW5lV2lkdGg9MixhLmZpbGwoKSk7YS5nbG9iYWxBbHBoYT0xO2EucmVzdG9yZSgpfX07cS5wcm90b3R5cGUucmVuZGVyUGllPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGYoKXtpZihrJiZyKXtmb3IodmFyIGE9MCxiPTAsYz0wLGU9MCxmPTA7ZjxyLmxlbmd0aDtmKyspe3ZhciBnPXJbZl0saD1rLmRhdGFQb2ludElkc1tmXTtkW2ZdLmlkPWg7ZFtmXS5vYmplY3RUeXBlPVwiZGF0YVBvaW50XCI7ZFtmXS5kYXRhUG9pbnRJbmRleD1mO2RbZl0uZGF0YVNlcmllc0luZGV4PTA7dmFyIGw9ZFtmXSxwPVxyXG57cGVyY2VudDpudWxsLHRvdGFsOm51bGx9LG09bnVsbCxwPXQuZ2V0UGVyY2VudEFuZFRvdGFsKGssZyk7aWYoay5pbmRleExhYmVsRm9ybWF0dGVyfHxnLmluZGV4TGFiZWxGb3JtYXR0ZXIpbT17Y2hhcnQ6dC5vcHRpb25zLGRhdGFTZXJpZXM6ayxkYXRhUG9pbnQ6Zyx0b3RhbDpwLnRvdGFsLHBlcmNlbnQ6cC5wZXJjZW50fTtwPWcuaW5kZXhMYWJlbEZvcm1hdHRlcj9nLmluZGV4TGFiZWxGb3JtYXR0ZXIobSk6Zy5pbmRleExhYmVsP3QucmVwbGFjZUtleXdvcmRzV2l0aFZhbHVlKGcuaW5kZXhMYWJlbCxnLGssZik6ay5pbmRleExhYmVsRm9ybWF0dGVyP2suaW5kZXhMYWJlbEZvcm1hdHRlcihtKTprLmluZGV4TGFiZWw/dC5yZXBsYWNlS2V5d29yZHNXaXRoVmFsdWUoay5pbmRleExhYmVsLGcsayxmKTpnLmxhYmVsP2cubGFiZWw6XCJcIjt0Ll9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2hdPWw7bC5jZW50ZXI9e3g6eC54LHk6eC55fTtsLnk9Zy55O2wucmFkaXVzPUE7bC5wZXJjZW50SW5uZXJSYWRpdXM9XHJcbkw7bC5pbmRleExhYmVsVGV4dD1wO2wuaW5kZXhMYWJlbFBsYWNlbWVudD1rLmluZGV4TGFiZWxQbGFjZW1lbnQ7bC5pbmRleExhYmVsTGluZUNvbG9yPWcuaW5kZXhMYWJlbExpbmVDb2xvcj9nLmluZGV4TGFiZWxMaW5lQ29sb3I6ay5vcHRpb25zLmluZGV4TGFiZWxMaW5lQ29sb3I/ay5vcHRpb25zLmluZGV4TGFiZWxMaW5lQ29sb3I6Zy5jb2xvcj9nLmNvbG9yOmsuX2NvbG9yU2V0W2Ylay5fY29sb3JTZXQubGVuZ3RoXTtsLmluZGV4TGFiZWxMaW5lVGhpY2tuZXNzPXkoZy5pbmRleExhYmVsTGluZVRoaWNrbmVzcyk/ay5pbmRleExhYmVsTGluZVRoaWNrbmVzczpnLmluZGV4TGFiZWxMaW5lVGhpY2tuZXNzO2wuaW5kZXhMYWJlbExpbmVEYXNoVHlwZT1nLmluZGV4TGFiZWxMaW5lRGFzaFR5cGU/Zy5pbmRleExhYmVsTGluZURhc2hUeXBlOmsuaW5kZXhMYWJlbExpbmVEYXNoVHlwZTtsLmluZGV4TGFiZWxGb250Q29sb3I9Zy5pbmRleExhYmVsRm9udENvbG9yP2cuaW5kZXhMYWJlbEZvbnRDb2xvcjpcclxuay5pbmRleExhYmVsRm9udENvbG9yO2wuaW5kZXhMYWJlbEZvbnRTdHlsZT1nLmluZGV4TGFiZWxGb250U3R5bGU/Zy5pbmRleExhYmVsRm9udFN0eWxlOmsuaW5kZXhMYWJlbEZvbnRTdHlsZTtsLmluZGV4TGFiZWxGb250V2VpZ2h0PWcuaW5kZXhMYWJlbEZvbnRXZWlnaHQ/Zy5pbmRleExhYmVsRm9udFdlaWdodDprLmluZGV4TGFiZWxGb250V2VpZ2h0O2wuaW5kZXhMYWJlbEZvbnRTaXplPXkoZy5pbmRleExhYmVsRm9udFNpemUpP2suaW5kZXhMYWJlbEZvbnRTaXplOmcuaW5kZXhMYWJlbEZvbnRTaXplO2wuaW5kZXhMYWJlbEZvbnRGYW1pbHk9Zy5pbmRleExhYmVsRm9udEZhbWlseT9nLmluZGV4TGFiZWxGb250RmFtaWx5OmsuaW5kZXhMYWJlbEZvbnRGYW1pbHk7bC5pbmRleExhYmVsQmFja2dyb3VuZENvbG9yPWcuaW5kZXhMYWJlbEJhY2tncm91bmRDb2xvcj9nLmluZGV4TGFiZWxCYWNrZ3JvdW5kQ29sb3I6ay5vcHRpb25zLmluZGV4TGFiZWxCYWNrZ3JvdW5kQ29sb3I/XHJcbmsub3B0aW9ucy5pbmRleExhYmVsQmFja2dyb3VuZENvbG9yOmsuaW5kZXhMYWJlbEJhY2tncm91bmRDb2xvcjtsLmluZGV4TGFiZWxNYXhXaWR0aD1nLmluZGV4TGFiZWxNYXhXaWR0aD9nLmluZGV4TGFiZWxNYXhXaWR0aDprLmluZGV4TGFiZWxNYXhXaWR0aD9rLmluZGV4TGFiZWxNYXhXaWR0aDowLjMzKm4ud2lkdGg7bC5pbmRleExhYmVsV3JhcD1cInVuZGVmaW5lZFwiIT09dHlwZW9mIGcuaW5kZXhMYWJlbFdyYXA/Zy5pbmRleExhYmVsV3JhcDprLmluZGV4TGFiZWxXcmFwO2wuc3RhcnRBbmdsZT0wPT09Zj9rLnN0YXJ0QW5nbGU/ay5zdGFydEFuZ2xlLzE4MCpNYXRoLlBJOjA6ZFtmLTFdLmVuZEFuZ2xlO2wuc3RhcnRBbmdsZT0obC5zdGFydEFuZ2xlKzIqTWF0aC5QSSklKDIqTWF0aC5QSSk7bC5lbmRBbmdsZT1sLnN0YXJ0QW5nbGUrMipNYXRoLlBJL3oqTWF0aC5hYnMoZy55KTtnPShsLmVuZEFuZ2xlK2wuc3RhcnRBbmdsZSkvMjtnPShnKzIqTWF0aC5QSSklKDIqTWF0aC5QSSk7XHJcbmwubWlkQW5nbGU9ZztpZihsLm1pZEFuZ2xlPk1hdGguUEkvMi11JiZsLm1pZEFuZ2xlPE1hdGguUEkvMit1KXtpZigwPT09YXx8ZFtjXS5taWRBbmdsZT5sLm1pZEFuZ2xlKWM9ZjthKyt9ZWxzZSBpZihsLm1pZEFuZ2xlPjMqTWF0aC5QSS8yLXUmJmwubWlkQW5nbGU8MypNYXRoLlBJLzIrdSl7aWYoMD09PWJ8fGRbZV0ubWlkQW5nbGU+bC5taWRBbmdsZSllPWY7YisrfWwuaGVtaXNwaGVyZT1nPk1hdGguUEkvMiYmZzw9MypNYXRoLlBJLzI/XCJsZWZ0XCI6XCJyaWdodFwiO2wuaW5kZXhMYWJlbFRleHRCbG9jaz1uZXcgbGEodC5wbG90QXJlYS5jdHgse2ZvbnRTaXplOmwuaW5kZXhMYWJlbEZvbnRTaXplLGZvbnRGYW1pbHk6bC5pbmRleExhYmVsRm9udEZhbWlseSxmb250Q29sb3I6bC5pbmRleExhYmVsRm9udENvbG9yLGZvbnRTdHlsZTpsLmluZGV4TGFiZWxGb250U3R5bGUsZm9udFdlaWdodDpsLmluZGV4TGFiZWxGb250V2VpZ2h0LGhvcml6b250YWxBbGlnbjpcImxlZnRcIixiYWNrZ3JvdW5kQ29sb3I6bC5pbmRleExhYmVsQmFja2dyb3VuZENvbG9yLFxyXG5tYXhXaWR0aDpsLmluZGV4TGFiZWxNYXhXaWR0aCxtYXhIZWlnaHQ6bC5pbmRleExhYmVsV3JhcD81KmwuaW5kZXhMYWJlbEZvbnRTaXplOjEuNSpsLmluZGV4TGFiZWxGb250U2l6ZSx0ZXh0OmwuaW5kZXhMYWJlbFRleHQscGFkZGluZzowLHRleHRCYXNlbGluZTpcInRvcFwifSk7bC5pbmRleExhYmVsVGV4dEJsb2NrLm1lYXN1cmVUZXh0KCl9aD1nPTA7cD0hMTtmb3IoZj0wO2Y8ci5sZW5ndGg7ZisrKWw9ZFsoYytmKSVyLmxlbmd0aF0sMTxhJiYobC5taWRBbmdsZT5NYXRoLlBJLzItdSYmbC5taWRBbmdsZTxNYXRoLlBJLzIrdSkmJihnPD1hLzImJiFwPyhsLmhlbWlzcGhlcmU9XCJyaWdodFwiLGcrKyk6KGwuaGVtaXNwaGVyZT1cImxlZnRcIixwPSEwKSk7cD0hMTtmb3IoZj0wO2Y8ci5sZW5ndGg7ZisrKWw9ZFsoZStmKSVyLmxlbmd0aF0sMTxiJiYobC5taWRBbmdsZT4zKk1hdGguUEkvMi11JiZsLm1pZEFuZ2xlPDMqTWF0aC5QSS8yK3UpJiYoaDw9Yi8yJiYhcD8obC5oZW1pc3BoZXJlPVxyXG5cImxlZnRcIixoKyspOihsLmhlbWlzcGhlcmU9XCJyaWdodFwiLHA9ITApKX19ZnVuY3Rpb24gYihhKXt2YXIgYj10LnBsb3RBcmVhLmN0eDtiLmNsZWFyUmVjdChuLngxLG4ueTEsbi53aWR0aCxuLmhlaWdodCk7Yi5maWxsU3R5bGU9dC5iYWNrZ3JvdW5kQ29sb3I7Yi5maWxsUmVjdChuLngxLG4ueTEsbi53aWR0aCxuLmhlaWdodCk7Zm9yKGI9MDtiPHIubGVuZ3RoO2IrKyl7dmFyIGM9ZFtiXS5zdGFydEFuZ2xlLGU9ZFtiXS5lbmRBbmdsZTtpZihlPmMpe3ZhciBmPTAuMDcqQSpNYXRoLmNvcyhkW2JdLm1pZEFuZ2xlKSxnPTAuMDcqQSpNYXRoLnNpbihkW2JdLm1pZEFuZ2xlKSxoPSExO2lmKHJbYl0uZXhwbG9kZWQpe2lmKDFFLTk8TWF0aC5hYnMoZFtiXS5jZW50ZXIueC0oeC54K2YpKXx8MUUtOTxNYXRoLmFicyhkW2JdLmNlbnRlci55LSh4LnkrZykpKWRbYl0uY2VudGVyLng9eC54K2YqYSxkW2JdLmNlbnRlci55PXgueStnKmEsaD0hMH1lbHNlIGlmKDA8TWF0aC5hYnMoZFtiXS5jZW50ZXIueC1cclxueC54KXx8MDxNYXRoLmFicyhkW2JdLmNlbnRlci55LXgueSkpZFtiXS5jZW50ZXIueD14LngrZiooMS1hKSxkW2JdLmNlbnRlci55PXgueStnKigxLWEpLGg9ITA7aCYmKGY9e30sZi5kYXRhU2VyaWVzPWssZi5kYXRhUG9pbnQ9ay5kYXRhUG9pbnRzW2JdLGYuaW5kZXg9Yix0LnRvb2xUaXAuaGlnaGxpZ2h0T2JqZWN0cyhbZl0pKTtyYSh0LnBsb3RBcmVhLmN0eCxkW2JdLmNlbnRlcixkW2JdLnJhZGl1cyxyW2JdLmNvbG9yP3JbYl0uY29sb3I6ay5fY29sb3JTZXRbYiVrLl9jb2xvclNldC5sZW5ndGhdLGsudHlwZSxjLGUsay5maWxsT3BhY2l0eSxkW2JdLnBlcmNlbnRJbm5lclJhZGl1cyl9fWE9dC5wbG90QXJlYS5jdHg7YS5zYXZlKCk7YS5maWxsU3R5bGU9XCJibGFja1wiO2Euc3Ryb2tlU3R5bGU9XCJncmV5XCI7YS50ZXh0QmFzZWxpbmU9XCJtaWRkbGVcIjthLmxpbmVKb2luPVwicm91bmRcIjtmb3IoYj1iPTA7YjxyLmxlbmd0aDtiKyspYz1kW2JdLGMuaW5kZXhMYWJlbFRleHQmJihjLmluZGV4TGFiZWxUZXh0QmxvY2sueS09XHJcbmMuaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvMixlPTAsZT1cImxlZnRcIj09PWMuaGVtaXNwaGVyZT9cImluc2lkZVwiIT09ay5pbmRleExhYmVsUGxhY2VtZW50Py0oYy5pbmRleExhYmVsVGV4dEJsb2NrLndpZHRoK3ApOi1jLmluZGV4TGFiZWxUZXh0QmxvY2sud2lkdGgvMjpcImluc2lkZVwiIT09ay5pbmRleExhYmVsUGxhY2VtZW50P3A6LWMuaW5kZXhMYWJlbFRleHRCbG9jay53aWR0aC8yLGMuaW5kZXhMYWJlbFRleHRCbG9jay54Kz1lLGMuaW5kZXhMYWJlbFRleHRCbG9jay5yZW5kZXIoITApLGMuaW5kZXhMYWJlbFRleHRCbG9jay54LT1lLGMuaW5kZXhMYWJlbFRleHRCbG9jay55Kz1jLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIsXCJpbnNpZGVcIiE9PWMuaW5kZXhMYWJlbFBsYWNlbWVudCYmMDxjLmluZGV4TGFiZWxMaW5lVGhpY2tuZXNzJiYoZT1jLmNlbnRlci54K0EqTWF0aC5jb3MoYy5taWRBbmdsZSksZj1jLmNlbnRlci55K0EqTWF0aC5zaW4oYy5taWRBbmdsZSksXHJcbmEuc3Ryb2tlU3R5bGU9Yy5pbmRleExhYmVsTGluZUNvbG9yLGEubGluZVdpZHRoPWMuaW5kZXhMYWJlbExpbmVUaGlja25lc3MsYS5zZXRMaW5lRGFzaCYmYS5zZXRMaW5lRGFzaChHKGMuaW5kZXhMYWJlbExpbmVEYXNoVHlwZSxjLmluZGV4TGFiZWxMaW5lVGhpY2tuZXNzKSksYS5iZWdpblBhdGgoKSxhLm1vdmVUbyhlLGYpLGEubGluZVRvKGMuaW5kZXhMYWJlbFRleHRCbG9jay54LGMuaW5kZXhMYWJlbFRleHRCbG9jay55KSxhLmxpbmVUbyhjLmluZGV4TGFiZWxUZXh0QmxvY2sueCsoXCJsZWZ0XCI9PT1jLmhlbWlzcGhlcmU/LXA6cCksYy5pbmRleExhYmVsVGV4dEJsb2NrLnkpLGEuc3Ryb2tlKCkpLGEubGluZUpvaW49XCJtaXRlclwiKTthLnNhdmUoKX1mdW5jdGlvbiBjKGEsYil7dmFyIGM9MCxjPWEuaW5kZXhMYWJlbFRleHRCbG9jay55LWEuaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvMixkPWEuaW5kZXhMYWJlbFRleHRCbG9jay55K2EuaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvXHJcbjIsZT1iLmluZGV4TGFiZWxUZXh0QmxvY2sueS1iLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIsZj1iLmluZGV4TGFiZWxUZXh0QmxvY2sueStiLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzI7cmV0dXJuIGM9Yi5pbmRleExhYmVsVGV4dEJsb2NrLnk+YS5pbmRleExhYmVsVGV4dEJsb2NrLnk/ZS1kOmMtZn1mdW5jdGlvbiBlKGEpe2Zvcih2YXIgYj1udWxsLGU9MTtlPHIubGVuZ3RoO2UrKylpZihiPShhK2UrZC5sZW5ndGgpJWQubGVuZ3RoLGRbYl0uaGVtaXNwaGVyZSE9PWRbYV0uaGVtaXNwaGVyZSl7Yj1udWxsO2JyZWFrfWVsc2UgaWYoZFtiXS5pbmRleExhYmVsVGV4dCYmYiE9PWEmJigwPmMoZFtiXSxkW2FdKXx8KFwicmlnaHRcIj09PWRbYV0uaGVtaXNwaGVyZT9kW2JdLmluZGV4TGFiZWxUZXh0QmxvY2sueT49ZFthXS5pbmRleExhYmVsVGV4dEJsb2NrLnk6ZFtiXS5pbmRleExhYmVsVGV4dEJsb2NrLnk8PWRbYV0uaW5kZXhMYWJlbFRleHRCbG9jay55KSkpYnJlYWs7XHJcbmVsc2UgYj1udWxsO3JldHVybiBifWZ1bmN0aW9uIGcoYSxiLGYpe2Y9KGZ8fDApKzE7aWYoMUUzPGYpcmV0dXJuIDA7Yj1ifHwwO3ZhciBrPTAsaD14LnktMSpxLG49eC55KzEqcTtpZigwPD1hJiZhPHIubGVuZ3RoKXt2YXIgbD1kW2FdO2lmKDA+YiYmbC5pbmRleExhYmVsVGV4dEJsb2NrLnk8aHx8MDxiJiZsLmluZGV4TGFiZWxUZXh0QmxvY2sueT5uKXJldHVybiAwO3ZhciB0PTAscD0wLHA9dD10PTA7MD5iP2wuaW5kZXhMYWJlbFRleHRCbG9jay55LWwuaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvMj5oJiZsLmluZGV4TGFiZWxUZXh0QmxvY2sueS1sLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIrYjxoJiYoYj0tKGgtKGwuaW5kZXhMYWJlbFRleHRCbG9jay55LWwuaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvMitiKSkpOmwuaW5kZXhMYWJlbFRleHRCbG9jay55K2wuaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvMjxoJiZsLmluZGV4TGFiZWxUZXh0QmxvY2sueStcclxubC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yK2I+biYmKGI9bC5pbmRleExhYmVsVGV4dEJsb2NrLnkrbC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yK2Itbik7Yj1sLmluZGV4TGFiZWxUZXh0QmxvY2sueStiO2g9MDtoPVwicmlnaHRcIj09PWwuaGVtaXNwaGVyZT94LngrTWF0aC5zcXJ0KE1hdGgucG93KHEsMiktTWF0aC5wb3coYi14LnksMikpOngueC1NYXRoLnNxcnQoTWF0aC5wb3cocSwyKS1NYXRoLnBvdyhiLXgueSwyKSk7cD14LngrQSpNYXRoLmNvcyhsLm1pZEFuZ2xlKTt0PXgueStBKk1hdGguc2luKGwubWlkQW5nbGUpO3Q9TWF0aC5zcXJ0KE1hdGgucG93KGgtcCwyKStNYXRoLnBvdyhiLXQsMikpO3A9TWF0aC5hY29zKEEvcSk7dD1NYXRoLmFjb3MoKHEqcStBKkEtdCp0KS8oMipBKnEpKTtiPXQ8cD9iLWwuaW5kZXhMYWJlbFRleHRCbG9jay55OjA7aD1udWxsO2ZvcihuPTE7bjxyLmxlbmd0aDtuKyspaWYoaD0oYS1uK2QubGVuZ3RoKSVkLmxlbmd0aCxkW2hdLmhlbWlzcGhlcmUhPT1cclxuZFthXS5oZW1pc3BoZXJlKXtoPW51bGw7YnJlYWt9ZWxzZSBpZihkW2hdLmluZGV4TGFiZWxUZXh0JiZkW2hdLmhlbWlzcGhlcmU9PT1kW2FdLmhlbWlzcGhlcmUmJmghPT1hJiYoMD5jKGRbaF0sZFthXSl8fChcInJpZ2h0XCI9PT1kW2FdLmhlbWlzcGhlcmU/ZFtoXS5pbmRleExhYmVsVGV4dEJsb2NrLnk8PWRbYV0uaW5kZXhMYWJlbFRleHRCbG9jay55OmRbaF0uaW5kZXhMYWJlbFRleHRCbG9jay55Pj1kW2FdLmluZGV4TGFiZWxUZXh0QmxvY2sueSkpKWJyZWFrO2Vsc2UgaD1udWxsO3A9aDt0PWUoYSk7bj1oPTA7MD5iPyhuPVwicmlnaHRcIj09PWwuaGVtaXNwaGVyZT9wOnQsaz1iLG51bGwhPT1uJiYocD0tYixiPWwuaW5kZXhMYWJlbFRleHRCbG9jay55LWwuaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvMi0oZFtuXS5pbmRleExhYmVsVGV4dEJsb2NrLnkrZFtuXS5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yKSxiLXA8bSYmKGg9LXAsbj1nKG4saCxmKzEpLCtuLnRvRml4ZWQodik+XHJcbitoLnRvRml4ZWQodikmJihrPWI+bT8tKGItbSk6LShwLShuLWgpKSkpKSk6MDxiJiYobj1cInJpZ2h0XCI9PT1sLmhlbWlzcGhlcmU/dDpwLGs9YixudWxsIT09biYmKHA9YixiPWRbbl0uaW5kZXhMYWJlbFRleHRCbG9jay55LWRbbl0uaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvMi0obC5pbmRleExhYmVsVGV4dEJsb2NrLnkrbC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yKSxiLXA8bSYmKGg9cCxuPWcobixoLGYrMSksK24udG9GaXhlZCh2KTwraC50b0ZpeGVkKHYpJiYoaz1iPm0/Yi1tOnAtKGgtbikpKSkpO2smJihmPWwuaW5kZXhMYWJlbFRleHRCbG9jay55K2ssYj0wLGI9XCJyaWdodFwiPT09bC5oZW1pc3BoZXJlP3gueCtNYXRoLnNxcnQoTWF0aC5wb3cocSwyKS1NYXRoLnBvdyhmLXgueSwyKSk6eC54LU1hdGguc3FydChNYXRoLnBvdyhxLDIpLU1hdGgucG93KGYteC55LDIpKSxsLm1pZEFuZ2xlPk1hdGguUEkvMi11JiZsLm1pZEFuZ2xlPE1hdGguUEkvMit1PyhoPShhLVxyXG4xK2QubGVuZ3RoKSVkLmxlbmd0aCxoPWRbaF0sYT1kWyhhKzErZC5sZW5ndGgpJWQubGVuZ3RoXSxcImxlZnRcIj09PWwuaGVtaXNwaGVyZSYmXCJyaWdodFwiPT09aC5oZW1pc3BoZXJlJiZiPmguaW5kZXhMYWJlbFRleHRCbG9jay54P2I9aC5pbmRleExhYmVsVGV4dEJsb2NrLngtMTU6XCJyaWdodFwiPT09bC5oZW1pc3BoZXJlJiYoXCJsZWZ0XCI9PT1hLmhlbWlzcGhlcmUmJmI8YS5pbmRleExhYmVsVGV4dEJsb2NrLngpJiYoYj1hLmluZGV4TGFiZWxUZXh0QmxvY2sueCsxNSkpOmwubWlkQW5nbGU+MypNYXRoLlBJLzItdSYmbC5taWRBbmdsZTwzKk1hdGguUEkvMit1JiYoaD0oYS0xK2QubGVuZ3RoKSVkLmxlbmd0aCxoPWRbaF0sYT1kWyhhKzErZC5sZW5ndGgpJWQubGVuZ3RoXSxcInJpZ2h0XCI9PT1sLmhlbWlzcGhlcmUmJlwibGVmdFwiPT09aC5oZW1pc3BoZXJlJiZiPGguaW5kZXhMYWJlbFRleHRCbG9jay54P2I9aC5pbmRleExhYmVsVGV4dEJsb2NrLngrMTU6XCJsZWZ0XCI9PT1sLmhlbWlzcGhlcmUmJlxyXG4oXCJyaWdodFwiPT09YS5oZW1pc3BoZXJlJiZiPmEuaW5kZXhMYWJlbFRleHRCbG9jay54KSYmKGI9YS5pbmRleExhYmVsVGV4dEJsb2NrLngtMTUpKSxsLmluZGV4TGFiZWxUZXh0QmxvY2sueT1mLGwuaW5kZXhMYWJlbFRleHRCbG9jay54PWIsbC5pbmRleExhYmVsQW5nbGU9TWF0aC5hdGFuMihsLmluZGV4TGFiZWxUZXh0QmxvY2sueS14LnksbC5pbmRleExhYmVsVGV4dEJsb2NrLngteC54KSl9cmV0dXJuIGt9ZnVuY3Rpb24gaCgpe3ZhciBhPXQucGxvdEFyZWEuY3R4O2EuZmlsbFN0eWxlPVwiZ3JleVwiO2Euc3Ryb2tlU3R5bGU9XCJncmV5XCI7YS5mb250PVwiMTZweCBBcmlhbFwiO2EudGV4dEJhc2VsaW5lPVwibWlkZGxlXCI7Zm9yKHZhciBiPWE9MCxmPTAsaD0hMCxiPTA7MTA+YiYmKDE+Ynx8MDxmKTtiKyspe2lmKGsucmFkaXVzfHwhay5yYWRpdXMmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygay5pbm5lclJhZGl1cyYmbnVsbCE9PWsuaW5uZXJSYWRpdXMmJkEtZjw9QyloPSExO2gmJihBLT1cclxuZik7Zj0wO2lmKFwiaW5zaWRlXCIhPT1rLmluZGV4TGFiZWxQbGFjZW1lbnQpe3E9QSpzO2ZvcihhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBsPWRbYV07bC5pbmRleExhYmVsVGV4dEJsb2NrLng9eC54K3EqTWF0aC5jb3MobC5taWRBbmdsZSk7bC5pbmRleExhYmVsVGV4dEJsb2NrLnk9eC55K3EqTWF0aC5zaW4obC5taWRBbmdsZSk7bC5pbmRleExhYmVsQW5nbGU9bC5taWRBbmdsZTtsLnJhZGl1cz1BO2wucGVyY2VudElubmVyUmFkaXVzPUx9Zm9yKHZhciB1LHksYT0wO2E8ci5sZW5ndGg7YSsrKXt2YXIgbD1kW2FdLEI9ZShhKTtpZihudWxsIT09Qil7dT1kW2FdO3k9ZFtCXTt2YXIgej0wLHo9Yyh1LHkpLW07aWYoMD56KXtmb3IodmFyIGJhPXk9MCxHPTA7RzxyLmxlbmd0aDtHKyspRyE9PWEmJmRbR10uaGVtaXNwaGVyZT09PWwuaGVtaXNwaGVyZSYmKGRbR10uaW5kZXhMYWJlbFRleHRCbG9jay55PGwuaW5kZXhMYWJlbFRleHRCbG9jay55P3krKzpiYSsrKTt5PXovKHkrYmF8fDEpKlxyXG5iYTt2YXIgYmE9LTEqKHoteSksSD1HPTA7XCJyaWdodFwiPT09bC5oZW1pc3BoZXJlPyhHPWcoYSx5KSxiYT0tMSooei1HKSxIPWcoQixiYSksK0gudG9GaXhlZCh2KTwrYmEudG9GaXhlZCh2KSYmK0cudG9GaXhlZCh2KTw9K3kudG9GaXhlZCh2KSYmZyhhLC0oYmEtSCkpKTooRz1nKEIseSksYmE9LTEqKHotRyksSD1nKGEsYmEpLCtILnRvRml4ZWQodik8K2JhLnRvRml4ZWQodikmJitHLnRvRml4ZWQodik8PSt5LnRvRml4ZWQodikmJmcoQiwtKGJhLUgpKSl9fX19ZWxzZSBmb3IoYT0wO2E8ci5sZW5ndGg7YSsrKWw9ZFthXSxxPVwicGllXCI9PT1rLnR5cGU/MC43KkE6MC44KkEsQj14LngrcSpNYXRoLmNvcyhsLm1pZEFuZ2xlKSx5PXgueStxKk1hdGguc2luKGwubWlkQW5nbGUpLGwuaW5kZXhMYWJlbFRleHRCbG9jay54PUIsbC5pbmRleExhYmVsVGV4dEJsb2NrLnk9eTtmb3IoYT0wO2E8ci5sZW5ndGg7YSsrKWlmKGw9ZFthXSxCPWwuaW5kZXhMYWJlbFRleHRCbG9jay5tZWFzdXJlVGV4dCgpLFxyXG4wIT09Qi5oZWlnaHQmJjAhPT1CLndpZHRoKUI9Qj0wLFwicmlnaHRcIj09PWwuaGVtaXNwaGVyZT8oQj1uLngyLShsLmluZGV4TGFiZWxUZXh0QmxvY2sueCtsLmluZGV4TGFiZWxUZXh0QmxvY2sud2lkdGgrcCksQio9LTEpOkI9bi54MS0obC5pbmRleExhYmVsVGV4dEJsb2NrLngtbC5pbmRleExhYmVsVGV4dEJsb2NrLndpZHRoLXApLDA8QiYmKCFoJiZsLmluZGV4TGFiZWxUZXh0JiYoeT1cInJpZ2h0XCI9PT1sLmhlbWlzcGhlcmU/bi54Mi1sLmluZGV4TGFiZWxUZXh0QmxvY2sueDpsLmluZGV4TGFiZWxUZXh0QmxvY2sueC1uLngxLDAuMypsLmluZGV4TGFiZWxUZXh0QmxvY2subWF4V2lkdGg+eT9sLmluZGV4TGFiZWxUZXh0PVwiXCI6bC5pbmRleExhYmVsVGV4dEJsb2NrLm1heFdpZHRoPTAuODUqeSwwLjMqbC5pbmRleExhYmVsVGV4dEJsb2NrLm1heFdpZHRoPHkmJihsLmluZGV4TGFiZWxUZXh0QmxvY2sueC09XCJyaWdodFwiPT09bC5oZW1pc3BoZXJlPzI6LTIpKSxNYXRoLmFicyhsLmluZGV4TGFiZWxUZXh0QmxvY2sueS1cclxubC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yLXgueSk8QXx8TWF0aC5hYnMobC5pbmRleExhYmVsVGV4dEJsb2NrLnkrbC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yLXgueSk8QSkmJihCLz1NYXRoLmFicyhNYXRoLmNvcyhsLmluZGV4TGFiZWxBbmdsZSkpLDk8QiYmKEIqPTAuMyksQj5mJiYoZj1CKSksQj1CPTAsMDxsLmluZGV4TGFiZWxBbmdsZSYmbC5pbmRleExhYmVsQW5nbGU8TWF0aC5QST8oQj1uLnkyLShsLmluZGV4TGFiZWxUZXh0QmxvY2sueStsLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIrNSksQio9LTEpOkI9bi55MS0obC5pbmRleExhYmVsVGV4dEJsb2NrLnktbC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yLTUpLDA8QiYmKCFoJiZsLmluZGV4TGFiZWxUZXh0JiYoeT0wPGwuaW5kZXhMYWJlbEFuZ2xlJiZsLmluZGV4TGFiZWxBbmdsZTxNYXRoLlBJPy0xOjEsMD09PWcoYSxCKnkpJiZnKGEsMip5KSksTWF0aC5hYnMobC5pbmRleExhYmVsVGV4dEJsb2NrLngtXHJcbngueCk8QSYmKEIvPU1hdGguYWJzKE1hdGguc2luKGwuaW5kZXhMYWJlbEFuZ2xlKSksOTxCJiYoQio9MC4zKSxCPmYmJihmPUIpKSk7dmFyIEs9ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZT1bXSxmPTA7ZS5wdXNoKGRbYl0pLGIhPT1jO2I9KGIrMStyLmxlbmd0aCklci5sZW5ndGgpO2Uuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLnktYi55fSk7Zm9yKGI9MDtiPGUubGVuZ3RoO2IrKylpZihjPWVbYl0sZjwwLjcqYSlmKz1jLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LGMuaW5kZXhMYWJlbFRleHRCbG9jay50ZXh0PVwiXCIsYy5pbmRleExhYmVsVGV4dD1cIlwiLGMuaW5kZXhMYWJlbFRleHRCbG9jay5tZWFzdXJlVGV4dCgpO2Vsc2UgYnJlYWt9OyhmdW5jdGlvbigpe2Zvcih2YXIgYT0tMSxiPS0xLGY9MCxnPSExLGg9MDtoPHIubGVuZ3RoO2grKylpZihnPSExLHU9ZFtoXSx1LmluZGV4TGFiZWxUZXh0KXt2YXIgaz1lKGgpO2lmKG51bGwhPT1rKXt2YXIgbD1kW2tdO3o9MDtcclxuej1jKHUsbCk7dmFyIG47aWYobj0wPnope249dS5pbmRleExhYmVsVGV4dEJsb2NrLng7dmFyIHQ9dS5pbmRleExhYmVsVGV4dEJsb2NrLnktdS5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yLG09dS5pbmRleExhYmVsVGV4dEJsb2NrLnkrdS5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yLHc9bC5pbmRleExhYmVsVGV4dEJsb2NrLnktbC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yLHE9bC5pbmRleExhYmVsVGV4dEJsb2NrLngrbC5pbmRleExhYmVsVGV4dEJsb2NrLndpZHRoLHM9bC5pbmRleExhYmVsVGV4dEJsb2NrLnkrbC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yO249dS5pbmRleExhYmVsVGV4dEJsb2NrLngrdS5pbmRleExhYmVsVGV4dEJsb2NrLndpZHRoPGwuaW5kZXhMYWJlbFRleHRCbG9jay54LXB8fG4+cStwfHx0PnMrcHx8bTx3LXA/ITE6ITB9bj8oMD5hJiYoYT1oKSxrIT09YSYmKGI9ayxmKz0teiksMD09PWglTWF0aC5tYXgoci5sZW5ndGgvXHJcbjEwLDMpJiYoZz0hMCkpOmc9ITA7ZyYmKDA8ZiYmMDw9YSYmMDw9YikmJihLKGYsYSxiKSxiPWE9LTEsZj0wKX19MDxmJiZLKGYsYSxiKX0pKCl9fWZ1bmN0aW9uIGwoKXt0LnBsb3RBcmVhLmxheW91dE1hbmFnZXIucmVzZXQoKTt0LnRpdGxlJiYodC50aXRsZS5kb2NrSW5zaWRlUGxvdEFyZWF8fFwiY2VudGVyXCI9PT10LnRpdGxlLmhvcml6b250YWxBbGlnbiYmXCJjZW50ZXJcIj09PXQudGl0bGUudmVydGljYWxBbGlnbikmJnQudGl0bGUucmVuZGVyKCk7aWYodC5zdWJ0aXRsZXMpZm9yKHZhciBhPTA7YTx0LnN1YnRpdGxlcy5sZW5ndGg7YSsrKXt2YXIgYj10LnN1YnRpdGxlc1thXTsoYi5kb2NrSW5zaWRlUGxvdEFyZWF8fFwiY2VudGVyXCI9PT1iLmhvcml6b250YWxBbGlnbiYmXCJjZW50ZXJcIj09PWIudmVydGljYWxBbGlnbikmJmIucmVuZGVyKCl9dC5sZWdlbmQmJih0LmxlZ2VuZC5kb2NrSW5zaWRlUGxvdEFyZWF8fFwiY2VudGVyXCI9PT10LmxlZ2VuZC5ob3Jpem9udGFsQWxpZ24mJlwiY2VudGVyXCI9PT1cclxudC5sZWdlbmQudmVydGljYWxBbGlnbikmJnQubGVnZW5kLnJlbmRlcigpfXZhciB0PXRoaXM7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBrPXRoaXMuZGF0YVthLmRhdGFTZXJpZXNJbmRleGVzWzBdXSxyPWsuZGF0YVBvaW50cyxwPTEwLG49dGhpcy5wbG90QXJlYSxkPWsuZGF0YVBvaW50RU9zLG09MixxLHM9MS4zLHU9MjAvMTgwKk1hdGguUEksdj02LHg9e3g6KG4ueDIrbi54MSkvMix5OihuLnkyK24ueTEpLzJ9LHo9MDthPSExO2Zvcih2YXIgQj0wO0I8ci5sZW5ndGg7QisrKXorPU1hdGguYWJzKHJbQl0ueSksIWEmJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIHJbQl0uaW5kZXhMYWJlbCYmbnVsbCE9PXJbQl0uaW5kZXhMYWJlbCYmMDxyW0JdLmluZGV4TGFiZWwudG9TdHJpbmcoKS5sZW5ndGgpJiYoYT0hMCksIWEmJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIHJbQl0ubGFiZWwmJm51bGwhPT1yW0JdLmxhYmVsJiYwPHJbQl0ubGFiZWwudG9TdHJpbmcoKS5sZW5ndGgpJiZcclxuKGE9ITApO2lmKDAhPT16KXthPWF8fFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygay5pbmRleExhYmVsJiZudWxsIT09ay5pbmRleExhYmVsJiYwPGsuaW5kZXhMYWJlbC50b1N0cmluZygpLmxlbmd0aDt2YXIgQT1cImluc2lkZVwiIT09ay5pbmRleExhYmVsUGxhY2VtZW50JiZhPzAuNzUqTWF0aC5taW4obi53aWR0aCxuLmhlaWdodCkvMjowLjkyKk1hdGgubWluKG4ud2lkdGgsbi5oZWlnaHQpLzI7ay5yYWRpdXMmJihBPU8oay5yYWRpdXMsQSkpO3ZhciBDPVwidW5kZWZpbmVkXCIhPT10eXBlb2Ygay5pbm5lclJhZGl1cyYmbnVsbCE9PWsuaW5uZXJSYWRpdXM/TyhrLmlubmVyUmFkaXVzLEEpOjAuNypBO2sucmFkaXVzPUE7XCJkb3VnaG51dFwiPT09ay50eXBlJiYoay5pbm5lclJhZGl1cz1DKTt2YXIgTD1NYXRoLm1pbihDL0EsKEEtMSkvQSk7dGhpcy5waWVEb3VnaG51dENsaWNrSGFuZGxlcj1mdW5jdGlvbihhKXt0LmlzQW5pbWF0aW5nfHwheShhLmRhdGFTZXJpZXMuZXhwbG9kZU9uQ2xpY2spJiZcclxuIWEuZGF0YVNlcmllcy5leHBsb2RlT25DbGlja3x8KGE9YS5kYXRhUG9pbnQsYS5leHBsb2RlZD1hLmV4cGxvZGVkPyExOiEwLDE8dGhpcy5kYXRhUG9pbnRzLmxlbmd0aCYmdC5fYW5pbWF0b3IuYW5pbWF0ZSgwLDUwMCxmdW5jdGlvbihhKXtiKGEpO2woKX0pKX07ZigpO2goKTtoKCk7aCgpO2goKTt0aGlzLmRpc2FibGVUb29sVGlwPSEwO3RoaXMuX2FuaW1hdG9yLmFuaW1hdGUoMCx0aGlzLmFuaW1hdGVkUmVuZGVyP3RoaXMuYW5pbWF0aW9uRHVyYXRpb246MCxmdW5jdGlvbihhKXt2YXIgYj10LnBsb3RBcmVhLmN0eDtiLmNsZWFyUmVjdChuLngxLG4ueTEsbi53aWR0aCxuLmhlaWdodCk7Yi5maWxsU3R5bGU9dC5iYWNrZ3JvdW5kQ29sb3I7Yi5maWxsUmVjdChuLngxLG4ueTEsbi53aWR0aCxuLmhlaWdodCk7YT1kWzBdLnN0YXJ0QW5nbGUrMipNYXRoLlBJKmE7Zm9yKGI9MDtiPHIubGVuZ3RoO2IrKyl7dmFyIGM9MD09PWI/ZFtiXS5zdGFydEFuZ2xlOmUsZT1jKyhkW2JdLmVuZEFuZ2xlLVxyXG5kW2JdLnN0YXJ0QW5nbGUpLGY9ITE7ZT5hJiYoZT1hLGY9ITApO3ZhciBnPXJbYl0uY29sb3I/cltiXS5jb2xvcjprLl9jb2xvclNldFtiJWsuX2NvbG9yU2V0Lmxlbmd0aF07ZT5jJiZyYSh0LnBsb3RBcmVhLmN0eCxkW2JdLmNlbnRlcixkW2JdLnJhZGl1cyxnLGsudHlwZSxjLGUsay5maWxsT3BhY2l0eSxkW2JdLnBlcmNlbnRJbm5lclJhZGl1cyk7aWYoZilicmVha31sKCl9LGZ1bmN0aW9uKCl7dC5kaXNhYmxlVG9vbFRpcD0hMTt0Ll9hbmltYXRvci5hbmltYXRlKDAsdC5hbmltYXRlZFJlbmRlcj81MDA6MCxmdW5jdGlvbihhKXtiKGEpO2woKX0pfSl9fX07dmFyIHNhPWZ1bmN0aW9uKGEsZixiLGMpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9MSk7MD49TWF0aC5yb3VuZChmLnk0LWYueTEpfHwoYS5zYXZlKCksYS5nbG9iYWxBbHBoYT1iLGEuYmVnaW5QYXRoKCksYS5tb3ZlVG8oTWF0aC5yb3VuZChmLngxKSxNYXRoLnJvdW5kKGYueTEpKSxhLmxpbmVUbyhNYXRoLnJvdW5kKGYueDIpLFxyXG5NYXRoLnJvdW5kKGYueTIpKSxhLmxpbmVUbyhNYXRoLnJvdW5kKGYueDMpLE1hdGgucm91bmQoZi55MykpLGEubGluZVRvKE1hdGgucm91bmQoZi54NCksTWF0aC5yb3VuZChmLnk0KSksXCJ1bmRlZmluZWRcIiE9PWYueDUmJihhLmxpbmVUbyhNYXRoLnJvdW5kKGYueDUpLE1hdGgucm91bmQoZi55NSkpLGEubGluZVRvKE1hdGgucm91bmQoZi54NiksTWF0aC5yb3VuZChmLnk2KSkpLGEuY2xvc2VQYXRoKCksYS5maWxsU3R5bGU9Yz9jOmYuY29sb3IsYS5maWxsKCksYS5nbG9iYWxBcGxoYT0xLGEucmVzdG9yZSgpKX07cS5wcm90b3R5cGUucmVuZGVyRnVubmVsPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGYoKXtmb3IodmFyIGE9MCxiPVtdLGM9MDtjPHgubGVuZ3RoO2MrKyl7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB4W2NdLnkpcmV0dXJuLTE7eFtjXS55PVwibnVtYmVyXCI9PT10eXBlb2YgeFtjXS55P3hbY10ueTowO2ErPU1hdGguYWJzKHhbY10ueSl9aWYoMD09PWEpcmV0dXJuLTE7Zm9yKGM9XHJcbmJbMF09MDtjPHgubGVuZ3RoO2MrKyliLnB1c2goTWF0aC5hYnMoeFtjXS55KSpPL2EpO3JldHVybiBifWZ1bmN0aW9uIGIoKXt2YXIgYT1YLGI9VixjPUssZD1ZLGUsZjtlPVE7Zj0kLU47aGVhZEFyZWE9KGYtZSkqKGItYSsoZC1jKSkvMjtoZWFkQXJlYT1NYXRoLmFicyhoZWFkQXJlYSk7Yz1ZLUs7ZT1mLWU7Zj1jKihmLSQpO2Y9TWF0aC5hYnMoZik7Zj1oZWFkQXJlYStmO2Zvcih2YXIgZD1bXSxnPTAsaD0wO2g8eC5sZW5ndGg7aCsrKXtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIHhbaF0ueSlyZXR1cm4tMTt4W2hdLnk9XCJudW1iZXJcIj09PXR5cGVvZiB4W2hdLnk/eFtoXS55OjA7Zys9TWF0aC5hYnMoeFtoXS55KX1pZigwPT09ZylyZXR1cm4tMTtmb3IodmFyIGs9ZFswXT0wLGw9MCxuLGI9Yi1hLHQ9ITEsaD0wO2g8eC5sZW5ndGg7aCsrKWE9TWF0aC5hYnMoeFtoXS55KSpmL2csdD9rPTA9PU51bWJlcihjLnRvRml4ZWQoMykpPzA6YS9jOihzcXJ0PWZhKmZhKmIqYi00Kk1hdGguYWJzKGZhKSpcclxuYSwwPnNxcnQ/KG49YyxrPShiK24pKihlLWwpLzIsYS09ayxrPWUtbCxsKz1lLWwsays9MD09bj8wOmEvbixsKz1hL24sdD0hMCk6KGs9KE1hdGguYWJzKGZhKSpiLU1hdGguc3FydChzcXJ0KSkvMixuPWItMiprL01hdGguYWJzKGZhKSxsKz1rLGw+ZSYmKGwtPWssbj1jLGs9KGIrbikqKGUtbCkvMixhLT1rLGs9ZS1sLGwrPWUtbCxrKz1hL24sbCs9YS9uLHQ9ITApLGI9bikpLGQucHVzaChrKTtyZXR1cm4gZH1mdW5jdGlvbiBjKCl7aWYodSYmeCl7Zm9yKHZhciBhLGIsYyxlLGYsZyxoLGssbCxuLHQscCxyLG0sdz1bXSxxPVtdLEE9e3BlcmNlbnQ6bnVsbCx0b3RhbDpudWxsfSxCPW51bGwsej0wO3o8eC5sZW5ndGg7eisrKW09TVt6XSxtPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgbS54NT8obS55MittLnk0KS8yOihtLnkyK20ueTMpLzIsbT1kKG0pLngyKzEsd1t6XT1QLW0tVTttPTAuNSpVO2Zvcih2YXIgej0wLHphPXgubGVuZ3RoLTE7ejx4Lmxlbmd0aHx8MDw9emE7eisrLHphLS0pe2I9XHJcbnUucmV2ZXJzZWQ/eFt6YV06eFt6XTthPWIuY29sb3I/Yi5jb2xvcjp1LnJldmVyc2VkP3UuX2NvbG9yU2V0Wyh4Lmxlbmd0aC0xLXopJXUuX2NvbG9yU2V0Lmxlbmd0aF06dS5fY29sb3JTZXRbeiV1Ll9jb2xvclNldC5sZW5ndGhdO2M9Yi5pbmRleExhYmVsUGxhY2VtZW50fHx1LmluZGV4TGFiZWxQbGFjZW1lbnR8fFwib3V0c2lkZVwiO2U9Yi5pbmRleExhYmVsQmFja2dyb3VuZENvbG9yfHx1LmluZGV4TGFiZWxCYWNrZ3JvdW5kQ29sb3J8fCh2P1widHJhbnNwYXJlbnRcIjpudWxsKTtmPWIuaW5kZXhMYWJlbEZvbnRDb2xvcnx8dS5pbmRleExhYmVsRm9udENvbG9yfHxcIiM5Nzk3OTdcIjtnPXkoYi5pbmRleExhYmVsRm9udFNpemUpP3UuaW5kZXhMYWJlbEZvbnRTaXplOmIuaW5kZXhMYWJlbEZvbnRTaXplO2g9Yi5pbmRleExhYmVsRm9udFN0eWxlfHx1LmluZGV4TGFiZWxGb250U3R5bGV8fFwibm9ybWFsXCI7az1iLmluZGV4TGFiZWxGb250RmFtaWx5fHx1LmluZGV4TGFiZWxGb250RmFtaWx5fHxcclxuXCJhcmlhbFwiO2w9Yi5pbmRleExhYmVsRm9udFdlaWdodHx8dS5pbmRleExhYmVsRm9udFdlaWdodHx8XCJub3JtYWxcIjthPWIuaW5kZXhMYWJlbExpbmVDb2xvcnx8dS5vcHRpb25zLmluZGV4TGFiZWxMaW5lQ29sb3J8fGE7bj1cIm51bWJlclwiPT09dHlwZW9mIGIuaW5kZXhMYWJlbExpbmVUaGlja25lc3M/Yi5pbmRleExhYmVsTGluZVRoaWNrbmVzczpcIm51bWJlclwiPT09dHlwZW9mIHUuaW5kZXhMYWJlbExpbmVUaGlja25lc3M/dS5pbmRleExhYmVsTGluZVRoaWNrbmVzczoyO3Q9Yi5pbmRleExhYmVsTGluZURhc2hUeXBlfHx1LmluZGV4TGFiZWxMaW5lRGFzaFR5cGV8fFwic29saWRcIjtwPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgYi5pbmRleExhYmVsV3JhcD9iLmluZGV4TGFiZWxXcmFwOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgdS5pbmRleExhYmVsV3JhcD91LmluZGV4TGFiZWxXcmFwOiEwO3I9dS5kYXRhUG9pbnRJZHNbel07cy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtyXT17aWQ6cixcclxub2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFQb2ludEluZGV4OnosZGF0YVNlcmllc0luZGV4OjAsZnVubmVsU2VjdGlvbjpNW3UucmV2ZXJzZWQ/eC5sZW5ndGgtMS16OnpdfTtcImluc2lkZVwiPT09dS5pbmRleExhYmVsUGxhY2VtZW50JiYod1t6XT16IT09Z2E/dS5yZXZlcnNlZD9NW3pdLngyLU1bel0ueDE6TVt6XS54My1NW3pdLng0Ok1bel0ueDMtTVt6XS54NiwyMD53W3pdJiYod1t6XT16IT09Z2E/dS5yZXZlcnNlZD9NW3pdLngzLU1bel0ueDQ6TVt6XS54Mi1NW3pdLngxOk1bel0ueDItTVt6XS54MSx3W3pdLz0yKSk7cj1iLmluZGV4TGFiZWxNYXhXaWR0aD9iLmluZGV4TGFiZWxNYXhXaWR0aDp1Lm9wdGlvbnMuaW5kZXhMYWJlbE1heFdpZHRoP3UuaW5kZXhMYWJlbE1heFdpZHRoOndbel07aWYocj53W3pdfHwwPnIpcj13W3pdO3Fbel09XCJpbnNpZGVcIj09PXUuaW5kZXhMYWJlbFBsYWNlbWVudD9NW3pdLmhlaWdodDohMTtBPXMuZ2V0UGVyY2VudEFuZFRvdGFsKHUsYik7XHJcbmlmKHUuaW5kZXhMYWJlbEZvcm1hdHRlcnx8Yi5pbmRleExhYmVsRm9ybWF0dGVyKUI9e2NoYXJ0OnMub3B0aW9ucyxkYXRhU2VyaWVzOnUsZGF0YVBvaW50OmIsdG90YWw6QS50b3RhbCxwZXJjZW50OkEucGVyY2VudH07Yj1iLmluZGV4TGFiZWxGb3JtYXR0ZXI/Yi5pbmRleExhYmVsRm9ybWF0dGVyKEIpOmIuaW5kZXhMYWJlbD9zLnJlcGxhY2VLZXl3b3Jkc1dpdGhWYWx1ZShiLmluZGV4TGFiZWwsYix1LHopOnUuaW5kZXhMYWJlbEZvcm1hdHRlcj91LmluZGV4TGFiZWxGb3JtYXR0ZXIoQik6dS5pbmRleExhYmVsP3MucmVwbGFjZUtleXdvcmRzV2l0aFZhbHVlKHUuaW5kZXhMYWJlbCxiLHUseik6Yi5sYWJlbD9iLmxhYmVsOlwiXCI7MD49biYmKG49MCk7MUUzPnImJjFFMy1yPG0mJihyKz0xRTMtcik7Ui5yb3VuZFJlY3R8fENhKFIpO2M9bmV3IGxhKFIse2ZvbnRTaXplOmcsZm9udEZhbWlseTprLGZvbnRDb2xvcjpmLGZvbnRTdHlsZTpoLGZvbnRXZWlnaHQ6bCxob3Jpem9udGFsQWxpZ246YyxcclxuYmFja2dyb3VuZENvbG9yOmUsbWF4V2lkdGg6cixtYXhIZWlnaHQ6ITE9PT1xW3pdP3A/NC4yODU3MTQyOSpnOjEuNSpnOnFbel0sdGV4dDpiLHBhZGRpbmc6aGF9KTtjLm1lYXN1cmVUZXh0KCk7Ri5wdXNoKHt0ZXh0QmxvY2s6YyxpZDp1LnJldmVyc2VkP3phOnosaXNEaXJ0eTohMSxsaW5lQ29sb3I6YSxsaW5lVGhpY2tuZXNzOm4sbGluZURhc2hUeXBlOnQsaGVpZ2h0OmMuaGVpZ2h0PGMubWF4SGVpZ2h0P2MuaGVpZ2h0OmMubWF4SGVpZ2h0LHdpZHRoOmMud2lkdGg8Yy5tYXhXaWR0aD9jLndpZHRoOmMubWF4V2lkdGh9KX19fWZ1bmN0aW9uIGUoKXt2YXIgYSxiLGMsZCxlLGY9W107ZT0hMTtjPTA7Zm9yKHZhciBnPVAtVi1VLzIsZz11Lm9wdGlvbnMuaW5kZXhMYWJlbE1heFdpZHRoP3UuaW5kZXhMYWJlbE1heFdpZHRoPmc/Zzp1LmluZGV4TGFiZWxNYXhXaWR0aDpnLGg9Ri5sZW5ndGgtMTswPD1oO2gtLSl7ZGF0YVBvaW50PXhbRltoXS5pZF07Yz1GW2hdO2Q9Yy50ZXh0QmxvY2s7XHJcbmI9KGE9bihoKTxNLmxlbmd0aD9GW24oaCldOm51bGwpP2EudGV4dEJsb2NrOm51bGw7Yz1jLmhlaWdodDthJiZkLnkrYytoYT5iLnkmJihlPSEwKTtjPWRhdGFQb2ludC5pbmRleExhYmVsTWF4V2lkdGh8fGc7aWYoYz5nfHwwPmMpYz1nO2YucHVzaChjKX1pZihlKWZvcihoPUYubGVuZ3RoLTE7MDw9aDtoLS0pYT1NW2hdLEZbaF0udGV4dEJsb2NrLm1heFdpZHRoPWZbZi5sZW5ndGgtKGgrMSldLEZbaF0udGV4dEJsb2NrLm1lYXN1cmVUZXh0KCksRltoXS50ZXh0QmxvY2sueD1QLWcsYz1GW2hdLnRleHRCbG9jay5oZWlnaHQ8RltoXS50ZXh0QmxvY2subWF4SGVpZ2h0P0ZbaF0udGV4dEJsb2NrLmhlaWdodDpGW2hdLnRleHRCbG9jay5tYXhIZWlnaHQsZT1GW2hdLnRleHRCbG9jay53aWR0aDxGW2hdLnRleHRCbG9jay5tYXhXaWR0aD9GW2hdLnRleHRCbG9jay53aWR0aDpGW2hdLnRleHRCbG9jay5tYXhXaWR0aCxGW2hdLmhlaWdodD1jLEZbaF0ud2lkdGg9ZSxjPVwidW5kZWZpbmVkXCIhPT1cclxudHlwZW9mIGEueDU/KGEueTIrYS55NCkvMjooYS55MithLnkzKS8yLEZbaF0udGV4dEJsb2NrLnk9Yy1GW2hdLmhlaWdodC8yLHUucmV2ZXJzZWQ/KEZbaF0udGV4dEJsb2NrLnkrRltoXS5oZWlnaHQ+VCtDJiYoRltoXS50ZXh0QmxvY2sueT1UK0MtRltoXS5oZWlnaHQpLEZbaF0udGV4dEJsb2NrLnk8dGEtQyYmKEZbaF0udGV4dEJsb2NrLnk9dGEtQykpOihGW2hdLnRleHRCbG9jay55PFQtQyYmKEZbaF0udGV4dEJsb2NrLnk9VC1DKSxGW2hdLnRleHRCbG9jay55K0ZbaF0uaGVpZ2h0PnRhK0MmJihGW2hdLnRleHRCbG9jay55PXRhK0MtRltoXS5oZWlnaHQpKX1mdW5jdGlvbiBnKCl7dmFyIGEsYixjLGU7aWYoXCJpbnNpZGVcIiE9PXUuaW5kZXhMYWJlbFBsYWNlbWVudClmb3IodmFyIGY9MDtmPE0ubGVuZ3RoO2YrKykwPT1GW2ZdLnRleHRCbG9jay50ZXh0Lmxlbmd0aD9GW2ZdLmlzRGlydHk9ITA6KGE9TVtmXSxjPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgYS54NT8oYS55MithLnk0KS9cclxuMjooYS55MithLnkzKS8yLGI9dS5yZXZlcnNlZD9cInVuZGVmaW5lZFwiIT09dHlwZW9mIGEueDU/Yz5hYT9kKGMpLngyKzE6KGEueDIrYS54MykvMisxOihhLngyK2EueDMpLzIrMTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGEueDU/YzxhYT9kKGMpLngyKzE6KGEueDQrYS54MykvMisxOihhLngyK2EueDMpLzIrMSxGW2ZdLnRleHRCbG9jay54PWIrVSxGW2ZdLnRleHRCbG9jay55PWMtRltmXS5oZWlnaHQvMix1LnJldmVyc2VkPyhGW2ZdLnRleHRCbG9jay55K0ZbZl0uaGVpZ2h0PlQrQyYmKEZbZl0udGV4dEJsb2NrLnk9VCtDLUZbZl0uaGVpZ2h0KSxGW2ZdLnRleHRCbG9jay55PHRhLUMmJihGW2ZdLnRleHRCbG9jay55PXRhLUMpKTooRltmXS50ZXh0QmxvY2sueTxULUMmJihGW2ZdLnRleHRCbG9jay55PVQtQyksRltmXS50ZXh0QmxvY2sueStGW2ZdLmhlaWdodD50YStDJiYoRltmXS50ZXh0QmxvY2sueT10YStDLUZbZl0uaGVpZ2h0KSkpO2Vsc2UgZm9yKGY9MDtmPE0ubGVuZ3RoO2YrKykwPT1cclxuRltmXS50ZXh0QmxvY2sudGV4dC5sZW5ndGg/RltmXS5pc0RpcnR5PSEwOihhPU1bZl0sYj1hLmhlaWdodCxjPUZbZl0uaGVpZ2h0LGU9RltmXS53aWR0aCxiPj1jPyhiPWYhPWdhPyhhLng0K2EueDMpLzItZS8yOihhLng1K2EueDQpLzItZS8yLGM9ZiE9Z2E/KGEueTErYS55MykvMi1jLzI6KGEueTErYS55NCkvMi1jLzIsRltmXS50ZXh0QmxvY2sueD1iLEZbZl0udGV4dEJsb2NrLnk9Yyk6RltmXS5pc0RpcnR5PSEwKX1mdW5jdGlvbiBoKCl7ZnVuY3Rpb24gYShiLGMpe3ZhciBkO2lmKDA+Ynx8Yj49Ri5sZW5ndGgpcmV0dXJuIDA7dmFyIGUsZj1GW2JdLnRleHRCbG9jaztpZigwPmMpe2MqPS0xO2U9cChiKTtkPWwoZSxiKTtpZihkPj1jKXJldHVybiBmLnktPWMsYztpZigwPT1iKXJldHVybiAwPGQmJihmLnktPWQpLGQ7ZCs9YShlLC0oYy1kKSk7MDxkJiYoZi55LT1kKTtyZXR1cm4gZH1lPW4oYik7ZD1sKGIsZSk7aWYoZD49YylyZXR1cm4gZi55Kz1jLGM7aWYoYj09TS5sZW5ndGgtXHJcbjEpcmV0dXJuIDA8ZCYmKGYueSs9ZCksZDtkKz1hKGUsYy1kKTswPGQmJihmLnkrPWQpO3JldHVybiBkfWZ1bmN0aW9uIGIoKXt2YXIgYSxkLGUsZixnPTAsaDtmPSgkLVErMipDKS90O2g9dDtmb3IodmFyIGssbD0xO2w8aDtsKyspe2U9bCpmO2Zvcih2YXIgcj1GLmxlbmd0aC0xOzA8PXI7ci0tKSFGW3JdLmlzRGlydHkmJihGW3JdLnRleHRCbG9jay55PGUmJkZbcl0udGV4dEJsb2NrLnkrRltyXS5oZWlnaHQ+ZSkmJihrPW4ociksIShrPj1GLmxlbmd0aC0xKSYmRltyXS50ZXh0QmxvY2sueStGW3JdLmhlaWdodCtoYT5GW2tdLnRleHRCbG9jay55JiYoRltyXS50ZXh0QmxvY2sueT1GW3JdLnRleHRCbG9jay55K0Zbcl0uaGVpZ2h0LWU+ZS1GW3JdLnRleHRCbG9jay55P2UrMTplLUZbcl0uaGVpZ2h0LTEpKX1mb3Ioaz1NLmxlbmd0aC0xOzA8aztrLS0paWYoIUZba10uaXNEaXJ0eSl7ZT1wKGspO2lmKDA+ZSYmKGU9MCxGW2VdLmlzRGlydHkpKWJyZWFrO2lmKEZba10udGV4dEJsb2NrLnk8XHJcbkZbZV0udGV4dEJsb2NrLnkrRltlXS5oZWlnaHQpe2Q9ZHx8aztmPWs7Zm9yKGg9MDtGW2ZdLnRleHRCbG9jay55PEZbZV0udGV4dEJsb2NrLnkrRltlXS5oZWlnaHQraGE7KXthPWF8fEZbZl0udGV4dEJsb2NrLnkrRltmXS5oZWlnaHQ7aCs9RltmXS5oZWlnaHQ7aCs9aGE7Zj1lO2lmKDA+PWYpe2Y9MDtoKz1GW2ZdLmhlaWdodDticmVha31lPXAoZik7aWYoMD5lKXtmPTA7aCs9RltmXS5oZWlnaHQ7YnJlYWt9fWlmKGYhPWspe2c9RltmXS50ZXh0QmxvY2sueTthLT1nO2E9aC1hO2c9YyhhLGQsZik7YnJlYWt9fX1yZXR1cm4gZ31mdW5jdGlvbiBjKGEsYixkKXt2YXIgZT1bXSxmPTAsZz0wO2ZvcihhPU1hdGguYWJzKGEpO2Q8PWI7ZCsrKWUucHVzaChNW2RdKTtlLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5oZWlnaHQtYi5oZWlnaHR9KTtmb3IoZD0wO2Q8ZS5sZW5ndGg7ZCsrKWlmKGI9ZVtkXSxmPGEpZysrLGYrPUZbYi5pZF0uaGVpZ2h0K2hhLEZbYi5pZF0udGV4dEJsb2NrLnRleHQ9XHJcblwiXCIsRltiLmlkXS5pbmRleExhYmVsVGV4dD1cIlwiLEZbYi5pZF0uaXNEaXJ0eT0hMCxGW2IuaWRdLnRleHRCbG9jay5tZWFzdXJlVGV4dCgpO2Vsc2UgYnJlYWs7cmV0dXJuIGd9Zm9yKHZhciBkLGUsZixnLGgsayx0PTEscj0wO3I8Mip0O3IrKyl7Zm9yKHZhciBtPUYubGVuZ3RoLTE7MDw9bSYmIShwcmV2aW91c1RleHRCbG9jaz0ocHJldmlvdXNMYWJlbD0wPD1wKG0pP0ZbcChtKV06bnVsbCk/cHJldmlvdXNMYWJlbC50ZXh0QmxvY2s6bnVsbCxmPUZbbV0sZz1mLnRleHRCbG9jayxrPShoPW4obSk8TS5sZW5ndGg/RltuKG0pXTpudWxsKT9oLnRleHRCbG9jazpudWxsLGQ9K2YuaGVpZ2h0LnRvRml4ZWQoNiksZT0rZy55LnRvRml4ZWQoNiksIWYuaXNEaXJ0eSYmKGgmJmUrZCtoYT4ray55LnRvRml4ZWQoNikpJiYoZD1nLnkrZCtoYS1rLnksZT1hKG0sLWQpLGU8ZCYmKDA8ZSYmKGQtPWUpLGU9YShuKG0pLGQpLGUhPWQpKSk7bS0tKTtiKCl9fWZ1bmN0aW9uIGwoYSxiKXtyZXR1cm4oYjxcclxuTS5sZW5ndGg/RltiXS50ZXh0QmxvY2sueTp1LnJldmVyc2VkP1QrQzp0YStDKS0oMD5hP3UucmV2ZXJzZWQ/dGEtQzpULUM6RlthXS50ZXh0QmxvY2sueStGW2FdLmhlaWdodCtoYSl9ZnVuY3Rpb24gdChhLGIsYyl7dmFyIGQsZSxmLGg9W10sbD1DLG49W107LTEhPT1iJiYoMDw9bWEuaW5kZXhPZihiKT8oZT1tYS5pbmRleE9mKGIpLG1hLnNwbGljZShlLDEpKToobWEucHVzaChiKSxtYT1tYS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEtYn0pKSk7aWYoMD09PW1hLmxlbmd0aCloPWthO2Vsc2V7ZT1DKigxIT1tYS5sZW5ndGh8fDAhPW1hWzBdJiZtYVswXSE9TS5sZW5ndGgtMT8yOjEpL2soKTtmb3IodmFyIHQ9MDt0PE0ubGVuZ3RoO3QrKyl7aWYoMT09bWEubGVuZ3RoJiYwPT1tYVswXSl7aWYoMD09PXQpe2gucHVzaChrYVt0XSk7ZD1sO2NvbnRpbnVlfX1lbHNlIDA9PT10JiYoZD0tMSpsKTtoLnB1c2goa2FbdF0rZCk7aWYoMDw9bWEuaW5kZXhPZih0KXx8dDxNLmxlbmd0aCYmXHJcbjA8PW1hLmluZGV4T2YodCsxKSlkKz1lfX1mPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVtdLGI9MDtiPE0ubGVuZ3RoO2IrKylhLnB1c2goaFtiXS1NW2JdLnkxKTtyZXR1cm4gYX0oKTt2YXIgcD17c3RhcnRUaW1lOihuZXcgRGF0ZSkuZ2V0VGltZSgpLGR1cmF0aW9uOmN8fDUwMCxlYXNpbmdGdW5jdGlvbjpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gSC5lYXNpbmcuZWFzZU91dFF1YXJ0KGEsYixjLGQpfSxjaGFuZ2VTZWN0aW9uOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYixjLGQ9MDtkPE0ubGVuZ3RoO2QrKyliPWZbZF0sYz1NW2RdLG5ld1k9YiphLFwidW5kZWZpbmVkXCI9PT10eXBlb2YgbltkXSYmKG5bZF09MCksMD5uJiYobio9LTEpLGMueTErPW5ld1ktbltkXSxjLnkyKz1uZXdZLW5bZF0sYy55Mys9bmV3WS1uW2RdLGMueTQrPW5ld1ktbltkXSxjLnk1JiYoYy55NSs9bmV3WS1uW2RdLGMueTYrPW5ld1ktbltkXSksbltkXT1uZXdZfX07YS5fYW5pbWF0b3IuYW5pbWF0ZSgwLGMsZnVuY3Rpb24oYyl7dmFyIGQ9XHJcbmEucGxvdEFyZWEuY3R4fHxhLmN0eDtqYT0hMDtkLmNsZWFyUmVjdCh6LngxLHoueTEsei54Mi16LngxLHoueTItei55MSk7ZC5maWxsU3R5bGU9YS5iYWNrZ3JvdW5kQ29sb3I7ZC5maWxsUmVjdCh6LngxLHoueTEsei53aWR0aCx6LmhlaWdodCk7cC5jaGFuZ2VTZWN0aW9uKGMsYik7dmFyIGU9e307ZS5kYXRhU2VyaWVzPXU7ZS5kYXRhUG9pbnQ9dS5yZXZlcnNlZD91LmRhdGFQb2ludHNbeC5sZW5ndGgtMS1iXTp1LmRhdGFQb2ludHNbYl07ZS5pbmRleD11LnJldmVyc2VkP3gubGVuZ3RoLTEtYjpiO2EudG9vbFRpcC5oaWdobGlnaHRPYmplY3RzKFtlXSk7Zm9yKGU9MDtlPE0ubGVuZ3RoO2UrKylzYShkLE1bZV0sdS5maWxsT3BhY2l0eSk7cShkKTtKJiYoXCJpbnNpZGVcIiE9PXUuaW5kZXhMYWJlbFBsYWNlbWVudD9yKGQpOmcoKSxtKGQpKTsxPD1jJiYoamE9ITEpfSxudWxsLEguZWFzaW5nLmVhc2VPdXRRdWFydCl9ZnVuY3Rpb24gaygpe2Zvcih2YXIgYT0wLGI9MDtiPE0ubGVuZ3RoLVxyXG4xO2IrKykoMDw9bWEuaW5kZXhPZihiKXx8MDw9bWEuaW5kZXhPZihiKzEpKSYmYSsrO3JldHVybiBhfWZ1bmN0aW9uIHIoYSl7Zm9yKHZhciBiLGMsZSxmLGc9MDtnPE0ubGVuZ3RoO2crKylmPTE9PT1GW2ddLmxpbmVUaGlja25lc3MlMj8wLjU6MCxjPSgoTVtnXS55MitNW2ddLnk0KS8yPDwwKStmLGI9ZChjKS54Mi0xLGU9RltnXS50ZXh0QmxvY2sueCxmPShGW2ddLnRleHRCbG9jay55K0ZbZ10uaGVpZ2h0LzI8PDApK2YsRltnXS5pc0RpcnR5fHwwPT1GW2ddLmxpbmVUaGlja25lc3N8fChhLnN0cm9rZVN0eWxlPUZbZ10ubGluZUNvbG9yLGEubGluZVdpZHRoPUZbZ10ubGluZVRoaWNrbmVzcyxhLnNldExpbmVEYXNoJiZhLnNldExpbmVEYXNoKEcoRltnXS5saW5lRGFzaFR5cGUsRltnXS5saW5lVGhpY2tuZXNzKSksYS5iZWdpblBhdGgoKSxhLm1vdmVUbyhiLGMpLGEubGluZVRvKGUsZiksYS5zdHJva2UoKSl9ZnVuY3Rpb24gcChhKXtmb3IoYS09MTstMTw9YSYmLTEhPWEmJkZbYV0uaXNEaXJ0eTthLS0pO1xyXG5yZXR1cm4gYX1mdW5jdGlvbiBuKGEpe2ZvcihhKz0xO2E8PU0ubGVuZ3RoJiZhIT1NLmxlbmd0aCYmRlthXS5pc0RpcnR5O2ErKyk7cmV0dXJuIGF9ZnVuY3Rpb24gZChhKXtmb3IodmFyIGIsYz0wO2M8eC5sZW5ndGg7YysrKWlmKE1bY10ueTE8YSYmTVtjXS55ND5hKXtiPU1bY107YnJlYWt9cmV0dXJuIGI/KGE9Yi55Nj9hPmIueTY/Yi54MysoYi54NC1iLngzKS8oYi55NC1iLnkzKSooYS1iLnkzKTpiLngyKyhiLngzLWIueDIpLyhiLnkzLWIueTIpKihhLWIueTIpOmIueDIrKGIueDMtYi54MikvKGIueTMtYi55MikqKGEtYi55Mikse3gxOmEseDI6YX0pOi0xfWZ1bmN0aW9uIG0oYSl7Zm9yKHZhciBiPTA7YjxNLmxlbmd0aDtiKyspRltiXS5pc0RpcnR5fHwoYSYmKEZbYl0udGV4dEJsb2NrLmN0eD1hKSxGW2JdLnRleHRCbG9jay5yZW5kZXIoITApKX1mdW5jdGlvbiBxKGEpe3MucGxvdEFyZWEubGF5b3V0TWFuYWdlci5yZXNldCgpO2Eucm91bmRSZWN0fHxDYShhKTtzLnRpdGxlJiZcclxuKHMudGl0bGUuZG9ja0luc2lkZVBsb3RBcmVhfHxcImNlbnRlclwiPT09cy50aXRsZS5ob3Jpem9udGFsQWxpZ24mJlwiY2VudGVyXCI9PT1zLnRpdGxlLnZlcnRpY2FsQWxpZ24pJiYocy50aXRsZS5jdHg9YSxzLnRpdGxlLnJlbmRlcigpKTtpZihzLnN1YnRpdGxlcylmb3IodmFyIGI9MDtiPHMuc3VidGl0bGVzLmxlbmd0aDtiKyspe3ZhciBjPXMuc3VidGl0bGVzW2JdO2lmKGMuZG9ja0luc2lkZVBsb3RBcmVhfHxcImNlbnRlclwiPT09Yy5ob3Jpem9udGFsQWxpZ24mJlwiY2VudGVyXCI9PT1jLnZlcnRpY2FsQWxpZ24pcy5zdWJ0aXRsZXMuY3R4PWEsYy5yZW5kZXIoKX1zLmxlZ2VuZCYmKHMubGVnZW5kLmRvY2tJbnNpZGVQbG90QXJlYXx8XCJjZW50ZXJcIj09PXMubGVnZW5kLmhvcml6b250YWxBbGlnbiYmXCJjZW50ZXJcIj09PXMubGVnZW5kLnZlcnRpY2FsQWxpZ24pJiYocy5sZWdlbmQuY3R4PWEscy5sZWdlbmQucmVuZGVyKCkpO1ouZk5nJiZaLmZOZyhzKX12YXIgcz10aGlzO2lmKCEoMD49XHJcbmEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7Zm9yKHZhciB1PXRoaXMuZGF0YVthLmRhdGFTZXJpZXNJbmRleGVzWzBdXSx4PXUuZGF0YVBvaW50cyx6PXRoaXMucGxvdEFyZWEsQz0wLjAyNSp6LndpZHRoLEI9MC4wMSp6LndpZHRoLEE9MCxPPXouaGVpZ2h0LTIqQyxMPU1hdGgubWluKHoud2lkdGgtMipCLDIuOCp6LmhlaWdodCksSj0hMSxJPTA7STx4Lmxlbmd0aDtJKyspaWYoIUomJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIHhbSV0uaW5kZXhMYWJlbCYmbnVsbCE9PXhbSV0uaW5kZXhMYWJlbCYmMDx4W0ldLmluZGV4TGFiZWwudG9TdHJpbmcoKS5sZW5ndGgpJiYoSj0hMCksIUomJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIHhbSV0ubGFiZWwmJm51bGwhPT14W0ldLmxhYmVsJiYwPHhbSV0ubGFiZWwudG9TdHJpbmcoKS5sZW5ndGgpJiYoSj0hMCksIUomJlwiZnVuY3Rpb25cIj09PXR5cGVvZiB1LmluZGV4TGFiZWxGb3JtYXR0ZXJ8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiB4W0ldLmluZGV4TGFiZWxGb3JtYXR0ZXIpSj1cclxuITA7Sj1KfHxcInVuZGVmaW5lZFwiIT09dHlwZW9mIHUuaW5kZXhMYWJlbCYmbnVsbCE9PXUuaW5kZXhMYWJlbCYmMDx1LmluZGV4TGFiZWwudG9TdHJpbmcoKS5sZW5ndGg7XCJpbnNpZGVcIiE9PXUuaW5kZXhMYWJlbFBsYWNlbWVudCYmSnx8KEI9KHoud2lkdGgtMC43NSpMKS8yKTt2YXIgST16LngxK0IsUD16LngyLUIsUT16LnkxK0MsJD16LnkyLUMsUj1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHh8fHRoaXMuY3R4O2lmKDAhPXUubGVuZ3RoJiYodS5kYXRhUG9pbnRzJiZ1LnZpc2libGUpJiYwIT09eC5sZW5ndGgpe3ZhciBOLEU7YT03NSpMLzEwMDt2YXIgVT0zMCooUC1hKS8xMDA7XCJmdW5uZWxcIj09PXUudHlwZT8oTj15KHUub3B0aW9ucy5uZWNrSGVpZ2h0KT8wLjM1Kk86dS5uZWNrSGVpZ2h0LEU9eSh1Lm9wdGlvbnMubmVja1dpZHRoKT8wLjI1KmE6dS5uZWNrV2lkdGgsXCJzdHJpbmdcIj09PXR5cGVvZiBOJiZOLm1hdGNoKC8lJC8pPyhOPXBhcnNlSW50KE4pLE49XHJcbk4qTy8xMDApOk49cGFyc2VJbnQoTiksXCJzdHJpbmdcIj09PXR5cGVvZiBFJiZFLm1hdGNoKC8lJC8pPyhFPXBhcnNlSW50KEUpLEU9RSphLzEwMCk6RT1wYXJzZUludChFKSxOPk8/Tj1POjA+PU4mJihOPTApLEU+YT9FPWEtMC41OjA+PUUmJihFPTApKTpcInB5cmFtaWRcIj09PXUudHlwZSYmKEU9Tj0wLHUucmV2ZXJzZWQ9dS5yZXZlcnNlZD8hMTohMCk7dmFyIEI9SSthLzIsWD1JLFY9SSthLFQ9dS5yZXZlcnNlZD8kOlEsSz1CLUUvMixZPUIrRS8yLGFhPXUucmV2ZXJzZWQ/UStOOiQtTix0YT11LnJldmVyc2VkP1E6JDthPVtdO3ZhciBCPVtdLE09W10sTD1bXSxXPVEsZ2EsZmE9KGFhLVQpLyhLLVgpLGlhPS1mYSxJPVwiYXJlYVwiPT09KHUudmFsdWVSZXByZXNlbnRzP3UudmFsdWVSZXByZXNlbnRzOlwiaGVpZ2h0XCIpP2IoKTpmKCk7aWYoLTEhPT1JKXtpZih1LnJldmVyc2VkKWZvcihMLnB1c2goVyksRT1JLmxlbmd0aC0xOzA8RTtFLS0pVys9SVtFXSxMLnB1c2goVyk7ZWxzZSBmb3IoRT1cclxuMDtFPEkubGVuZ3RoO0UrKylXKz1JW0VdLEwucHVzaChXKTtpZih1LnJldmVyc2VkKWZvcihFPTA7RTxJLmxlbmd0aDtFKyspTFtFXTxhYT8oYS5wdXNoKEspLEIucHVzaChZKSxnYT1FKTooYS5wdXNoKChMW0VdLVQrZmEqWCkvZmEpLEIucHVzaCgoTFtFXS1UK2lhKlYpL2lhKSk7ZWxzZSBmb3IoRT0wO0U8SS5sZW5ndGg7RSsrKUxbRV08YWE/KGEucHVzaCgoTFtFXS1UK2ZhKlgpL2ZhKSxCLnB1c2goKExbRV0tVCtpYSpWKS9pYSksZ2E9RSk6KGEucHVzaChLKSxCLnB1c2goWSkpO2ZvcihFPTA7RTxJLmxlbmd0aC0xO0UrKylXPXUucmV2ZXJzZWQ/eFt4Lmxlbmd0aC0xLUVdLmNvbG9yP3hbeC5sZW5ndGgtMS1FXS5jb2xvcjp1Ll9jb2xvclNldFsoeC5sZW5ndGgtMS1FKSV1Ll9jb2xvclNldC5sZW5ndGhdOnhbRV0uY29sb3I/eFtFXS5jb2xvcjp1Ll9jb2xvclNldFtFJXUuX2NvbG9yU2V0Lmxlbmd0aF0sRT09PWdhP00ucHVzaCh7eDE6YVtFXSx5MTpMW0VdLHgyOkJbRV0seTI6TFtFXSxcclxueDM6WSx5MzphYSx4NDpCW0UrMV0seTQ6TFtFKzFdLHg1OmFbRSsxXSx5NTpMW0UrMV0seDY6Syx5NjphYSxpZDpFLGhlaWdodDpMW0UrMV0tTFtFXSxjb2xvcjpXfSk6TS5wdXNoKHt4MTphW0VdLHkxOkxbRV0seDI6QltFXSx5MjpMW0VdLHgzOkJbRSsxXSx5MzpMW0UrMV0seDQ6YVtFKzFdLHk0OkxbRSsxXSxpZDpFLGhlaWdodDpMW0UrMV0tTFtFXSxjb2xvcjpXfSk7dmFyIGhhPTIsRj1bXSxqYT0hMSxtYT1bXSxrYT1bXSxJPSExO2E9YT0wO0RhKG1hKTtmb3IoRT0wO0U8eC5sZW5ndGg7RSsrKXhbRV0uZXhwbG9kZWQmJihJPSEwLHUucmV2ZXJzZWQ/bWEucHVzaCh4Lmxlbmd0aC0xLUUpOm1hLnB1c2goRSkpO1IuY2xlYXJSZWN0KHoueDEsei55MSx6LndpZHRoLHouaGVpZ2h0KTtSLmZpbGxTdHlsZT1zLmJhY2tncm91bmRDb2xvcjtSLmZpbGxSZWN0KHoueDEsei55MSx6LndpZHRoLHouaGVpZ2h0KTtpZihKJiZ1LnZpc2libGUmJihjKCksZygpLGUoKSxcImluc2lkZVwiIT09dS5pbmRleExhYmVsUGxhY2VtZW50KSl7aCgpO1xyXG5mb3IoRT0wO0U8eC5sZW5ndGg7RSsrKUZbRV0uaXNEaXJ0eXx8KGE9RltFXS50ZXh0QmxvY2sueCtGW0VdLndpZHRoLGE9KFAtYSkvMiwwPT1FJiYoQT1hKSxBPmEmJihBPWEpKTtmb3IoRT0wO0U8TS5sZW5ndGg7RSsrKU1bRV0ueDErPUEsTVtFXS54Mis9QSxNW0VdLngzKz1BLE1bRV0ueDQrPUEsTVtFXS54NSYmKE1bRV0ueDUrPUEsTVtFXS54Nis9QSksRltFXS50ZXh0QmxvY2sueCs9QX1mb3IoRT0wO0U8TS5sZW5ndGg7RSsrKUE9TVtFXSxzYShSLEEsdS5maWxsT3BhY2l0eSksa2EucHVzaChBLnkxKTtxKFIpO0omJnUudmlzaWJsZSYmKFwiaW5zaWRlXCI9PT11LmluZGV4TGFiZWxQbGFjZW1lbnR8fHMuYW5pbWF0aW9uRW5hYmxlZHx8cihSKSxzLmFuaW1hdGlvbkVuYWJsZWR8fG0oKSk7aWYoIUopZm9yKEU9MDtFPHgubGVuZ3RoO0UrKylBPXUuZGF0YVBvaW50SWRzW0VdLGE9e2lkOkEsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFQb2ludEluZGV4OkUsZGF0YVNlcmllc0luZGV4OjAsXHJcbmZ1bm5lbFNlY3Rpb246TVt1LnJldmVyc2VkP3gubGVuZ3RoLTEtRTpFXX0scy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtBXT1hOyFzLmFuaW1hdGlvbkVuYWJsZWQmJkk/dChzLC0xLDApOnMuYW5pbWF0aW9uRW5hYmxlZCYmIXMuYW5pbWF0ZWRSZW5kZXImJnQocywtMSwwKTt0aGlzLmZ1bm5lbFB5cmFtaWRDbGlja0hhbmRsZXI9ZnVuY3Rpb24oYSl7dmFyIGI9LTE7aWYoIWphJiYhcy5pc0FuaW1hdGluZyYmKHkoYS5kYXRhU2VyaWVzLmV4cGxvZGVPbkNsaWNrKXx8YS5kYXRhU2VyaWVzLmV4cGxvZGVPbkNsaWNrKSYmKGI9dS5yZXZlcnNlZD94Lmxlbmd0aC0xLWEuZGF0YVBvaW50SW5kZXg6YS5kYXRhUG9pbnRJbmRleCwwPD1iKSl7YT1iO2lmKFwiZnVubmVsXCI9PT11LnR5cGV8fFwicHlyYW1pZFwiPT09dS50eXBlKXUucmV2ZXJzZWQ/eFt4Lmxlbmd0aC0xLWFdLmV4cGxvZGVkPXhbeC5sZW5ndGgtMS1hXS5leHBsb2RlZD8hMTohMDp4W2FdLmV4cGxvZGVkPXhbYV0uZXhwbG9kZWQ/XHJcbiExOiEwO3QocyxiLDUwMCl9fTtyZXR1cm57c291cmNlOlIsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpmdW5jdGlvbihhLGIpe0guZmFkZUluQW5pbWF0aW9uKGEsYik7MTw9YSYmKHQocywtMSw1MDApLHEocy5wbG90QXJlYS5jdHh8fHMuY3R4KSl9LGVhc2luZ0Z1bmN0aW9uOkguZWFzaW5nLmVhc2VJblF1YWQsYW5pbWF0aW9uQmFzZTowfX19fX07cS5wcm90b3R5cGUuYW5pbWF0aW9uUmVxdWVzdElkPW51bGw7cS5wcm90b3R5cGUucmVxdWVzdEFuaW1GcmFtZT1mdW5jdGlvbigpe3JldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbihhKXt3aW5kb3cuc2V0VGltZW91dChhLDFFMy82MCl9fSgpO1xyXG5xLnByb3RvdHlwZS5jYW5jZWxSZXF1ZXN0QW5pbUZyYW1lPXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1vekNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm9DYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZXx8Y2xlYXJUaW1lb3V0O3EucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGYsYil7Yj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI/ITA6YjtcIm9wdGlvbnNcIj09PWE/KHRoaXMub3B0aW9ucz1mLGImJnRoaXMucmVuZGVyKCkpOnEuYmFzZS5zZXQuY2FsbCh0aGlzLGEsZixiKX07cS5wcm90b3R5cGUuZXhwb3J0Q2hhcnQ9ZnVuY3Rpb24oYSl7YT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/e306YTt2YXIgZj1hLmZvcm1hdD9hLmZvcm1hdDpcInBuZ1wiLGI9YS5maWxlTmFtZT9hLmZpbGVOYW1lOnRoaXMuZXhwb3J0RmlsZU5hbWU7XHJcbmlmKGEudG9EYXRhVVJMKXJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9cIitmKTtzKHRoaXMuY2FudmFzLGYsYil9O3EucHJvdG90eXBlLnByaW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5leHBvcnRDaGFydCh7dG9EYXRhVVJMOiEwfSksZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO2Yuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixcImNhbnZhc2pzLWNoYXJ0LXByaW50LWZyYW1lXCIpO2Yuc2V0QXR0cmlidXRlKFwic3R5bGVcIixcInBvc2l0aW9uOmFic29sdXRlOyB3aWR0aDoxMDAlOyBib3JkZXI6IDBweDsgbWFyZ2luOiAwcHggMHB4IDBweCAwcHg7IHBhZGRpbmcgMHB4IDBweCAwcHggMHB4O1wiKTtmLnN0eWxlLmhlaWdodD10aGlzLmhlaWdodCtcInB4XCI7dGhpcy5fY2FudmFzSlNDb250YWluZXIuYXBwZW5kQ2hpbGQoZik7dmFyIGI9dGhpcyxjPWYuY29udGVudFdpbmRvd3x8Zi5jb250ZW50RG9jdW1lbnQuZG9jdW1lbnR8fGYuY29udGVudERvY3VtZW50O2MuZG9jdW1lbnQub3BlbigpO1xyXG5jLmRvY3VtZW50LndyaXRlKCc8IURPQ1RZUEUgSFRNTD5cXG48aHRtbD48Ym9keSBzdHlsZT1cIm1hcmdpbjogMHB4IDBweCAwcHggMHB4OyBwYWRkaW5nOiAwcHggMHB4IDBweCAwcHg7XCI+PGltZyBzcmM9XCInK2ErJ1wiLz48Ym9keS8+PC9odG1sPicpO2MuZG9jdW1lbnQuY2xvc2UoKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5mb2N1cygpO2MucHJpbnQoKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5fY2FudmFzSlNDb250YWluZXIucmVtb3ZlQ2hpbGQoZil9LDFFMyl9LDUwMCl9O3EucHJvdG90eXBlLmdldFBlcmNlbnRBbmRUb3RhbD1mdW5jdGlvbihhLGYpe3ZhciBiPW51bGwsYz1udWxsLGU9bnVsbDtpZigwPD1hLnR5cGUuaW5kZXhPZihcInN0YWNrZWRcIikpYz0wLGI9Zi54LmdldFRpbWU/Zi54LmdldFRpbWUoKTpmLngsYiBpbiBhLnBsb3RVbml0LnlUb3RhbHMmJihjPWEucGxvdFVuaXQueVRvdGFsc1tiXSxlPWlzTmFOKGYueSk/MDoxMDAqKGYueS9jKSk7ZWxzZSBpZihcInBpZVwiPT09XHJcbmEudHlwZXx8XCJkb3VnaG51dFwiPT09YS50eXBlfHxcImZ1bm5lbFwiPT09YS50eXBlfHxcInB5cmFtaWRcIj09PWEudHlwZSl7Zm9yKGk9Yz0wO2k8YS5kYXRhUG9pbnRzLmxlbmd0aDtpKyspaXNOYU4oYS5kYXRhUG9pbnRzW2ldLnkpfHwoYys9YS5kYXRhUG9pbnRzW2ldLnkpO2U9aXNOYU4oZi55KT8wOjEwMCooZi55L2MpfXJldHVybntwZXJjZW50OmUsdG90YWw6Y319O3EucHJvdG90eXBlLnJlcGxhY2VLZXl3b3Jkc1dpdGhWYWx1ZT1mdW5jdGlvbihhLGYsYixjLGUpe3ZhciBnPXRoaXM7ZT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGU/MDplO2lmKCgwPD1iLnR5cGUuaW5kZXhPZihcInN0YWNrZWRcIil8fFwicGllXCI9PT1iLnR5cGV8fFwiZG91Z2hudXRcIj09PWIudHlwZXx8XCJmdW5uZWxcIj09PWIudHlwZXx8XCJweXJhbWlkXCI9PT1iLnR5cGUpJiYoMDw9YS5pbmRleE9mKFwiI3BlcmNlbnRcIil8fDA8PWEuaW5kZXhPZihcIiN0b3RhbFwiKSkpe3ZhciBoPVwiI3BlcmNlbnRcIixsPVwiI3RvdGFsXCIsdD10aGlzLmdldFBlcmNlbnRBbmRUb3RhbChiLFxyXG5mKSxsPWlzTmFOKHQudG90YWwpP2w6dC50b3RhbCxoPWlzTmFOKHQucGVyY2VudCk/aDp0LnBlcmNlbnQ7ZG97dD1cIlwiO2lmKGIucGVyY2VudEZvcm1hdFN0cmluZyl0PWIucGVyY2VudEZvcm1hdFN0cmluZztlbHNle3ZhciB0PVwiIywjIzAuXCIsaz1NYXRoLm1heChNYXRoLmNlaWwoTWF0aC5sb2coMS9NYXRoLmFicyhoKSkvTWF0aC5MTjEwKSwyKTtpZihpc05hTihrKXx8IWlzRmluaXRlKGspKWs9Mjtmb3IodmFyIHI9MDtyPGs7cisrKXQrPVwiI1wiO2IucGVyY2VudEZvcm1hdFN0cmluZz10fWE9YS5yZXBsYWNlKFwiI3BlcmNlbnRcIixXKGgsdCxnLl9jdWx0dXJlSW5mbykpO2E9YS5yZXBsYWNlKFwiI3RvdGFsXCIsVyhsLGIueVZhbHVlRm9ybWF0U3RyaW5nP2IueVZhbHVlRm9ybWF0U3RyaW5nOlwiIywjIzAuIyMjIyMjIyNcIixnLl9jdWx0dXJlSW5mbykpfXdoaWxlKDA8PWEuaW5kZXhPZihcIiNwZXJjZW50XCIpfHwwPD1hLmluZGV4T2YoXCIjdG90YWxcIikpfXJldHVybiBhLnJlcGxhY2UoL1xcey4qP1xcfXxcIlteXCJdKlwifCdbXiddKicvZyxcclxuZnVuY3Rpb24oYSl7aWYoJ1wiJz09PWFbMF0mJidcIic9PT1hW2EubGVuZ3RoLTFdfHxcIidcIj09PWFbMF0mJlwiJ1wiPT09YVthLmxlbmd0aC0xXSlyZXR1cm4gYS5zbGljZSgxLGEubGVuZ3RoLTEpO2E9R2EoYS5zbGljZSgxLGEubGVuZ3RoLTEpKTthPWEucmVwbGFjZShcIiNpbmRleFwiLGUpO3ZhciBoPW51bGw7dHJ5e3ZhciBkPWEubWF0Y2goLyguKj8pXFxzKlxcW1xccyooLio/KVxccypcXF0vKTtkJiYwPGQubGVuZ3RoJiYoaD1HYShkWzJdKSxhPUdhKGRbMV0pKX1jYXRjaChrKXt9ZD1udWxsO2lmKFwiY29sb3JcIj09PWEpcmV0dXJuXCJ3YXRlcmZhbGxcIj09PWIudHlwZT9mLmNvbG9yP2YuY29sb3I6LTE8Zi55P2IucmlzaW5nQ29sb3I6Yi5mYWxsaW5nQ29sb3I6XCJlcnJvclwiPT09Yi50eXBlP2IuY29sb3I/Yi5jb2xvcjpiLl9jb2xvclNldFtoJWIuX2NvbG9yU2V0Lmxlbmd0aF06Zi5jb2xvcj9mLmNvbG9yOmIuY29sb3I/Yi5jb2xvcjpiLl9jb2xvclNldFtjJWIuX2NvbG9yU2V0Lmxlbmd0aF07aWYoZi5oYXNPd25Qcm9wZXJ0eShhKSlkPVxyXG5mO2Vsc2UgaWYoYi5oYXNPd25Qcm9wZXJ0eShhKSlkPWI7ZWxzZSByZXR1cm5cIlwiO2Q9ZFthXTtudWxsIT09aCYmKGQ9ZFtoXSk7aWYoXCJ4XCI9PT1hKWlmKFwiZGF0ZVRpbWVcIj09PWIuYXhpc1gudmFsdWVUeXBlfHxcImRhdGVUaW1lXCI9PT1iLnhWYWx1ZVR5cGV8fGYueCYmZi54LmdldFRpbWUpe2lmKGcucGxvdEluZm8ucGxvdFR5cGVzWzBdLnBsb3RVbml0c1swXS5heGlzWCYmIWcucGxvdEluZm8ucGxvdFR5cGVzWzBdLnBsb3RVbml0c1swXS5heGlzWC5sb2dhcml0aG1pYylyZXR1cm4gQmEoZCxmLnhWYWx1ZUZvcm1hdFN0cmluZz9mLnhWYWx1ZUZvcm1hdFN0cmluZzpiLnhWYWx1ZUZvcm1hdFN0cmluZz9iLnhWYWx1ZUZvcm1hdFN0cmluZzpiLnhWYWx1ZUZvcm1hdFN0cmluZz1nLmF4aXNYJiZnLmF4aXNYLmF1dG9WYWx1ZUZvcm1hdFN0cmluZz9nLmF4aXNYLmF1dG9WYWx1ZUZvcm1hdFN0cmluZzpcIkREIE1NTSBZWVwiLGcuX2N1bHR1cmVJbmZvKX1lbHNlIHJldHVybiBXKGQsZi54VmFsdWVGb3JtYXRTdHJpbmc/XHJcbmYueFZhbHVlRm9ybWF0U3RyaW5nOmIueFZhbHVlRm9ybWF0U3RyaW5nP2IueFZhbHVlRm9ybWF0U3RyaW5nOmIueFZhbHVlRm9ybWF0U3RyaW5nPVwiIywjIzAuIyMjIyMjIyNcIixnLl9jdWx0dXJlSW5mbyk7ZWxzZSByZXR1cm5cInlcIj09PWE/VyhkLGYueVZhbHVlRm9ybWF0U3RyaW5nP2YueVZhbHVlRm9ybWF0U3RyaW5nOmIueVZhbHVlRm9ybWF0U3RyaW5nP2IueVZhbHVlRm9ybWF0U3RyaW5nOmIueVZhbHVlRm9ybWF0U3RyaW5nPVwiIywjIzAuIyMjIyMjIyNcIixnLl9jdWx0dXJlSW5mbyk6XCJ6XCI9PT1hP1coZCxmLnpWYWx1ZUZvcm1hdFN0cmluZz9mLnpWYWx1ZUZvcm1hdFN0cmluZzpiLnpWYWx1ZUZvcm1hdFN0cmluZz9iLnpWYWx1ZUZvcm1hdFN0cmluZzpiLnpWYWx1ZUZvcm1hdFN0cmluZz1cIiMsIyMwLiMjIyMjIyMjXCIsZy5fY3VsdHVyZUluZm8pOmR9KX07cGEoVCxYKTtULnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmRvY2tJbnNpZGVQbG90QXJlYT9cclxudGhpcy5jaGFydC5wbG90QXJlYTp0aGlzLmNoYXJ0LGY9YS5sYXlvdXRNYW5hZ2VyLmdldEZyZWVTcGFjZSgpLGI9bnVsbCxjPTAsZT0wLGc9MCxoPTAsbD10aGlzLm1hcmtlck1hcmdpbj10aGlzLmNoYXJ0Lm9wdGlvbnMubGVnZW5kJiYheSh0aGlzLmNoYXJ0Lm9wdGlvbnMubGVnZW5kLm1hcmtlck1hcmdpbik/dGhpcy5jaGFydC5vcHRpb25zLmxlZ2VuZC5tYXJrZXJNYXJnaW46MC4zKnRoaXMuZm9udFNpemU7dGhpcy5oZWlnaHQ9MDt2YXIgdD1bXSxrPVtdO1widG9wXCI9PT10aGlzLnZlcnRpY2FsQWxpZ258fFwiYm90dG9tXCI9PT10aGlzLnZlcnRpY2FsQWxpZ24/KHRoaXMub3JpZW50YXRpb249XCJob3Jpem9udGFsXCIsYj10aGlzLnZlcnRpY2FsQWxpZ24sZz10aGlzLm1heFdpZHRoPW51bGwhPT10aGlzLm1heFdpZHRoP3RoaXMubWF4V2lkdGg6Zi53aWR0aCxoPXRoaXMubWF4SGVpZ2h0PW51bGwhPT10aGlzLm1heEhlaWdodD90aGlzLm1heEhlaWdodDowLjUqZi5oZWlnaHQpOlwiY2VudGVyXCI9PT1cclxudGhpcy52ZXJ0aWNhbEFsaWduJiYodGhpcy5vcmllbnRhdGlvbj1cInZlcnRpY2FsXCIsYj10aGlzLmhvcml6b250YWxBbGlnbixnPXRoaXMubWF4V2lkdGg9bnVsbCE9PXRoaXMubWF4V2lkdGg/dGhpcy5tYXhXaWR0aDowLjUqZi53aWR0aCxoPXRoaXMubWF4SGVpZ2h0PW51bGwhPT10aGlzLm1heEhlaWdodD90aGlzLm1heEhlaWdodDpmLmhlaWdodCk7Zm9yKHZhciByPVtdLHA9MDtwPHRoaXMuZGF0YVNlcmllcy5sZW5ndGg7cCsrKXt2YXIgbj10aGlzLmRhdGFTZXJpZXNbcF07aWYobi5kYXRhUG9pbnRzJiZuLmRhdGFQb2ludHMubGVuZ3RoKWlmKFwicGllXCIhPT1uLnR5cGUmJlwiZG91Z2hudXRcIiE9PW4udHlwZSYmXCJmdW5uZWxcIiE9PW4udHlwZSYmXCJweXJhbWlkXCIhPT1uLnR5cGUpe3ZhciBkPW4ubGVnZW5kTWFya2VyVHlwZT1uLmxlZ2VuZE1hcmtlclR5cGU/bi5sZWdlbmRNYXJrZXJUeXBlOlwibGluZVwiIT09bi50eXBlJiZcInN0ZXBMaW5lXCIhPT1uLnR5cGUmJlwic3BsaW5lXCIhPT1uLnR5cGUmJlxyXG5cInNjYXR0ZXJcIiE9PW4udHlwZSYmXCJidWJibGVcIiE9PW4udHlwZXx8IW4ubWFya2VyVHlwZT9cImVycm9yXCI9PT1uLnR5cGUmJm4uX2xpbmtlZFNlcmllcz9uLl9saW5rZWRTZXJpZXMubGVnZW5kTWFya2VyVHlwZT9uLl9saW5rZWRTZXJpZXMubGVnZW5kTWFya2VyVHlwZTpRLmdldERlZmF1bHRMZWdlbmRNYXJrZXIobi5fbGlua2VkU2VyaWVzLnR5cGUpOlEuZ2V0RGVmYXVsdExlZ2VuZE1hcmtlcihuLnR5cGUpOm4ubWFya2VyVHlwZSxtPW4ubGVnZW5kVGV4dD9uLmxlZ2VuZFRleHQ6dGhpcy5pdGVtVGV4dEZvcm1hdHRlcj90aGlzLml0ZW1UZXh0Rm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGxlZ2VuZDp0aGlzLm9wdGlvbnMsZGF0YVNlcmllczpuLGRhdGFQb2ludDpudWxsfSk6bi5uYW1lLHE9bi5sZWdlbmRNYXJrZXJDb2xvcj1uLmxlZ2VuZE1hcmtlckNvbG9yP24ubGVnZW5kTWFya2VyQ29sb3I6bi5tYXJrZXJDb2xvcj9uLm1hcmtlckNvbG9yOlwiZXJyb3JcIj09PW4udHlwZT9cclxueShuLndoaXNrZXJDb2xvcik/bi5fY29sb3JTZXRbMF06bi53aGlza2VyQ29sb3I6bi5fY29sb3JTZXRbMF0scz1uLm1hcmtlclNpemV8fFwibGluZVwiIT09bi50eXBlJiZcInN0ZXBMaW5lXCIhPT1uLnR5cGUmJlwic3BsaW5lXCIhPT1uLnR5cGU/MC43NSp0aGlzLmxpbmVIZWlnaHQ6MCx1PW4ubGVnZW5kTWFya2VyQm9yZGVyQ29sb3I/bi5sZWdlbmRNYXJrZXJCb3JkZXJDb2xvcjpuLm1hcmtlckJvcmRlckNvbG9yLHY9bi5sZWdlbmRNYXJrZXJCb3JkZXJUaGlja25lc3M/bi5sZWdlbmRNYXJrZXJCb3JkZXJUaGlja25lc3M6bi5tYXJrZXJCb3JkZXJUaGlja25lc3M/TWF0aC5tYXgoMSxNYXRoLnJvdW5kKDAuMipzKSk6MDtcImVycm9yXCI9PT1uLnR5cGUmJnIucHVzaChxKTttPXRoaXMuY2hhcnQucmVwbGFjZUtleXdvcmRzV2l0aFZhbHVlKG0sbi5kYXRhUG9pbnRzWzBdLG4scCk7ZD17bWFya2VyVHlwZTpkLG1hcmtlckNvbG9yOnEsdGV4dDptLHRleHRCbG9jazpudWxsLGNoYXJ0VHlwZTpuLnR5cGUsXHJcbm1hcmtlclNpemU6cyxsaW5lQ29sb3I6bi5fY29sb3JTZXRbMF0sZGF0YVNlcmllc0luZGV4Om4uaW5kZXgsZGF0YVBvaW50SW5kZXg6bnVsbCxtYXJrZXJCb3JkZXJDb2xvcjp1LG1hcmtlckJvcmRlclRoaWNrbmVzczp2fTt0LnB1c2goZCl9ZWxzZSBmb3IodmFyIHg9MDt4PG4uZGF0YVBvaW50cy5sZW5ndGg7eCsrKXt2YXIgej1uLmRhdGFQb2ludHNbeF0sZD16LmxlZ2VuZE1hcmtlclR5cGU/ei5sZWdlbmRNYXJrZXJUeXBlOm4ubGVnZW5kTWFya2VyVHlwZT9uLmxlZ2VuZE1hcmtlclR5cGU6US5nZXREZWZhdWx0TGVnZW5kTWFya2VyKG4udHlwZSksbT16LmxlZ2VuZFRleHQ/ei5sZWdlbmRUZXh0Om4ubGVnZW5kVGV4dD9uLmxlZ2VuZFRleHQ6dGhpcy5pdGVtVGV4dEZvcm1hdHRlcj90aGlzLml0ZW1UZXh0Rm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGxlZ2VuZDp0aGlzLm9wdGlvbnMsZGF0YVNlcmllczpuLGRhdGFQb2ludDp6fSk6ei5uYW1lP3oubmFtZTpcIkRhdGFQb2ludDogXCIrXHJcbih4KzEpLHE9ei5sZWdlbmRNYXJrZXJDb2xvcj96LmxlZ2VuZE1hcmtlckNvbG9yOm4ubGVnZW5kTWFya2VyQ29sb3I/bi5sZWdlbmRNYXJrZXJDb2xvcjp6LmNvbG9yP3ouY29sb3I6bi5jb2xvcj9uLmNvbG9yOm4uX2NvbG9yU2V0W3glbi5fY29sb3JTZXQubGVuZ3RoXSxzPTAuNzUqdGhpcy5saW5lSGVpZ2h0LHU9ei5sZWdlbmRNYXJrZXJCb3JkZXJDb2xvcj96LmxlZ2VuZE1hcmtlckJvcmRlckNvbG9yOm4ubGVnZW5kTWFya2VyQm9yZGVyQ29sb3I/bi5sZWdlbmRNYXJrZXJCb3JkZXJDb2xvcjp6Lm1hcmtlckJvcmRlckNvbG9yP3oubWFya2VyQm9yZGVyQ29sb3I6bi5tYXJrZXJCb3JkZXJDb2xvcix2PXoubGVnZW5kTWFya2VyQm9yZGVyVGhpY2tuZXNzP3oubGVnZW5kTWFya2VyQm9yZGVyVGhpY2tuZXNzOm4ubGVnZW5kTWFya2VyQm9yZGVyVGhpY2tuZXNzP24ubGVnZW5kTWFya2VyQm9yZGVyVGhpY2tuZXNzOnoubWFya2VyQm9yZGVyVGhpY2tuZXNzfHxuLm1hcmtlckJvcmRlclRoaWNrbmVzcz9cclxuTWF0aC5tYXgoMSxNYXRoLnJvdW5kKDAuMipzKSk6MCxtPXRoaXMuY2hhcnQucmVwbGFjZUtleXdvcmRzV2l0aFZhbHVlKG0seixuLHgpLGQ9e21hcmtlclR5cGU6ZCxtYXJrZXJDb2xvcjpxLHRleHQ6bSx0ZXh0QmxvY2s6bnVsbCxjaGFydFR5cGU6bi50eXBlLG1hcmtlclNpemU6cyxkYXRhU2VyaWVzSW5kZXg6cCxkYXRhUG9pbnRJbmRleDp4LG1hcmtlckJvcmRlckNvbG9yOnUsbWFya2VyQm9yZGVyVGhpY2tuZXNzOnZ9Oyh6LnNob3dJbkxlZ2VuZHx8bi5zaG93SW5MZWdlbmQmJiExIT09ei5zaG93SW5MZWdlbmQpJiZ0LnB1c2goZCl9fSEwPT09dGhpcy5yZXZlcnNlZCYmdC5yZXZlcnNlKCk7aWYoMDx0Lmxlbmd0aCl7bj1udWxsO209eD16PXY9MDt6PW51bGwhPT10aGlzLml0ZW1XaWR0aD9udWxsIT09dGhpcy5pdGVtTWF4V2lkdGg/TWF0aC5taW4odGhpcy5pdGVtV2lkdGgsdGhpcy5pdGVtTWF4V2lkdGgsZyk6dGhpcy5pdGVtTWF4V2lkdGg9TWF0aC5taW4odGhpcy5pdGVtV2lkdGgsXHJcbmcpOm51bGwhPT10aGlzLml0ZW1NYXhXaWR0aD9NYXRoLm1pbih0aGlzLml0ZW1NYXhXaWR0aCxnKTp0aGlzLml0ZW1NYXhXaWR0aD1nO3M9MD09PXM/MC43NSp0aGlzLmxpbmVIZWlnaHQ6czt6LT1zK2w7Zm9yKHA9MDtwPHQubGVuZ3RoO3ArKyl7ZD10W3BdO3E9ejtpZihcImxpbmVcIj09PWQuY2hhcnRUeXBlfHxcInNwbGluZVwiPT09ZC5jaGFydFR5cGV8fFwic3RlcExpbmVcIj09PWQuY2hhcnRUeXBlKXEtPTIqMC4xKnRoaXMubGluZUhlaWdodDtpZighKDA+PWh8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgaHx8MD49cXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBxKSl7aWYoXCJob3Jpem9udGFsXCI9PT10aGlzLm9yaWVudGF0aW9uKXtkLnRleHRCbG9jaz1uZXcgbGEodGhpcy5jdHgse3g6MCx5OjAsbWF4V2lkdGg6cSxtYXhIZWlnaHQ6dGhpcy5pdGVtV3JhcD9oOnRoaXMubGluZUhlaWdodCxhbmdsZTowLHRleHQ6ZC50ZXh0LGhvcml6b250YWxBbGlnbjpcImxlZnRcIixmb250U2l6ZTp0aGlzLmZvbnRTaXplLFxyXG5mb250RmFtaWx5OnRoaXMuZm9udEZhbWlseSxmb250V2VpZ2h0OnRoaXMuZm9udFdlaWdodCxmb250Q29sb3I6dGhpcy5mb250Q29sb3IsZm9udFN0eWxlOnRoaXMuZm9udFN0eWxlLHRleHRCYXNlbGluZTpcIm1pZGRsZVwifSk7ZC50ZXh0QmxvY2subWVhc3VyZVRleHQoKTtudWxsIT09dGhpcy5pdGVtV2lkdGgmJihkLnRleHRCbG9jay53aWR0aD10aGlzLml0ZW1XaWR0aC0ocytsKyhcImxpbmVcIj09PWQuY2hhcnRUeXBlfHxcInNwbGluZVwiPT09ZC5jaGFydFR5cGV8fFwic3RlcExpbmVcIj09PWQuY2hhcnRUeXBlPzIqMC4xKnRoaXMubGluZUhlaWdodDowKSkpO2lmKCFufHxuLndpZHRoK01hdGgucm91bmQoZC50ZXh0QmxvY2sud2lkdGgrcytsKygwPT09bi53aWR0aD8wOnRoaXMuaG9yaXpvbnRhbFNwYWNpbmcpKyhcImxpbmVcIj09PWQuY2hhcnRUeXBlfHxcInNwbGluZVwiPT09ZC5jaGFydFR5cGV8fFwic3RlcExpbmVcIj09PWQuY2hhcnRUeXBlPzIqMC4xKnRoaXMubGluZUhlaWdodDowKSk+ZyluPVxyXG57aXRlbXM6W10sd2lkdGg6MH0say5wdXNoKG4pLHRoaXMuaGVpZ2h0Kz14LHg9MDt4PU1hdGgubWF4KHgsZC50ZXh0QmxvY2suaGVpZ2h0KX1lbHNlIGQudGV4dEJsb2NrPW5ldyBsYSh0aGlzLmN0eCx7eDowLHk6MCxtYXhXaWR0aDp6LG1heEhlaWdodDohMD09PXRoaXMuaXRlbVdyYXA/aDoxLjUqdGhpcy5mb250U2l6ZSxhbmdsZTowLHRleHQ6ZC50ZXh0LGhvcml6b250YWxBbGlnbjpcImxlZnRcIixmb250U2l6ZTp0aGlzLmZvbnRTaXplLGZvbnRGYW1pbHk6dGhpcy5mb250RmFtaWx5LGZvbnRXZWlnaHQ6dGhpcy5mb250V2VpZ2h0LGZvbnRDb2xvcjp0aGlzLmZvbnRDb2xvcixmb250U3R5bGU6dGhpcy5mb250U3R5bGUsdGV4dEJhc2VsaW5lOlwibWlkZGxlXCJ9KSxkLnRleHRCbG9jay5tZWFzdXJlVGV4dCgpLG51bGwhPT10aGlzLml0ZW1XaWR0aCYmKGQudGV4dEJsb2NrLndpZHRoPXRoaXMuaXRlbVdpZHRoLShzK2wrKFwibGluZVwiPT09ZC5jaGFydFR5cGV8fFwic3BsaW5lXCI9PT1kLmNoYXJ0VHlwZXx8XHJcblwic3RlcExpbmVcIj09PWQuY2hhcnRUeXBlPzIqMC4xKnRoaXMubGluZUhlaWdodDowKSkpLHRoaXMuaGVpZ2h0PGgtdGhpcy5saW5lSGVpZ2h0PyhuPXtpdGVtczpbXSx3aWR0aDowfSxrLnB1c2gobikpOihuPWtbdl0sdj0odisxKSVrLmxlbmd0aCksdGhpcy5oZWlnaHQrPWQudGV4dEJsb2NrLmhlaWdodDtkLnRleHRCbG9jay54PW4ud2lkdGg7ZC50ZXh0QmxvY2sueT0wO24ud2lkdGgrPU1hdGgucm91bmQoZC50ZXh0QmxvY2sud2lkdGgrcytsKygwPT09bi53aWR0aD8wOnRoaXMuaG9yaXpvbnRhbFNwYWNpbmcpKyhcImxpbmVcIj09PWQuY2hhcnRUeXBlfHxcInNwbGluZVwiPT09ZC5jaGFydFR5cGV8fFwic3RlcExpbmVcIj09PWQuY2hhcnRUeXBlPzIqMC4xKnRoaXMubGluZUhlaWdodDowKSk7bi5pdGVtcy5wdXNoKGQpO3RoaXMud2lkdGg9TWF0aC5tYXgobi53aWR0aCx0aGlzLndpZHRoKTttPWQudGV4dEJsb2NrLndpZHRoKyhzK2wrKFwibGluZVwiPT09ZC5jaGFydFR5cGV8fFwic3BsaW5lXCI9PT1cclxuZC5jaGFydFR5cGV8fFwic3RlcExpbmVcIj09PWQuY2hhcnRUeXBlPzIqMC4xKnRoaXMubGluZUhlaWdodDowKSl9fXRoaXMuaXRlbVdpZHRoPW07dGhpcy5oZWlnaHQ9ITE9PT10aGlzLml0ZW1XcmFwP2subGVuZ3RoKnRoaXMubGluZUhlaWdodDp0aGlzLmhlaWdodCt4O3RoaXMuaGVpZ2h0PU1hdGgubWluKGgsdGhpcy5oZWlnaHQpO3RoaXMud2lkdGg9TWF0aC5taW4oZyx0aGlzLndpZHRoKX1cInRvcFwiPT09dGhpcy52ZXJ0aWNhbEFsaWduPyhlPVwibGVmdFwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ24/Zi54MTpcInJpZ2h0XCI9PT10aGlzLmhvcml6b250YWxBbGlnbj9mLngyLXRoaXMud2lkdGg6Zi54MStmLndpZHRoLzItdGhpcy53aWR0aC8yLGM9Zi55MSk6XCJjZW50ZXJcIj09PXRoaXMudmVydGljYWxBbGlnbj8oZT1cImxlZnRcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWduP2YueDE6XCJyaWdodFwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ24/Zi54Mi10aGlzLndpZHRoOmYueDErZi53aWR0aC8yLXRoaXMud2lkdGgvXHJcbjIsYz1mLnkxK2YuaGVpZ2h0LzItdGhpcy5oZWlnaHQvMik6XCJib3R0b21cIj09PXRoaXMudmVydGljYWxBbGlnbiYmKGU9XCJsZWZ0XCI9PT10aGlzLmhvcml6b250YWxBbGlnbj9mLngxOlwicmlnaHRcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWduP2YueDItdGhpcy53aWR0aDpmLngxK2Yud2lkdGgvMi10aGlzLndpZHRoLzIsYz1mLnkyLXRoaXMuaGVpZ2h0KTt0aGlzLml0ZW1zPXQ7Zm9yKHA9MDtwPHRoaXMuaXRlbXMubGVuZ3RoO3ArKylkPXRbcF0sZC5pZD0rK3RoaXMuY2hhcnQuX2V2ZW50TWFuYWdlci5sYXN0T2JqZWN0SWQsdGhpcy5jaGFydC5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtkLmlkXT17aWQ6ZC5pZCxvYmplY3RUeXBlOlwibGVnZW5kSXRlbVwiLGxlZ2VuZEl0ZW1JbmRleDpwLGRhdGFTZXJpZXNJbmRleDpkLmRhdGFTZXJpZXNJbmRleCxkYXRhUG9pbnRJbmRleDpkLmRhdGFQb2ludEluZGV4fTsoMDx0aGlzLmJvcmRlclRoaWNrbmVzcyYmdGhpcy5ib3JkZXJDb2xvcnx8dGhpcy5iYWNrZ3JvdW5kQ29sb3IpJiZcclxudGhpcy5jdHgucm91bmRSZWN0KGUsYyx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0LHRoaXMuY29ybmVyUmFkaXVzLHRoaXMuYm9yZGVyVGhpY2tuZXNzLHRoaXMuYmFja2dyb3VuZENvbG9yLHRoaXMuYm9yZGVyQ29sb3IpO2ZvcihwPWY9MDtwPGsubGVuZ3RoO3ArKyl7bj1rW3BdO2Zvcih6PXg9MDt6PG4uaXRlbXMubGVuZ3RoO3orKyl7ZD1uLml0ZW1zW3pdO3E9ZC50ZXh0QmxvY2sueCtlKygwPT09ej8wLjIqczp0aGlzLmhvcml6b250YWxTcGFjaW5nKTt1PWMrZjttPXE7dGhpcy5jaGFydC5kYXRhW2QuZGF0YVNlcmllc0luZGV4XS52aXNpYmxlfHwodGhpcy5jdHguZ2xvYmFsQWxwaGE9MC41KTt0aGlzLmN0eC5zYXZlKCk7dGhpcy5jdHguYmVnaW5QYXRoKCk7dGhpcy5jdHgucmVjdChlLGMsZyxNYXRoLm1heChoLWgldGhpcy5saW5lSGVpZ2h0LDApKTt0aGlzLmN0eC5jbGlwKCk7aWYoXCJsaW5lXCI9PT1kLmNoYXJ0VHlwZXx8XCJzdGVwTGluZVwiPT09ZC5jaGFydFR5cGV8fFwic3BsaW5lXCI9PT1cclxuZC5jaGFydFR5cGUpdGhpcy5jdHguc3Ryb2tlU3R5bGU9ZC5saW5lQ29sb3IsdGhpcy5jdHgubGluZVdpZHRoPU1hdGguY2VpbCh0aGlzLmxpbmVIZWlnaHQvOCksdGhpcy5jdHguYmVnaW5QYXRoKCksdGhpcy5jdHgubW92ZVRvKHEtMC4xKnRoaXMubGluZUhlaWdodCx1K3RoaXMubGluZUhlaWdodC8yKSx0aGlzLmN0eC5saW5lVG8ocSswLjg1KnRoaXMubGluZUhlaWdodCx1K3RoaXMubGluZUhlaWdodC8yKSx0aGlzLmN0eC5zdHJva2UoKSxtLT0wLjEqdGhpcy5saW5lSGVpZ2h0O2lmKFwiZXJyb3JcIj09PWQuY2hhcnRUeXBlKXt0aGlzLmN0eC5zdHJva2VTdHlsZT1yWzBdO3Y9cy84O3RoaXMuY3R4LmxpbmVXaWR0aD12O3RoaXMuY3R4LmJlZ2luUGF0aCgpO3ZhciB2PXEtMC4wOCp0aGlzLmxpbmVIZWlnaHQrMC4xKnRoaXMubGluZUhlaWdodCxCPXUrMC4xNSp0aGlzLmxpbmVIZWlnaHQsQT0wLjcqdGhpcy5saW5lSGVpZ2h0LEM9QSswLjAyKnRoaXMubGluZUhlaWdodDt0aGlzLmN0eC5tb3ZlVG8odixcclxuQik7dGhpcy5jdHgubGluZVRvKHYrQSxCKTt0aGlzLmN0eC5zdHJva2UoKTt0aGlzLmN0eC5iZWdpblBhdGgoKTt0aGlzLmN0eC5tb3ZlVG8oditBLzIsQik7dGhpcy5jdHgubGluZVRvKHYrQS8yLEIrQyk7dGhpcy5jdHguc3Ryb2tlKCk7dGhpcy5jdHguYmVnaW5QYXRoKCk7dGhpcy5jdHgubW92ZVRvKHYsQitDKTt0aGlzLmN0eC5saW5lVG8oditBLEIrQyk7dGhpcy5jdHguc3Ryb2tlKCk7ci5zaGlmdCgpfWphLmRyYXdNYXJrZXIocStzLzIsdSt0aGlzLmxpbmVIZWlnaHQvMix0aGlzLmN0eCxkLm1hcmtlclR5cGUsXCJlcnJvclwiPT09ZC5jaGFydFR5cGV8fFwibGluZVwiPT09ZC5jaGFydFR5cGV8fFwic3BsaW5lXCI9PT1kLmNoYXJ0VHlwZT9kLm1hcmtlclNpemUvMjpkLm1hcmtlclNpemUsZC5tYXJrZXJDb2xvcixkLm1hcmtlckJvcmRlckNvbG9yLGQubWFya2VyQm9yZGVyVGhpY2tuZXNzKTtkLnRleHRCbG9jay54PXErbCtzO2lmKFwibGluZVwiPT09ZC5jaGFydFR5cGV8fFwic3RlcExpbmVcIj09PVxyXG5kLmNoYXJ0VHlwZXx8XCJzcGxpbmVcIj09PWQuY2hhcnRUeXBlKWQudGV4dEJsb2NrLngrPTAuMSp0aGlzLmxpbmVIZWlnaHQ7ZC50ZXh0QmxvY2sueT1NYXRoLnJvdW5kKHUrdGhpcy5saW5lSGVpZ2h0LzIpO2QudGV4dEJsb2NrLnJlbmRlcighMCk7dGhpcy5jdHgucmVzdG9yZSgpO3g9MDx6P01hdGgubWF4KHgsZC50ZXh0QmxvY2suaGVpZ2h0KTpkLnRleHRCbG9jay5oZWlnaHQ7dGhpcy5jaGFydC5kYXRhW2QuZGF0YVNlcmllc0luZGV4XS52aXNpYmxlfHwodGhpcy5jdHguZ2xvYmFsQWxwaGE9MSk7dj1SKGQuaWQpO3RoaXMuZ2hvc3RDdHguZmlsbFN0eWxlPXY7dGhpcy5naG9zdEN0eC5iZWdpblBhdGgoKTt0aGlzLmdob3N0Q3R4LmZpbGxSZWN0KG0sZC50ZXh0QmxvY2sueS10aGlzLmxpbmVIZWlnaHQvMixkLnRleHRCbG9jay54K2QudGV4dEJsb2NrLndpZHRoLW0sZC50ZXh0QmxvY2suaGVpZ2h0KTtkLngxPXRoaXMuY2hhcnQuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbZC5pZF0ueDE9XHJcbm07ZC55MT10aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2QuaWRdLnkxPWQudGV4dEJsb2NrLnktdGhpcy5saW5lSGVpZ2h0LzI7ZC54Mj10aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2QuaWRdLngyPWQudGV4dEJsb2NrLngrZC50ZXh0QmxvY2sud2lkdGg7ZC55Mj10aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2QuaWRdLnkyPWQudGV4dEJsb2NrLnkrZC50ZXh0QmxvY2suaGVpZ2h0LXRoaXMubGluZUhlaWdodC8yfWYrPXh9MDx0Lmxlbmd0aCYmYS5sYXlvdXRNYW5hZ2VyLnJlZ2lzdGVyU3BhY2UoYix7d2lkdGg6dGhpcy53aWR0aCsyKzIsaGVpZ2h0OnRoaXMuaGVpZ2h0KzUrNX0pO3RoaXMuYm91bmRzPXt4MTplLHkxOmMseDI6ZSt0aGlzLndpZHRoLHkyOmMrdGhpcy5oZWlnaHR9fTtwYShRLFgpO1EucHJvdG90eXBlLmdldERlZmF1bHRBeGlzUGxhY2VtZW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy50eXBlO2lmKFwiY29sdW1uXCI9PT1cclxuYXx8XCJsaW5lXCI9PT1hfHxcInN0ZXBMaW5lXCI9PT1hfHxcInNwbGluZVwiPT09YXx8XCJhcmVhXCI9PT1hfHxcInN0ZXBBcmVhXCI9PT1hfHxcInNwbGluZUFyZWFcIj09PWF8fFwic3RhY2tlZENvbHVtblwiPT09YXx8XCJzdGFja2VkTGluZVwiPT09YXx8XCJidWJibGVcIj09PWF8fFwic2NhdHRlclwiPT09YXx8XCJzdGFja2VkQXJlYVwiPT09YXx8XCJzdGFja2VkQ29sdW1uMTAwXCI9PT1hfHxcInN0YWNrZWRMaW5lMTAwXCI9PT1hfHxcInN0YWNrZWRBcmVhMTAwXCI9PT1hfHxcImNhbmRsZXN0aWNrXCI9PT1hfHxcIm9obGNcIj09PWF8fFwicmFuZ2VDb2x1bW5cIj09PWF8fFwicmFuZ2VBcmVhXCI9PT1hfHxcInJhbmdlU3BsaW5lQXJlYVwiPT09YXx8XCJib3hBbmRXaGlza2VyXCI9PT1hfHxcIndhdGVyZmFsbFwiPT09YSlyZXR1cm5cIm5vcm1hbFwiO2lmKFwiYmFyXCI9PT1hfHxcInN0YWNrZWRCYXJcIj09PWF8fFwic3RhY2tlZEJhcjEwMFwiPT09YXx8XCJyYW5nZUJhclwiPT09YSlyZXR1cm5cInh5U3dhcHBlZFwiO2lmKFwicGllXCI9PT1hfHxcImRvdWdobnV0XCI9PT1cclxuYXx8XCJmdW5uZWxcIj09PWF8fFwicHlyYW1pZFwiPT09YSlyZXR1cm5cIm5vbmVcIjtcImVycm9yXCIhPT1hJiZ3aW5kb3cuY29uc29sZS5sb2coXCJVbmtub3duIENoYXJ0IFR5cGU6IFwiK2EpO3JldHVybiBudWxsfTtRLmdldERlZmF1bHRMZWdlbmRNYXJrZXI9ZnVuY3Rpb24oYSl7aWYoXCJjb2x1bW5cIj09PWF8fFwic3RhY2tlZENvbHVtblwiPT09YXx8XCJzdGFja2VkTGluZVwiPT09YXx8XCJiYXJcIj09PWF8fFwic3RhY2tlZEJhclwiPT09YXx8XCJzdGFja2VkQmFyMTAwXCI9PT1hfHxcImJ1YmJsZVwiPT09YXx8XCJzY2F0dGVyXCI9PT1hfHxcInN0YWNrZWRDb2x1bW4xMDBcIj09PWF8fFwic3RhY2tlZExpbmUxMDBcIj09PWF8fFwic3RlcEFyZWFcIj09PWF8fFwiY2FuZGxlc3RpY2tcIj09PWF8fFwib2hsY1wiPT09YXx8XCJyYW5nZUNvbHVtblwiPT09YXx8XCJyYW5nZUJhclwiPT09YXx8XCJyYW5nZUFyZWFcIj09PWF8fFwicmFuZ2VTcGxpbmVBcmVhXCI9PT1hfHxcImJveEFuZFdoaXNrZXJcIj09PWF8fFwid2F0ZXJmYWxsXCI9PT1hKXJldHVyblwic3F1YXJlXCI7XHJcbmlmKFwibGluZVwiPT09YXx8XCJzdGVwTGluZVwiPT09YXx8XCJzcGxpbmVcIj09PWF8fFwicGllXCI9PT1hfHxcImRvdWdobnV0XCI9PT1hKXJldHVyblwiY2lyY2xlXCI7aWYoXCJhcmVhXCI9PT1hfHxcInNwbGluZUFyZWFcIj09PWF8fFwic3RhY2tlZEFyZWFcIj09PWF8fFwic3RhY2tlZEFyZWExMDBcIj09PWF8fFwiZnVubmVsXCI9PT1hfHxcInB5cmFtaWRcIj09PWEpcmV0dXJuXCJ0cmlhbmdsZVwiO2lmKFwiZXJyb3JcIj09PWEpcmV0dXJuXCJub25lXCI7d2luZG93LmNvbnNvbGUubG9nKFwiVW5rbm93biBDaGFydCBUeXBlOiBcIithKTtyZXR1cm4gbnVsbH07US5wcm90b3R5cGUuZ2V0RGF0YVBvaW50QXRYPWZ1bmN0aW9uKGEsZil7aWYoIXRoaXMuZGF0YVBvaW50c3x8MD09PXRoaXMuZGF0YVBvaW50cy5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIGI9e2RhdGFQb2ludDpudWxsLGRpc3RhbmNlOkluZmluaXR5LGluZGV4Ok5hTn0sYz1udWxsLGU9MCxnPTAsaD0xLGw9SW5maW5pdHksdD0wLGs9MCxyPTA7XCJub25lXCIhPT10aGlzLmNoYXJ0LnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQmJlxyXG4odGhpcy5heGlzWC5sb2dhcml0aG1pYz8ocj1NYXRoLmxvZyh0aGlzLmRhdGFQb2ludHNbdGhpcy5kYXRhUG9pbnRzLmxlbmd0aC0xXS54L3RoaXMuZGF0YVBvaW50c1swXS54KSxyPTE8cj9NYXRoLm1pbihNYXRoLm1heCgodGhpcy5kYXRhUG9pbnRzLmxlbmd0aC0xKS9yKk1hdGgubG9nKGEvdGhpcy5kYXRhUG9pbnRzWzBdLngpPj4wLDApLHRoaXMuZGF0YVBvaW50cy5sZW5ndGgpOjApOihyPXRoaXMuZGF0YVBvaW50c1t0aGlzLmRhdGFQb2ludHMubGVuZ3RoLTFdLngtdGhpcy5kYXRhUG9pbnRzWzBdLngscj0wPHI/TWF0aC5taW4oTWF0aC5tYXgoKHRoaXMuZGF0YVBvaW50cy5sZW5ndGgtMSkvciooYS10aGlzLmRhdGFQb2ludHNbMF0ueCk+PjAsMCksdGhpcy5kYXRhUG9pbnRzLmxlbmd0aCk6MCkpO2Zvcig7Oyl7Zz0wPGg/citlOnItZTtpZigwPD1nJiZnPHRoaXMuZGF0YVBvaW50cy5sZW5ndGgpe3ZhciBjPXRoaXMuZGF0YVBvaW50c1tnXSxwPXRoaXMuYXhpc1gubG9nYXJpdGhtaWM/XHJcbmMueD5hP2MueC9hOmEvYy54Ok1hdGguYWJzKGMueC1hKTtwPGIuZGlzdGFuY2UmJihiLmRhdGFQb2ludD1jLGIuZGlzdGFuY2U9cCxiLmluZGV4PWcpO2M9cDtjPD1sP2w9YzowPGg/dCsrOmsrKztpZigxRTM8dCYmMUUzPGspYnJlYWt9ZWxzZSBpZigwPnItZSYmcitlPj10aGlzLmRhdGFQb2ludHMubGVuZ3RoKWJyZWFrOy0xPT09aD8oZSsrLGg9MSk6aD0tMX1yZXR1cm4gZnx8Yi5kYXRhUG9pbnQueCE9PWE/ZiYmbnVsbCE9PWIuZGF0YVBvaW50P2I6bnVsbDpifTtRLnByb3RvdHlwZS5nZXREYXRhUG9pbnRBdFhZPWZ1bmN0aW9uKGEsZixiKXtpZighdGhpcy5kYXRhUG9pbnRzfHwwPT09dGhpcy5kYXRhUG9pbnRzLmxlbmd0aHx8YTx0aGlzLmNoYXJ0LnBsb3RBcmVhLngxfHxhPnRoaXMuY2hhcnQucGxvdEFyZWEueDJ8fGY8dGhpcy5jaGFydC5wbG90QXJlYS55MXx8Zj50aGlzLmNoYXJ0LnBsb3RBcmVhLnkyKXJldHVybiBudWxsO2I9Ynx8ITE7dmFyIGM9W10sZT0wLGc9MCxoPVxyXG4xLGw9ITEsdD1JbmZpbml0eSxrPTAscj0wLHA9MDtpZihcIm5vbmVcIiE9PXRoaXMuY2hhcnQucGxvdEluZm8uYXhpc1BsYWNlbWVudClpZihwPSh0aGlzLmNoYXJ0LmF4aXNYWzBdP3RoaXMuY2hhcnQuYXhpc1hbMF06dGhpcy5jaGFydC5heGlzWDJbMF0pLmdldFhWYWx1ZUF0KHt4OmEseTpmfSksdGhpcy5heGlzWC5sb2dhcml0aG1pYyl2YXIgbj1NYXRoLmxvZyh0aGlzLmRhdGFQb2ludHNbdGhpcy5kYXRhUG9pbnRzLmxlbmd0aC0xXS54L3RoaXMuZGF0YVBvaW50c1swXS54KSxwPTE8bj9NYXRoLm1pbihNYXRoLm1heCgodGhpcy5kYXRhUG9pbnRzLmxlbmd0aC0xKS9uKk1hdGgubG9nKHAvdGhpcy5kYXRhUG9pbnRzWzBdLngpPj4wLDApLHRoaXMuZGF0YVBvaW50cy5sZW5ndGgpOjA7ZWxzZSBuPXRoaXMuZGF0YVBvaW50c1t0aGlzLmRhdGFQb2ludHMubGVuZ3RoLTFdLngtdGhpcy5kYXRhUG9pbnRzWzBdLngscD0wPG4/TWF0aC5taW4oTWF0aC5tYXgoKHRoaXMuZGF0YVBvaW50cy5sZW5ndGgtXHJcbjEpL24qKHAtdGhpcy5kYXRhUG9pbnRzWzBdLngpPj4wLDApLHRoaXMuZGF0YVBvaW50cy5sZW5ndGgpOjA7Zm9yKDs7KXtnPTA8aD9wK2U6cC1lO2lmKDA8PWcmJmc8dGhpcy5kYXRhUG9pbnRzLmxlbmd0aCl7dmFyIG49dGhpcy5jaGFydC5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFt0aGlzLmRhdGFQb2ludElkc1tnXV0sZD10aGlzLmRhdGFQb2ludHNbZ10sbT1udWxsO2lmKG4pe3N3aXRjaCh0aGlzLnR5cGUpe2Nhc2UgXCJjb2x1bW5cIjpjYXNlIFwic3RhY2tlZENvbHVtblwiOmNhc2UgXCJzdGFja2VkQ29sdW1uMTAwXCI6Y2FzZSBcImJhclwiOmNhc2UgXCJzdGFja2VkQmFyXCI6Y2FzZSBcInN0YWNrZWRCYXIxMDBcIjpjYXNlIFwicmFuZ2VDb2x1bW5cIjpjYXNlIFwicmFuZ2VCYXJcIjpjYXNlIFwid2F0ZXJmYWxsXCI6Y2FzZSBcImVycm9yXCI6YT49bi54MSYmKGE8PW4ueDImJmY+PW4ueTEmJmY8PW4ueTIpJiYoYy5wdXNoKHtkYXRhUG9pbnQ6ZCxkYXRhUG9pbnRJbmRleDpnLGRhdGFTZXJpZXM6dGhpcyxkaXN0YW5jZTpNYXRoLm1pbihNYXRoLmFicyhuLngxLVxyXG5hKSxNYXRoLmFicyhuLngyLWEpLE1hdGguYWJzKG4ueTEtZiksTWF0aC5hYnMobi55Mi1mKSl9KSxsPSEwKTticmVhaztjYXNlIFwibGluZVwiOmNhc2UgXCJzdGVwTGluZVwiOmNhc2UgXCJzcGxpbmVcIjpjYXNlIFwiYXJlYVwiOmNhc2UgXCJzdGVwQXJlYVwiOmNhc2UgXCJzdGFja2VkQXJlYVwiOmNhc2UgXCJzdGFja2VkQXJlYTEwMFwiOmNhc2UgXCJzcGxpbmVBcmVhXCI6Y2FzZSBcInNjYXR0ZXJcIjp2YXIgcT1uYShcIm1hcmtlclNpemVcIixkLHRoaXMpfHw0LHM9Yj8yMDpxLG09TWF0aC5zcXJ0KE1hdGgucG93KG4ueDEtYSwyKStNYXRoLnBvdyhuLnkxLWYsMikpO208PXMmJmMucHVzaCh7ZGF0YVBvaW50OmQsZGF0YVBvaW50SW5kZXg6ZyxkYXRhU2VyaWVzOnRoaXMsZGlzdGFuY2U6bX0pO249TWF0aC5hYnMobi54MS1hKTtuPD10P3Q9bjowPGg/aysrOnIrKzttPD1xLzImJihsPSEwKTticmVhaztjYXNlIFwicmFuZ2VBcmVhXCI6Y2FzZSBcInJhbmdlU3BsaW5lQXJlYVwiOnE9bmEoXCJtYXJrZXJTaXplXCIsZCx0aGlzKXx8XHJcbjQ7cz1iPzIwOnE7bT1NYXRoLm1pbihNYXRoLnNxcnQoTWF0aC5wb3cobi54MS1hLDIpK01hdGgucG93KG4ueTEtZiwyKSksTWF0aC5zcXJ0KE1hdGgucG93KG4ueDEtYSwyKStNYXRoLnBvdyhuLnkyLWYsMikpKTttPD1zJiZjLnB1c2goe2RhdGFQb2ludDpkLGRhdGFQb2ludEluZGV4OmcsZGF0YVNlcmllczp0aGlzLGRpc3RhbmNlOm19KTtuPU1hdGguYWJzKG4ueDEtYSk7bjw9dD90PW46MDxoP2srKzpyKys7bTw9cS8yJiYobD0hMCk7YnJlYWs7Y2FzZSBcImJ1YmJsZVwiOnE9bi5zaXplO209TWF0aC5zcXJ0KE1hdGgucG93KG4ueDEtYSwyKStNYXRoLnBvdyhuLnkxLWYsMikpO208PXEvMiYmKGMucHVzaCh7ZGF0YVBvaW50OmQsZGF0YVBvaW50SW5kZXg6ZyxkYXRhU2VyaWVzOnRoaXMsZGlzdGFuY2U6bX0pLGw9ITApO2JyZWFrO2Nhc2UgXCJwaWVcIjpjYXNlIFwiZG91Z2hudXRcIjpxPW4uY2VudGVyO3M9XCJkb3VnaG51dFwiPT09dGhpcy50eXBlP24ucGVyY2VudElubmVyUmFkaXVzKm4ucmFkaXVzOlxyXG4wO209TWF0aC5zcXJ0KE1hdGgucG93KHEueC1hLDIpK01hdGgucG93KHEueS1mLDIpKTttPG4ucmFkaXVzJiZtPnMmJihtPU1hdGguYXRhbjIoZi1xLnksYS1xLngpLDA+bSYmKG0rPTIqTWF0aC5QSSksbT1OdW1iZXIoKCgxODAqKG0vTWF0aC5QSSklMzYwKzM2MCklMzYwKS50b0ZpeGVkKDEyKSkscT1OdW1iZXIoKCgxODAqKG4uc3RhcnRBbmdsZS9NYXRoLlBJKSUzNjArMzYwKSUzNjApLnRvRml4ZWQoMTIpKSxzPU51bWJlcigoKDE4MCoobi5lbmRBbmdsZS9NYXRoLlBJKSUzNjArMzYwKSUzNjApLnRvRml4ZWQoMTIpKSwwPT09cyYmMTxuLmVuZEFuZ2xlJiYocz0zNjApLHE+PXMmJjAhPT1kLnkmJihzKz0zNjAsbTxxJiYobSs9MzYwKSksbT5xJiZtPHMmJihjLnB1c2goe2RhdGFQb2ludDpkLGRhdGFQb2ludEluZGV4OmcsZGF0YVNlcmllczp0aGlzLGRpc3RhbmNlOjB9KSxsPSEwKSk7YnJlYWs7Y2FzZSBcImZ1bm5lbFwiOmNhc2UgXCJweXJhbWlkXCI6bT1uLmZ1bm5lbFNlY3Rpb247XHJcbmY+bS55MSYmZjxtLnk0JiYobS55Nj9mPm0ueTY/KGc9bS54NisobS54NS1tLng2KS8obS55NS1tLnk2KSooZi1tLnk2KSxtPW0ueDMrKG0ueDQtbS54MykvKG0ueTQtbS55MykqKGYtbS55MykpOihnPW0ueDErKG0ueDYtbS54MSkvKG0ueTYtbS55MSkqKGYtbS55MSksbT1tLngyKyhtLngzLW0ueDIpLyhtLnkzLW0ueTIpKihmLW0ueTIpKTooZz1tLngxKyhtLng0LW0ueDEpLyhtLnk0LW0ueTEpKihmLW0ueTEpLG09bS54MisobS54My1tLngyKS8obS55My1tLnkyKSooZi1tLnkyKSksYT5nJiZhPG0mJihjLnB1c2goe2RhdGFQb2ludDpkLGRhdGFQb2ludEluZGV4Om4uZGF0YVBvaW50SW5kZXgsZGF0YVNlcmllczp0aGlzLGRpc3RhbmNlOjB9KSxsPSEwKSk7YnJlYWs7Y2FzZSBcImJveEFuZFdoaXNrZXJcIjppZihhPj1uLngxLW4uYm9yZGVyVGhpY2tuZXNzLzImJmE8PW4ueDIrbi5ib3JkZXJUaGlja25lc3MvMiYmZj49bi55NC1uLmJvcmRlclRoaWNrbmVzcy8yJiZmPD1uLnkxK24uYm9yZGVyVGhpY2tuZXNzL1xyXG4yfHxNYXRoLmFicyhuLngyLWErbi54MS1hKTxuLmJvcmRlclRoaWNrbmVzcyYmZj49bi55MSYmZjw9bi55NCljLnB1c2goe2RhdGFQb2ludDpkLGRhdGFQb2ludEluZGV4OmcsZGF0YVNlcmllczp0aGlzLGRpc3RhbmNlOk1hdGgubWluKE1hdGguYWJzKG4ueDEtYSksTWF0aC5hYnMobi54Mi1hKSxNYXRoLmFicyhuLnkyLWYpLE1hdGguYWJzKG4ueTMtZikpfSksbD0hMDticmVhaztjYXNlIFwiY2FuZGxlc3RpY2tcIjppZihhPj1uLngxLW4uYm9yZGVyVGhpY2tuZXNzLzImJmE8PW4ueDIrbi5ib3JkZXJUaGlja25lc3MvMiYmZj49bi55Mi1uLmJvcmRlclRoaWNrbmVzcy8yJiZmPD1uLnkzK24uYm9yZGVyVGhpY2tuZXNzLzJ8fE1hdGguYWJzKG4ueDItYStuLngxLWEpPG4uYm9yZGVyVGhpY2tuZXNzJiZmPj1uLnkxJiZmPD1uLnk0KWMucHVzaCh7ZGF0YVBvaW50OmQsZGF0YVBvaW50SW5kZXg6ZyxkYXRhU2VyaWVzOnRoaXMsZGlzdGFuY2U6TWF0aC5taW4oTWF0aC5hYnMobi54MS1hKSxcclxuTWF0aC5hYnMobi54Mi1hKSxNYXRoLmFicyhuLnkyLWYpLE1hdGguYWJzKG4ueTMtZikpfSksbD0hMDticmVhaztjYXNlIFwib2hsY1wiOmlmKE1hdGguYWJzKG4ueDItYStuLngxLWEpPG4uYm9yZGVyVGhpY2tuZXNzJiZmPj1uLnkyJiZmPD1uLnkzfHxhPj1uLngxJiZhPD0obi54MituLngxKS8yJiZmPj1uLnkxLW4uYm9yZGVyVGhpY2tuZXNzLzImJmY8PW4ueTErbi5ib3JkZXJUaGlja25lc3MvMnx8YT49KG4ueDErbi54MikvMiYmYTw9bi54MiYmZj49bi55NC1uLmJvcmRlclRoaWNrbmVzcy8yJiZmPD1uLnk0K24uYm9yZGVyVGhpY2tuZXNzLzIpYy5wdXNoKHtkYXRhUG9pbnQ6ZCxkYXRhUG9pbnRJbmRleDpnLGRhdGFTZXJpZXM6dGhpcyxkaXN0YW5jZTpNYXRoLm1pbihNYXRoLmFicyhuLngxLWEpLE1hdGguYWJzKG4ueDItYSksTWF0aC5hYnMobi55Mi1mKSxNYXRoLmFicyhuLnkzLWYpKX0pLGw9ITB9aWYobHx8MUUzPGsmJjFFMzxyKWJyZWFrfX1lbHNlIGlmKDA+cC1lJiZwK2U+PVxyXG50aGlzLmRhdGFQb2ludHMubGVuZ3RoKWJyZWFrOy0xPT09aD8oZSsrLGg9MSk6aD0tMX1hPW51bGw7Zm9yKGY9MDtmPGMubGVuZ3RoO2YrKylhP2NbZl0uZGlzdGFuY2U8PWEuZGlzdGFuY2UmJihhPWNbZl0pOmE9Y1tmXTtyZXR1cm4gYX07US5wcm90b3R5cGUuZ2V0TWFya2VyUHJvcGVydGllcz1mdW5jdGlvbihhLGYsYixjKXt2YXIgZT10aGlzLmRhdGFQb2ludHM7cmV0dXJue3g6Zix5OmIsY3R4OmMsdHlwZTplW2FdLm1hcmtlclR5cGU/ZVthXS5tYXJrZXJUeXBlOnRoaXMubWFya2VyVHlwZSxzaXplOmVbYV0ubWFya2VyU2l6ZT9lW2FdLm1hcmtlclNpemU6dGhpcy5tYXJrZXJTaXplLGNvbG9yOmVbYV0ubWFya2VyQ29sb3I/ZVthXS5tYXJrZXJDb2xvcjp0aGlzLm1hcmtlckNvbG9yP3RoaXMubWFya2VyQ29sb3I6ZVthXS5jb2xvcj9lW2FdLmNvbG9yOnRoaXMuY29sb3I/dGhpcy5jb2xvcjp0aGlzLl9jb2xvclNldFthJXRoaXMuX2NvbG9yU2V0Lmxlbmd0aF0sYm9yZGVyQ29sb3I6ZVthXS5tYXJrZXJCb3JkZXJDb2xvcj9cclxuZVthXS5tYXJrZXJCb3JkZXJDb2xvcjp0aGlzLm1hcmtlckJvcmRlckNvbG9yP3RoaXMubWFya2VyQm9yZGVyQ29sb3I6bnVsbCxib3JkZXJUaGlja25lc3M6ZVthXS5tYXJrZXJCb3JkZXJUaGlja25lc3M/ZVthXS5tYXJrZXJCb3JkZXJUaGlja25lc3M6dGhpcy5tYXJrZXJCb3JkZXJUaGlja25lc3M/dGhpcy5tYXJrZXJCb3JkZXJUaGlja25lc3M6bnVsbH19O3BhKEMsWCk7Qy5wcm90b3R5cGUuY3JlYXRlRXh0cmFMYWJlbHNGb3JMb2c9ZnVuY3Rpb24oYSl7YT0oYXx8MCkrMTtpZighKDU8YSkpe3ZhciBmPXRoaXMubG9nTGFiZWxWYWx1ZXNbMF18fHRoaXMuaW50ZXJ2YWxTdGFydFBvc2l0aW9uO2lmKE1hdGgubG9nKHRoaXMucmFuZ2UpL01hdGgubG9nKGYvdGhpcy52aWV3cG9ydE1pbmltdW0pPHRoaXMubm9UaWNrcy0xKXtmb3IodmFyIGI9Qy5nZXROaWNlTnVtYmVyKChmLXRoaXMudmlld3BvcnRNaW5pbXVtKS9NYXRoLm1pbihNYXRoLm1heCgyLHRoaXMubm9UaWNrcy10aGlzLmxvZ0xhYmVsVmFsdWVzLmxlbmd0aCksXHJcbjMpLCEwKSxjPU1hdGguY2VpbCh0aGlzLnZpZXdwb3J0TWluaW11bS9iKSpiO2M8ZjtjKz1iKWM8dGhpcy52aWV3cG9ydE1pbmltdW18fHRoaXMubG9nTGFiZWxWYWx1ZXMucHVzaChjKTt0aGlzLmxvZ0xhYmVsVmFsdWVzLnNvcnQoUGEpO3RoaXMuY3JlYXRlRXh0cmFMYWJlbHNGb3JMb2coYSl9fX07Qy5wcm90b3R5cGUuY3JlYXRlTGFiZWxzPWZ1bmN0aW9uKCl7dmFyIGEsZixiPTAsYz0wLGUsZz0wLGg9MCxjPTAsYz10aGlzLmludGVydmFsLGw9MCx0LGs9MC42KnRoaXMuY2hhcnQuaGVpZ2h0LG07YT0hMTt2YXIgcD10aGlzLnNjYWxlQnJlYWtzP3RoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3M6W10sbj1wLmxlbmd0aD95KHRoaXMuc2NhbGVCcmVha3MuZmlyc3RCcmVha0luZGV4KT8wOnRoaXMuc2NhbGVCcmVha3MuZmlyc3RCcmVha0luZGV4OjA7aWYoXCJheGlzWFwiIT09dGhpcy50eXBlfHxcImRhdGVUaW1lXCIhPT10aGlzLnZhbHVlVHlwZXx8dGhpcy5sb2dhcml0aG1pYyl7ZT1cclxudGhpcy52aWV3cG9ydE1heGltdW07aWYodGhpcy5sYWJlbHMpe2E9TWF0aC5jZWlsKGMpO2Zvcih2YXIgYz1NYXRoLmNlaWwodGhpcy5pbnRlcnZhbFN0YXJ0UG9zaXRpb24pLGQ9ITEsYj1jO2I8dGhpcy52aWV3cG9ydE1heGltdW07Yis9YSlpZih0aGlzLmxhYmVsc1tiXSlkPSEwO2Vsc2V7ZD0hMTticmVha31kJiYodGhpcy5pbnRlcnZhbD1hLHRoaXMuaW50ZXJ2YWxTdGFydFBvc2l0aW9uPWMpfWlmKHRoaXMubG9nYXJpdGhtaWMmJiF0aGlzLmVxdWlkaXN0YW50SW50ZXJ2YWwpZm9yKHRoaXMubG9nTGFiZWxWYWx1ZXN8fCh0aGlzLmxvZ0xhYmVsVmFsdWVzPVtdLHRoaXMuY3JlYXRlRXh0cmFMYWJlbHNGb3JMb2coKSksYz0wLGQ9bjtjPHRoaXMubG9nTGFiZWxWYWx1ZXMubGVuZ3RoO2MrKylpZihiPXRoaXMubG9nTGFiZWxWYWx1ZXNbY10sYjx0aGlzLnZpZXdwb3J0TWluaW11bSljKys7ZWxzZXtmb3IoO2Q8cC5sZW5ndGgmJmI+cFtkXS5lbmRWYWx1ZTtkKyspO2E9ZDxwLmxlbmd0aCYmXHJcbmI+PXBbZF0uc3RhcnRWYWx1ZSYmYjw9cFtkXS5lbmRWYWx1ZTttPWI7YXx8KGE9dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5vcHRpb25zLHZhbHVlOm0sbGFiZWw6dGhpcy5sYWJlbHNbbV0/dGhpcy5sYWJlbHNbbV06bnVsbH0pOlwiYXhpc1hcIj09PXRoaXMudHlwZSYmdGhpcy5sYWJlbHNbbV0/dGhpcy5sYWJlbHNbbV06VyhtLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pLGE9bmV3IGxhKHRoaXMuY3R4LHt4OjAseTowLG1heFdpZHRoOmcsbWF4SGVpZ2h0OmgsYW5nbGU6dGhpcy5sYWJlbEFuZ2xlLHRleHQ6dGhpcy5wcmVmaXgrYSt0aGlzLnN1ZmZpeCxiYWNrZ3JvdW5kQ29sb3I6dGhpcy5sYWJlbEJhY2tncm91bmRDb2xvcixib3JkZXJDb2xvcjp0aGlzLmxhYmVsQm9yZGVyQ29sb3IsYm9yZGVyVGhpY2tuZXNzOnRoaXMubGFiZWxCb3JkZXJUaGlja25lc3MsY29ybmVyUmFkaXVzOnRoaXMubGFiZWxDb3JuZXJSYWRpdXMsXHJcbmhvcml6b250YWxBbGlnbjpcImxlZnRcIixmb250U2l6ZTp0aGlzLmxhYmVsRm9udFNpemUsZm9udEZhbWlseTp0aGlzLmxhYmVsRm9udEZhbWlseSxmb250V2VpZ2h0OnRoaXMubGFiZWxGb250V2VpZ2h0LGZvbnRDb2xvcjp0aGlzLmxhYmVsRm9udENvbG9yLGZvbnRTdHlsZTp0aGlzLmxhYmVsRm9udFN0eWxlLHRleHRCYXNlbGluZTpcIm1pZGRsZVwiLGJvcmRlclRoaWNrbmVzczowfSksdGhpcy5fbGFiZWxzLnB1c2goe3Bvc2l0aW9uOm0sdGV4dEJsb2NrOmEsZWZmZWN0aXZlSGVpZ2h0Om51bGx9KSl9ZD1uO2ZvcihiPXRoaXMuaW50ZXJ2YWxTdGFydFBvc2l0aW9uO2I8PWU7Yj1wYXJzZUZsb2F0KCh0aGlzLmxvZ2FyaXRobWljJiZ0aGlzLmVxdWlkaXN0YW50SW50ZXJ2YWw/YipNYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsdGhpcy5pbnRlcnZhbCk6Yit0aGlzLmludGVydmFsKS50b0ZpeGVkKDEyKSkpe2Zvcig7ZDxwLmxlbmd0aCYmYj5wW2RdLmVuZFZhbHVlO2QrKyk7YT1kPHAubGVuZ3RoJiZcclxuYj49cFtkXS5zdGFydFZhbHVlJiZiPD1wW2RdLmVuZFZhbHVlO209YjthfHwoYT10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLm9wdGlvbnMsdmFsdWU6bSxsYWJlbDp0aGlzLmxhYmVsc1ttXT90aGlzLmxhYmVsc1ttXTpudWxsfSk6XCJheGlzWFwiPT09dGhpcy50eXBlJiZ0aGlzLmxhYmVsc1ttXT90aGlzLmxhYmVsc1ttXTpXKG0sdGhpcy52YWx1ZUZvcm1hdFN0cmluZyx0aGlzLmNoYXJ0Ll9jdWx0dXJlSW5mbyksYT1uZXcgbGEodGhpcy5jdHgse3g6MCx5OjAsbWF4V2lkdGg6ZyxtYXhIZWlnaHQ6aCxhbmdsZTp0aGlzLmxhYmVsQW5nbGUsdGV4dDp0aGlzLnByZWZpeCthK3RoaXMuc3VmZml4LGhvcml6b250YWxBbGlnbjpcImxlZnRcIixiYWNrZ3JvdW5kQ29sb3I6dGhpcy5sYWJlbEJhY2tncm91bmRDb2xvcixib3JkZXJDb2xvcjp0aGlzLmxhYmVsQm9yZGVyQ29sb3IsYm9yZGVyVGhpY2tuZXNzOnRoaXMubGFiZWxCb3JkZXJUaGlja25lc3MsXHJcbmNvcm5lclJhZGl1czp0aGlzLmxhYmVsQ29ybmVyUmFkaXVzLGZvbnRTaXplOnRoaXMubGFiZWxGb250U2l6ZSxmb250RmFtaWx5OnRoaXMubGFiZWxGb250RmFtaWx5LGZvbnRXZWlnaHQ6dGhpcy5sYWJlbEZvbnRXZWlnaHQsZm9udENvbG9yOnRoaXMubGFiZWxGb250Q29sb3IsZm9udFN0eWxlOnRoaXMubGFiZWxGb250U3R5bGUsdGV4dEJhc2VsaW5lOlwibWlkZGxlXCJ9KSx0aGlzLl9sYWJlbHMucHVzaCh7cG9zaXRpb246bSx0ZXh0QmxvY2s6YSxlZmZlY3RpdmVIZWlnaHQ6bnVsbH0pKX19ZWxzZSBmb3IodGhpcy5pbnRlcnZhbFN0YXJ0UG9zaXRpb249dGhpcy5nZXRMYWJlbFN0YXJ0UG9pbnQobmV3IERhdGUodGhpcy52aWV3cG9ydE1pbmltdW0pLHRoaXMuaW50ZXJ2YWxUeXBlLHRoaXMuaW50ZXJ2YWwpLGU9VGEobmV3IERhdGUodGhpcy52aWV3cG9ydE1heGltdW0pLHRoaXMuaW50ZXJ2YWwsdGhpcy5pbnRlcnZhbFR5cGUpLGQ9bixiPXRoaXMuaW50ZXJ2YWxTdGFydFBvc2l0aW9uO2I8XHJcbmU7VGEoYixjLHRoaXMuaW50ZXJ2YWxUeXBlKSl7Zm9yKGE9Yi5nZXRUaW1lKCk7ZDxwLmxlbmd0aCYmYT5wW2RdLmVuZFZhbHVlO2QrKyk7bT1hO2E9ZDxwLmxlbmd0aCYmYT49cFtkXS5zdGFydFZhbHVlJiZhPD1wW2RdLmVuZFZhbHVlO2F8fChhPXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMub3B0aW9ucyx2YWx1ZTpuZXcgRGF0ZShtKSxsYWJlbDp0aGlzLmxhYmVsc1ttXT90aGlzLmxhYmVsc1ttXTpudWxsfSk6XCJheGlzWFwiPT09dGhpcy50eXBlJiZ0aGlzLmxhYmVsc1ttXT90aGlzLmxhYmVsc1ttXTpCYShtLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pLGE9bmV3IGxhKHRoaXMuY3R4LHt4OjAseTowLG1heFdpZHRoOmcsYmFja2dyb3VuZENvbG9yOnRoaXMubGFiZWxCYWNrZ3JvdW5kQ29sb3IsYm9yZGVyQ29sb3I6dGhpcy5sYWJlbEJvcmRlckNvbG9yLGJvcmRlclRoaWNrbmVzczp0aGlzLmxhYmVsQm9yZGVyVGhpY2tuZXNzLFxyXG5jb3JuZXJSYWRpdXM6dGhpcy5sYWJlbENvcm5lclJhZGl1cyxtYXhIZWlnaHQ6aCxhbmdsZTp0aGlzLmxhYmVsQW5nbGUsdGV4dDp0aGlzLnByZWZpeCthK3RoaXMuc3VmZml4LGhvcml6b250YWxBbGlnbjpcImxlZnRcIixmb250U2l6ZTp0aGlzLmxhYmVsRm9udFNpemUsZm9udEZhbWlseTp0aGlzLmxhYmVsRm9udEZhbWlseSxmb250V2VpZ2h0OnRoaXMubGFiZWxGb250V2VpZ2h0LGZvbnRDb2xvcjp0aGlzLmxhYmVsRm9udENvbG9yLGZvbnRTdHlsZTp0aGlzLmxhYmVsRm9udFN0eWxlLHRleHRCYXNlbGluZTpcIm1pZGRsZVwifSksdGhpcy5fbGFiZWxzLnB1c2goe3Bvc2l0aW9uOm0sdGV4dEJsb2NrOmEsZWZmZWN0aXZlSGVpZ2h0Om51bGwsYnJlYWtzTGFiZWxUeXBlOnZvaWQgMH0pKX1pZihcImJvdHRvbVwiPT09dGhpcy5fcG9zaXRpb258fFwidG9wXCI9PT10aGlzLl9wb3NpdGlvbilsPXRoaXMubG9nYXJpdGhtaWMmJiF0aGlzLmVxdWlkaXN0YW50SW50ZXJ2YWwmJjI8PXRoaXMuX2xhYmVscy5sZW5ndGg/XHJcbnRoaXMubGluZUNvb3JkaW5hdGVzLndpZHRoKk1hdGgubG9nKE1hdGgubWluKHRoaXMuX2xhYmVsc1t0aGlzLl9sYWJlbHMubGVuZ3RoLTFdLnBvc2l0aW9uL3RoaXMuX2xhYmVsc1t0aGlzLl9sYWJlbHMubGVuZ3RoLTJdLnBvc2l0aW9uLHRoaXMuX2xhYmVsc1sxXS5wb3NpdGlvbi90aGlzLl9sYWJlbHNbMF0ucG9zaXRpb24pKS9NYXRoLmxvZyh0aGlzLnJhbmdlKTp0aGlzLmxpbmVDb29yZGluYXRlcy53aWR0aC8odGhpcy5sb2dhcml0aG1pYyYmdGhpcy5lcXVpZGlzdGFudEludGVydmFsP01hdGgubG9nKHRoaXMucmFuZ2UpL01hdGgubG9nKHRoaXMubG9nYXJpdGhtQmFzZSk6TWF0aC5hYnModGhpcy5yYW5nZSkpKlVbdGhpcy5pbnRlcnZhbFR5cGUrXCJEdXJhdGlvblwiXSp0aGlzLmludGVydmFsLGc9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aD8wLjUqdGhpcy5jaGFydC53aWR0aD4+MDp0aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCx0aGlzLmNoYXJ0LnBhbkVuYWJsZWR8fFxyXG4oaD1cInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5sYWJlbFdyYXB8fHRoaXMubGFiZWxXcmFwPzAuOCp0aGlzLmNoYXJ0LmhlaWdodD4+MDoxLjUqdGhpcy5sYWJlbEZvbnRTaXplKTtlbHNlIGlmKFwibGVmdFwiPT09dGhpcy5fcG9zaXRpb258fFwicmlnaHRcIj09PXRoaXMuX3Bvc2l0aW9uKWw9dGhpcy5sb2dhcml0aG1pYyYmIXRoaXMuZXF1aWRpc3RhbnRJbnRlcnZhbCYmMjw9dGhpcy5fbGFiZWxzLmxlbmd0aD90aGlzLmxpbmVDb29yZGluYXRlcy5oZWlnaHQqTWF0aC5sb2coTWF0aC5taW4odGhpcy5fbGFiZWxzW3RoaXMuX2xhYmVscy5sZW5ndGgtMV0ucG9zaXRpb24vdGhpcy5fbGFiZWxzW3RoaXMuX2xhYmVscy5sZW5ndGgtMl0ucG9zaXRpb24sdGhpcy5fbGFiZWxzWzFdLnBvc2l0aW9uL3RoaXMuX2xhYmVsc1swXS5wb3NpdGlvbikpL01hdGgubG9nKHRoaXMucmFuZ2UpOnRoaXMubGluZUNvb3JkaW5hdGVzLmhlaWdodC8odGhpcy5sb2dhcml0aG1pYyYmdGhpcy5lcXVpZGlzdGFudEludGVydmFsP1xyXG5NYXRoLmxvZyh0aGlzLnJhbmdlKS9NYXRoLmxvZyh0aGlzLmxvZ2FyaXRobUJhc2UpOk1hdGguYWJzKHRoaXMucmFuZ2UpKSpVW3RoaXMuaW50ZXJ2YWxUeXBlK1wiRHVyYXRpb25cIl0qdGhpcy5pbnRlcnZhbCx0aGlzLmNoYXJ0LnBhbkVuYWJsZWR8fChnPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg/MC4zKnRoaXMuY2hhcnQud2lkdGg+PjA6dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpLGg9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLm9wdGlvbnMubGFiZWxXcmFwfHx0aGlzLmxhYmVsV3JhcD8wLjMqdGhpcy5jaGFydC5oZWlnaHQ+PjA6MS41KnRoaXMubGFiZWxGb250U2l6ZTtmb3IoYz0wO2M8dGhpcy5fbGFiZWxzLmxlbmd0aDtjKyspe2E9dGhpcy5fbGFiZWxzW2NdLnRleHRCbG9jazthLm1heFdpZHRoPWc7YS5tYXhIZWlnaHQ9aDt2YXIgcT1hLm1lYXN1cmVUZXh0KCk7dD1xLmhlaWdodH1lPVtdO249cD0wO2lmKHRoaXMubGFiZWxBdXRvRml0fHxcclxudGhpcy5vcHRpb25zLmxhYmVsQXV0b0ZpdClpZih5KHRoaXMubGFiZWxBbmdsZSl8fCh0aGlzLmxhYmVsQW5nbGU9KHRoaXMubGFiZWxBbmdsZSUzNjArMzYwKSUzNjAsOTA8dGhpcy5sYWJlbEFuZ2xlJiYyNzA+dGhpcy5sYWJlbEFuZ2xlP3RoaXMubGFiZWxBbmdsZS09MTgwOjI3MDw9dGhpcy5sYWJlbEFuZ2xlJiYzNjA+PXRoaXMubGFiZWxBbmdsZSYmKHRoaXMubGFiZWxBbmdsZS09MzYwKSksXCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5fcG9zaXRpb24paWYoZz0wLjkqbD4+MCxuPTAsIXRoaXMuY2hhcnQucGFuRW5hYmxlZCYmMTw9dGhpcy5fbGFiZWxzLmxlbmd0aCl7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9dGhpcy5sYWJlbEZvbnRTaXplO3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPWc7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWg7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9XHJcbnRoaXMubGFiZWxBbmdsZTt0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPXRoaXMubGFiZWxXcmFwO2ZvcihiPTA7Yjx0aGlzLl9sYWJlbHMubGVuZ3RoO2IrKylpZighdGhpcy5fbGFiZWxzW2JdLmJyZWFrc0xhYmVsVHlwZSl7YT10aGlzLl9sYWJlbHNbYl0udGV4dEJsb2NrO2Zvcih2YXIgcyxkPWEudGV4dC5zcGxpdChcIiBcIiksYz0wO2M8ZC5sZW5ndGg7YysrKW09ZFtjXSx0aGlzLmN0eC5mb250PWEuZm9udFN0eWxlK1wiIFwiK2EuZm9udFdlaWdodCtcIiBcIithLmZvbnRTaXplK1wicHggXCIrYS5mb250RmFtaWx5LG09dGhpcy5jdHgubWVhc3VyZVRleHQobSksbS53aWR0aD5uJiYocz1iLG49bS53aWR0aCl9Yj0wO2ZvcihiPXRoaXMuaW50ZXJ2YWxTdGFydFBvc2l0aW9uPHRoaXMudmlld3BvcnRNaW5pbXVtPzE6MDtiPHRoaXMuX2xhYmVscy5sZW5ndGg7YisrKWlmKCF0aGlzLl9sYWJlbHNbYl0uYnJlYWtzTGFiZWxUeXBlKXthPXRoaXMuX2xhYmVsc1tiXS50ZXh0QmxvY2s7XHJcbnE9YS5tZWFzdXJlVGV4dCgpO2ZvcihkPWIrMTtkPHRoaXMuX2xhYmVscy5sZW5ndGg7ZCsrKWlmKCF0aGlzLl9sYWJlbHNbZF0uYnJlYWtzTGFiZWxUeXBlKXtmPXRoaXMuX2xhYmVsc1tkXS50ZXh0QmxvY2s7Zj1mLm1lYXN1cmVUZXh0KCk7YnJlYWt9ZS5wdXNoKGEuaGVpZ2h0KTt0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9TWF0aC5tYXguYXBwbHkoTWF0aCxlKTtNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKTtNYXRoLnNpbihNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKTtjPWcqTWF0aC5zaW4oTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSkrKGgtYS5mb250U2l6ZS8yKSpNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKTtpZih5KHRoaXMub3B0aW9ucy5sYWJlbEFuZ2xlKSYmaXNOYU4odGhpcy5vcHRpb25zLmxhYmVsQW5nbGUpJiYwIT09dGhpcy5vcHRpb25zLmxhYmVsQW5nbGUpaWYodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PVxyXG4wPT09dGhpcy5sYWJlbEFuZ2xlP2g6TWF0aC5taW4oKGMtZypNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKSkvTWF0aC5zaW4oTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSksYyksbT0oay0odCthLmZvbnRTaXplLzIpKk1hdGguY29zKE1hdGguUEkvMTgwKk1hdGguYWJzKC0yNSkpKS9NYXRoLnNpbihNYXRoLlBJLzE4MCpNYXRoLmFicygtMjUpKSwheSh0aGlzLm9wdGlvbnMubGFiZWxXcmFwKSl0aGlzLmxhYmVsV3JhcD95KHRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoKT8odGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9TWF0aC5taW4oTWF0aC5tYXgoZyxuKSxtKSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPXRoaXMubGFiZWxXcmFwLHEud2lkdGgrZi53aWR0aD4+MD4yKmcmJih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT0tMjUpKToodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD1cclxudGhpcy5sYWJlbFdyYXAsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg+Zz8tMjU6dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGUpOnkodGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpPyh0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPXRoaXMubGFiZWxXcmFwLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1oLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPWcscS53aWR0aCtmLndpZHRoPj4wPjIqZyYmKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlPS0yNSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD1tKSk6KHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlPXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPlxyXG5nPy0yNTp0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD10aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9aCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPXRoaXMubGFiZWxXcmFwKTtlbHNle2lmKHkodGhpcy5vcHRpb25zLmxhYmVsV3JhcCkpaWYoIXkodGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpKXRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoPGc/KHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPXRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1jKToodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9LTI1LHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPXRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1cclxuaCk7ZWxzZSBpZigheShmKSlpZihjPXEud2lkdGgrZi53aWR0aD4+MCxkPXRoaXMubGFiZWxGb250U2l6ZSxuPGcpYy0yKmc+cCYmKHA9Yy0yKmcsYz49MipnJiZjPDIuMipnPyh0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD1nLHkodGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUpJiYxMjxkJiYoZD1NYXRoLmZsb29yKDEyLzEzKmQpLGEubWVhc3VyZVRleHQoKSksdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9eSh0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSk/ZDp0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT10aGlzLmxhYmVsQW5nbGUpOmM+PTIuMipnJiZjPDIuOCpnPyh0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT0tMjUsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9bSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZT1kKTpjPj0yLjgqXHJcbmcmJmM8My4yKmc/KHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPU1hdGgubWF4KGcsbiksdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD0hMCx5KHRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKSYmMTI8dGhpcy5sYWJlbEZvbnRTaXplJiYodGhpcy5sYWJlbEZvbnRTaXplPU1hdGguZmxvb3IoMTIvMTMqdGhpcy5sYWJlbEZvbnRTaXplKSxhLm1lYXN1cmVUZXh0KCkpLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEZvbnRTaXplPXkodGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUpP2Q6dGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9dGhpcy5sYWJlbEFuZ2xlKTpjPj0zLjIqZyYmYzwzLjYqZz8odGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9LTI1LHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9ITAsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9bSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZT1cclxudGhpcy5sYWJlbEZvbnRTaXplKTpjPjMuNipnJiZjPDUqZz8oeSh0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSkmJjEyPGQmJihkPU1hdGguZmxvb3IoMTIvMTMqZCksYS5tZWFzdXJlVGV4dCgpKSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZT15KHRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKT9kOnRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9ITAsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9LTI1LHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPW0pOmM+NSpnJiYodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD0hMCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD1nLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEZvbnRTaXplPWQsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWgsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9XHJcbnRoaXMubGFiZWxBbmdsZSkpO2Vsc2UgaWYocz09PWImJigwPT09cyYmbit0aGlzLl9sYWJlbHNbcysxXS50ZXh0QmxvY2subWVhc3VyZVRleHQoKS53aWR0aC0yKmc+cHx8cz09PXRoaXMuX2xhYmVscy5sZW5ndGgtMSYmbit0aGlzLl9sYWJlbHNbcy0xXS50ZXh0QmxvY2subWVhc3VyZVRleHQoKS53aWR0aC0yKmc+cHx8MDxzJiZzPHRoaXMuX2xhYmVscy5sZW5ndGgtMSYmbit0aGlzLl9sYWJlbHNbcysxXS50ZXh0QmxvY2subWVhc3VyZVRleHQoKS53aWR0aC0yKmc+cCYmbit0aGlzLl9sYWJlbHNbcy0xXS50ZXh0QmxvY2subWVhc3VyZVRleHQoKS53aWR0aC0yKmc+cCkpcD0wPT09cz9uK3RoaXMuX2xhYmVsc1tzKzFdLnRleHRCbG9jay5tZWFzdXJlVGV4dCgpLndpZHRoLTIqZzpuK3RoaXMuX2xhYmVsc1tzLTFdLnRleHRCbG9jay5tZWFzdXJlVGV4dCgpLndpZHRoLTIqZyx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZT15KHRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKT9cclxuZDp0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPSEwLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlPS0yNSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD1tO2Vsc2UgaWYoMD09PXApZm9yKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEZvbnRTaXplPXkodGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUpP2Q6dGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD0hMCxjPTA7Yzx0aGlzLl9sYWJlbHMubGVuZ3RoO2MrKylhPXRoaXMuX2xhYmVsc1tjXS50ZXh0QmxvY2ssYS5tYXhXaWR0aD10aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD1NYXRoLm1pbihNYXRoLm1heChnLG4pLG0pLHE9YS5tZWFzdXJlVGV4dCgpLGM8dGhpcy5fbGFiZWxzLmxlbmd0aC0xJiYoZD1jKzEsZj10aGlzLl9sYWJlbHNbZF0udGV4dEJsb2NrLGYubWF4V2lkdGg9XHJcbnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPU1hdGgubWluKE1hdGgubWF4KGcsbiksbSksZj1mLm1lYXN1cmVUZXh0KCkscS53aWR0aCtmLndpZHRoPj4wPjIqZyYmKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlPS0yNSkpfWVsc2UodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9dGhpcy5sYWJlbEFuZ2xlLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD0wPT09dGhpcy5sYWJlbEFuZ2xlP2g6TWF0aC5taW4oKGMtZypNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKSkvTWF0aC5zaW4oTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSksYyksbT0wIT10aGlzLmxhYmVsQW5nbGU/KGstKHQrYS5mb250U2l6ZS8yKSpNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKSkvTWF0aC5zaW4oTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSk6XHJcbmcsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWg9dGhpcy5sYWJlbFdyYXA/KGstbSpNYXRoLnNpbihNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKSkvTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSk6MS41KnRoaXMubGFiZWxGb250U2l6ZSx5KHRoaXMub3B0aW9ucy5sYWJlbFdyYXApKT95KHRoaXMub3B0aW9ucy5sYWJlbFdyYXApJiYodGhpcy5sYWJlbFdyYXAmJiF5KHRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoKT8odGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD10aGlzLmxhYmVsV3JhcCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD10aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aD90aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aDptLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1oKToodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9dGhpcy5sYWJlbEFuZ2xlLFxyXG50aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD1tLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1jPDAuOSpsPzAuOSpsOmMsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD10aGlzLmxhYmVsV3JhcCkpOih0aGlzLm9wdGlvbnMubGFiZWxXcmFwPyh0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPXRoaXMubGFiZWxXcmFwLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPXRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoP3RoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoOm0pOih5KHRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoKSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD10aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aD90aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aDptLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9dGhpcy5sYWJlbFdyYXApLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1cclxuaCl9Zm9yKGM9MDtjPHRoaXMuX2xhYmVscy5sZW5ndGg7YysrKWE9dGhpcy5fbGFiZWxzW2NdLnRleHRCbG9jayxhLm1heFdpZHRoPXRoaXMubGFiZWxNYXhXaWR0aD10aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aCxhLmZvbnRTaXplPXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEZvbnRTaXplLGEuYW5nbGU9dGhpcy5sYWJlbEFuZ2xlPXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlLGEud3JhcD10aGlzLmxhYmVsV3JhcD10aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwLGEubWF4SGVpZ2h0PXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodCxhLm1lYXN1cmVUZXh0KCl9ZWxzZSBmb3IoYj0wO2I8dGhpcy5fbGFiZWxzLmxlbmd0aDtiKyspYT10aGlzLl9sYWJlbHNbYl0udGV4dEJsb2NrLGEubWF4V2lkdGg9dGhpcy5sYWJlbE1heFdpZHRoPXkodGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoOlxyXG50aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCxhLmZvbnRTaXplPXRoaXMubGFiZWxGb250U2l6ZT15KHRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKT90aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZTp0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSxhLmFuZ2xlPXRoaXMubGFiZWxBbmdsZT15KHRoaXMub3B0aW9ucy5sYWJlbEFuZ2xlKT90aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZTp0aGlzLmxhYmVsQW5nbGUsYS53cmFwPXRoaXMubGFiZWxXcmFwPXkodGhpcy5vcHRpb25zLmxhYmVsV3JhcCk/dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcDp0aGlzLm9wdGlvbnMubGFiZWxXcmFwLGEubWF4SGVpZ2h0PXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodCxhLm1lYXN1cmVUZXh0KCk7ZWxzZSBpZihcImxlZnRcIj09PXRoaXMuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLl9wb3NpdGlvbilpZihnPXkodGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpP1xyXG4wLjMqdGhpcy5jaGFydC53aWR0aD4+MDp0aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCxoPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmxhYmVsV3JhcHx8dGhpcy5sYWJlbFdyYXA/MC4zKnRoaXMuY2hhcnQuaGVpZ2h0Pj4wOjEuNSp0aGlzLmxhYmVsRm9udFNpemUsIXRoaXMuY2hhcnQucGFuRW5hYmxlZCYmMTw9dGhpcy5fbGFiZWxzLmxlbmd0aCl7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9dGhpcy5sYWJlbEZvbnRTaXplO3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPWc7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWg7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9eSh0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSk/MDp0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZTt0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPXRoaXMubGFiZWxXcmFwO2ZvcihiPTA7YjxcclxudGhpcy5fbGFiZWxzLmxlbmd0aDtiKyspaWYoIXRoaXMuX2xhYmVsc1tiXS5icmVha3NMYWJlbFR5cGUpe2E9dGhpcy5fbGFiZWxzW2JdLnRleHRCbG9jaztxPWEubWVhc3VyZVRleHQoKTtmb3IoZD1iKzE7ZDx0aGlzLl9sYWJlbHMubGVuZ3RoO2QrKylpZighdGhpcy5fbGFiZWxzW2RdLmJyZWFrc0xhYmVsVHlwZSl7Zj10aGlzLl9sYWJlbHNbZF0udGV4dEJsb2NrO2Y9Zi5tZWFzdXJlVGV4dCgpO2JyZWFrfWUucHVzaChhLmhlaWdodCk7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PU1hdGgubWF4LmFwcGx5KE1hdGgsZSk7Yz1nKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpKyhoLWEuZm9udFNpemUvMikqTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSk7TWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSk7TWF0aC5zaW4oTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSk7XHJcbnkodGhpcy5vcHRpb25zLmxhYmVsQW5nbGUpJiZpc05hTih0aGlzLm9wdGlvbnMubGFiZWxBbmdsZSkmJjAhPT10aGlzLm9wdGlvbnMubGFiZWxBbmdsZT95KHRoaXMub3B0aW9ucy5sYWJlbFdyYXApP3kodGhpcy5vcHRpb25zLmxhYmVsV3JhcCkmJih5KHRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoKT95KGYpfHwobD1xLmhlaWdodCtmLmhlaWdodD4+MCxsLTIqaD5uJiYobj1sLTIqaCxsPj0yKmgmJmw8Mi40Kmg/KHkodGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUpJiYxMjx0aGlzLmxhYmVsRm9udFNpemUmJih0aGlzLmxhYmVsRm9udFNpemU9TWF0aC5mbG9vcigxMi8xMyp0aGlzLmxhYmVsRm9udFNpemUpLGEubWVhc3VyZVRleHQoKSksdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWgsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9eSh0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSk/dGhpcy5sYWJlbEZvbnRTaXplOnRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKTpcclxubD49Mi40KmgmJmw8Mi44Kmg/KHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1jLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEZvbnRTaXplPXRoaXMubGFiZWxGb250U2l6ZSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPSEwKTpsPj0yLjgqaCYmbDwzLjIqaD8odGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWgsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD0hMCx5KHRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKSYmMTI8dGhpcy5sYWJlbEZvbnRTaXplJiYodGhpcy5sYWJlbEZvbnRTaXplPU1hdGguZmxvb3IoMTIvMTMqdGhpcy5sYWJlbEZvbnRTaXplKSxhLm1lYXN1cmVUZXh0KCkpLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEZvbnRTaXplPXkodGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUpP3RoaXMubGFiZWxGb250U2l6ZTp0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT1cclxueSh0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSk/MDp0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSk6bD49My4yKmgmJmw8My42Kmg/KHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1jLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9ITAsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9dGhpcy5sYWJlbEZvbnRTaXplKTpsPjMuNipoJiZsPDEwKmg/KHkodGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUpJiYxMjx0aGlzLmxhYmVsRm9udFNpemUmJih0aGlzLmxhYmVsRm9udFNpemU9TWF0aC5mbG9vcigxMi8xMyp0aGlzLmxhYmVsRm9udFNpemUpLGEubWVhc3VyZVRleHQoKSksdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9eSh0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSk/dGhpcy5sYWJlbEZvbnRTaXplOnRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPVxyXG5nLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1oLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlPXkodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGUpPzA6dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGUpOmw+MTAqaCYmbDw1MCpoJiYoeSh0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSkmJjEyPHRoaXMubGFiZWxGb250U2l6ZSYmKHRoaXMubGFiZWxGb250U2l6ZT1NYXRoLmZsb29yKDEyLzEzKnRoaXMubGFiZWxGb250U2l6ZSksYS5tZWFzdXJlVGV4dCgpKSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZT15KHRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKT90aGlzLmxhYmVsRm9udFNpemU6dGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWgsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9Zyx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT1cclxueSh0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSk/MDp0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSkpKToodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWgsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg/dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg6dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGgpKToodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9dGhpcy5sYWJlbFdyYXA/dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg/dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg6dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg6dGhpcy5sYWJlbE1heFdpZHRoP3RoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoP3RoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoOnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoOmcsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PVxyXG5oKToodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9dGhpcy5sYWJlbEFuZ2xlLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPTA9PT10aGlzLmxhYmVsQW5nbGU/ZzpNYXRoLm1pbigoYy1oKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpKS9NYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKSxoKSx5KHRoaXMub3B0aW9ucy5sYWJlbFdyYXApKT95KHRoaXMub3B0aW9ucy5sYWJlbFdyYXApJiYodGhpcy5sYWJlbFdyYXAmJiF5KHRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoKT8odGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg/dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg+dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg6dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGgsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD1cclxudGhpcy5sYWJlbFdyYXAsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWMpOih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD10aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aD90aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aDpnLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD0wPT09dGhpcy5sYWJlbEFuZ2xlP2g6Yyx5KHRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoKSYmKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlPXRoaXMubGFiZWxBbmdsZSkpKTp0aGlzLm9wdGlvbnMubGFiZWxXcmFwPyh0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9MD09PXRoaXMubGFiZWxBbmdsZT9oOmMsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD10aGlzLmxhYmVsV3JhcCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD1nKToodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PVxyXG5oLHkodGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPXRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoP3RoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoOnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9dGhpcy5sYWJlbFdyYXApfWZvcihjPTA7Yzx0aGlzLl9sYWJlbHMubGVuZ3RoO2MrKylhPXRoaXMuX2xhYmVsc1tjXS50ZXh0QmxvY2ssYS5tYXhXaWR0aD10aGlzLmxhYmVsTWF4V2lkdGg9dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGgsYS5mb250U2l6ZT10aGlzLmxhYmVsRm9udFNpemU9dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemUsYS5hbmdsZT10aGlzLmxhYmVsQW5nbGU9dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGUsYS53cmFwPXRoaXMubGFiZWxXcmFwPXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXAsXHJcbmEubWF4SGVpZ2h0PXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodCxhLm1lYXN1cmVUZXh0KCl9ZWxzZSBmb3IoYj0wO2I8dGhpcy5fbGFiZWxzLmxlbmd0aDtiKyspYT10aGlzLl9sYWJlbHNbYl0udGV4dEJsb2NrLGEubWF4V2lkdGg9dGhpcy5sYWJlbE1heFdpZHRoPXkodGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoOnRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoLGEuZm9udFNpemU9dGhpcy5sYWJlbEZvbnRTaXplPXkodGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUpP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEZvbnRTaXplOnRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplLGEuYW5nbGU9dGhpcy5sYWJlbEFuZ2xlPXkodGhpcy5vcHRpb25zLmxhYmVsQW5nbGUpP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlOnRoaXMubGFiZWxBbmdsZSxhLndyYXA9dGhpcy5sYWJlbFdyYXA9eSh0aGlzLm9wdGlvbnMubGFiZWxXcmFwKT9cclxudGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcDp0aGlzLm9wdGlvbnMubGFiZWxXcmFwLGEubWF4SGVpZ2h0PXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodCxhLm1lYXN1cmVUZXh0KCk7Zm9yKGI9MDtiPHRoaXMuc3RyaXBMaW5lcy5sZW5ndGg7YisrKXt2YXIgZz10aGlzLnN0cmlwTGluZXNbYl0seDtpZihcIm91dHNpZGVcIj09PWcubGFiZWxQbGFjZW1lbnQpe2g9dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg7aWYoXCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5fcG9zaXRpb24peD15KGcub3B0aW9ucy5sYWJlbFdyYXApP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodDpnLmxhYmVsV3JhcD8wLjgqdGhpcy5jaGFydC5oZWlnaHQ+PjA6MS41KnRoaXMubGFiZWxGb250U2l6ZTtpZihcImxlZnRcIj09PXRoaXMuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLl9wb3NpdGlvbil4PXkoZy5vcHRpb25zLmxhYmVsV3JhcCk/XHJcbnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodDpnLmxhYmVsV3JhcD8wLjgqdGhpcy5jaGFydC53aWR0aD4+MDoxLjUqdGhpcy5sYWJlbEZvbnRTaXplO3koZy5sYWJlbEJhY2tncm91bmRDb2xvcikmJihnLmxhYmVsQmFja2dyb3VuZENvbG9yPVwiI0VFRUVFRVwiKX1lbHNlIGg9XCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5fcG9zaXRpb24/MC45KnRoaXMuY2hhcnQud2lkdGg+PjA6MC45KnRoaXMuY2hhcnQuaGVpZ2h0Pj4wLHg9eShnLm9wdGlvbnMubGFiZWxXcmFwKXx8Zy5sYWJlbFdyYXA/XCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5fcG9zaXRpb24/MC44KnRoaXMuY2hhcnQud2lkdGg+PjA6MC44KnRoaXMuY2hhcnQuaGVpZ2h0Pj4wOjEuNSp0aGlzLmxhYmVsRm9udFNpemUseShnLmxhYmVsQmFja2dyb3VuZENvbG9yKSYmKHkoZy5zdGFydFZhbHVlKSYmMCE9PWcuc3RhcnRWYWx1ZT9nLmxhYmVsQmFja2dyb3VuZENvbG9yPVxyXG52P1widHJhbnNwYXJlbnRcIjpudWxsOmcubGFiZWxCYWNrZ3JvdW5kQ29sb3I9XCIjRUVFRUVFXCIpO2E9bmV3IGxhKHRoaXMuY3R4LHt4OjAseTowLGJhY2tncm91bmRDb2xvcjpnLmxhYmVsQmFja2dyb3VuZENvbG9yLGJvcmRlckNvbG9yOmcubGFiZWxCb3JkZXJDb2xvcixib3JkZXJUaGlja25lc3M6Zy5sYWJlbEJvcmRlclRoaWNrbmVzcyxjb3JuZXJSYWRpdXM6Zy5sYWJlbENvcm5lclJhZGl1cyxtYXhXaWR0aDpnLm9wdGlvbnMubGFiZWxNYXhXaWR0aD9nLm9wdGlvbnMubGFiZWxNYXhXaWR0aDpoLG1heEhlaWdodDp4LGFuZ2xlOnRoaXMubGFiZWxBbmdsZSx0ZXh0OmcubGFiZWxGb3JtYXR0ZXI/Zy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMsc3RyaXBMaW5lOmd9KTpnLmxhYmVsLGhvcml6b250YWxBbGlnbjpcImxlZnRcIixmb250U2l6ZTpcIm91dHNpZGVcIj09PWcubGFiZWxQbGFjZW1lbnQ/Zy5vcHRpb25zLmxhYmVsRm9udFNpemU/Zy5sYWJlbEZvbnRTaXplOlxyXG50aGlzLmxhYmVsRm9udFNpemU6Zy5sYWJlbEZvbnRTaXplLGZvbnRGYW1pbHk6XCJvdXRzaWRlXCI9PT1nLmxhYmVsUGxhY2VtZW50P2cub3B0aW9ucy5sYWJlbEZvbnRGYW1pbHk/Zy5sYWJlbEZvbnRGYW1pbHk6dGhpcy5sYWJlbEZvbnRGYW1pbHk6Zy5sYWJlbEZvbnRGYW1pbHksZm9udFdlaWdodDpcIm91dHNpZGVcIj09PWcubGFiZWxQbGFjZW1lbnQ/Zy5vcHRpb25zLmxhYmVsRm9udFdlaWdodD9nLmxhYmVsRm9udFdlaWdodDp0aGlzLmxhYmVsRm9udFdlaWdodDpnLmxhYmVsRm9udFdlaWdodCxmb250Q29sb3I6Zy5sYWJlbEZvbnRDb2xvcnx8Zy5jb2xvcixmb250U3R5bGU6XCJvdXRzaWRlXCI9PT1nLmxhYmVsUGxhY2VtZW50P2cub3B0aW9ucy5sYWJlbEZvbnRTdHlsZT9nLmxhYmVsRm9udFN0eWxlOnRoaXMuZm9udFdlaWdodDpnLmxhYmVsRm9udFN0eWxlLHRleHRCYXNlbGluZTpcIm1pZGRsZVwifSk7dGhpcy5fc3RyaXBMaW5lTGFiZWxzLnB1c2goe3Bvc2l0aW9uOmcudmFsdWUsdGV4dEJsb2NrOmEsXHJcbmVmZmVjdGl2ZUhlaWdodDpudWxsLHN0cmlwTGluZTpnfSl9fTtDLnByb3RvdHlwZS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVXaWR0aD1mdW5jdGlvbigpe3ZhciBhPTAsZj0wO3RoaXMuX2xhYmVscz1bXTt0aGlzLl9zdHJpcExpbmVMYWJlbHM9W107aWYoXCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24pe3RoaXMuY3JlYXRlTGFiZWxzKCk7Zm9yKGY9MDtmPHRoaXMuX2xhYmVscy5sZW5ndGg7ZisrKXt2YXIgYj10aGlzLl9sYWJlbHNbZl0udGV4dEJsb2NrLGM9Yi5tZWFzdXJlVGV4dCgpLGU9MCxlPTA9PT10aGlzLmxhYmVsQW5nbGU/Yy53aWR0aDpjLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpKyhjLmhlaWdodC1iLmZvbnRTaXplLzIpKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpO2E8ZSYmKGE9ZSk7dGhpcy5fbGFiZWxzW2ZdLmVmZmVjdGl2ZVdpZHRoPVxyXG5lfWZvcihmPTA7Zjx0aGlzLl9zdHJpcExpbmVMYWJlbHMubGVuZ3RoO2YrKylcIm91dHNpZGVcIj09PXRoaXMuX3N0cmlwTGluZUxhYmVsc1tmXS5zdHJpcExpbmUubGFiZWxQbGFjZW1lbnQmJih0aGlzLl9zdHJpcExpbmVMYWJlbHNbZl0uc3RyaXBMaW5lLnZhbHVlPnRoaXMudmlld3BvcnRNaW5pbXVtJiZ0aGlzLl9zdHJpcExpbmVMYWJlbHNbZl0uc3RyaXBMaW5lLnZhbHVlPHRoaXMudmlld3BvcnRNYXhpbXVtKSYmKGI9dGhpcy5fc3RyaXBMaW5lTGFiZWxzW2ZdLnRleHRCbG9jayxjPWIubWVhc3VyZVRleHQoKSxlPTA9PT10aGlzLmxhYmVsQW5nbGU/Yy53aWR0aDpjLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpKyhjLmhlaWdodC1iLmZvbnRTaXplLzIpKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpLGE8ZSYmKGE9ZSksdGhpcy5fc3RyaXBMaW5lTGFiZWxzW2ZdLmVmZmVjdGl2ZVdpZHRoPVxyXG5lKX1mPXRoaXMudGl0bGU/dGhpcy5fdGl0bGVUZXh0QmxvY2subWVhc3VyZVRleHQoKS5oZWlnaHQrMjowO3JldHVybiBiPVwiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50P2I9Zis1OmYrYSt0aGlzLnRpY2tMZW5ndGgrNX07Qy5wcm90b3R5cGUuY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlSGVpZ2h0PWZ1bmN0aW9uKCl7dmFyIGE9MDt0aGlzLl9sYWJlbHM9W107dGhpcy5fc3RyaXBMaW5lTGFiZWxzPVtdO3ZhciBmLGI9MDt0aGlzLmNyZWF0ZUxhYmVscygpO2lmKFwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uKXtmb3IoYj0wO2I8dGhpcy5fbGFiZWxzLmxlbmd0aDtiKyspe2Y9dGhpcy5fbGFiZWxzW2JdLnRleHRCbG9jazt2YXIgYz1mLm1lYXN1cmVUZXh0KCksZT0wLGU9MD09PXRoaXMubGFiZWxBbmdsZT9jLmhlaWdodDpjLndpZHRoKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpKyhjLmhlaWdodC1cclxuZi5mb250U2l6ZS8yKSpNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKTthPGUmJihhPWUpO3RoaXMuX2xhYmVsc1tiXS5lZmZlY3RpdmVIZWlnaHQ9ZX1mb3IoYj0wO2I8dGhpcy5fc3RyaXBMaW5lTGFiZWxzLmxlbmd0aDtiKyspXCJvdXRzaWRlXCI9PT10aGlzLl9zdHJpcExpbmVMYWJlbHNbYl0uc3RyaXBMaW5lLmxhYmVsUGxhY2VtZW50JiYoZj10aGlzLl9zdHJpcExpbmVMYWJlbHNbYl0udGV4dEJsb2NrLGM9Zi5tZWFzdXJlVGV4dCgpLGU9MD09PXRoaXMubGFiZWxBbmdsZT9jLmhlaWdodDpjLndpZHRoKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpKyhjLmhlaWdodC1mLmZvbnRTaXplLzIpKk1hdGguY29zKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpLGE8ZSYmKGE9ZSksdGhpcy5fc3RyaXBMaW5lTGFiZWxzW2JdLmVmZmVjdGl2ZUhlaWdodD1lKX1mPXRoaXMudGl0bGU/dGhpcy5fdGl0bGVUZXh0QmxvY2subWVhc3VyZVRleHQoKS5oZWlnaHQrXHJcbjI6MDtyZXR1cm4gYj1cImluc2lkZVwiPT09dGhpcy5sYWJlbFBsYWNlbWVudD9iPWYrNTpmK2ErdGhpcy50aWNrTGVuZ3RoKzV9O0Muc2V0TGF5b3V0QW5kUmVuZGVyPWZ1bmN0aW9uKGEsZixiLGMsZSxnKXt2YXIgaCxsLHQsayxtPWFbMF0/YVswXS5jaGFydDpmWzBdLmNoYXJ0LHA9bS5jdHgsbj1tLl9heGVzO2lmKGEmJjA8YS5sZW5ndGgpZm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspYVtkXSYmYVtkXS5jYWxjdWxhdGVBeGlzUGFyYW1ldGVycygpO2lmKGYmJjA8Zi5sZW5ndGgpZm9yKGQ9MDtkPGYubGVuZ3RoO2QrKylmW2RdLmNhbGN1bGF0ZUF4aXNQYXJhbWV0ZXJzKCk7aWYoYiYmMDxiLmxlbmd0aClmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKWJbZF0uY2FsY3VsYXRlQXhpc1BhcmFtZXRlcnMoKTtpZihjJiYwPGMubGVuZ3RoKWZvcihkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5jYWxjdWxhdGVBeGlzUGFyYW1ldGVycygpO2ZvcihkPTA7ZDxuLmxlbmd0aDtkKyspaWYobltkXSYmXHJcbm5bZF0uc2NhbGVCcmVha3MmJm5bZF0uc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MubGVuZ3RoKWZvcih2YXIgcT1uW2RdLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLHM9MDtzPHEubGVuZ3RoJiYhKHFbc10uc3RhcnRWYWx1ZT5uW2RdLnZpZXdwb3J0TWF4aW11bSk7cysrKXFbc10uZW5kVmFsdWU8bltkXS52aWV3cG9ydE1pbmltdW18fCh5KG5bZF0uc2NhbGVCcmVha3MuZmlyc3RCcmVha0luZGV4KSYmKG5bZF0uc2NhbGVCcmVha3MuZmlyc3RCcmVha0luZGV4PXMpLHFbc10uc3RhcnRWYWx1ZT49bltkXS52aWV3UG9ydE1pbmltdW0mJihuW2RdLnNjYWxlQnJlYWtzLmxhc3RCcmVha0luZGV4PXMpKTtmb3IodmFyIHg9cz0wLHU9MCx6PTAsQz0wLEc9MCxCPTAsQSxILEw9bD0wLEosSSxOLHE9Sj1JPU49ITEsZD0wO2Q8bi5sZW5ndGg7ZCsrKW5bZF0mJm5bZF0udGl0bGUmJihuW2RdLl90aXRsZVRleHRCbG9jaz1uZXcgbGEobltkXS5jdHgse3RleHQ6bltkXS50aXRsZSxob3Jpem9udGFsQWxpZ246XCJjZW50ZXJcIixcclxuZm9udFNpemU6bltkXS50aXRsZUZvbnRTaXplLGZvbnRGYW1pbHk6bltkXS50aXRsZUZvbnRGYW1pbHksZm9udFdlaWdodDpuW2RdLnRpdGxlRm9udFdlaWdodCxmb250Q29sb3I6bltkXS50aXRsZUZvbnRDb2xvcixmb250U3R5bGU6bltkXS50aXRsZUZvbnRTdHlsZSxib3JkZXJDb2xvcjpuW2RdLnRpdGxlQm9yZGVyQ29sb3IsYm9yZGVyVGhpY2tuZXNzOm5bZF0udGl0bGVCb3JkZXJUaGlja25lc3MsYmFja2dyb3VuZENvbG9yOm5bZF0udGl0bGVCYWNrZ3JvdW5kQ29sb3IsY29ybmVyUmFkaXVzOm5bZF0udGl0bGVDb3JuZXJSYWRpdXMsdGV4dEJhc2VsaW5lOlwidG9wXCJ9KSk7Zm9yKGQ9MDtkPG4ubGVuZ3RoO2QrKylpZihuW2RdLnRpdGxlKXN3aXRjaChuW2RdLl9wb3NpdGlvbil7Y2FzZSBcImxlZnRcIjpuW2RdLl90aXRsZVRleHRCbG9jay5tYXhXaWR0aD1uW2RdLnRpdGxlTWF4V2lkdGh8fGcuaGVpZ2h0O25bZF0uX3RpdGxlVGV4dEJsb2NrLm1heEhlaWdodD1uW2RdLnRpdGxlV3JhcD9cclxuMC44Kmcud2lkdGg6MS41Km5bZF0udGl0bGVGb250U2l6ZTtuW2RdLl90aXRsZVRleHRCbG9jay5hbmdsZT0tOTA7YnJlYWs7Y2FzZSBcInJpZ2h0XCI6bltkXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9bltkXS50aXRsZU1heFdpZHRofHxnLmhlaWdodDtuW2RdLl90aXRsZVRleHRCbG9jay5tYXhIZWlnaHQ9bltkXS50aXRsZVdyYXA/MC44Kmcud2lkdGg6MS41Km5bZF0udGl0bGVGb250U2l6ZTtuW2RdLl90aXRsZVRleHRCbG9jay5hbmdsZT05MDticmVhaztkZWZhdWx0Om5bZF0uX3RpdGxlVGV4dEJsb2NrLm1heFdpZHRoPW5bZF0udGl0bGVNYXhXaWR0aHx8Zy53aWR0aCxuW2RdLl90aXRsZVRleHRCbG9jay5tYXhIZWlnaHQ9bltkXS50aXRsZVdyYXA/MC44KmcuaGVpZ2h0OjEuNSpuW2RdLnRpdGxlRm9udFNpemUsbltkXS5fdGl0bGVUZXh0QmxvY2suYW5nbGU9MH1pZihcIm5vcm1hbFwiPT09ZSl7Zm9yKHZhciB6PVtdLEM9W10sRz1bXSxCPVtdLE89W10sUD1bXSxSPVtdLFE9W107ND5cclxuczspe3ZhciBFPTAsVD0wLFU9MCxYPTAsVj1lPTAsSz0wLFo9MCxZPTAsVz0wLE09MCxhYT0wO2lmKGImJjA8Yi5sZW5ndGgpZm9yKEc9W10sZD1NPTA7ZDxiLmxlbmd0aDtkKyspRy5wdXNoKE1hdGguY2VpbChiW2RdP2JbZF0uY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlV2lkdGgoKTowKSksTSs9R1tkXSxLKz1iW2RdP2JbZF0ubWFyZ2luOjA7ZWxzZSBHLnB1c2goTWF0aC5jZWlsKGJbMF0/YlswXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVXaWR0aCgpOjApKTtSLnB1c2goRyk7aWYoYyYmMDxjLmxlbmd0aClmb3IoQj1bXSxkPWFhPTA7ZDxjLmxlbmd0aDtkKyspQi5wdXNoKE1hdGguY2VpbChjW2RdP2NbZF0uY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlV2lkdGgoKTowKSksYWErPUJbZF0sWis9Y1tkXT9jW2RdLm1hcmdpbjowO2Vsc2UgQi5wdXNoKE1hdGguY2VpbChjWzBdP2NbMF0uY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlV2lkdGgoKTowKSk7US5wdXNoKEIpO2g9TWF0aC5yb3VuZChnLngxK1xyXG5NK0spO3Q9TWF0aC5yb3VuZChnLngyLWFhLVo+bS53aWR0aC0xMD9tLndpZHRoLTEwOmcueDItYWEtWik7aWYoYSYmMDxhLmxlbmd0aClmb3Ioej1bXSxkPVk9MDtkPGEubGVuZ3RoO2QrKylhW2RdJiYoYVtkXS5saW5lQ29vcmRpbmF0ZXM9e30pLGFbZF0ubGluZUNvb3JkaW5hdGVzLndpZHRoPU1hdGguYWJzKHQtaCksYVtkXS50aXRsZSYmKGFbZF0uX3RpdGxlVGV4dEJsb2NrLm1heFdpZHRoPTA8YVtkXS50aXRsZU1heFdpZHRoJiZhW2RdLnRpdGxlTWF4V2lkdGg8YVtkXS5saW5lQ29vcmRpbmF0ZXMud2lkdGg/YVtkXS50aXRsZU1heFdpZHRoOmFbZF0ubGluZUNvb3JkaW5hdGVzLndpZHRoKSx6LnB1c2goTWF0aC5jZWlsKGFbZF0/YVtkXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVIZWlnaHQoKTowKSksWSs9eltkXSxlKz1hW2RdP2FbZF0ubWFyZ2luOjA7ZWxzZSB6LnB1c2goTWF0aC5jZWlsKGFbMF0/YVswXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVIZWlnaHQoKTowKSk7XHJcbk8ucHVzaCh6KTtpZihmJiYwPGYubGVuZ3RoKWZvcihDPVtdLGQ9Vz0wO2Q8Zi5sZW5ndGg7ZCsrKWZbZF0mJihmW2RdLmxpbmVDb29yZGluYXRlcz17fSksZltkXS5saW5lQ29vcmRpbmF0ZXMud2lkdGg9TWF0aC5hYnModC1oKSxmW2RdLnRpdGxlJiYoZltkXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9MDxmW2RdLnRpdGxlTWF4V2lkdGgmJmZbZF0udGl0bGVNYXhXaWR0aDxmW2RdLmxpbmVDb29yZGluYXRlcy53aWR0aD9mW2RdLnRpdGxlTWF4V2lkdGg6ZltkXS5saW5lQ29vcmRpbmF0ZXMud2lkdGgpLEMucHVzaChNYXRoLmNlaWwoZltkXT9mW2RdLmNyZWF0ZUxhYmVsc0FuZENhbGN1bGF0ZUhlaWdodCgpOjApKSxXKz1DW2RdLFYrPWZbZF0/ZltkXS5tYXJnaW46MDtlbHNlIEMucHVzaChNYXRoLmNlaWwoZlswXT9mWzBdLmNyZWF0ZUxhYmVsc0FuZENhbGN1bGF0ZUhlaWdodCgpOjApKTtQLnB1c2goQyk7aWYoYSYmMDxhLmxlbmd0aClmb3IoZD0wO2Q8YS5sZW5ndGg7ZCsrKWFbZF0mJlxyXG4oYVtkXS5saW5lQ29vcmRpbmF0ZXMueDE9aCx0PU1hdGgucm91bmQoZy54Mi1hYS1aPm0ud2lkdGgtMTA/bS53aWR0aC0xMDpnLngyLWFhLVopLGFbZF0uX2xhYmVscyYmMTxhW2RdLl9sYWJlbHMubGVuZ3RoJiYobD1rPTAsaz1hW2RdLl9sYWJlbHNbMV0sbD1cImRhdGVUaW1lXCI9PT1hW2RdLnZhbHVlVHlwZT9hW2RdLl9sYWJlbHNbYVtkXS5fbGFiZWxzLmxlbmd0aC0yXTphW2RdLl9sYWJlbHNbYVtkXS5fbGFiZWxzLmxlbmd0aC0xXSx4PWsudGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKk1hdGguYWJzKGsudGV4dEJsb2NrLmFuZ2xlKSkrKGsudGV4dEJsb2NrLmhlaWdodC1sLnRleHRCbG9jay5mb250U2l6ZS8yKSpNYXRoLnNpbihNYXRoLlBJLzE4MCpNYXRoLmFicyhrLnRleHRCbG9jay5hbmdsZSkpLHU9bC50ZXh0QmxvY2sud2lkdGgqTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnMobC50ZXh0QmxvY2suYW5nbGUpKSsobC50ZXh0QmxvY2suaGVpZ2h0LVxyXG5sLnRleHRCbG9jay5mb250U2l6ZS8yKSpNYXRoLnNpbihNYXRoLlBJLzE4MCpNYXRoLmFicyhsLnRleHRCbG9jay5hbmdsZSkpKSxhW2RdJiYoYVtkXS5sYWJlbEF1dG9GaXQmJiF5KEEpJiYheShIKSkmJihsPTAsMDxhW2RdLmxhYmVsQW5nbGU/SCt1PnQmJihsKz0wPGFbZF0ubGFiZWxBbmdsZT9IK3UtdC1hYTowKTowPmFbZF0ubGFiZWxBbmdsZT9BLXg8aCYmQS14PGFbZF0udmlld3BvcnRNaW5pbXVtJiYoTD1oLShLK2FbZF0udGlja0xlbmd0aCtHK0EteCthW2RdLmxhYmVsRm9udFNpemUvMikpOjA9PT1hW2RdLmxhYmVsQW5nbGUmJihIK3U+dCYmKGw9SCt1LzItdC1hYSksQS14PGgmJkEteDxhW2RdLnZpZXdwb3J0TWluaW11bSYmKEw9aC1LLWFbZF0udGlja0xlbmd0aC1HLUEreC8yKSksYVtkXS52aWV3cG9ydE1heGltdW09PT1hW2RdLm1heGltdW0mJmFbZF0udmlld3BvcnRNaW5pbXVtPT09YVtkXS5taW5pbXVtJiYwPGFbZF0ubGFiZWxBbmdsZSYmMDxsP3QtPWw6YVtkXS52aWV3cG9ydE1heGltdW09PT1cclxuYVtkXS5tYXhpbXVtJiZhW2RdLnZpZXdwb3J0TWluaW11bT09PWFbZF0ubWluaW11bSYmMD5hW2RdLmxhYmVsQW5nbGUmJjA8TD9oKz1MOmFbZF0udmlld3BvcnRNYXhpbXVtPT09YVtkXS5tYXhpbXVtJiZhW2RdLnZpZXdwb3J0TWluaW11bT09PWFbZF0ubWluaW11bSYmMD09PWFbZF0ubGFiZWxBbmdsZSYmKDA8TCYmKGgrPUwpLDA8bCYmKHQtPWwpKSksbS5wYW5FbmFibGVkP1k9bS5zZXNzaW9uVmFyaWFibGVzLmF4aXNYLmhlaWdodDptLnNlc3Npb25WYXJpYWJsZXMuYXhpc1guaGVpZ2h0PVksbD1NYXRoLnJvdW5kKGcueTItWS1lK0UpLGs9TWF0aC5yb3VuZChnLnkyKSxhW2RdLmxpbmVDb29yZGluYXRlcy54Mj10LGFbZF0ubGluZUNvb3JkaW5hdGVzLndpZHRoPXQtaCxhW2RdLmxpbmVDb29yZGluYXRlcy55MT1sLGFbZF0ubGluZUNvb3JkaW5hdGVzLnkyPWwsYVtkXS5ib3VuZHM9e3gxOmgseTE6bCx4Mjp0LHkyOmstKFkrZS16W2RdLUUpLHdpZHRoOnQtaCxoZWlnaHQ6ay1sfSksXHJcbkUrPXpbZF0rYVtkXS5tYXJnaW47aWYoZiYmMDxmLmxlbmd0aClmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCsrKWZbZF0ubGluZUNvb3JkaW5hdGVzLngxPU1hdGgucm91bmQoZy54MStNK0spLGZbZF0ubGluZUNvb3JkaW5hdGVzLngyPU1hdGgucm91bmQoZy54Mi1hYS1aPm0ud2lkdGgtMTA/bS53aWR0aC0xMDpnLngyLWFhLVopLGZbZF0ubGluZUNvb3JkaW5hdGVzLndpZHRoPU1hdGguYWJzKHQtaCksZltkXS5fbGFiZWxzJiYxPGZbZF0uX2xhYmVscy5sZW5ndGgmJihrPWZbZF0uX2xhYmVsc1sxXSxsPVwiZGF0ZVRpbWVcIj09PWZbZF0udmFsdWVUeXBlP2ZbZF0uX2xhYmVsc1tmW2RdLl9sYWJlbHMubGVuZ3RoLTJdOmZbZF0uX2xhYmVsc1tmW2RdLl9sYWJlbHMubGVuZ3RoLTFdLHg9ay50ZXh0QmxvY2sud2lkdGgqTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnMoay50ZXh0QmxvY2suYW5nbGUpKSsoay50ZXh0QmxvY2suaGVpZ2h0LWwudGV4dEJsb2NrLmZvbnRTaXplLzIpKk1hdGguc2luKE1hdGguUEkvXHJcbjE4MCpNYXRoLmFicyhrLnRleHRCbG9jay5hbmdsZSkpLHU9bC50ZXh0QmxvY2sud2lkdGgqTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnMobC50ZXh0QmxvY2suYW5nbGUpKSsobC50ZXh0QmxvY2suaGVpZ2h0LWwudGV4dEJsb2NrLmZvbnRTaXplLzIpKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKGwudGV4dEJsb2NrLmFuZ2xlKSkpLG0ucGFuRW5hYmxlZD9XPW0uc2Vzc2lvblZhcmlhYmxlcy5heGlzWDIuaGVpZ2h0Om0uc2Vzc2lvblZhcmlhYmxlcy5heGlzWDIuaGVpZ2h0PVcsbD1NYXRoLnJvdW5kKGcueTEpLGs9TWF0aC5yb3VuZChnLnkyK2ZbZF0ubWFyZ2luKSxmW2RdLmxpbmVDb29yZGluYXRlcy55MT1sK1crVi1ULGZbZF0ubGluZUNvb3JkaW5hdGVzLnkyPWwsZltkXS5ib3VuZHM9e3gxOmgseTE6bCsoVytWLUNbZF0tVCkseDI6dCx5MjprLHdpZHRoOnQtaCxoZWlnaHQ6ay1sfSxUKz1DW2RdK2ZbZF0ubWFyZ2luO2lmKGImJjA8Yi5sZW5ndGgpZm9yKGQ9MDtkPFxyXG5iLmxlbmd0aDtkKyspSz0xMCxiW2RdJiYoaD1NYXRoLnJvdW5kKGFbMF0/YVswXS5saW5lQ29vcmRpbmF0ZXMueDE6ZlswXS5saW5lQ29vcmRpbmF0ZXMueDEpLEs9YltkXS5fbGFiZWxzJiYwPGJbZF0uX2xhYmVscy5sZW5ndGg/YltkXS5fbGFiZWxzW2JbZF0uX2xhYmVscy5sZW5ndGgtMV0udGV4dEJsb2NrLmhlaWdodC8yOjEwLGw9TWF0aC5yb3VuZChnLnkxK1crVjxNYXRoLm1heChLLDEwKT9NYXRoLm1heChLLDEwKTpnLnkxK1crViksdD1NYXRoLnJvdW5kKGFbMF0/YVswXS5saW5lQ29vcmRpbmF0ZXMueDE6ZlswXS5saW5lQ29vcmRpbmF0ZXMueDEpLEs9MDxhLmxlbmd0aD8wOmJbZF0uX2xhYmVscyYmMDxiW2RdLl9sYWJlbHMubGVuZ3RoP2JbZF0uX2xhYmVsc1swXS50ZXh0QmxvY2suaGVpZ2h0LzI6MTAsaz1NYXRoLnJvdW5kKGcueTItWS1lLUspLGJbZF0ubGluZUNvb3JkaW5hdGVzPXt4MTp0LVUseTE6bCx4Mjp0LVUseTI6ayxoZWlnaHQ6TWF0aC5hYnMoay1sKX0sYltkXS5ib3VuZHM9XHJcbnt4MTpoLShHW2RdK1UpLHkxOmwseDI6dCx5MjprLHdpZHRoOnQtaCxoZWlnaHQ6ay1sfSxiW2RdLnRpdGxlJiYoYltkXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9MDxiW2RdLnRpdGxlTWF4V2lkdGgmJmJbZF0udGl0bGVNYXhXaWR0aDxiW2RdLmxpbmVDb29yZGluYXRlcy5oZWlnaHQ/YltkXS50aXRsZU1heFdpZHRoOmJbZF0ubGluZUNvb3JkaW5hdGVzLmhlaWdodCksVSs9R1tkXStiW2RdLm1hcmdpbik7aWYoYyYmMDxjLmxlbmd0aClmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0mJihoPU1hdGgucm91bmQoYVswXT9hWzBdLmxpbmVDb29yZGluYXRlcy54MjpmWzBdLmxpbmVDb29yZGluYXRlcy54MiksdD1NYXRoLnJvdW5kKGgpLEs9Y1tkXS5fbGFiZWxzJiYwPGNbZF0uX2xhYmVscy5sZW5ndGg/Y1tkXS5fbGFiZWxzW2NbZF0uX2xhYmVscy5sZW5ndGgtMV0udGV4dEJsb2NrLmhlaWdodC8yOjAsbD1NYXRoLnJvdW5kKGcueTErVytWPE1hdGgubWF4KEssMTApP01hdGgubWF4KEssXHJcbjEwKTpnLnkxK1crViksSz0wPGEubGVuZ3RoPzA6Y1tkXS5fbGFiZWxzJiYwPGNbZF0uX2xhYmVscy5sZW5ndGg/Y1tkXS5fbGFiZWxzWzBdLnRleHRCbG9jay5oZWlnaHQvMjowLGs9TWF0aC5yb3VuZChnLnkyLShZK2UrSykpLGNbZF0ubGluZUNvb3JkaW5hdGVzPXt4MTpoK1gseTE6bCx4MjpoK1gseTI6ayxoZWlnaHQ6TWF0aC5hYnMoay1sKX0sY1tkXS5ib3VuZHM9e3gxOmgseTE6bCx4Mjp0KyhCW2RdK1gpLHkyOmssd2lkdGg6dC1oLGhlaWdodDprLWx9LGNbZF0udGl0bGUmJihjW2RdLl90aXRsZVRleHRCbG9jay5tYXhXaWR0aD0wPGNbZF0udGl0bGVNYXhXaWR0aCYmY1tkXS50aXRsZU1heFdpZHRoPGNbZF0ubGluZUNvb3JkaW5hdGVzLmhlaWdodD9jW2RdLnRpdGxlTWF4V2lkdGg6Y1tkXS5saW5lQ29vcmRpbmF0ZXMuaGVpZ2h0KSxYKz1CW2RdK2NbZF0ubWFyZ2luKTtpZihhJiYwPGEubGVuZ3RoKWZvcihkPTA7ZDxhLmxlbmd0aDtkKyspYVtkXSYmKGFbZF0uY2FsY3VsYXRlVmFsdWVUb1BpeGVsQ29udmVyc2lvblBhcmFtZXRlcnMoKSxcclxuYVtkXS5jYWxjdWxhdGVCcmVha3NTaXplSW5WYWx1ZXMoKSxhW2RdLl9sYWJlbHMmJjE8YVtkXS5fbGFiZWxzLmxlbmd0aCYmKEE9KGFbZF0ubG9nYXJpdGhtaWM/TWF0aC5sb2coYVtkXS5fbGFiZWxzWzFdLnBvc2l0aW9uL2FbZF0udmlld3BvcnRNaW5pbXVtKS9hW2RdLmNvbnZlcnNpb25QYXJhbWV0ZXJzLmxuTG9nYXJpdGhtQmFzZTphW2RdLl9sYWJlbHNbMV0ucG9zaXRpb24tYVtkXS52aWV3cG9ydE1pbmltdW0pKk1hdGguYWJzKGFbZF0uY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0KSthW2RdLmxpbmVDb29yZGluYXRlcy54MSxoPWFbZF0uX2xhYmVsc1thW2RdLl9sYWJlbHMubGVuZ3RoLShcImRhdGVUaW1lXCI9PT1hW2RdLnZhbHVlVHlwZT8yOjEpXS5wb3NpdGlvbixoPWFbZF0uZ2V0QXBwYXJlbnREaWZmZXJlbmNlKGFbZF0udmlld3BvcnRNaW5pbXVtLGgpLEg9YVtkXS5sb2dhcml0aG1pYz8oMTxoP01hdGgubG9nKGgpL2FbZF0uY29udmVyc2lvblBhcmFtZXRlcnMubG5Mb2dhcml0aG1CYXNlKlxyXG5NYXRoLmFicyhhW2RdLmNvbnZlcnNpb25QYXJhbWV0ZXJzLnBpeGVsUGVyVW5pdCk6MCkrYVtkXS5saW5lQ29vcmRpbmF0ZXMueDE6KDA8aD9oKk1hdGguYWJzKGFbZF0uY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0KTowKSthW2RdLmxpbmVDb29yZGluYXRlcy54MSkpO2lmKGYmJjA8Zi5sZW5ndGgpZm9yKGQ9MDtkPGYubGVuZ3RoO2QrKylmW2RdLmNhbGN1bGF0ZVZhbHVlVG9QaXhlbENvbnZlcnNpb25QYXJhbWV0ZXJzKCksZltkXS5jYWxjdWxhdGVCcmVha3NTaXplSW5WYWx1ZXMoKSxmW2RdLl9sYWJlbHMmJjE8ZltkXS5fbGFiZWxzLmxlbmd0aCYmKEE9KGZbZF0ubG9nYXJpdGhtaWM/TWF0aC5sb2coZltkXS5fbGFiZWxzWzFdLnBvc2l0aW9uL2ZbZF0udmlld3BvcnRNaW5pbXVtKS9mW2RdLmNvbnZlcnNpb25QYXJhbWV0ZXJzLmxuTG9nYXJpdGhtQmFzZTpmW2RdLl9sYWJlbHNbMV0ucG9zaXRpb24tZltkXS52aWV3cG9ydE1pbmltdW0pKk1hdGguYWJzKGZbZF0uY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0KStcclxuZltkXS5saW5lQ29vcmRpbmF0ZXMueDEsaD1mW2RdLl9sYWJlbHNbZltkXS5fbGFiZWxzLmxlbmd0aC0oXCJkYXRlVGltZVwiPT09ZltkXS52YWx1ZVR5cGU/MjoxKV0ucG9zaXRpb24saD1mW2RdLmdldEFwcGFyZW50RGlmZmVyZW5jZShmW2RdLnZpZXdwb3J0TWluaW11bSxoKSxIPWZbZF0ubG9nYXJpdGhtaWM/KDE8aD9NYXRoLmxvZyhoKS9mW2RdLmNvbnZlcnNpb25QYXJhbWV0ZXJzLmxuTG9nYXJpdGhtQmFzZSpNYXRoLmFicyhmW2RdLmNvbnZlcnNpb25QYXJhbWV0ZXJzLnBpeGVsUGVyVW5pdCk6MCkrZltkXS5saW5lQ29vcmRpbmF0ZXMueDE6KDA8aD9oKk1hdGguYWJzKGZbZF0uY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0KTowKStmW2RdLmxpbmVDb29yZGluYXRlcy54MSk7Zm9yKGQ9MDtkPG4ubGVuZ3RoO2QrKylcImF4aXNZXCI9PT1uW2RdLnR5cGUmJihuW2RdLmNhbGN1bGF0ZVZhbHVlVG9QaXhlbENvbnZlcnNpb25QYXJhbWV0ZXJzKCksbltkXS5jYWxjdWxhdGVCcmVha3NTaXplSW5WYWx1ZXMoKSk7XHJcbmlmKDA8cyl7aWYoYSYmMDxhLmxlbmd0aClmb3IoZD0wO2Q8YS5sZW5ndGg7ZCsrKXE9T1tzLTFdW2RdPT09T1tzXVtkXT8hMDohMTtlbHNlIHE9ITA7aWYoZiYmMDxmLmxlbmd0aClmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCsrKUo9UFtzLTFdW2RdPT09UFtzXVtkXT8hMDohMTtlbHNlIEo9ITA7aWYoYiYmMDxiLmxlbmd0aClmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKUk9UltzLTFdW2RdPT09UltzXVtkXT8hMDohMTtlbHNlIEk9ITA7aWYoYyYmMDxjLmxlbmd0aClmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKU49UVtzLTFdW2RdPT09UVtzXVtkXT8hMDohMTtlbHNlIE49ITB9aWYocSYmSiYmSSYmTilicmVhaztzKyt9cC5zYXZlKCk7cC5iZWdpblBhdGgoKTthWzBdJiZwLnJlY3QoNSxhWzBdLmJvdW5kcy55MSxhWzBdLmNoYXJ0LndpZHRoLTEwLGFbMF0uYm91bmRzLmhlaWdodCk7ZlswXSYmcC5yZWN0KDUsZltmLmxlbmd0aC0xXS5ib3VuZHMueTEsZlswXS5jaGFydC53aWR0aC0xMCxmWzBdLmJvdW5kcy5oZWlnaHQpO1xyXG5wLmNsaXAoKTtpZihhJiYwPGEubGVuZ3RoKWZvcihkPTA7ZDxhLmxlbmd0aDtkKyspYVtkXS5jYWxjdWxhdGVTdHJpcExpbmVzVGhpY2tuZXNzSW5WYWx1ZXMoKSxhW2RdLmNhbGN1bGF0ZUJyZWFrc0luUGl4ZWxzKCksYVtkXS5yZW5kZXJMYWJlbHNUaWNrc0FuZFRpdGxlKCk7aWYoZiYmMDxmLmxlbmd0aClmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCsrKWZbZF0uY2FsY3VsYXRlU3RyaXBMaW5lc1RoaWNrbmVzc0luVmFsdWVzKCksZltkXS5jYWxjdWxhdGVCcmVha3NJblBpeGVscygpLGZbZF0ucmVuZGVyTGFiZWxzVGlja3NBbmRUaXRsZSgpO3AucmVzdG9yZSgpO2lmKGImJjA8Yi5sZW5ndGgpZm9yKGQ9MDtkPGIubGVuZ3RoO2QrKyliW2RdLmNhbGN1bGF0ZVN0cmlwTGluZXNUaGlja25lc3NJblZhbHVlcygpLGJbZF0uY2FsY3VsYXRlQnJlYWtzSW5QaXhlbHMoKSxiW2RdLnJlbmRlckxhYmVsc1RpY2tzQW5kVGl0bGUoKTtpZihjJiYwPGMubGVuZ3RoKWZvcihkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5jYWxjdWxhdGVTdHJpcExpbmVzVGhpY2tuZXNzSW5WYWx1ZXMoKSxcclxuY1tkXS5jYWxjdWxhdGVCcmVha3NJblBpeGVscygpLGNbZF0ucmVuZGVyTGFiZWxzVGlja3NBbmRUaXRsZSgpfWVsc2V7QT1bXTtMPVtdO3g9W107SD1bXTt1PVtdO089W107UD1bXTtmb3IoUj1bXTs0PnM7KXtXPVk9TT1YPVo9Sz1WPWU9VT1RPVQ9RT0wO2lmKGEmJjA8YS5sZW5ndGgpZm9yKHg9W10sZD1ZPTA7ZDxhLmxlbmd0aDtkKyspeC5wdXNoKE1hdGguY2VpbChhW2RdP2FbZF0uY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlV2lkdGgoKTowKSksWSs9eFtkXSxlKz1hW2RdP2FbZF0ubWFyZ2luOjA7ZWxzZSB4LnB1c2goTWF0aC5jZWlsKGFbMF0/YVswXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVXaWR0aCgpOjApKTtQLnB1c2goeCk7aWYoZiYmMDxmLmxlbmd0aClmb3IoSD1bXSxkPVc9MDtkPGYubGVuZ3RoO2QrKylILnB1c2goTWF0aC5jZWlsKGZbZF0/ZltkXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVXaWR0aCgpOjApKSxXKz1IW2RdLFYrPWZbZF0/ZltkXS5tYXJnaW46XHJcbjA7ZWxzZSBILnB1c2goTWF0aC5jZWlsKGZbMF0/ZlswXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVXaWR0aCgpOjApKTtSLnB1c2goSCk7aWYoYiYmMDxiLmxlbmd0aClmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKWJbZF0ubGluZUNvb3JkaW5hdGVzPXt9LGg9TWF0aC5yb3VuZChnLngxK1krZSksdD1NYXRoLnJvdW5kKGcueDItVy1WPm0ud2lkdGgtMTA/bS53aWR0aC0xMDpnLngyLVctViksYltkXS5sYWJlbEF1dG9GaXQmJiF5KHopJiYoMDwhYS5sZW5ndGgmJihoPTA+YltkXS5sYWJlbEFuZ2xlP01hdGgubWF4KGgseik6MD09PWJbZF0ubGFiZWxBbmdsZT9NYXRoLm1heChoLHovMik6aCksMDwhZi5sZW5ndGgmJih0PTA8YltkXS5sYWJlbEFuZ2xlP3QtQy8yOjA9PT1iW2RdLmxhYmVsQW5nbGU/dC1DLzI6dCkpLGJbZF0ubGluZUNvb3JkaW5hdGVzLngxPWgsYltkXS5saW5lQ29vcmRpbmF0ZXMueDI9dCxiW2RdLmxpbmVDb29yZGluYXRlcy53aWR0aD1NYXRoLmFicyh0LWgpLGJbZF0udGl0bGUmJlxyXG4oYltkXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9MDxiW2RdLnRpdGxlTWF4V2lkdGgmJmJbZF0udGl0bGVNYXhXaWR0aDxiW2RdLmxpbmVDb29yZGluYXRlcy53aWR0aD9iW2RdLnRpdGxlTWF4V2lkdGg6YltkXS5saW5lQ29vcmRpbmF0ZXMud2lkdGgpO2lmKGMmJjA8Yy5sZW5ndGgpZm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyljW2RdLmxpbmVDb29yZGluYXRlcz17fSxoPU1hdGgucm91bmQoZy54MStZK2UpLHQ9TWF0aC5yb3VuZChnLngyLVctVj5jW2RdLmNoYXJ0LndpZHRoLTEwP2NbZF0uY2hhcnQud2lkdGgtMTA6Zy54Mi1XLVYpLGNbZF0mJmNbZF0ubGFiZWxBdXRvRml0JiYheShHKSYmKDA8IWEubGVuZ3RoJiYoaD0wPGNbZF0ubGFiZWxBbmdsZT9NYXRoLm1heChoLEcpOjA9PT1jW2RdLmxhYmVsQW5nbGU/TWF0aC5tYXgoaCxHLzIpOmgpLDA8IWYubGVuZ3RoJiYodC09Qi8yKSksY1tkXS5saW5lQ29vcmRpbmF0ZXMueDE9aCxjW2RdLmxpbmVDb29yZGluYXRlcy54Mj10LGNbZF0ubGluZUNvb3JkaW5hdGVzLndpZHRoPVxyXG5NYXRoLmFicyh0LWgpLGNbZF0udGl0bGUmJihjW2RdLl90aXRsZVRleHRCbG9jay5tYXhXaWR0aD0wPGNbZF0udGl0bGVNYXhXaWR0aCYmY1tkXS50aXRsZU1heFdpZHRoPGNbZF0ubGluZUNvb3JkaW5hdGVzLndpZHRoP2NbZF0udGl0bGVNYXhXaWR0aDpjW2RdLmxpbmVDb29yZGluYXRlcy53aWR0aCk7aWYoYiYmMDxiLmxlbmd0aClmb3IoQT1bXSxkPVg9MDtkPGIubGVuZ3RoO2QrKylBLnB1c2goTWF0aC5jZWlsKGJbZF0/YltkXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVIZWlnaHQoKTowKSksWCs9QVtkXStiW2RdLm1hcmdpbixLKz1iW2RdLm1hcmdpbjtlbHNlIEEucHVzaChNYXRoLmNlaWwoYlswXT9iWzBdLmNyZWF0ZUxhYmVsc0FuZENhbGN1bGF0ZUhlaWdodCgpOjApKTt1LnB1c2goQSk7aWYoYyYmMDxjLmxlbmd0aClmb3IoTD1bXSxkPU09MDtkPGMubGVuZ3RoO2QrKylMLnB1c2goTWF0aC5jZWlsKGNbZF0/Y1tkXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVIZWlnaHQoKTpcclxuMCkpLE0rPUxbZF0sWis9Y1tkXS5tYXJnaW47ZWxzZSBMLnB1c2goTWF0aC5jZWlsKGNbMF0/Y1swXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVIZWlnaHQoKTowKSk7Ty5wdXNoKEwpO2lmKGImJjA8Yi5sZW5ndGgpZm9yKGQ9MDtkPGIubGVuZ3RoO2QrKykwPGJbZF0uX2xhYmVscy5sZW5ndGgmJihrPWJbZF0uX2xhYmVsc1swXSxsPWJbZF0uX2xhYmVsc1tiW2RdLl9sYWJlbHMubGVuZ3RoLTFdLHo9ay50ZXh0QmxvY2sud2lkdGgqTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnMoay50ZXh0QmxvY2suYW5nbGUpKSsoay50ZXh0QmxvY2suaGVpZ2h0LWwudGV4dEJsb2NrLmZvbnRTaXplLzIpKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKGsudGV4dEJsb2NrLmFuZ2xlKSksQz1sLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyhsLnRleHRCbG9jay5hbmdsZSkpKyhsLnRleHRCbG9jay5oZWlnaHQtbC50ZXh0QmxvY2suZm9udFNpemUvXHJcbjIpKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKGwudGV4dEJsb2NrLmFuZ2xlKSkpO2lmKGMmJjA8Yy5sZW5ndGgpZm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyljW2RdJiYwPGNbZF0uX2xhYmVscy5sZW5ndGgmJihrPWNbZF0uX2xhYmVsc1swXSxsPWNbZF0uX2xhYmVsc1tjW2RdLl9sYWJlbHMubGVuZ3RoLTFdLEc9ay50ZXh0QmxvY2sud2lkdGgqTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnMoay50ZXh0QmxvY2suYW5nbGUpKSsoay50ZXh0QmxvY2suaGVpZ2h0LWwudGV4dEJsb2NrLmZvbnRTaXplLzIpKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKGsudGV4dEJsb2NrLmFuZ2xlKSksQj1sLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyhsLnRleHRCbG9jay5hbmdsZSkpKyhsLnRleHRCbG9jay5oZWlnaHQtbC50ZXh0QmxvY2suZm9udFNpemUvMikqTWF0aC5zaW4oTWF0aC5QSS8xODAqTWF0aC5hYnMobC50ZXh0QmxvY2suYW5nbGUpKSk7XHJcbmlmKG0ucGFuRW5hYmxlZClmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKUFbZF09bS5zZXNzaW9uVmFyaWFibGVzLmF4aXNZLmhlaWdodDtlbHNlIGZvcihkPTA7ZDxiLmxlbmd0aDtkKyspbS5zZXNzaW9uVmFyaWFibGVzLmF4aXNZLmhlaWdodD1BW2RdO2lmKGImJjA8Yi5sZW5ndGgpZm9yKGQ9Yi5sZW5ndGgtMTswPD1kO2QtLSlsPU1hdGgucm91bmQoZy55Miksaz1NYXRoLnJvdW5kKGcueTI+YltkXS5jaGFydC5oZWlnaHQtMTA/YltkXS5jaGFydC5oZWlnaHQtMTA6Zy55MiksYltkXS5saW5lQ29vcmRpbmF0ZXMueTE9bC0oQVtkXStiW2RdLm1hcmdpbitFKSxiW2RdLmxpbmVDb29yZGluYXRlcy55Mj1sLShBW2RdK2JbZF0ubWFyZ2luK0UpLGJbZF0uYm91bmRzPXt4MTpoLHkxOmwtKEFbZF0rRStiW2RdLm1hcmdpbikseDI6dCx5MjprLShFK2JbZF0ubWFyZ2luKSx3aWR0aDp0LWgsaGVpZ2h0OkFbZF19LGJbZF0udGl0bGUmJihiW2RdLl90aXRsZVRleHRCbG9jay5tYXhXaWR0aD0wPFxyXG5iW2RdLnRpdGxlTWF4V2lkdGgmJmJbZF0udGl0bGVNYXhXaWR0aDxiW2RdLmxpbmVDb29yZGluYXRlcy53aWR0aD9iW2RdLnRpdGxlTWF4V2lkdGg6YltkXS5saW5lQ29vcmRpbmF0ZXMud2lkdGgpLEUrPUFbZF0rYltkXS5tYXJnaW47aWYoYyYmMDxjLmxlbmd0aClmb3IoZD1jLmxlbmd0aC0xOzA8PWQ7ZC0tKWNbZF0mJihsPU1hdGgucm91bmQoZy55MSksaz1NYXRoLnJvdW5kKGcueTErKExbZF0rY1tkXS5tYXJnaW4rVCkpLGNbZF0ubGluZUNvb3JkaW5hdGVzLnkxPWssY1tkXS5saW5lQ29vcmRpbmF0ZXMueTI9ayxjW2RdLmJvdW5kcz17eDE6aCx5MTpsKyhjW2RdLm1hcmdpbitUKSx4Mjp0LHkyOmssd2lkdGg6dC1oLGhlaWdodDpNfSxjW2RdLnRpdGxlJiYoY1tkXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9MDxjW2RdLnRpdGxlTWF4V2lkdGgmJmNbZF0udGl0bGVNYXhXaWR0aDxjW2RdLmxpbmVDb29yZGluYXRlcy53aWR0aD9jW2RdLnRpdGxlTWF4V2lkdGg6Y1tkXS5saW5lQ29vcmRpbmF0ZXMud2lkdGgpLFxyXG5UKz1MW2RdK2NbZF0ubWFyZ2luKTtpZihhJiYwPGEubGVuZ3RoKWZvcihkPTA7ZDxhLmxlbmd0aDtkKyspe0s9YVtkXS5fbGFiZWxzJiYwPGFbZF0uX2xhYmVscy5sZW5ndGg/YVtkXS5fbGFiZWxzWzBdLnRleHRCbG9jay5mb250U2l6ZS8yOjA7aD1NYXRoLnJvdW5kKGcueDErZSk7bD1jJiYwPGMubGVuZ3RoP01hdGgucm91bmQoY1swXT9jWzBdLmxpbmVDb29yZGluYXRlcy55MjpnLnkxPE1hdGgubWF4KEssMTApP01hdGgubWF4KEssMTApOmcueTEpOmcueTE8TWF0aC5tYXgoSywxMCk/TWF0aC5tYXgoSywxMCk6Zy55MTt0PU1hdGgucm91bmQoZy54MStZK2UpO2s9YiYmMDxiLmxlbmd0aD9NYXRoLnJvdW5kKGJbMF0/YlswXS5saW5lQ29vcmRpbmF0ZXMueTE6Zy55Mi1YPm0uaGVpZ2h0LU1hdGgubWF4KEssMTApP20uaGVpZ2h0LU1hdGgubWF4KEssMTApOmcueTItWCk6Zy55Mj5tLmhlaWdodC1NYXRoLm1heChLLDEwKT9tLmhlaWdodC1NYXRoLm1heChLLDEwKTpnLnkyO2lmKGImJlxyXG4wPGIubGVuZ3RoKWZvcihLPTA7SzxiLmxlbmd0aDtLKyspYltLXSYmYltLXS5sYWJlbEF1dG9GaXQmJih0PTA+YltLXS5sYWJlbEFuZ2xlP01hdGgubWF4KHQseik6MD09PWJbS10ubGFiZWxBbmdsZT9NYXRoLm1heCh0LHovMik6dCxoPTA+YltLXS5sYWJlbEFuZ2xlfHwwPT09YltLXS5sYWJlbEFuZ2xlP3QtWTpoKTtpZihjJiYwPGMubGVuZ3RoKWZvcihLPTA7SzxjLmxlbmd0aDtLKyspY1tLXSYmY1tLXS5sYWJlbEF1dG9GaXQmJih0PWNbS10ubGluZUNvb3JkaW5hdGVzLngxLGg9dC1ZKTthW2RdLmxpbmVDb29yZGluYXRlcz17eDE6dC1RLHkxOmwseDI6dC1RLHkyOmssaGVpZ2h0Ok1hdGguYWJzKGstbCl9O2FbZF0uYm91bmRzPXt4MTp0LSh4W2RdK1EpLHkxOmwseDI6dCx5MjprLHdpZHRoOnQtaCxoZWlnaHQ6ay1sfTthW2RdLnRpdGxlJiYoYVtkXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9MDxhW2RdLnRpdGxlTWF4V2lkdGgmJmFbZF0udGl0bGVNYXhXaWR0aDxhW2RdLmxpbmVDb29yZGluYXRlcy5oZWlnaHQ/XHJcbmFbZF0udGl0bGVNYXhXaWR0aDphW2RdLmxpbmVDb29yZGluYXRlcy5oZWlnaHQpO2FbZF0uY2FsY3VsYXRlVmFsdWVUb1BpeGVsQ29udmVyc2lvblBhcmFtZXRlcnMoKTthW2RdLmNhbGN1bGF0ZUJyZWFrc1NpemVJblZhbHVlcygpO1ErPXhbZF0rYVtkXS5tYXJnaW59aWYoZiYmMDxmLmxlbmd0aClmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCsrKXtLPWZbZF0uX2xhYmVscyYmMDxmW2RdLl9sYWJlbHMubGVuZ3RoP2ZbZF0uX2xhYmVsc1swXS50ZXh0QmxvY2suZm9udFNpemUvMjowO2g9TWF0aC5yb3VuZChnLngxLWUpO2w9YyYmMDxjLmxlbmd0aD9NYXRoLnJvdW5kKGNbMF0/Y1swXS5saW5lQ29vcmRpbmF0ZXMueTI6Zy55MTxNYXRoLm1heChLLDEwKT9NYXRoLm1heChLLDEwKTpnLnkxKTpnLnkxPE1hdGgubWF4KEssMTApP01hdGgubWF4KEssMTApOmcueTE7dD1NYXRoLnJvdW5kKGcueDItVy1WKTtrPWImJjA8Yi5sZW5ndGg/TWF0aC5yb3VuZChiWzBdP2JbMF0ubGluZUNvb3JkaW5hdGVzLnkxOlxyXG5nLnkyLVg+bS5oZWlnaHQtTWF0aC5tYXgoSywxMCk/bS5oZWlnaHQtTWF0aC5tYXgoSywxMCk6Zy55Mi1YKTpnLnkyPm0uaGVpZ2h0LU1hdGgubWF4KEssMTApP20uaGVpZ2h0LU1hdGgubWF4KEssMTApOmcueTI7aWYoYiYmMDxiLmxlbmd0aClmb3IoSz0wO0s8Yi5sZW5ndGg7SysrKWJbS10mJmJbS10ubGFiZWxBdXRvRml0JiYodD0wPmJbS10ubGFiZWxBbmdsZT9NYXRoLm1heCh0LHopOjA9PT1iW0tdLmxhYmVsQW5nbGU/TWF0aC5tYXgodCx6LzIpOnQsaD0wPmJbS10ubGFiZWxBbmdsZXx8MD09PWJbS10ubGFiZWxBbmdsZT90LVc6aCk7aWYoYyYmMDxjLmxlbmd0aClmb3IoSz0wO0s8Yy5sZW5ndGg7SysrKWNbS10mJmNbS10ubGFiZWxBdXRvRml0JiYodD1jW0tdLmxpbmVDb29yZGluYXRlcy54MixoPXQtVyk7ZltkXS5saW5lQ29vcmRpbmF0ZXM9e3gxOnQrVSx5MTpsLHgyOnQrVSx5MjprLGhlaWdodDpNYXRoLmFicyhrLWwpfTtmW2RdLmJvdW5kcz17eDE6aCx5MTpsLHgyOnQrXHJcbkhbZF0rVSx5MjprLHdpZHRoOnQtaCxoZWlnaHQ6ay1sfTtmW2RdLnRpdGxlJiYoZltkXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9MDxmW2RdLnRpdGxlTWF4V2lkdGgmJmZbZF0udGl0bGVNYXhXaWR0aDxmW2RdLmxpbmVDb29yZGluYXRlcy5oZWlnaHQ/ZltkXS50aXRsZU1heFdpZHRoOmZbZF0ubGluZUNvb3JkaW5hdGVzLmhlaWdodCk7ZltkXS5jYWxjdWxhdGVWYWx1ZVRvUGl4ZWxDb252ZXJzaW9uUGFyYW1ldGVycygpO2ZbZF0uY2FsY3VsYXRlQnJlYWtzU2l6ZUluVmFsdWVzKCk7VSs9SFtkXStmW2RdLm1hcmdpbn1mb3IoZD0wO2Q8bi5sZW5ndGg7ZCsrKVwiYXhpc1lcIj09PW5bZF0udHlwZSYmKG5bZF0uY2FsY3VsYXRlVmFsdWVUb1BpeGVsQ29udmVyc2lvblBhcmFtZXRlcnMoKSxuW2RdLmNhbGN1bGF0ZUJyZWFrc1NpemVJblZhbHVlcygpKTtpZigwPHMpe2lmKGEmJjA8YS5sZW5ndGgpZm9yKGQ9MDtkPGEubGVuZ3RoO2QrKylxPVBbcy0xXVtkXT09PVBbc11bZF0/ITA6XHJcbiExO2Vsc2UgcT0hMDtpZihmJiYwPGYubGVuZ3RoKWZvcihkPTA7ZDxmLmxlbmd0aDtkKyspSj1SW3MtMV1bZF09PT1SW3NdW2RdPyEwOiExO2Vsc2UgSj0hMDtpZihiJiYwPGIubGVuZ3RoKWZvcihkPTA7ZDxiLmxlbmd0aDtkKyspST11W3MtMV1bZF09PT11W3NdW2RdPyEwOiExO2Vsc2UgST0hMDtpZihjJiYwPGMubGVuZ3RoKWZvcihkPTA7ZDxjLmxlbmd0aDtkKyspTj1PW3MtMV1bZF09PT1PW3NdW2RdPyEwOiExO2Vsc2UgTj0hMH1pZihxJiZKJiZJJiZOKWJyZWFrO3MrK31pZihiJiYwPGIubGVuZ3RoKWZvcihkPTA7ZDxiLmxlbmd0aDtkKyspYltkXS5jYWxjdWxhdGVTdHJpcExpbmVzVGhpY2tuZXNzSW5WYWx1ZXMoKSxiW2RdLmNhbGN1bGF0ZUJyZWFrc0luUGl4ZWxzKCksYltkXS5yZW5kZXJMYWJlbHNUaWNrc0FuZFRpdGxlKCk7aWYoYyYmMDxjLmxlbmd0aClmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0uY2FsY3VsYXRlU3RyaXBMaW5lc1RoaWNrbmVzc0luVmFsdWVzKCksXHJcbmNbZF0uY2FsY3VsYXRlQnJlYWtzSW5QaXhlbHMoKSxjW2RdLnJlbmRlckxhYmVsc1RpY2tzQW5kVGl0bGUoKTtpZihhJiYwPGEubGVuZ3RoKWZvcihkPTA7ZDxhLmxlbmd0aDtkKyspYVtkXS5jYWxjdWxhdGVTdHJpcExpbmVzVGhpY2tuZXNzSW5WYWx1ZXMoKSxhW2RdLmNhbGN1bGF0ZUJyZWFrc0luUGl4ZWxzKCksYVtkXS5yZW5kZXJMYWJlbHNUaWNrc0FuZFRpdGxlKCk7aWYoZiYmMDxmLmxlbmd0aClmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCsrKWZbZF0uY2FsY3VsYXRlU3RyaXBMaW5lc1RoaWNrbmVzc0luVmFsdWVzKCksZltkXS5jYWxjdWxhdGVCcmVha3NJblBpeGVscygpLGZbZF0ucmVuZGVyTGFiZWxzVGlja3NBbmRUaXRsZSgpfW0ucHJlcGFyZVBsb3RBcmVhKCk7Zz1tLnBsb3RBcmVhO3Auc2F2ZSgpO3AuYmVnaW5QYXRoKCk7cC5yZWN0KGcueDEsZy55MSxNYXRoLmFicyhnLngyLWcueDEpLE1hdGguYWJzKGcueTItZy55MSkpO3AuY2xpcCgpO2lmKGEmJjA8YS5sZW5ndGgpZm9yKGQ9XHJcbjA7ZDxuLmxlbmd0aDtkKyspbltkXS5yZW5kZXJTdHJpcExpbmVzT2ZUaGlja25lc3NUeXBlKFwidmFsdWVcIik7aWYoZiYmMDxmLmxlbmd0aClmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCsrKWZbZF0ucmVuZGVyU3RyaXBMaW5lc09mVGhpY2tuZXNzVHlwZShcInZhbHVlXCIpO2lmKGImJjA8Yi5sZW5ndGgpZm9yKGQ9MDtkPGIubGVuZ3RoO2QrKyliW2RdLnJlbmRlclN0cmlwTGluZXNPZlRoaWNrbmVzc1R5cGUoXCJ2YWx1ZVwiKTtpZihjJiYwPGMubGVuZ3RoKWZvcihkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5yZW5kZXJTdHJpcExpbmVzT2ZUaGlja25lc3NUeXBlKFwidmFsdWVcIik7aWYoYSYmMDxhLmxlbmd0aClmb3IoZD0wO2Q8YS5sZW5ndGg7ZCsrKWFbZF0ucmVuZGVySW50ZXJsYWNlZENvbG9ycygpO2lmKGYmJjA8Zi5sZW5ndGgpZm9yKGQ9MDtkPGYubGVuZ3RoO2QrKylmW2RdLnJlbmRlckludGVybGFjZWRDb2xvcnMoKTtpZihiJiYwPGIubGVuZ3RoKWZvcihkPTA7ZDxiLmxlbmd0aDtkKyspYltkXS5yZW5kZXJJbnRlcmxhY2VkQ29sb3JzKCk7XHJcbmlmKGMmJjA8Yy5sZW5ndGgpZm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyljW2RdLnJlbmRlckludGVybGFjZWRDb2xvcnMoKTtwLnJlc3RvcmUoKTtpZihhJiYwPGEubGVuZ3RoKWZvcihkPTA7ZDxhLmxlbmd0aDtkKyspYVtkXS5yZW5kZXJHcmlkKCksdiYmKGFbZF0uY3JlYXRlTWFzaygpLGFbZF0ucmVuZGVyQnJlYWtzQmFja2dyb3VuZCgpKTtpZihmJiYwPGYubGVuZ3RoKWZvcihkPTA7ZDxmLmxlbmd0aDtkKyspZltkXS5yZW5kZXJHcmlkKCksdiYmKGZbZF0uY3JlYXRlTWFzaygpLGZbZF0ucmVuZGVyQnJlYWtzQmFja2dyb3VuZCgpKTtpZihiJiYwPGIubGVuZ3RoKWZvcihkPTA7ZDxiLmxlbmd0aDtkKyspYltkXS5yZW5kZXJHcmlkKCksdiYmKGJbZF0uY3JlYXRlTWFzaygpLGJbZF0ucmVuZGVyQnJlYWtzQmFja2dyb3VuZCgpKTtpZihjJiYwPGMubGVuZ3RoKWZvcihkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5yZW5kZXJHcmlkKCksdiYmKGNbZF0uY3JlYXRlTWFzaygpLGNbZF0ucmVuZGVyQnJlYWtzQmFja2dyb3VuZCgpKTtcclxuaWYoYSYmMDxhLmxlbmd0aClmb3IoZD0wO2Q8YS5sZW5ndGg7ZCsrKWFbZF0ucmVuZGVyQXhpc0xpbmUoKTtpZihmJiYwPGYubGVuZ3RoKWZvcihkPTA7ZDxmLmxlbmd0aDtkKyspZltkXS5yZW5kZXJBeGlzTGluZSgpO2lmKGImJjA8Yi5sZW5ndGgpZm9yKGQ9MDtkPGIubGVuZ3RoO2QrKyliW2RdLnJlbmRlckF4aXNMaW5lKCk7aWYoYyYmMDxjLmxlbmd0aClmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0ucmVuZGVyQXhpc0xpbmUoKTtpZihhJiYwPGEubGVuZ3RoKWZvcihkPTA7ZDxhLmxlbmd0aDtkKyspYVtkXS5yZW5kZXJTdHJpcExpbmVzT2ZUaGlja25lc3NUeXBlKFwicGl4ZWxcIik7aWYoZiYmMDxmLmxlbmd0aClmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCsrKWZbZF0ucmVuZGVyU3RyaXBMaW5lc09mVGhpY2tuZXNzVHlwZShcInBpeGVsXCIpO2lmKGImJjA8Yi5sZW5ndGgpZm9yKGQ9MDtkPGIubGVuZ3RoO2QrKyliW2RdLnJlbmRlclN0cmlwTGluZXNPZlRoaWNrbmVzc1R5cGUoXCJwaXhlbFwiKTtcclxuaWYoYyYmMDxjLmxlbmd0aClmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0ucmVuZGVyU3RyaXBMaW5lc09mVGhpY2tuZXNzVHlwZShcInBpeGVsXCIpfTtDLnByb3RvdHlwZS5jYWxjdWxhdGVTdHJpcExpbmVzVGhpY2tuZXNzSW5WYWx1ZXM9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMuc3RyaXBMaW5lcy5sZW5ndGg7YSsrKWlmKG51bGwhPT10aGlzLnN0cmlwTGluZXNbYV0uc3RhcnRWYWx1ZSYmbnVsbCE9PXRoaXMuc3RyaXBMaW5lc1thXS5lbmRWYWx1ZSl7dmFyIGY9TWF0aC5taW4odGhpcy5zdHJpcExpbmVzW2FdLnN0YXJ0VmFsdWUsdGhpcy5zdHJpcExpbmVzW2FdLmVuZFZhbHVlKSxiPU1hdGgubWF4KHRoaXMuc3RyaXBMaW5lc1thXS5zdGFydFZhbHVlLHRoaXMuc3RyaXBMaW5lc1thXS5lbmRWYWx1ZSksZj10aGlzLmdldEFwcGFyZW50RGlmZmVyZW5jZShmLGIpO3RoaXMuc3RyaXBMaW5lc1thXS52YWx1ZT10aGlzLmxvZ2FyaXRobWljP3RoaXMuc3RyaXBMaW5lc1thXS52YWx1ZSpcclxuTWF0aC5zcXJ0KE1hdGgubG9nKHRoaXMuc3RyaXBMaW5lc1thXS5lbmRWYWx1ZS90aGlzLnN0cmlwTGluZXNbYV0uc3RhcnRWYWx1ZSkvTWF0aC5sb2coZikpOnRoaXMuc3RyaXBMaW5lc1thXS52YWx1ZSsoTWF0aC5hYnModGhpcy5zdHJpcExpbmVzW2FdLmVuZFZhbHVlLXRoaXMuc3RyaXBMaW5lc1thXS5zdGFydFZhbHVlKS1mKS8yO3RoaXMuc3RyaXBMaW5lc1thXS50aGlja25lc3M9Zjt0aGlzLnN0cmlwTGluZXNbYV0uX3RoaWNrbmVzc1R5cGU9XCJ2YWx1ZVwifX07Qy5wcm90b3R5cGUuY2FsY3VsYXRlQnJlYWtzU2l6ZUluVmFsdWVzPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVwibGVmdFwiPT09dGhpcy5fcG9zaXRpb258fFwicmlnaHRcIj09PXRoaXMuX3Bvc2l0aW9uP3RoaXMubGluZUNvb3JkaW5hdGVzLmhlaWdodHx8dGhpcy5jaGFydC5oZWlnaHQ6dGhpcy5saW5lQ29vcmRpbmF0ZXMud2lkdGh8fHRoaXMuY2hhcnQud2lkdGgsZj10aGlzLnNjYWxlQnJlYWtzP3RoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3M6XHJcbltdLGI9dGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5waXhlbFBlclVuaXR8fGEvKHRoaXMubG9nYXJpdGhtaWM/dGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5tYXhpbXVtL3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bTp0aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1heGltdW0tdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKSxjPXRoaXMuc2NhbGVCcmVha3MmJiF5KHRoaXMuc2NhbGVCcmVha3Mub3B0aW9ucy5zcGFjaW5nKSxlLGc9MDtnPGYubGVuZ3RoO2crKyllPWN8fCF5KGZbZ10ub3B0aW9ucy5zcGFjaW5nKSxmW2ddLnNwYWNpbmc9TyhmW2ddLnNwYWNpbmcsYSw4LGU/MC4xKmE6OCxlPzA6Myk8PDAsZltnXS5zaXplPTA+ZltnXS5zcGFjaW5nPzA6TWF0aC5hYnMoZltnXS5zcGFjaW5nL2IpLHRoaXMubG9nYXJpdGhtaWMmJihmW2ddLnNpemU9TWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLGZbZ10uc2l6ZSkpfTtDLnByb3RvdHlwZS5jYWxjdWxhdGVCcmVha3NJblBpeGVscz1cclxuZnVuY3Rpb24oKXtpZighKHRoaXMuc2NhbGVCcmVha3MmJjA+PXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MubGVuZ3RoKSl7dmFyIGE9dGhpcy5zY2FsZUJyZWFrcz90aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzOltdO2EubGVuZ3RoJiYodGhpcy5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXg9dGhpcy5zY2FsZUJyZWFrcy5sYXN0QnJlYWtJbmRleD1udWxsKTtmb3IodmFyIGY9MDtmPGEubGVuZ3RoJiYhKGFbZl0uc3RhcnRWYWx1ZT50aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1heGltdW0pO2YrKylhW2ZdLmVuZFZhbHVlPHRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bXx8KHkodGhpcy5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXgpJiYodGhpcy5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXg9ZiksYVtmXS5zdGFydFZhbHVlPj10aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0mJihhW2ZdLnN0YXJ0UGl4ZWw9dGhpcy5jb252ZXJ0VmFsdWVUb1BpeGVsKGFbZl0uc3RhcnRWYWx1ZSksXHJcbnRoaXMuc2NhbGVCcmVha3MubGFzdEJyZWFrSW5kZXg9ZiksYVtmXS5lbmRWYWx1ZTw9dGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5tYXhpbXVtJiYoYVtmXS5lbmRQaXhlbD10aGlzLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoYVtmXS5lbmRWYWx1ZSkpKX19O0MucHJvdG90eXBlLnJlbmRlckxhYmVsc1RpY2tzQW5kVGl0bGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGY9ITEsYj0wLGM9MCxlPTEsZz0wOzAhPT10aGlzLmxhYmVsQW5nbGUmJjM2MCE9PXRoaXMubGFiZWxBbmdsZSYmKGU9MS4yKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5pbnRlcnZhbCl7aWYoXCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5fcG9zaXRpb24paWYodGhpcy5sb2dhcml0aG1pYyYmIXRoaXMuZXF1aWRpc3RhbnRJbnRlcnZhbCYmdGhpcy5sYWJlbEF1dG9GaXQpe2Zvcih2YXIgYj1bXSxlPTAhPT10aGlzLmxhYmVsQW5nbGUmJjM2MCE9PXRoaXMubGFiZWxBbmdsZT9cclxuMToxLjIsaCxsPXRoaXMudmlld3BvcnRNYXhpbXVtLG09dGhpcy5saW5lQ29vcmRpbmF0ZXMud2lkdGgvTWF0aC5sb2codGhpcy5yYW5nZSksaz10aGlzLl9sYWJlbHMubGVuZ3RoLTE7MDw9aztrLS0pe3A9dGhpcy5fbGFiZWxzW2tdO2lmKHAucG9zaXRpb248dGhpcy52aWV3cG9ydE1pbmltdW0pYnJlYWs7cC5wb3NpdGlvbj50aGlzLnZpZXdwb3J0TWF4aW11bXx8IShrPT09dGhpcy5fbGFiZWxzLmxlbmd0aC0xfHxoPE1hdGgubG9nKGwvcC5wb3NpdGlvbikqbS9lKXx8KGIucHVzaChwKSxsPXAucG9zaXRpb24saD1wLnRleHRCbG9jay53aWR0aCpNYXRoLmFicyhNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpKStwLnRleHRCbG9jay5oZWlnaHQqTWF0aC5hYnMoTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSkpfXRoaXMuX2xhYmVscz1ifWVsc2V7Zm9yKGs9MDtrPHRoaXMuX2xhYmVscy5sZW5ndGg7aysrKXA9dGhpcy5fbGFiZWxzW2tdLHAucG9zaXRpb248XHJcbnRoaXMudmlld3BvcnRNaW5pbXVtfHwoaD1wLnRleHRCbG9jay53aWR0aCpNYXRoLmFicyhNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpKStwLnRleHRCbG9jay5oZWlnaHQqTWF0aC5hYnMoTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSksYis9aCk7Yj50aGlzLmxpbmVDb29yZGluYXRlcy53aWR0aCplJiZ0aGlzLmxhYmVsQXV0b0ZpdCYmKGY9ITApfWlmKFwibGVmdFwiPT09dGhpcy5fcG9zaXRpb258fFwicmlnaHRcIj09PXRoaXMuX3Bvc2l0aW9uKWlmKHRoaXMubG9nYXJpdGhtaWMmJiF0aGlzLmVxdWlkaXN0YW50SW50ZXJ2YWwmJnRoaXMubGFiZWxBdXRvRml0KXtmb3IodmFyIGI9W10scixsPXRoaXMudmlld3BvcnRNYXhpbXVtLG09dGhpcy5saW5lQ29vcmRpbmF0ZXMuaGVpZ2h0L01hdGgubG9nKHRoaXMucmFuZ2UpLGs9dGhpcy5fbGFiZWxzLmxlbmd0aC0xOzA8PWs7ay0tKXtwPXRoaXMuX2xhYmVsc1trXTtpZihwLnBvc2l0aW9uPHRoaXMudmlld3BvcnRNaW5pbXVtKWJyZWFrO1xyXG5wLnBvc2l0aW9uPnRoaXMudmlld3BvcnRNYXhpbXVtfHwhKGs9PT10aGlzLl9sYWJlbHMubGVuZ3RoLTF8fHI8TWF0aC5sb2cobC9wLnBvc2l0aW9uKSptKXx8KGIucHVzaChwKSxsPXAucG9zaXRpb24scj1wLnRleHRCbG9jay5oZWlnaHQqTWF0aC5hYnMoTWF0aC5jb3MoTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSkrcC50ZXh0QmxvY2sud2lkdGgqTWF0aC5hYnMoTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSkpfXRoaXMuX2xhYmVscz1ifWVsc2V7Zm9yKGs9MDtrPHRoaXMuX2xhYmVscy5sZW5ndGg7aysrKXA9dGhpcy5fbGFiZWxzW2tdLHAucG9zaXRpb248dGhpcy52aWV3cG9ydE1pbmltdW18fChyPXAudGV4dEJsb2NrLmhlaWdodCpNYXRoLmFicyhNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpKStwLnRleHRCbG9jay53aWR0aCpNYXRoLmFicyhNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpKSxjKz1yKTtjPnRoaXMubGluZUNvb3JkaW5hdGVzLmhlaWdodCpcclxuZSYmdGhpcy5sYWJlbEF1dG9GaXQmJihmPSEwKX19dGhpcy5sb2dhcml0aG1pYyYmKCF0aGlzLmVxdWlkaXN0YW50SW50ZXJ2YWwmJnRoaXMubGFiZWxBdXRvRml0KSYmdGhpcy5fbGFiZWxzLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5wb3NpdGlvbi1iLnBvc2l0aW9ufSk7dmFyIGs9MCxwLG47aWYoXCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9uKXtmb3Ioaz0wO2s8dGhpcy5fbGFiZWxzLmxlbmd0aDtrKyspcD10aGlzLl9sYWJlbHNba10scC5wb3NpdGlvbjx0aGlzLnZpZXdwb3J0TWluaW11bXx8KHAucG9zaXRpb24+dGhpcy52aWV3cG9ydE1heGltdW18fGYmJjAhPT1nKyslMiYmdGhpcy5sYWJlbEF1dG9GaXQpfHwobj10aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXMocC5wb3NpdGlvbiksdGhpcy50aWNrVGhpY2tuZXNzJiZcImluc2lkZVwiIT10aGlzLmxhYmVsUGxhY2VtZW50JiYodGhpcy5jdHgubGluZVdpZHRoPXRoaXMudGlja1RoaWNrbmVzcyx0aGlzLmN0eC5zdHJva2VTdHlsZT1cclxudGhpcy50aWNrQ29sb3IsYz0xPT09dGhpcy5jdHgubGluZVdpZHRoJTI/KG4ueDw8MCkrMC41Om4ueDw8MCx0aGlzLmN0eC5iZWdpblBhdGgoKSx0aGlzLmN0eC5tb3ZlVG8oYyxuLnk8PDApLHRoaXMuY3R4LmxpbmVUbyhjLG4ueSt0aGlzLnRpY2tMZW5ndGg8PDApLHRoaXMuY3R4LnN0cm9rZSgpKSwwPT09cC50ZXh0QmxvY2suYW5nbGU/KG4ueC09cC50ZXh0QmxvY2sud2lkdGgvMixuLnk9XCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQ/bi55LSh0aGlzLnRpY2tMZW5ndGgrcC50ZXh0QmxvY2suZm9udFNpemUvMik6bi55K3RoaXMudGlja0xlbmd0aCtwLnRleHRCbG9jay5mb250U2l6ZS8yKToobi54PVwiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50PzA+dGhpcy5sYWJlbEFuZ2xlP24ueDpuLngtcC50ZXh0QmxvY2sud2lkdGgqTWF0aC5jb3MoTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKTpuLngtKDA+dGhpcy5sYWJlbEFuZ2xlP3AudGV4dEJsb2NrLndpZHRoKlxyXG5NYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpOjApLG4ueT1cImluc2lkZVwiPT09dGhpcy5sYWJlbFBsYWNlbWVudD8wPnRoaXMubGFiZWxBbmdsZT9uLnktdGhpcy50aWNrTGVuZ3RoLTU6bi55LXRoaXMudGlja0xlbmd0aC1NYXRoLmFicyhwLnRleHRCbG9jay53aWR0aCpNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpKzUpOm4ueSt0aGlzLnRpY2tMZW5ndGgrTWF0aC5hYnMoMD50aGlzLmxhYmVsQW5nbGU/cC50ZXh0QmxvY2sud2lkdGgqTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKS01OjUpKSxwLnRleHRCbG9jay54PW4ueCxwLnRleHRCbG9jay55PW4ueSk7XCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQmJnRoaXMuY2hhcnQuYWRkRXZlbnRMaXN0ZW5lcihcImRhdGFBbmltYXRpb25JdGVyYXRpb25FbmRcIixmdW5jdGlvbigpe2ZvcihrPTA7azxhLl9sYWJlbHMubGVuZ3RoO2srKylpZihwPWEuX2xhYmVsc1trXSwhKHAucG9zaXRpb248XHJcbmEudmlld3BvcnRNaW5pbXVtfHxwLnBvc2l0aW9uPmEudmlld3BvcnRNYXhpbXVtfHxmJiYwIT09ZysrJTImJmEubGFiZWxBdXRvRml0KSYmKG49YS5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzKHAucG9zaXRpb24pLGEudGlja1RoaWNrbmVzcykpe2EuY3R4LmxpbmVXaWR0aD1hLnRpY2tUaGlja25lc3M7YS5jdHguc3Ryb2tlU3R5bGU9YS50aWNrQ29sb3I7dmFyIGI9MT09PWEuY3R4LmxpbmVXaWR0aCUyPyhuLng8PDApKzAuNTpuLng8PDA7YS5jdHguc2F2ZSgpO2EuY3R4LmJlZ2luUGF0aCgpO2EuY3R4Lm1vdmVUbyhiLG4ueTw8MCk7YS5jdHgubGluZVRvKGIsbi55LWEudGlja0xlbmd0aDw8MCk7YS5jdHguc3Ryb2tlKCk7YS5jdHgucmVzdG9yZSgpfX0sdGhpcyk7dGhpcy50aXRsZSYmKHRoaXMuX3RpdGxlVGV4dEJsb2NrLm1lYXN1cmVUZXh0KCksdGhpcy5fdGl0bGVUZXh0QmxvY2sueD10aGlzLmxpbmVDb29yZGluYXRlcy54MSt0aGlzLmxpbmVDb29yZGluYXRlcy53aWR0aC9cclxuMi10aGlzLl90aXRsZVRleHRCbG9jay53aWR0aC8yLHRoaXMuX3RpdGxlVGV4dEJsb2NrLnk9dGhpcy5ib3VuZHMueTItdGhpcy5fdGl0bGVUZXh0QmxvY2suaGVpZ2h0LTMsdGhpcy50aXRsZU1heFdpZHRoPXRoaXMuX3RpdGxlVGV4dEJsb2NrLm1heFdpZHRoLHRoaXMuX3RpdGxlVGV4dEJsb2NrLnJlbmRlcighMCkpfWVsc2UgaWYoXCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uKXtmb3Ioaz0wO2s8dGhpcy5fbGFiZWxzLmxlbmd0aDtrKyspcD10aGlzLl9sYWJlbHNba10scC5wb3NpdGlvbjx0aGlzLnZpZXdwb3J0TWluaW11bXx8KHAucG9zaXRpb24+dGhpcy52aWV3cG9ydE1heGltdW18fGYmJjAhPT1nKyslMiYmdGhpcy5sYWJlbEF1dG9GaXQpfHwobj10aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXMocC5wb3NpdGlvbiksdGhpcy50aWNrVGhpY2tuZXNzJiZcImluc2lkZVwiIT10aGlzLmxhYmVsUGxhY2VtZW50JiYodGhpcy5jdHgubGluZVdpZHRoPXRoaXMudGlja1RoaWNrbmVzcyxcclxudGhpcy5jdHguc3Ryb2tlU3R5bGU9dGhpcy50aWNrQ29sb3IsYz0xPT09dGhpcy5jdHgubGluZVdpZHRoJTI/KG4ueDw8MCkrMC41Om4ueDw8MCx0aGlzLmN0eC5iZWdpblBhdGgoKSx0aGlzLmN0eC5tb3ZlVG8oYyxuLnk8PDApLHRoaXMuY3R4LmxpbmVUbyhjLG4ueS10aGlzLnRpY2tMZW5ndGg8PDApLHRoaXMuY3R4LnN0cm9rZSgpKSwwPT09cC50ZXh0QmxvY2suYW5nbGU/KG4ueC09cC50ZXh0QmxvY2sud2lkdGgvMixuLnk9XCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQ/bi55K3RoaXMubGFiZWxGb250U2l6ZS8yK3RoaXMudGlja0xlbmd0aCs1Om4ueS0odGhpcy50aWNrTGVuZ3RoK3AudGV4dEJsb2NrLmhlaWdodC1wLnRleHRCbG9jay5mb250U2l6ZS8yKSk6KG4ueD1cImluc2lkZVwiPT09dGhpcy5sYWJlbFBsYWNlbWVudD8wPHRoaXMubGFiZWxBbmdsZT9uLng6bi54LXAudGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSk6bi54K1xyXG4ocC50ZXh0QmxvY2suaGVpZ2h0LXRoaXMudGlja0xlbmd0aC10aGlzLmxhYmVsRm9udFNpemUpKk1hdGguc2luKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSktKDA8dGhpcy5sYWJlbEFuZ2xlP3AudGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSk6MCksbi55PVwiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50PzA8dGhpcy5sYWJlbEFuZ2xlP24ueSt0aGlzLnRpY2tMZW5ndGgrNTpuLnktcC50ZXh0QmxvY2sud2lkdGgqTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSt0aGlzLnRpY2tMZW5ndGgrNTpuLnktKHRoaXMudGlja0xlbmd0aCsoKHAudGV4dEJsb2NrLmhlaWdodC1wLnRleHRCbG9jay5mb250U2l6ZS8yKSpNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpKygwPHRoaXMubGFiZWxBbmdsZT9wLnRleHRCbG9jay53aWR0aCpNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpOlxyXG4wKSkpKSxwLnRleHRCbG9jay54PW4ueCxwLnRleHRCbG9jay55PW4ueSk7XCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQmJnRoaXMuY2hhcnQuYWRkRXZlbnRMaXN0ZW5lcihcImRhdGFBbmltYXRpb25JdGVyYXRpb25FbmRcIixmdW5jdGlvbigpe2ZvcihrPTA7azxhLl9sYWJlbHMubGVuZ3RoO2srKylpZihwPWEuX2xhYmVsc1trXSwhKHAucG9zaXRpb248YS52aWV3cG9ydE1pbmltdW18fHAucG9zaXRpb24+YS52aWV3cG9ydE1heGltdW18fGYmJjAhPT1nKyslMiYmYS5sYWJlbEF1dG9GaXQpJiYobj1hLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXMocC5wb3NpdGlvbiksYS50aWNrVGhpY2tuZXNzKSl7YS5jdHgubGluZVdpZHRoPWEudGlja1RoaWNrbmVzczthLmN0eC5zdHJva2VTdHlsZT1hLnRpY2tDb2xvcjt2YXIgYj0xPT09dGhpcy5jdHgubGluZVdpZHRoJTI/KG4ueDw8MCkrMC41Om4ueDw8MDthLmN0eC5zYXZlKCk7YS5jdHguYmVnaW5QYXRoKCk7YS5jdHgubW92ZVRvKGIsXHJcbm4ueTw8MCk7YS5jdHgubGluZVRvKGIsbi55K2EudGlja0xlbmd0aDw8MCk7YS5jdHguc3Ryb2tlKCk7YS5jdHgucmVzdG9yZSgpfX0sdGhpcyk7dGhpcy50aXRsZSYmKHRoaXMuX3RpdGxlVGV4dEJsb2NrLm1lYXN1cmVUZXh0KCksdGhpcy5fdGl0bGVUZXh0QmxvY2sueD10aGlzLmxpbmVDb29yZGluYXRlcy54MSt0aGlzLmxpbmVDb29yZGluYXRlcy53aWR0aC8yLXRoaXMuX3RpdGxlVGV4dEJsb2NrLndpZHRoLzIsdGhpcy5fdGl0bGVUZXh0QmxvY2sueT10aGlzLmJvdW5kcy55MSsxLHRoaXMudGl0bGVNYXhXaWR0aD10aGlzLl90aXRsZVRleHRCbG9jay5tYXhXaWR0aCx0aGlzLl90aXRsZVRleHRCbG9jay5yZW5kZXIoITApKX1lbHNlIGlmKFwibGVmdFwiPT09dGhpcy5fcG9zaXRpb24pe2ZvcihrPTA7azx0aGlzLl9sYWJlbHMubGVuZ3RoO2srKylwPXRoaXMuX2xhYmVsc1trXSxwLnBvc2l0aW9uPHRoaXMudmlld3BvcnRNaW5pbXVtfHwocC5wb3NpdGlvbj50aGlzLnZpZXdwb3J0TWF4aW11bXx8XHJcbmYmJjAhPT1nKyslMiYmdGhpcy5sYWJlbEF1dG9GaXQpfHwobj10aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXMocC5wb3NpdGlvbiksdGhpcy50aWNrVGhpY2tuZXNzJiZcImluc2lkZVwiIT10aGlzLmxhYmVsUGxhY2VtZW50JiYodGhpcy5jdHgubGluZVdpZHRoPXRoaXMudGlja1RoaWNrbmVzcyx0aGlzLmN0eC5zdHJva2VTdHlsZT10aGlzLnRpY2tDb2xvcixjPTE9PT10aGlzLmN0eC5saW5lV2lkdGglMj8obi55PDwwKSswLjU6bi55PDwwLHRoaXMuY3R4LmJlZ2luUGF0aCgpLHRoaXMuY3R4Lm1vdmVUbyhuLng8PDAsYyksdGhpcy5jdHgubGluZVRvKG4ueC10aGlzLnRpY2tMZW5ndGg8PDAsYyksdGhpcy5jdHguc3Ryb2tlKCkpLDA9PT10aGlzLmxhYmVsQW5nbGU/KHAudGV4dEJsb2NrLnk9bi55LHAudGV4dEJsb2NrLng9XCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQ/bi54K3RoaXMudGlja0xlbmd0aCs1Om4ueC1wLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJL1xyXG4xODAqdGhpcy5sYWJlbEFuZ2xlKS10aGlzLnRpY2tMZW5ndGgtNSk6KHAudGV4dEJsb2NrLnk9XCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQ/bi55Om4ueS1wLnRleHRCbG9jay53aWR0aCpNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpLHAudGV4dEJsb2NrLng9XCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQ/bi54K3RoaXMudGlja0xlbmd0aCs1OjA8dGhpcy5sYWJlbEFuZ2xlP24ueC1wLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpLXRoaXMudGlja0xlbmd0aC01Om4ueC1wLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpKyhwLnRleHRCbG9jay5oZWlnaHQtcC50ZXh0QmxvY2suZm9udFNpemUvMi01KSpNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpLXRoaXMudGlja0xlbmd0aCkpO1wiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50JiZcclxudGhpcy5jaGFydC5hZGRFdmVudExpc3RlbmVyKFwiZGF0YUFuaW1hdGlvbkl0ZXJhdGlvbkVuZFwiLGZ1bmN0aW9uKCl7Zm9yKGs9MDtrPGEuX2xhYmVscy5sZW5ndGg7aysrKWlmKHA9YS5fbGFiZWxzW2tdLCEocC5wb3NpdGlvbjxhLnZpZXdwb3J0TWluaW11bXx8cC5wb3NpdGlvbj5hLnZpZXdwb3J0TWF4aW11bXx8ZiYmMCE9PWcrKyUyJiZhLmxhYmVsQXV0b0ZpdCkmJihuPWEuZ2V0UGl4ZWxDb29yZGluYXRlc09uQXhpcyhwLnBvc2l0aW9uKSxhLnRpY2tUaGlja25lc3MpKXthLmN0eC5saW5lV2lkdGg9YS50aWNrVGhpY2tuZXNzO2EuY3R4LnN0cm9rZVN0eWxlPWEudGlja0NvbG9yO3ZhciBiPTE9PT1hLmN0eC5saW5lV2lkdGglMj8obi55PDwwKSswLjU6bi55PDwwO2EuY3R4LnNhdmUoKTthLmN0eC5iZWdpblBhdGgoKTthLmN0eC5tb3ZlVG8obi54PDwwLGIpO2EuY3R4LmxpbmVUbyhuLngrYS50aWNrTGVuZ3RoPDwwLGIpO2EuY3R4LnN0cm9rZSgpO2EuY3R4LnJlc3RvcmUoKX19LFxyXG50aGlzKTt0aGlzLnRpdGxlJiYodGhpcy5fdGl0bGVUZXh0QmxvY2subWVhc3VyZVRleHQoKSx0aGlzLl90aXRsZVRleHRCbG9jay54PXRoaXMuYm91bmRzLngxKzEsdGhpcy5fdGl0bGVUZXh0QmxvY2sueT10aGlzLmxpbmVDb29yZGluYXRlcy5oZWlnaHQvMit0aGlzLl90aXRsZVRleHRCbG9jay53aWR0aC8yK3RoaXMubGluZUNvb3JkaW5hdGVzLnkxLHRoaXMudGl0bGVNYXhXaWR0aD10aGlzLl90aXRsZVRleHRCbG9jay5tYXhXaWR0aCx0aGlzLl90aXRsZVRleHRCbG9jay5yZW5kZXIoITApKX1lbHNlIGlmKFwicmlnaHRcIj09PXRoaXMuX3Bvc2l0aW9uKXtmb3Ioaz0wO2s8dGhpcy5fbGFiZWxzLmxlbmd0aDtrKyspcD10aGlzLl9sYWJlbHNba10scC5wb3NpdGlvbjx0aGlzLnZpZXdwb3J0TWluaW11bXx8KHAucG9zaXRpb24+dGhpcy52aWV3cG9ydE1heGltdW18fGYmJjAhPT1nKyslMiYmdGhpcy5sYWJlbEF1dG9GaXQpfHwobj10aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXMocC5wb3NpdGlvbiksXHJcbnRoaXMudGlja1RoaWNrbmVzcyYmXCJpbnNpZGVcIiE9dGhpcy5sYWJlbFBsYWNlbWVudCYmKHRoaXMuY3R4LmxpbmVXaWR0aD10aGlzLnRpY2tUaGlja25lc3MsdGhpcy5jdHguc3Ryb2tlU3R5bGU9dGhpcy50aWNrQ29sb3IsYz0xPT09dGhpcy5jdHgubGluZVdpZHRoJTI/KG4ueTw8MCkrMC41Om4ueTw8MCx0aGlzLmN0eC5iZWdpblBhdGgoKSx0aGlzLmN0eC5tb3ZlVG8obi54PDwwLGMpLHRoaXMuY3R4LmxpbmVUbyhuLngrdGhpcy50aWNrTGVuZ3RoPDwwLGMpLHRoaXMuY3R4LnN0cm9rZSgpKSwwPT09dGhpcy5sYWJlbEFuZ2xlPyhwLnRleHRCbG9jay55PW4ueSxwLnRleHRCbG9jay54PVwiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50P24ueC1wLnRleHRCbG9jay53aWR0aC10aGlzLnRpY2tMZW5ndGgtNTpuLngrdGhpcy50aWNrTGVuZ3RoKzUpOihwLnRleHRCbG9jay55PVwiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50P24ueS1wLnRleHRCbG9jay53aWR0aCpNYXRoLnNpbihNYXRoLlBJL1xyXG4xODAqdGhpcy5sYWJlbEFuZ2xlKTowPnRoaXMubGFiZWxBbmdsZT9uLnk6bi55LShwLnRleHRCbG9jay5oZWlnaHQtcC50ZXh0QmxvY2suZm9udFNpemUvMi01KSpNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpLHAudGV4dEJsb2NrLng9XCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQ/bi54LXAudGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSktdGhpcy50aWNrTGVuZ3RoLTU6MDx0aGlzLmxhYmVsQW5nbGU/bi54KyhwLnRleHRCbG9jay5oZWlnaHQtcC50ZXh0QmxvY2suZm9udFNpemUvMi01KSpNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpK3RoaXMudGlja0xlbmd0aDpuLngrdGhpcy50aWNrTGVuZ3RoKzUpKTtcImluc2lkZVwiPT09dGhpcy5sYWJlbFBsYWNlbWVudCYmdGhpcy5jaGFydC5hZGRFdmVudExpc3RlbmVyKFwiZGF0YUFuaW1hdGlvbkl0ZXJhdGlvbkVuZFwiLGZ1bmN0aW9uKCl7Zm9yKGs9XHJcbjA7azxhLl9sYWJlbHMubGVuZ3RoO2srKylpZihwPWEuX2xhYmVsc1trXSwhKHAucG9zaXRpb248YS52aWV3cG9ydE1pbmltdW18fHAucG9zaXRpb24+YS52aWV3cG9ydE1heGltdW18fGYmJjAhPT1nKyslMiYmYS5sYWJlbEF1dG9GaXQpJiYobj1hLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXMocC5wb3NpdGlvbiksYS50aWNrVGhpY2tuZXNzKSl7YS5jdHgubGluZVdpZHRoPWEudGlja1RoaWNrbmVzczthLmN0eC5zdHJva2VTdHlsZT1hLnRpY2tDb2xvcjt2YXIgYj0xPT09YS5jdHgubGluZVdpZHRoJTI/KG4ueTw8MCkrMC41Om4ueTw8MDthLmN0eC5zYXZlKCk7YS5jdHguYmVnaW5QYXRoKCk7YS5jdHgubW92ZVRvKG4ueDw8MCxiKTthLmN0eC5saW5lVG8obi54LWEudGlja0xlbmd0aDw8MCxiKTthLmN0eC5zdHJva2UoKTthLmN0eC5yZXN0b3JlKCl9fSx0aGlzKTt0aGlzLnRpdGxlJiYodGhpcy5fdGl0bGVUZXh0QmxvY2subWVhc3VyZVRleHQoKSx0aGlzLl90aXRsZVRleHRCbG9jay54PVxyXG50aGlzLmJvdW5kcy54Mi0xLHRoaXMuX3RpdGxlVGV4dEJsb2NrLnk9dGhpcy5saW5lQ29vcmRpbmF0ZXMuaGVpZ2h0LzItdGhpcy5fdGl0bGVUZXh0QmxvY2sud2lkdGgvMit0aGlzLmxpbmVDb29yZGluYXRlcy55MSx0aGlzLnRpdGxlTWF4V2lkdGg9dGhpcy5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGgsdGhpcy5fdGl0bGVUZXh0QmxvY2sucmVuZGVyKCEwKSl9Zz0wO2lmKFwiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50KXRoaXMuY2hhcnQuYWRkRXZlbnRMaXN0ZW5lcihcImRhdGFBbmltYXRpb25JdGVyYXRpb25FbmRcIixmdW5jdGlvbigpe2ZvcihrPTA7azxhLl9sYWJlbHMubGVuZ3RoO2srKylwPWEuX2xhYmVsc1trXSxwLnBvc2l0aW9uPGEudmlld3BvcnRNaW5pbXVtfHwocC5wb3NpdGlvbj5hLnZpZXdwb3J0TWF4aW11bXx8ZiYmMCE9PWcrKyUyJiZhLmxhYmVsQXV0b0ZpdCYmcC5za2lwRmxhZyl8fChhLmN0eC5zYXZlKCksYS5jdHguYmVnaW5QYXRoKCkscC50ZXh0QmxvY2sucmVuZGVyKCEwKSxcclxuYS5jdHgucmVzdG9yZSgpKX0scC50ZXh0QmxvY2spO2Vsc2UgZm9yKGs9MDtrPHRoaXMuX2xhYmVscy5sZW5ndGg7aysrKXA9dGhpcy5fbGFiZWxzW2tdLHAucG9zaXRpb248dGhpcy52aWV3cG9ydE1pbmltdW18fChwLnBvc2l0aW9uPnRoaXMudmlld3BvcnRNYXhpbXVtfHxmJiYwIT09ZysrJTImJnRoaXMubGFiZWxBdXRvRml0JiZwLnNraXBGbGFnKXx8cC50ZXh0QmxvY2sucmVuZGVyKCEwKX07Qy5wcm90b3R5cGUucmVuZGVySW50ZXJsYWNlZENvbG9ycz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQucGxvdEFyZWEuY3R4LGYsYixjPXRoaXMuY2hhcnQucGxvdEFyZWEsZT0wO2Y9ITA7aWYoKFwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uKSYmdGhpcy5pbnRlcmxhY2VkQ29sb3IpZm9yKGEuZmlsbFN0eWxlPXRoaXMuaW50ZXJsYWNlZENvbG9yLGU9MDtlPHRoaXMuX2xhYmVscy5sZW5ndGg7ZSsrKWY/KGY9dGhpcy5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzKHRoaXMuX2xhYmVsc1tlXS5wb3NpdGlvbiksXHJcbmI9ZSsxPnRoaXMuX2xhYmVscy5sZW5ndGgtMT90aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXModGhpcy52aWV3cG9ydE1heGltdW0pOnRoaXMuZ2V0UGl4ZWxDb29yZGluYXRlc09uQXhpcyh0aGlzLl9sYWJlbHNbZSsxXS5wb3NpdGlvbiksYS5maWxsUmVjdChNYXRoLm1pbihiLngsZi54KSxjLnkxLE1hdGguYWJzKGIueC1mLngpLE1hdGguYWJzKGMueTEtYy55MikpLGY9ITEpOmY9ITA7ZWxzZSBpZigoXCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24pJiZ0aGlzLmludGVybGFjZWRDb2xvcilmb3IoYS5maWxsU3R5bGU9dGhpcy5pbnRlcmxhY2VkQ29sb3IsZT0wO2U8dGhpcy5fbGFiZWxzLmxlbmd0aDtlKyspZj8oYj10aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXModGhpcy5fbGFiZWxzW2VdLnBvc2l0aW9uKSxmPWUrMT50aGlzLl9sYWJlbHMubGVuZ3RoLTE/dGhpcy5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzKHRoaXMudmlld3BvcnRNYXhpbXVtKTpcclxudGhpcy5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzKHRoaXMuX2xhYmVsc1tlKzFdLnBvc2l0aW9uKSxhLmZpbGxSZWN0KGMueDEsTWF0aC5taW4oYi55LGYueSksTWF0aC5hYnMoYy54MS1jLngyKSxNYXRoLmFicyhmLnktYi55KSksZj0hMSk6Zj0hMDthLmJlZ2luUGF0aCgpfTtDLnByb3RvdHlwZS5yZW5kZXJTdHJpcExpbmVzT2ZUaGlja25lc3NUeXBlPWZ1bmN0aW9uKGEpe2lmKHRoaXMuc3RyaXBMaW5lcyYmMDx0aGlzLnN0cmlwTGluZXMubGVuZ3RoJiZhKXtmb3IodmFyIGY9dGhpcyxiLGM9MCxlPTAsZz0hMSxoPSExLGw9W10sbT1bXSxoPSExLGM9MDtjPHRoaXMuc3RyaXBMaW5lcy5sZW5ndGg7YysrKXt2YXIgaz10aGlzLnN0cmlwTGluZXNbY107ay5fdGhpY2tuZXNzVHlwZT09PWEmJihcInBpeGVsXCI9PT1hJiYoay52YWx1ZTx0aGlzLnZpZXdwb3J0TWluaW11bXx8ay52YWx1ZT50aGlzLnZpZXdwb3J0TWF4aW11bXx8eShrLnZhbHVlKXx8aXNOYU4odGhpcy5yYW5nZSkpfHxcclxubC5wdXNoKGspKX1mb3IoYz0wO2M8dGhpcy5fc3RyaXBMaW5lTGFiZWxzLmxlbmd0aDtjKyspaWYoaz10aGlzLnN0cmlwTGluZXNbY10sYj10aGlzLl9zdHJpcExpbmVMYWJlbHNbY10sIShiLnBvc2l0aW9uPHRoaXMudmlld3BvcnRNaW5pbXVtfHxiLnBvc2l0aW9uPnRoaXMudmlld3BvcnRNYXhpbXVtfHxpc05hTih0aGlzLnJhbmdlKSkpe2E9dGhpcy5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzKGIucG9zaXRpb24pO2lmKFwib3V0c2lkZVwiPT09Yi5zdHJpcExpbmUubGFiZWxQbGFjZW1lbnQpaWYoayYmKHRoaXMuY3R4LnN0cm9rZVN0eWxlPWsuY29sb3IsXCJwaXhlbFwiPT09ay5fdGhpY2tuZXNzVHlwZSYmKHRoaXMuY3R4LmxpbmVXaWR0aD1rLnRoaWNrbmVzcykpLFwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbil7dmFyIHI9MT09PXRoaXMuY3R4LmxpbmVXaWR0aCUyPyhhLng8PDApKzAuNTphLng8PDA7dGhpcy5jdHguYmVnaW5QYXRoKCk7dGhpcy5jdHgubW92ZVRvKHIsYS55PDwwKTtcclxudGhpcy5jdHgubGluZVRvKHIsYS55K3RoaXMudGlja0xlbmd0aDw8MCk7dGhpcy5jdHguc3Ryb2tlKCk7MD09PXRoaXMubGFiZWxBbmdsZT8oYS54LT1iLnRleHRCbG9jay53aWR0aC8yLGEueSs9dGhpcy50aWNrTGVuZ3RoK2IudGV4dEJsb2NrLmZvbnRTaXplLzIpOihhLngtPTA+dGhpcy5sYWJlbEFuZ2xlP2IudGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSk6MCxhLnkrPXRoaXMudGlja0xlbmd0aCtNYXRoLmFicygwPnRoaXMubGFiZWxBbmdsZT9iLnRleHRCbG9jay53aWR0aCpNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpLTU6NSkpfWVsc2VcInRvcFwiPT09dGhpcy5fcG9zaXRpb24/KHI9MT09PXRoaXMuY3R4LmxpbmVXaWR0aCUyPyhhLng8PDApKzAuNTphLng8PDAsdGhpcy5jdHguYmVnaW5QYXRoKCksdGhpcy5jdHgubW92ZVRvKHIsYS55PDwwKSx0aGlzLmN0eC5saW5lVG8ocixhLnktdGhpcy50aWNrTGVuZ3RoPDxcclxuMCksdGhpcy5jdHguc3Ryb2tlKCksMD09PXRoaXMubGFiZWxBbmdsZT8oYS54LT1iLnRleHRCbG9jay53aWR0aC8yLGEueS09dGhpcy50aWNrTGVuZ3RoK2IudGV4dEJsb2NrLmhlaWdodCk6KGEueCs9KGIudGV4dEJsb2NrLmhlaWdodC10aGlzLnRpY2tMZW5ndGgtdGhpcy5sYWJlbEZvbnRTaXplLzIpKk1hdGguc2luKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSktKDA8dGhpcy5sYWJlbEFuZ2xlP2IudGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSk6MCksYS55LT10aGlzLnRpY2tMZW5ndGgrKGIudGV4dEJsb2NrLmhlaWdodCpNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpKygwPHRoaXMubGFiZWxBbmdsZT9iLnRleHRCbG9jay53aWR0aCpNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpOjApKSkpOlwibGVmdFwiPT09dGhpcy5fcG9zaXRpb24/KHI9MT09PXRoaXMuY3R4LmxpbmVXaWR0aCUyPyhhLnk8PFxyXG4wKSswLjU6YS55PDwwLHRoaXMuY3R4LmJlZ2luUGF0aCgpLHRoaXMuY3R4Lm1vdmVUbyhhLng8PDAsciksdGhpcy5jdHgubGluZVRvKGEueC10aGlzLnRpY2tMZW5ndGg8PDAsciksdGhpcy5jdHguc3Ryb2tlKCksMD09PXRoaXMubGFiZWxBbmdsZT9hLng9YS54LWIudGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSktdGhpcy50aWNrTGVuZ3RoLTU6KGEueS09Yi50ZXh0QmxvY2sud2lkdGgqTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSxhLng9MDx0aGlzLmxhYmVsQW5nbGU/YS54LWIudGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSktdGhpcy50aWNrTGVuZ3RoLTU6YS54LWIudGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSkrKGIudGV4dEJsb2NrLmhlaWdodC1iLnRleHRCbG9jay5mb250U2l6ZS8yLTUpKk1hdGguc2luKE1hdGguUEkvXHJcbjE4MCp0aGlzLmxhYmVsQW5nbGUpLXRoaXMudGlja0xlbmd0aCkpOlwicmlnaHRcIj09PXRoaXMuX3Bvc2l0aW9uJiYocj0xPT09dGhpcy5jdHgubGluZVdpZHRoJTI/KGEueTw8MCkrMC41OmEueTw8MCx0aGlzLmN0eC5iZWdpblBhdGgoKSx0aGlzLmN0eC5tb3ZlVG8oYS54PDwwLHIpLHRoaXMuY3R4LmxpbmVUbyhhLngrdGhpcy50aWNrTGVuZ3RoPDwwLHIpLHRoaXMuY3R4LnN0cm9rZSgpLDA9PT10aGlzLmxhYmVsQW5nbGU/YS54PWEueCt0aGlzLnRpY2tMZW5ndGgrNTooYS55PTA+dGhpcy5sYWJlbEFuZ2xlP2EueTphLnktKGIudGV4dEJsb2NrLmhlaWdodC1iLnRleHRCbG9jay5mb250U2l6ZS8yLTUpKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSksYS54PTA8dGhpcy5sYWJlbEFuZ2xlP2EueCsoYi50ZXh0QmxvY2suaGVpZ2h0LWIudGV4dEJsb2NrLmZvbnRTaXplLzItNSkqTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSt0aGlzLnRpY2tMZW5ndGg6XHJcbmEueCt0aGlzLnRpY2tMZW5ndGgrNSkpO2Vsc2UgYi50ZXh0QmxvY2suYW5nbGU9LTkwLFwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbj8oYi50ZXh0QmxvY2subWF4V2lkdGg9dGhpcy5vcHRpb25zLnN0cmlwTGluZXNbY10ubGFiZWxNYXhXaWR0aD90aGlzLm9wdGlvbnMuc3RyaXBMaW5lc1tjXS5sYWJlbE1heFdpZHRoOnRoaXMuY2hhcnQucGxvdEFyZWEuaGVpZ2h0LTMsYi50ZXh0QmxvY2subWVhc3VyZVRleHQoKSxhLngtYi50ZXh0QmxvY2suaGVpZ2h0PnRoaXMuY2hhcnQucGxvdEFyZWEueDE/eShrLnN0YXJ0VmFsdWUpP2EueC09Yi50ZXh0QmxvY2suaGVpZ2h0LWIudGV4dEJsb2NrLmZvbnRTaXplLzI6YS54LT1iLnRleHRCbG9jay5oZWlnaHQvMi1iLnRleHRCbG9jay5mb250U2l6ZS8yKzM6KGIudGV4dEJsb2NrLmFuZ2xlPTkwLHkoay5zdGFydFZhbHVlKT9hLngrPWIudGV4dEJsb2NrLmhlaWdodC1iLnRleHRCbG9jay5mb250U2l6ZS8yOmEueCs9Yi50ZXh0QmxvY2suaGVpZ2h0L1xyXG4yLWIudGV4dEJsb2NrLmZvbnRTaXplLzIrMyksYS55PS05MD09PWIudGV4dEJsb2NrLmFuZ2xlP1wibmVhclwiPT09Yi5zdHJpcExpbmUubGFiZWxBbGlnbj90aGlzLmNoYXJ0LnBsb3RBcmVhLnkyLTM6XCJjZW50ZXJcIj09PWIuc3RyaXBMaW5lLmxhYmVsQWxpZ24/KHRoaXMuY2hhcnQucGxvdEFyZWEueTIrdGhpcy5jaGFydC5wbG90QXJlYS55MStiLnRleHRCbG9jay53aWR0aCkvMjp0aGlzLmNoYXJ0LnBsb3RBcmVhLnkxK2IudGV4dEJsb2NrLndpZHRoKzM6XCJuZWFyXCI9PT1iLnN0cmlwTGluZS5sYWJlbEFsaWduP3RoaXMuY2hhcnQucGxvdEFyZWEueTItYi50ZXh0QmxvY2sud2lkdGgtMzpcImNlbnRlclwiPT09Yi5zdHJpcExpbmUubGFiZWxBbGlnbj8odGhpcy5jaGFydC5wbG90QXJlYS55Mit0aGlzLmNoYXJ0LnBsb3RBcmVhLnkxLWIudGV4dEJsb2NrLndpZHRoKS8yOnRoaXMuY2hhcnQucGxvdEFyZWEueTErMyk6XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uPyhiLnRleHRCbG9jay5tYXhXaWR0aD1cclxudGhpcy5vcHRpb25zLnN0cmlwTGluZXNbY10ubGFiZWxNYXhXaWR0aD90aGlzLm9wdGlvbnMuc3RyaXBMaW5lc1tjXS5sYWJlbE1heFdpZHRoOnRoaXMuY2hhcnQucGxvdEFyZWEuaGVpZ2h0LTMsYi50ZXh0QmxvY2subWVhc3VyZVRleHQoKSxhLngtYi50ZXh0QmxvY2suaGVpZ2h0PnRoaXMuY2hhcnQucGxvdEFyZWEueDE/eShrLnN0YXJ0VmFsdWUpP2EueC09Yi50ZXh0QmxvY2suaGVpZ2h0LWIudGV4dEJsb2NrLmZvbnRTaXplLzI6YS54LT1iLnRleHRCbG9jay5oZWlnaHQvMi1iLnRleHRCbG9jay5mb250U2l6ZS8yKzM6KGIudGV4dEJsb2NrLmFuZ2xlPTkwLHkoay5zdGFydFZhbHVlKT9hLngrPWIudGV4dEJsb2NrLmhlaWdodC1iLnRleHRCbG9jay5mb250U2l6ZS8yOmEueCs9Yi50ZXh0QmxvY2suaGVpZ2h0LzItYi50ZXh0QmxvY2suZm9udFNpemUvMiszKSxhLnk9LTkwPT09Yi50ZXh0QmxvY2suYW5nbGU/XCJuZWFyXCI9PT1iLnN0cmlwTGluZS5sYWJlbEFsaWduP3RoaXMuY2hhcnQucGxvdEFyZWEueTErXHJcbmIudGV4dEJsb2NrLndpZHRoKzM6XCJjZW50ZXJcIj09PWIuc3RyaXBMaW5lLmxhYmVsQWxpZ24/KHRoaXMuY2hhcnQucGxvdEFyZWEueTIrdGhpcy5jaGFydC5wbG90QXJlYS55MStiLnRleHRCbG9jay53aWR0aCkvMjp0aGlzLmNoYXJ0LnBsb3RBcmVhLnkyLTM6XCJuZWFyXCI9PT1iLnN0cmlwTGluZS5sYWJlbEFsaWduP3RoaXMuY2hhcnQucGxvdEFyZWEueTErMzpcImNlbnRlclwiPT09Yi5zdHJpcExpbmUubGFiZWxBbGlnbj8odGhpcy5jaGFydC5wbG90QXJlYS55Mit0aGlzLmNoYXJ0LnBsb3RBcmVhLnkxLWIudGV4dEJsb2NrLndpZHRoKS8yOnRoaXMuY2hhcnQucGxvdEFyZWEueTItYi50ZXh0QmxvY2sud2lkdGgtMyk6XCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbj8oYi50ZXh0QmxvY2subWF4V2lkdGg9dGhpcy5vcHRpb25zLnN0cmlwTGluZXNbY10ubGFiZWxNYXhXaWR0aD90aGlzLm9wdGlvbnMuc3RyaXBMaW5lc1tjXS5sYWJlbE1heFdpZHRoOnRoaXMuY2hhcnQucGxvdEFyZWEud2lkdGgtXHJcbjMsYi50ZXh0QmxvY2suYW5nbGU9MCxiLnRleHRCbG9jay5tZWFzdXJlVGV4dCgpLGEueS1iLnRleHRCbG9jay5oZWlnaHQ+dGhpcy5jaGFydC5wbG90QXJlYS55MT95KGsuc3RhcnRWYWx1ZSk/YS55LT1iLnRleHRCbG9jay5oZWlnaHQtYi50ZXh0QmxvY2suZm9udFNpemUvMjphLnktPWIudGV4dEJsb2NrLmhlaWdodC8yLWIudGV4dEJsb2NrLmZvbnRTaXplKzM6YS55LWIudGV4dEJsb2NrLmhlaWdodDx0aGlzLmNoYXJ0LnBsb3RBcmVhLnkyP2EueSs9Yi50ZXh0QmxvY2suZm9udFNpemUvMiszOnkoay5zdGFydFZhbHVlKT9hLnktPWIudGV4dEJsb2NrLmhlaWdodC1iLnRleHRCbG9jay5mb250U2l6ZS8yOmEueS09Yi50ZXh0QmxvY2suaGVpZ2h0LzItYi50ZXh0QmxvY2suZm9udFNpemUrMyxhLng9XCJuZWFyXCI9PT1iLnN0cmlwTGluZS5sYWJlbEFsaWduP3RoaXMuY2hhcnQucGxvdEFyZWEueDErMzpcImNlbnRlclwiPT09Yi5zdHJpcExpbmUubGFiZWxBbGlnbj8odGhpcy5jaGFydC5wbG90QXJlYS54MitcclxudGhpcy5jaGFydC5wbG90QXJlYS54MSkvMi1iLnRleHRCbG9jay53aWR0aC8yOnRoaXMuY2hhcnQucGxvdEFyZWEueDItYi50ZXh0QmxvY2sud2lkdGgtMyk6XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24mJihiLnRleHRCbG9jay5tYXhXaWR0aD10aGlzLm9wdGlvbnMuc3RyaXBMaW5lc1tjXS5sYWJlbE1heFdpZHRoP3RoaXMub3B0aW9ucy5zdHJpcExpbmVzW2NdLmxhYmVsTWF4V2lkdGg6dGhpcy5jaGFydC5wbG90QXJlYS53aWR0aC0zLGIudGV4dEJsb2NrLmFuZ2xlPTAsYi50ZXh0QmxvY2subWVhc3VyZVRleHQoKSxhLnktK2IudGV4dEJsb2NrLmhlaWdodD50aGlzLmNoYXJ0LnBsb3RBcmVhLnkxP3koay5zdGFydFZhbHVlKT9hLnktPWIudGV4dEJsb2NrLmhlaWdodC1iLnRleHRCbG9jay5mb250U2l6ZS8yOmEueS09Yi50ZXh0QmxvY2suaGVpZ2h0LzItYi50ZXh0QmxvY2suZm9udFNpemUvMi0zOmEueS1iLnRleHRCbG9jay5oZWlnaHQ8dGhpcy5jaGFydC5wbG90QXJlYS55Mj9cclxuYS55Kz1iLnRleHRCbG9jay5mb250U2l6ZS8yKzM6eShrLnN0YXJ0VmFsdWUpP2EueS09Yi50ZXh0QmxvY2suaGVpZ2h0LWIudGV4dEJsb2NrLmZvbnRTaXplLzI6YS55LT1iLnRleHRCbG9jay5oZWlnaHQvMi1iLnRleHRCbG9jay5mb250U2l6ZS8yKzMsYS54PVwibmVhclwiPT09Yi5zdHJpcExpbmUubGFiZWxBbGlnbj90aGlzLmNoYXJ0LnBsb3RBcmVhLngyLWIudGV4dEJsb2NrLndpZHRoLTM6XCJjZW50ZXJcIj09PWIuc3RyaXBMaW5lLmxhYmVsQWxpZ24/KHRoaXMuY2hhcnQucGxvdEFyZWEueDIrdGhpcy5jaGFydC5wbG90QXJlYS54MSkvMi1iLnRleHRCbG9jay53aWR0aC8yOnRoaXMuY2hhcnQucGxvdEFyZWEueDErMyk7Yi50ZXh0QmxvY2sueD1hLng7Yi50ZXh0QmxvY2sueT1hLnk7bS5wdXNoKGIpfWlmKCFoKXtoPSExO3RoaXMuY3R4LnNhdmUoKTt0aGlzLmN0eC5iZWdpblBhdGgoKTt0aGlzLmN0eC5yZWN0KHRoaXMuY2hhcnQucGxvdEFyZWEueDEsdGhpcy5jaGFydC5wbG90QXJlYS55MSxcclxudGhpcy5jaGFydC5wbG90QXJlYS53aWR0aCx0aGlzLmNoYXJ0LnBsb3RBcmVhLmhlaWdodCk7dGhpcy5jdHguY2xpcCgpO2ZvcihjPTA7YzxsLmxlbmd0aDtjKyspaz1sW2NdLGsuc2hvd09uVG9wP2d8fChnPSEwLHRoaXMuY2hhcnQuYWRkRXZlbnRMaXN0ZW5lcihcImRhdGFBbmltYXRpb25JdGVyYXRpb25FbmRcIixmdW5jdGlvbigpe3RoaXMuY3R4LnNhdmUoKTt0aGlzLmN0eC5iZWdpblBhdGgoKTt0aGlzLmN0eC5yZWN0KHRoaXMuY2hhcnQucGxvdEFyZWEueDEsdGhpcy5jaGFydC5wbG90QXJlYS55MSx0aGlzLmNoYXJ0LnBsb3RBcmVhLndpZHRoLHRoaXMuY2hhcnQucGxvdEFyZWEuaGVpZ2h0KTt0aGlzLmN0eC5jbGlwKCk7Zm9yKGU9MDtlPGwubGVuZ3RoO2UrKylrPWxbZV0say5zaG93T25Ub3AmJmsucmVuZGVyKCk7dGhpcy5jdHgucmVzdG9yZSgpfSxrKSk6ay5yZW5kZXIoKTtmb3IoYz0wO2M8bS5sZW5ndGg7YysrKWI9bVtjXSxiLnN0cmlwTGluZS5zaG93T25Ub3A/aHx8KGg9XHJcbiEwLHRoaXMuY2hhcnQuYWRkRXZlbnRMaXN0ZW5lcihcImRhdGFBbmltYXRpb25JdGVyYXRpb25FbmRcIixmdW5jdGlvbigpe2ZvcihlPTA7ZTxtLmxlbmd0aDtlKyspYj1tW2VdLFwiaW5zaWRlXCI9PT1iLnN0cmlwTGluZS5sYWJlbFBsYWNlbWVudCYmYi5zdHJpcExpbmUuc2hvd09uVG9wJiYoZi5jdHguc2F2ZSgpLGYuY3R4LmJlZ2luUGF0aCgpLGYuY3R4LnJlY3QoZi5jaGFydC5wbG90QXJlYS54MSxmLmNoYXJ0LnBsb3RBcmVhLnkxLGYuY2hhcnQucGxvdEFyZWEud2lkdGgsZi5jaGFydC5wbG90QXJlYS5oZWlnaHQpLGYuY3R4LmNsaXAoKSxiLnRleHRCbG9jay5yZW5kZXIoITApLGYuY3R4LnJlc3RvcmUoKSl9LGIudGV4dEJsb2NrKSk6XCJpbnNpZGVcIj09PWIuc3RyaXBMaW5lLmxhYmVsUGxhY2VtZW50JiZiLnRleHRCbG9jay5yZW5kZXIoITApO3RoaXMuY3R4LnJlc3RvcmUoKTtoPSEwfWlmKGgpZm9yKGg9ITEsYz0wO2M8bS5sZW5ndGg7YysrKWI9bVtjXSxiLnN0cmlwTGluZS5zaG93T25Ub3A/XHJcbmh8fChoPSEwLHRoaXMuY2hhcnQuYWRkRXZlbnRMaXN0ZW5lcihcImRhdGFBbmltYXRpb25JdGVyYXRpb25FbmRcIixmdW5jdGlvbigpe2ZvcihlPTA7ZTxtLmxlbmd0aDtlKyspYj1tW2VdLFwib3V0c2lkZVwiPT09Yi5zdHJpcExpbmUubGFiZWxQbGFjZW1lbnQmJmIuc3RyaXBMaW5lLnNob3dPblRvcCYmYi50ZXh0QmxvY2sucmVuZGVyKCEwKX0sYi50ZXh0QmxvY2spKTpcIm91dHNpZGVcIj09PWIuc3RyaXBMaW5lLmxhYmVsUGxhY2VtZW50JiZiLnRleHRCbG9jay5yZW5kZXIoITApfX07Qy5wcm90b3R5cGUucmVuZGVyQnJlYWtzQmFja2dyb3VuZD1mdW5jdGlvbigpe3RoaXMuY2hhcnQuX2JyZWFrc0NhbnZhcyYmKHRoaXMuc2NhbGVCcmVha3MmJjA8dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgmJnRoaXMubWFza0NhbnZhcykmJih0aGlzLmNoYXJ0Ll9icmVha3NDYW52YXNDdHguc2F2ZSgpLHRoaXMuY2hhcnQuX2JyZWFrc0NhbnZhc0N0eC5iZWdpblBhdGgoKSx0aGlzLmNoYXJ0Ll9icmVha3NDYW52YXNDdHgucmVjdCh0aGlzLmNoYXJ0LnBsb3RBcmVhLngxLFxyXG50aGlzLmNoYXJ0LnBsb3RBcmVhLnkxLHRoaXMuY2hhcnQucGxvdEFyZWEud2lkdGgsdGhpcy5jaGFydC5wbG90QXJlYS5oZWlnaHQpLHRoaXMuY2hhcnQuX2JyZWFrc0NhbnZhc0N0eC5jbGlwKCksdGhpcy5jaGFydC5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLm1hc2tDYW52YXMsMCwwLHRoaXMuY2hhcnQud2lkdGgsdGhpcy5jaGFydC5oZWlnaHQpLHRoaXMuY2hhcnQuX2JyZWFrc0NhbnZhc0N0eC5yZXN0b3JlKCkpfTtDLnByb3RvdHlwZS5jcmVhdGVNYXNrPWZ1bmN0aW9uKCl7aWYodGhpcy5zY2FsZUJyZWFrcyYmMDx0aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aCl7dmFyIGE9dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrczt2Pyh0aGlzLm1hc2tDYW52YXM9dWEodGhpcy5jaGFydC53aWR0aCx0aGlzLmNoYXJ0LmhlaWdodCksdGhpcy5tYXNrQ3R4PXRoaXMubWFza0NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikpOih0aGlzLm1hc2tDYW52YXM9XHJcbnRoaXMuY2hhcnQucGxvdEFyZWEuY2FudmFzLHRoaXMubWFza0N0eD10aGlzLmNoYXJ0LnBsb3RBcmVhLmN0eCk7dGhpcy5tYXNrQ3R4LnNhdmUoKTt0aGlzLm1hc2tDdHguYmVnaW5QYXRoKCk7dGhpcy5tYXNrQ3R4LnJlY3QodGhpcy5jaGFydC5wbG90QXJlYS54MSx0aGlzLmNoYXJ0LnBsb3RBcmVhLnkxLHRoaXMuY2hhcnQucGxvdEFyZWEud2lkdGgsdGhpcy5jaGFydC5wbG90QXJlYS5oZWlnaHQpO3RoaXMubWFza0N0eC5jbGlwKCk7Zm9yKHZhciBmPTA7ZjxhLmxlbmd0aDtmKyspYVtmXS5lbmRWYWx1ZTx0aGlzLnZpZXdwb3J0TWluaW11bXx8KGFbZl0uc3RhcnRWYWx1ZT50aGlzLnZpZXdwb3J0TWF4aW11bXx8aXNOYU4odGhpcy5yYW5nZSkpfHxhW2ZdLnJlbmRlcih0aGlzLm1hc2tDdHgpO3RoaXMubWFza0N0eC5yZXN0b3JlKCl9fTtDLnByb3RvdHlwZS5yZW5kZXJDcm9zc2hhaXI9ZnVuY3Rpb24oYSxmKXt0aGlzLmNyb3NzaGFpci5yZW5kZXIoYSxmKX07Qy5wcm90b3R5cGUucmVuZGVyR3JpZD1cclxuZnVuY3Rpb24oKXtpZih0aGlzLmdyaWRUaGlja25lc3MmJjA8dGhpcy5ncmlkVGhpY2tuZXNzKXt2YXIgYT10aGlzLmNoYXJ0LmN0eDthLnNhdmUoKTt2YXIgZixiPXRoaXMuY2hhcnQucGxvdEFyZWE7YS5saW5lV2lkdGg9dGhpcy5ncmlkVGhpY2tuZXNzO2Euc3Ryb2tlU3R5bGU9dGhpcy5ncmlkQ29sb3I7YS5zZXRMaW5lRGFzaCYmYS5zZXRMaW5lRGFzaChHKHRoaXMuZ3JpZERhc2hUeXBlLHRoaXMuZ3JpZFRoaWNrbmVzcykpO2lmKFwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uKWZvcihjPTA7Yzx0aGlzLl9sYWJlbHMubGVuZ3RoO2MrKyl0aGlzLl9sYWJlbHNbY10ucG9zaXRpb248dGhpcy52aWV3cG9ydE1pbmltdW18fCh0aGlzLl9sYWJlbHNbY10ucG9zaXRpb24+dGhpcy52aWV3cG9ydE1heGltdW18fHRoaXMuX2xhYmVsc1tjXS5icmVha3NMYWJlbFR5cGUpfHwoYS5iZWdpblBhdGgoKSxmPXRoaXMuZ2V0UGl4ZWxDb29yZGluYXRlc09uQXhpcyh0aGlzLl9sYWJlbHNbY10ucG9zaXRpb24pLFxyXG5mPTE9PT1hLmxpbmVXaWR0aCUyPyhmLng8PDApKzAuNTpmLng8PDAsYS5tb3ZlVG8oZixiLnkxPDwwKSxhLmxpbmVUbyhmLGIueTI8PDApLGEuc3Ryb2tlKCkpO2Vsc2UgaWYoXCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24pZm9yKHZhciBjPTA7Yzx0aGlzLl9sYWJlbHMubGVuZ3RoO2MrKyl0aGlzLl9sYWJlbHNbY10ucG9zaXRpb248dGhpcy52aWV3cG9ydE1pbmltdW18fCh0aGlzLl9sYWJlbHNbY10ucG9zaXRpb24+dGhpcy52aWV3cG9ydE1heGltdW18fHRoaXMuX2xhYmVsc1tjXS5icmVha3NMYWJlbFR5cGUpfHwoYS5iZWdpblBhdGgoKSxmPXRoaXMuZ2V0UGl4ZWxDb29yZGluYXRlc09uQXhpcyh0aGlzLl9sYWJlbHNbY10ucG9zaXRpb24pLGY9MT09PWEubGluZVdpZHRoJTI/KGYueTw8MCkrMC41OmYueTw8MCxhLm1vdmVUbyhiLngxPDwwLGYpLGEubGluZVRvKGIueDI8PDAsZiksYS5zdHJva2UoKSk7YS5yZXN0b3JlKCl9fTtDLnByb3RvdHlwZS5yZW5kZXJBeGlzTGluZT1cclxuZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LmN0eCxmPXY/dGhpcy5jaGFydC5fcHJlUmVuZGVyQ3R4OmEsYj1NYXRoLmNlaWwodGhpcy50aWNrVGhpY2tuZXNzLyh0aGlzLnJldmVyc2VkPy0yOjIpKSxjPU1hdGguY2VpbCh0aGlzLnRpY2tUaGlja25lc3MvKHRoaXMucmV2ZXJzZWQ/MjotMikpLGUsZztmLnNhdmUoKTtpZihcImJvdHRvbVwiPT09dGhpcy5fcG9zaXRpb258fFwidG9wXCI9PT10aGlzLl9wb3NpdGlvbil7aWYodGhpcy5saW5lVGhpY2tuZXNzKXt0aGlzLnJldmVyc2VkPyhlPXRoaXMubGluZUNvb3JkaW5hdGVzLngyLGc9dGhpcy5saW5lQ29vcmRpbmF0ZXMueDEpOihlPXRoaXMubGluZUNvb3JkaW5hdGVzLngxLGc9dGhpcy5saW5lQ29vcmRpbmF0ZXMueDIpO2YubGluZVdpZHRoPXRoaXMubGluZVRoaWNrbmVzcztmLnN0cm9rZVN0eWxlPXRoaXMubGluZUNvbG9yP3RoaXMubGluZUNvbG9yOlwiYmxhY2tcIjtmLnNldExpbmVEYXNoJiZmLnNldExpbmVEYXNoKEcodGhpcy5saW5lRGFzaFR5cGUsXHJcbnRoaXMubGluZVRoaWNrbmVzcykpO3ZhciBoPTE9PT10aGlzLmxpbmVUaGlja25lc3MlMj8odGhpcy5saW5lQ29vcmRpbmF0ZXMueTE8PDApKzAuNTp0aGlzLmxpbmVDb29yZGluYXRlcy55MTw8MDtmLmJlZ2luUGF0aCgpO2lmKHRoaXMuc2NhbGVCcmVha3MmJiF5KHRoaXMuc2NhbGVCcmVha3MuZmlyc3RCcmVha0luZGV4KSlpZih5KHRoaXMuc2NhbGVCcmVha3MubGFzdEJyZWFrSW5kZXgpKWU9dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrc1t0aGlzLnNjYWxlQnJlYWtzLmZpcnN0QnJlYWtJbmRleF0uZW5kUGl4ZWwrYztlbHNlIGZvcih2YXIgbD10aGlzLnNjYWxlQnJlYWtzLmZpcnN0QnJlYWtJbmRleDtsPD10aGlzLnNjYWxlQnJlYWtzLmxhc3RCcmVha0luZGV4O2wrKylmLm1vdmVUbyhlLGgpLGYubGluZVRvKHRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbbF0uc3RhcnRQaXhlbCtiLGgpLGU9dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrc1tsXS5lbmRQaXhlbCtcclxuYztlJiYoZi5tb3ZlVG8oZSxoKSxmLmxpbmVUbyhnLGgpKTtmLnN0cm9rZSgpfX1lbHNlIGlmKChcImxlZnRcIj09PXRoaXMuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLl9wb3NpdGlvbikmJnRoaXMubGluZVRoaWNrbmVzcyl7dGhpcy5yZXZlcnNlZD8oZT10aGlzLmxpbmVDb29yZGluYXRlcy55MSxnPXRoaXMubGluZUNvb3JkaW5hdGVzLnkyKTooZT10aGlzLmxpbmVDb29yZGluYXRlcy55MixnPXRoaXMubGluZUNvb3JkaW5hdGVzLnkxKTtmLmxpbmVXaWR0aD10aGlzLmxpbmVUaGlja25lc3M7Zi5zdHJva2VTdHlsZT10aGlzLmxpbmVDb2xvcjtmLnNldExpbmVEYXNoJiZmLnNldExpbmVEYXNoKEcodGhpcy5saW5lRGFzaFR5cGUsdGhpcy5saW5lVGhpY2tuZXNzKSk7aD0xPT09dGhpcy5saW5lVGhpY2tuZXNzJTI/KHRoaXMubGluZUNvb3JkaW5hdGVzLngxPDwwKSswLjU6dGhpcy5saW5lQ29vcmRpbmF0ZXMueDE8PDA7Zi5iZWdpblBhdGgoKTtpZih0aGlzLnNjYWxlQnJlYWtzJiZcclxuIXkodGhpcy5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXgpKWlmKHkodGhpcy5zY2FsZUJyZWFrcy5sYXN0QnJlYWtJbmRleCkpZT10aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW3RoaXMuc2NhbGVCcmVha3MuZmlyc3RCcmVha0luZGV4XS5lbmRQaXhlbCtiO2Vsc2UgZm9yKGw9dGhpcy5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXg7bDw9dGhpcy5zY2FsZUJyZWFrcy5sYXN0QnJlYWtJbmRleDtsKyspZi5tb3ZlVG8oaCxlKSxmLmxpbmVUbyhoLHRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbbF0uc3RhcnRQaXhlbCtjKSxlPXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbbF0uZW5kUGl4ZWwrYjtlJiYoZi5tb3ZlVG8oaCxlKSxmLmxpbmVUbyhoLGcpKTtmLnN0cm9rZSgpfXYmJihhLmRyYXdJbWFnZSh0aGlzLmNoYXJ0Ll9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMuY2hhcnQud2lkdGgsdGhpcy5jaGFydC5oZWlnaHQpLHRoaXMuY2hhcnQuX2JyZWFrc0NhbnZhc0N0eCYmXHJcbnRoaXMuY2hhcnQuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5jaGFydC5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLmNoYXJ0LndpZHRoLHRoaXMuY2hhcnQuaGVpZ2h0KSxmLmNsZWFyUmVjdCgwLDAsdGhpcy5jaGFydC53aWR0aCx0aGlzLmNoYXJ0LmhlaWdodCkpO2YucmVzdG9yZSgpfTtDLnByb3RvdHlwZS5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzPWZ1bmN0aW9uKGEpe3ZhciBmPXt9O2lmKFwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uKWYueD10aGlzLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoYSksZi55PXRoaXMubGluZUNvb3JkaW5hdGVzLnkxO2lmKFwibGVmdFwiPT09dGhpcy5fcG9zaXRpb258fFwicmlnaHRcIj09PXRoaXMuX3Bvc2l0aW9uKWYueT10aGlzLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoYSksZi54PXRoaXMubGluZUNvb3JkaW5hdGVzLngyO3JldHVybiBmfTtDLnByb3RvdHlwZS5jb252ZXJ0UGl4ZWxUb1ZhbHVlPWZ1bmN0aW9uKGEpe2lmKFwidW5kZWZpbmVkXCI9PT1cclxudHlwZW9mIGEpcmV0dXJuIG51bGw7dmFyIGY9MCxiPTAsYyxmPSEwLGU9dGhpcy5zY2FsZUJyZWFrcz90aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzOltdLGI9XCJudW1iZXJcIj09PXR5cGVvZiBhP2E6XCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24/YS55OmEueDtpZih0aGlzLmxvZ2FyaXRobWljKXthPWM9TWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLChiLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucmVmZXJlbmNlKS90aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLnBpeGVsUGVyVW5pdCk7aWYoYjw9dGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5yZWZlcmVuY2U9PT0oXCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24pIT09dGhpcy5yZXZlcnNlZClmb3IoYj0wO2I8ZS5sZW5ndGg7YisrKXtpZighKGVbYl0uZW5kVmFsdWU8dGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKSlpZihmKWlmKGVbYl0uc3RhcnRWYWx1ZTxcclxudGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKXtpZigxPGVbYl0uc2l6ZSYmdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKk1hdGgucG93KGVbYl0uZW5kVmFsdWUvZVtiXS5zdGFydFZhbHVlLE1hdGgubG9nKGMpL01hdGgubG9nKGVbYl0uc2l6ZSkpPGVbYl0uZW5kVmFsdWUpe2E9TWF0aC5wb3coZVtiXS5lbmRWYWx1ZS9lW2JdLnN0YXJ0VmFsdWUsTWF0aC5sb2coYykvTWF0aC5sb2coZVtiXS5zaXplKSk7YnJlYWt9ZWxzZSBhKj1lW2JdLmVuZFZhbHVlL3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bS9NYXRoLnBvdyhlW2JdLnNpemUsTWF0aC5sb2coZVtiXS5lbmRWYWx1ZS90aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0pL01hdGgubG9nKGVbYl0uZW5kVmFsdWUvZVtiXS5zdGFydFZhbHVlKSksYy89TWF0aC5wb3coZVtiXS5zaXplLE1hdGgubG9nKGVbYl0uZW5kVmFsdWUvdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKS9cclxuTWF0aC5sb2coZVtiXS5lbmRWYWx1ZS9lW2JdLnN0YXJ0VmFsdWUpKTtmPSExfWVsc2UgaWYoYz5lW2JdLnN0YXJ0VmFsdWUvdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKXtjLz1lW2JdLnN0YXJ0VmFsdWUvdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtO2lmKGM8ZVtiXS5zaXplKXthKj1NYXRoLnBvdyhlW2JdLmVuZFZhbHVlL2VbYl0uc3RhcnRWYWx1ZSwxPT09ZVtiXS5zaXplPzE6TWF0aC5sb2coYykvTWF0aC5sb2coZVtiXS5zaXplKSkvYzticmVha31lbHNlIGEqPWVbYl0uZW5kVmFsdWUvZVtiXS5zdGFydFZhbHVlL2VbYl0uc2l6ZTtjLz1lW2JdLnNpemU7Zj0hMX1lbHNlIGJyZWFrO2Vsc2UgaWYoYz5lW2JdLnN0YXJ0VmFsdWUvZVtiLTFdLmVuZFZhbHVlKXtjLz1lW2JdLnN0YXJ0VmFsdWUvZVtiLTFdLmVuZFZhbHVlO2lmKGM8ZVtiXS5zaXplKXthKj1NYXRoLnBvdyhlW2JdLmVuZFZhbHVlL2VbYl0uc3RhcnRWYWx1ZSwxPT09ZVtiXS5zaXplP1xyXG4xOk1hdGgubG9nKGMpL01hdGgubG9nKGVbYl0uc2l6ZSkpL2M7YnJlYWt9ZWxzZSBhKj1lW2JdLmVuZFZhbHVlL2VbYl0uc3RhcnRWYWx1ZS9lW2JdLnNpemU7Yy89ZVtiXS5zaXplfWVsc2UgYnJlYWt9ZWxzZSBmb3IoYj1lLmxlbmd0aC0xOzA8PWI7Yi0tKWlmKCEoZVtiXS5zdGFydFZhbHVlPnRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSkpaWYoZilpZihlW2JdLmVuZFZhbHVlPnRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSl7aWYoMTxlW2JdLnNpemUmJnRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSpNYXRoLnBvdyhlW2JdLmVuZFZhbHVlL2VbYl0uc3RhcnRWYWx1ZSxNYXRoLmxvZyhjKS9NYXRoLmxvZyhlW2JdLnNpemUpKT5lW2JdLnN0YXJ0VmFsdWUpe2E9TWF0aC5wb3coZVtiXS5lbmRWYWx1ZS9lW2JdLnN0YXJ0VmFsdWUsTWF0aC5sb2coYykvTWF0aC5sb2coZVtiXS5zaXplKSk7YnJlYWt9ZWxzZSBhKj1lW2JdLnN0YXJ0VmFsdWUvXHJcbnRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSpNYXRoLnBvdyhlW2JdLnNpemUsTWF0aC5sb2coZVtiXS5zdGFydFZhbHVlL3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSkvTWF0aC5sb2coZVtiXS5lbmRWYWx1ZS9lW2JdLnN0YXJ0VmFsdWUpKSpjLGMqPU1hdGgucG93KGVbYl0uc2l6ZSxNYXRoLmxvZyh0aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0vZVtiXS5zdGFydFZhbHVlKS9NYXRoLmxvZyhlW2JdLmVuZFZhbHVlL2VbYl0uc3RhcnRWYWx1ZSkpO2Y9ITF9ZWxzZSBpZihjPGVbYl0uZW5kVmFsdWUvdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKXtjLz1lW2JdLmVuZFZhbHVlL3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bTtpZihjPjEvZVtiXS5zaXplKXthKj1NYXRoLnBvdyhlW2JdLmVuZFZhbHVlL2VbYl0uc3RhcnRWYWx1ZSwxPj1lW2JdLnNpemU/MTpNYXRoLmxvZyhjKS9NYXRoLmxvZyhlW2JdLnNpemUpKSpcclxuYzticmVha31lbHNlIGEvPWVbYl0uZW5kVmFsdWUvZVtiXS5zdGFydFZhbHVlL2VbYl0uc2l6ZTtjKj1lW2JdLnNpemU7Zj0hMX1lbHNlIGJyZWFrO2Vsc2UgaWYoYzxlW2JdLmVuZFZhbHVlL2VbYisxXS5zdGFydFZhbHVlKXtjLz1lW2JdLmVuZFZhbHVlL2VbYisxXS5zdGFydFZhbHVlO2lmKGM+MS9lW2JdLnNpemUpe2EqPU1hdGgucG93KGVbYl0uZW5kVmFsdWUvZVtiXS5zdGFydFZhbHVlLDE+PWVbYl0uc2l6ZT8xOk1hdGgubG9nKGMpL01hdGgubG9nKGVbYl0uc2l6ZSkpKmM7YnJlYWt9ZWxzZSBhLz1lW2JdLmVuZFZhbHVlL2VbYl0uc3RhcnRWYWx1ZS9lW2JdLnNpemU7Yyo9ZVtiXS5zaXplfWVsc2UgYnJlYWs7Zj1hKnRoaXMudmlld3BvcnRNaW5pbXVtfWVsc2V7YT1jPShiLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucmVmZXJlbmNlKS90aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLnBpeGVsUGVyVW5pdDtpZihiPD10aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLnJlZmVyZW5jZT09PVxyXG4oXCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24pIT09dGhpcy5yZXZlcnNlZClmb3IoYj0wO2I8ZS5sZW5ndGg7YisrKXtpZighKGVbYl0uZW5kVmFsdWU8dGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKSlpZihmKWlmKGVbYl0uc3RhcnRWYWx1ZTx0aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0pe2lmKGVbYl0uc2l6ZSYmdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtK2MqKGVbYl0uZW5kVmFsdWUtZVtiXS5zdGFydFZhbHVlKS9lW2JdLnNpemU8ZVtiXS5lbmRWYWx1ZSl7YT0wPj1lW2JdLnNpemU/MDpjKihlW2JdLmVuZFZhbHVlLWVbYl0uc3RhcnRWYWx1ZSkvZVtiXS5zaXplO2JyZWFrfWVsc2UgYSs9ZVtiXS5lbmRWYWx1ZS10aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0tZVtiXS5zaXplKihlW2JdLmVuZFZhbHVlLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSkvKGVbYl0uZW5kVmFsdWUtXHJcbmVbYl0uc3RhcnRWYWx1ZSksYy09ZVtiXS5zaXplKihlW2JdLmVuZFZhbHVlLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSkvKGVbYl0uZW5kVmFsdWUtZVtiXS5zdGFydFZhbHVlKTtmPSExfWVsc2UgaWYoYz5lW2JdLnN0YXJ0VmFsdWUtdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKXtjLT1lW2JdLnN0YXJ0VmFsdWUtdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtO2lmKGM8ZVtiXS5zaXplKXthKz0oZVtiXS5lbmRWYWx1ZS1lW2JdLnN0YXJ0VmFsdWUpKigwPT09ZVtiXS5zaXplPzE6Yy9lW2JdLnNpemUpLWM7YnJlYWt9ZWxzZSBhKz1lW2JdLmVuZFZhbHVlLWVbYl0uc3RhcnRWYWx1ZS1lW2JdLnNpemU7Yy09ZVtiXS5zaXplO2Y9ITF9ZWxzZSBicmVhaztlbHNlIGlmKGM+ZVtiXS5zdGFydFZhbHVlLWVbYi0xXS5lbmRWYWx1ZSl7Yy09ZVtiXS5zdGFydFZhbHVlLWVbYi0xXS5lbmRWYWx1ZTtpZihjPGVbYl0uc2l6ZSl7YSs9KGVbYl0uZW5kVmFsdWUtXHJcbmVbYl0uc3RhcnRWYWx1ZSkqKDA9PT1lW2JdLnNpemU/MTpjL2VbYl0uc2l6ZSktYzticmVha31lbHNlIGErPWVbYl0uZW5kVmFsdWUtZVtiXS5zdGFydFZhbHVlLWVbYl0uc2l6ZTtjLT1lW2JdLnNpemV9ZWxzZSBicmVha31lbHNlIGZvcihiPWUubGVuZ3RoLTE7MDw9YjtiLS0paWYoIShlW2JdLnN0YXJ0VmFsdWU+dGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKSlpZihmKWlmKGVbYl0uZW5kVmFsdWU+dGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKWlmKGVbYl0uc2l6ZSYmdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtK2MqKGVbYl0uZW5kVmFsdWUtZVtiXS5zdGFydFZhbHVlKS9lW2JdLnNpemU+ZVtiXS5zdGFydFZhbHVlKXthPTA+PWVbYl0uc2l6ZT8wOmMqKGVbYl0uZW5kVmFsdWUtZVtiXS5zdGFydFZhbHVlKS9lW2JdLnNpemU7YnJlYWt9ZWxzZSBhKz1lW2JdLnN0YXJ0VmFsdWUtdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtK1xyXG5lW2JdLnNpemUqKHRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bS1lW2JdLnN0YXJ0VmFsdWUpLyhlW2JdLmVuZFZhbHVlLWVbYl0uc3RhcnRWYWx1ZSksYys9ZVtiXS5zaXplKih0aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0tZVtiXS5zdGFydFZhbHVlKS8oZVtiXS5lbmRWYWx1ZS1lW2JdLnN0YXJ0VmFsdWUpLGY9ITE7ZWxzZSBpZihjPGVbYl0uZW5kVmFsdWUtdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKXtjLT1lW2JdLmVuZFZhbHVlLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bTtpZihjPi0xKmVbYl0uc2l6ZSl7YSs9KGVbYl0uZW5kVmFsdWUtZVtiXS5zdGFydFZhbHVlKSooMD09PWVbYl0uc2l6ZT8xOmMvZVtiXS5zaXplKStjO2JyZWFrfWVsc2UgYS09ZVtiXS5lbmRWYWx1ZS1lW2JdLnN0YXJ0VmFsdWUtZVtiXS5zaXplO2MrPWVbYl0uc2l6ZTtmPSExfWVsc2UgYnJlYWs7ZWxzZSBpZihjPGVbYl0uZW5kVmFsdWUtZVtiK1xyXG4xXS5zdGFydFZhbHVlKXtjLT1lW2JdLmVuZFZhbHVlLWVbYisxXS5zdGFydFZhbHVlO2lmKGM+LTEqZVtiXS5zaXplKXthKz0oZVtiXS5lbmRWYWx1ZS1lW2JdLnN0YXJ0VmFsdWUpKigwPT09ZVtiXS5zaXplPzE6Yy9lW2JdLnNpemUpK2M7YnJlYWt9ZWxzZSBhLT1lW2JdLmVuZFZhbHVlLWVbYl0uc3RhcnRWYWx1ZS1lW2JdLnNpemU7Yys9ZVtiXS5zaXplfWVsc2UgYnJlYWs7Zj10aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0rYX1yZXR1cm4gZn07Qy5wcm90b3R5cGUuY29udmVydFZhbHVlVG9QaXhlbD1mdW5jdGlvbihhKXthPXRoaXMuZ2V0QXBwYXJlbnREaWZmZXJlbmNlKHRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSxhLGEpO3JldHVybiB0aGlzLmxvZ2FyaXRobWljP3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucmVmZXJlbmNlK3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0Kk1hdGgubG9nKGEvdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKS9cclxudGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5sbkxvZ2FyaXRobUJhc2UrMC41PDwwOnRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucmVmZXJlbmNlK3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0KihhLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSkrMC41PDwwfTtDLnByb3RvdHlwZS5nZXRBcHBhcmVudERpZmZlcmVuY2U9ZnVuY3Rpb24oYSxmLGIsYyl7dmFyIGU9dGhpcy5zY2FsZUJyZWFrcz90aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzOltdO2lmKHRoaXMubG9nYXJpdGhtaWMpe2I9eShiKT9mL2E6Yjtmb3IodmFyIGc9MDtnPGUubGVuZ3RoJiYhKGY8ZVtnXS5zdGFydFZhbHVlKTtnKyspYT5lW2ddLmVuZFZhbHVlfHwoYTw9ZVtnXS5zdGFydFZhbHVlJiZmPj1lW2ddLmVuZFZhbHVlP2I9Yi9lW2ddLmVuZFZhbHVlKmVbZ10uc3RhcnRWYWx1ZSplW2ddLnNpemU6YT49ZVtnXS5zdGFydFZhbHVlJiZmPj1lW2ddLmVuZFZhbHVlP2I9XHJcbmIvZVtnXS5lbmRWYWx1ZSphKk1hdGgucG93KGVbZ10uc2l6ZSxNYXRoLmxvZyhlW2ddLmVuZFZhbHVlL2EpL01hdGgubG9nKGVbZ10uZW5kVmFsdWUvZVtnXS5zdGFydFZhbHVlKSk6YTw9ZVtnXS5zdGFydFZhbHVlJiZmPD1lW2ddLmVuZFZhbHVlP2I9Yi9mKmVbZ10uc3RhcnRWYWx1ZSpNYXRoLnBvdyhlW2ddLnNpemUsTWF0aC5sb2coZi9lW2ddLnN0YXJ0VmFsdWUpL01hdGgubG9nKGVbZ10uZW5kVmFsdWUvZVtnXS5zdGFydFZhbHVlKSk6IWMmJihhPmVbZ10uc3RhcnRWYWx1ZSYmZjxlW2ddLmVuZFZhbHVlKSYmKGI9YSpNYXRoLnBvdyhlW2ddLnNpemUsTWF0aC5sb2coZi9hKS9NYXRoLmxvZyhlW2ddLmVuZFZhbHVlL2VbZ10uc3RhcnRWYWx1ZSkpKSl9ZWxzZSBmb3IoYj15KGIpP01hdGguYWJzKGYtYSk6YixnPTA7ZzxlLmxlbmd0aCYmIShmPGVbZ10uc3RhcnRWYWx1ZSk7ZysrKWE+ZVtnXS5lbmRWYWx1ZXx8KGE8PWVbZ10uc3RhcnRWYWx1ZSYmZj49ZVtnXS5lbmRWYWx1ZT9cclxuYj1iLWVbZ10uZW5kVmFsdWUrZVtnXS5zdGFydFZhbHVlK2VbZ10uc2l6ZTphPmVbZ10uc3RhcnRWYWx1ZSYmZj49ZVtnXS5lbmRWYWx1ZT9iPWItZVtnXS5lbmRWYWx1ZSthK2VbZ10uc2l6ZSooZVtnXS5lbmRWYWx1ZS1hKS8oZVtnXS5lbmRWYWx1ZS1lW2ddLnN0YXJ0VmFsdWUpOmE8PWVbZ10uc3RhcnRWYWx1ZSYmZjxlW2ddLmVuZFZhbHVlP2I9Yi1mK2VbZ10uc3RhcnRWYWx1ZStlW2ddLnNpemUqKGYtZVtnXS5zdGFydFZhbHVlKS8oZVtnXS5lbmRWYWx1ZS1lW2ddLnN0YXJ0VmFsdWUpOiFjJiYoYT5lW2ddLnN0YXJ0VmFsdWUmJmY8ZVtnXS5lbmRWYWx1ZSkmJihiPWErZVtnXS5zaXplKihmLWEpLyhlW2ddLmVuZFZhbHVlLWVbZ10uc3RhcnRWYWx1ZSkpKTtyZXR1cm4gYn07Qy5wcm90b3R5cGUuc2V0Vmlld1BvcnRSYW5nZT1mdW5jdGlvbihhLGYpe3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW09dGhpcy52aWV3cG9ydE1pbmltdW09TWF0aC5taW4oYSxcclxuZik7dGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bT10aGlzLnZpZXdwb3J0TWF4aW11bT1NYXRoLm1heChhLGYpfTtDLnByb3RvdHlwZS5nZXRYVmFsdWVBdD1mdW5jdGlvbihhKXtpZighYSlyZXR1cm4gbnVsbDt2YXIgZj1udWxsO1wibGVmdFwiPT09dGhpcy5fcG9zaXRpb24/Zj10aGlzLmNvbnZlcnRQaXhlbFRvVmFsdWUoYS55KTpcImJvdHRvbVwiPT09dGhpcy5fcG9zaXRpb24mJihmPXRoaXMuY29udmVydFBpeGVsVG9WYWx1ZShhLngpKTtyZXR1cm4gZn07Qy5wcm90b3R5cGUuY2FsY3VsYXRlVmFsdWVUb1BpeGVsQ29udmVyc2lvblBhcmFtZXRlcnM9ZnVuY3Rpb24oYSl7YT10aGlzLnNjYWxlQnJlYWtzP3RoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3M6W107dmFyIGY9e3BpeGVsUGVyVW5pdDpudWxsLG1pbmltdW06bnVsbCxyZWZlcmVuY2U6bnVsbH0sYj10aGlzLmxpbmVDb29yZGluYXRlcy53aWR0aCxjPXRoaXMubGluZUNvb3JkaW5hdGVzLmhlaWdodCxcclxuYj1cImJvdHRvbVwiPT09dGhpcy5fcG9zaXRpb258fFwidG9wXCI9PT10aGlzLl9wb3NpdGlvbj9iOmMsYz1NYXRoLmFicyh0aGlzLnJhbmdlKTtpZih0aGlzLmxvZ2FyaXRobWljKWZvcih2YXIgZT0wO2U8YS5sZW5ndGgmJiEodGhpcy52aWV3cG9ydE1heGltdW08YVtlXS5zdGFydFZhbHVlKTtlKyspdGhpcy52aWV3cG9ydE1pbmltdW0+YVtlXS5lbmRWYWx1ZXx8KHRoaXMudmlld3BvcnRNaW5pbXVtPj1hW2VdLnN0YXJ0VmFsdWUmJnRoaXMudmlld3BvcnRNYXhpbXVtPD1hW2VdLmVuZFZhbHVlP2I9MDp0aGlzLnZpZXdwb3J0TWluaW11bTw9YVtlXS5zdGFydFZhbHVlJiZ0aGlzLnZpZXdwb3J0TWF4aW11bT49YVtlXS5lbmRWYWx1ZT8oYz1jL2FbZV0uZW5kVmFsdWUqYVtlXS5zdGFydFZhbHVlLGI9MDxhW2VdLnNwYWNpbmcudG9TdHJpbmcoKS5pbmRleE9mKFwiJVwiKT9iKigxLXBhcnNlRmxvYXQoYVtlXS5zcGFjaW5nKS8xMDApOmItTWF0aC5taW4oYVtlXS5zcGFjaW5nLDAuMSpiKSk6XHJcbnRoaXMudmlld3BvcnRNaW5pbXVtPmFbZV0uc3RhcnRWYWx1ZSYmdGhpcy52aWV3cG9ydE1heGltdW0+PWFbZV0uZW5kVmFsdWU/KGM9Yy9hW2VdLmVuZFZhbHVlKnRoaXMudmlld3BvcnRNaW5pbXVtLGI9MDxhW2VdLnNwYWNpbmcudG9TdHJpbmcoKS5pbmRleE9mKFwiJVwiKT9iKigxLXBhcnNlRmxvYXQoYVtlXS5zcGFjaW5nKS8xMDAqTWF0aC5sb2coYVtlXS5lbmRWYWx1ZS90aGlzLnZpZXdwb3J0TWluaW11bSkvTWF0aC5sb2coYVtlXS5lbmRWYWx1ZS9hW2VdLnN0YXJ0VmFsdWUpKTpiLU1hdGgubWluKGFbZV0uc3BhY2luZywwLjEqYikqTWF0aC5sb2coYVtlXS5lbmRWYWx1ZS90aGlzLnZpZXdwb3J0TWluaW11bSkvTWF0aC5sb2coYVtlXS5lbmRWYWx1ZS9hW2VdLnN0YXJ0VmFsdWUpKTp0aGlzLnZpZXdwb3J0TWluaW11bTw9YVtlXS5zdGFydFZhbHVlJiZ0aGlzLnZpZXdwb3J0TWF4aW11bTxhW2VdLmVuZFZhbHVlJiYoYz1jL3RoaXMudmlld3BvcnRNYXhpbXVtKmFbZV0uc3RhcnRWYWx1ZSxcclxuYj0wPGFbZV0uc3BhY2luZy50b1N0cmluZygpLmluZGV4T2YoXCIlXCIpP2IqKDEtcGFyc2VGbG9hdChhW2VdLnNwYWNpbmcpLzEwMCpNYXRoLmxvZyh0aGlzLnZpZXdwb3J0TWF4aW11bS9hW2VdLnN0YXJ0VmFsdWUpL01hdGgubG9nKGFbZV0uZW5kVmFsdWUvYVtlXS5zdGFydFZhbHVlKSk6Yi1NYXRoLm1pbihhW2VdLnNwYWNpbmcsMC4xKmIpKk1hdGgubG9nKHRoaXMudmlld3BvcnRNYXhpbXVtL2FbZV0uc3RhcnRWYWx1ZSkvTWF0aC5sb2coYVtlXS5lbmRWYWx1ZS9hW2VdLnN0YXJ0VmFsdWUpKSk7ZWxzZSBmb3IoZT0wO2U8YS5sZW5ndGgmJiEodGhpcy52aWV3cG9ydE1heGltdW08YVtlXS5zdGFydFZhbHVlKTtlKyspdGhpcy52aWV3cG9ydE1pbmltdW0+YVtlXS5lbmRWYWx1ZXx8KHRoaXMudmlld3BvcnRNaW5pbXVtPj1hW2VdLnN0YXJ0VmFsdWUmJnRoaXMudmlld3BvcnRNYXhpbXVtPD1hW2VdLmVuZFZhbHVlP2I9MDp0aGlzLnZpZXdwb3J0TWluaW11bTw9YVtlXS5zdGFydFZhbHVlJiZcclxudGhpcy52aWV3cG9ydE1heGltdW0+PWFbZV0uZW5kVmFsdWU/KGM9Yy1hW2VdLmVuZFZhbHVlK2FbZV0uc3RhcnRWYWx1ZSxiPTA8YVtlXS5zcGFjaW5nLnRvU3RyaW5nKCkuaW5kZXhPZihcIiVcIik/YiooMS1wYXJzZUZsb2F0KGFbZV0uc3BhY2luZykvMTAwKTpiLU1hdGgubWluKGFbZV0uc3BhY2luZywwLjEqYikpOnRoaXMudmlld3BvcnRNaW5pbXVtPmFbZV0uc3RhcnRWYWx1ZSYmdGhpcy52aWV3cG9ydE1heGltdW0+PWFbZV0uZW5kVmFsdWU/KGM9Yy1hW2VdLmVuZFZhbHVlK3RoaXMudmlld3BvcnRNaW5pbXVtLGI9MDxhW2VdLnNwYWNpbmcudG9TdHJpbmcoKS5pbmRleE9mKFwiJVwiKT9iKigxLXBhcnNlRmxvYXQoYVtlXS5zcGFjaW5nKS8xMDAqKGFbZV0uZW5kVmFsdWUtdGhpcy52aWV3cG9ydE1pbmltdW0pLyhhW2VdLmVuZFZhbHVlLWFbZV0uc3RhcnRWYWx1ZSkpOmItTWF0aC5taW4oYVtlXS5zcGFjaW5nLDAuMSpiKSooYVtlXS5lbmRWYWx1ZS10aGlzLnZpZXdwb3J0TWluaW11bSkvXHJcbihhW2VdLmVuZFZhbHVlLWFbZV0uc3RhcnRWYWx1ZSkpOnRoaXMudmlld3BvcnRNaW5pbXVtPD1hW2VdLnN0YXJ0VmFsdWUmJnRoaXMudmlld3BvcnRNYXhpbXVtPGFbZV0uZW5kVmFsdWUmJihjPWMtdGhpcy52aWV3cG9ydE1heGltdW0rYVtlXS5zdGFydFZhbHVlLGI9MDxhW2VdLnNwYWNpbmcudG9TdHJpbmcoKS5pbmRleE9mKFwiJVwiKT9iKigxLXBhcnNlRmxvYXQoYVtlXS5zcGFjaW5nKS8xMDAqKHRoaXMudmlld3BvcnRNYXhpbXVtLWFbZV0uc3RhcnRWYWx1ZSkvKGFbZV0uZW5kVmFsdWUtYVtlXS5zdGFydFZhbHVlKSk6Yi1NYXRoLm1pbihhW2VdLnNwYWNpbmcsMC4xKmIpKih0aGlzLnZpZXdwb3J0TWF4aW11bS1hW2VdLnN0YXJ0VmFsdWUpLyhhW2VdLmVuZFZhbHVlLWFbZV0uc3RhcnRWYWx1ZSkpKTtmLm1pbmltdW09dGhpcy52aWV3cG9ydE1pbmltdW07Zi5tYXhpbXVtPXRoaXMudmlld3BvcnRNYXhpbXVtO2YucmFuZ2U9YztpZihcImJvdHRvbVwiPT09dGhpcy5fcG9zaXRpb258fFxyXG5cInRvcFwiPT09dGhpcy5fcG9zaXRpb24pdGhpcy5sb2dhcml0aG1pYz8oZi5sbkxvZ2FyaXRobUJhc2U9TWF0aC5sb2codGhpcy5sb2dhcml0aG1CYXNlKSxmLnBpeGVsUGVyVW5pdD0odGhpcy5yZXZlcnNlZD8tMToxKSpiKmYubG5Mb2dhcml0aG1CYXNlL01hdGgubG9nKE1hdGguYWJzKGMpKSk6Zi5waXhlbFBlclVuaXQ9KHRoaXMucmV2ZXJzZWQ/LTE6MSkqYi9NYXRoLmFicyhjKSxmLnJlZmVyZW5jZT10aGlzLnJldmVyc2VkP3RoaXMubGluZUNvb3JkaW5hdGVzLngyOnRoaXMubGluZUNvb3JkaW5hdGVzLngxO2lmKFwibGVmdFwiPT09dGhpcy5fcG9zaXRpb258fFwicmlnaHRcIj09PXRoaXMuX3Bvc2l0aW9uKXRoaXMubG9nYXJpdGhtaWM/KGYubG5Mb2dhcml0aG1CYXNlPU1hdGgubG9nKHRoaXMubG9nYXJpdGhtQmFzZSksZi5waXhlbFBlclVuaXQ9KHRoaXMucmV2ZXJzZWQ/MTotMSkqYipmLmxuTG9nYXJpdGhtQmFzZS9NYXRoLmxvZyhNYXRoLmFicyhjKSkpOmYucGl4ZWxQZXJVbml0PVxyXG4odGhpcy5yZXZlcnNlZD8xOi0xKSpiL01hdGguYWJzKGMpLGYucmVmZXJlbmNlPXRoaXMucmV2ZXJzZWQ/dGhpcy5saW5lQ29vcmRpbmF0ZXMueTE6dGhpcy5saW5lQ29vcmRpbmF0ZXMueTI7dGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycz1mfTtDLnByb3RvdHlwZS5jYWxjdWxhdGVBeGlzUGFyYW1ldGVycz1mdW5jdGlvbigpe2lmKHRoaXMubG9nYXJpdGhtaWMpdGhpcy5jYWxjdWxhdGVMb2dhcml0aG1pY0F4aXNQYXJhbWV0ZXJzKCk7ZWxzZXt2YXIgYT10aGlzLmNoYXJ0LmxheW91dE1hbmFnZXIuZ2V0RnJlZVNwYWNlKCksZj0hMSxiPSExO1wiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uPyh0aGlzLm1heFdpZHRoPWEud2lkdGgsdGhpcy5tYXhIZWlnaHQ9YS5oZWlnaHQpOih0aGlzLm1heFdpZHRoPWEuaGVpZ2h0LHRoaXMubWF4SGVpZ2h0PWEud2lkdGgpO3ZhciBhPVwiYXhpc1hcIj09PXRoaXMudHlwZT9cInh5U3dhcHBlZFwiPT09dGhpcy5jaGFydC5wbG90SW5mby5heGlzUGxhY2VtZW50P1xyXG42Mjo3MDpcInh5U3dhcHBlZFwiPT09dGhpcy5jaGFydC5wbG90SW5mby5heGlzUGxhY2VtZW50PzUwOjQwLGM9NDtcImF4aXNYXCI9PT10aGlzLnR5cGUmJihjPTYwMD50aGlzLm1heFdpZHRoPzg6Nik7dmFyIGE9TWF0aC5tYXgoYyxNYXRoLmZsb29yKHRoaXMubWF4V2lkdGgvYSkpLGUsZyxoLGM9MDsheSh0aGlzLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtKSYmKCF5KHRoaXMub3B0aW9ucy52aWV3cG9ydE1heGltdW0pJiZ0aGlzLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtPj10aGlzLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtKSYmKHRoaXMudmlld3BvcnRNaW5pbXVtPXRoaXMudmlld3BvcnRNYXhpbXVtPW51bGwpO2lmKHkodGhpcy5vcHRpb25zLnZpZXdwb3J0TWluaW11bSkmJiF5KHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW0pJiYhaXNOYU4odGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bSkpdGhpcy52aWV3cG9ydE1pbmltdW09dGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bTtcclxuZWxzZSBpZihudWxsPT09dGhpcy52aWV3cG9ydE1pbmltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNaW5pbXVtKSl0aGlzLnZpZXdwb3J0TWluaW11bT10aGlzLm1pbmltdW07aWYoeSh0aGlzLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtKSYmIXkodGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bSkmJiFpc05hTih0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtKSl0aGlzLnZpZXdwb3J0TWF4aW11bT10aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtO2Vsc2UgaWYobnVsbD09PXRoaXMudmlld3BvcnRNYXhpbXVtfHxpc05hTih0aGlzLnZpZXdwb3J0TWF4aW11bSkpdGhpcy52aWV3cG9ydE1heGltdW09dGhpcy5tYXhpbXVtO2lmKHRoaXMuc2NhbGVCcmVha3MpZm9yKGM9MDtjPHRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MubGVuZ3RoO2MrKylpZigoIXkodGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bSkmJlxyXG50aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtPj10aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW2NdLnN0YXJ0VmFsdWV8fCF5KHRoaXMub3B0aW9ucy5taW5pbXVtKSYmdGhpcy5vcHRpb25zLm1pbmltdW0+PXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbY10uc3RhcnRWYWx1ZXx8IXkodGhpcy5vcHRpb25zLnZpZXdwb3J0TWluaW11bSkmJnRoaXMudmlld3BvcnRNaW5pbXVtPj10aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW2NdLnN0YXJ0VmFsdWUpJiYoIXkodGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bSkmJnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW08PXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbY10uZW5kVmFsdWV8fCF5KHRoaXMub3B0aW9ucy5tYXhpbXVtKSYmdGhpcy5vcHRpb25zLm1heGltdW08PXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbY10uZW5kVmFsdWV8fFxyXG4heSh0aGlzLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtKSYmdGhpcy52aWV3cG9ydE1heGltdW08PXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbY10uZW5kVmFsdWUpKXt0aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLnNwbGljZShjLDEpO2JyZWFrfWlmKFwiYXhpc1hcIj09PXRoaXMudHlwZSl7aWYodGhpcy5kYXRhU2VyaWVzJiYwPHRoaXMuZGF0YVNlcmllcy5sZW5ndGgpZm9yKGU9MDtlPHRoaXMuZGF0YVNlcmllcy5sZW5ndGg7ZSsrKVwiZGF0ZVRpbWVcIj09PXRoaXMuZGF0YVNlcmllc1tlXS54VmFsdWVUeXBlJiYoYj0hMCk7ZT1udWxsIT09dGhpcy52aWV3cG9ydE1pbmltdW0/dGhpcy52aWV3cG9ydE1pbmltdW06dGhpcy5kYXRhSW5mby52aWV3UG9ydE1pbjtnPW51bGwhPT10aGlzLnZpZXdwb3J0TWF4aW11bT90aGlzLnZpZXdwb3J0TWF4aW11bTp0aGlzLmRhdGFJbmZvLnZpZXdQb3J0TWF4OzA9PT1nLWUmJihjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmludGVydmFsP1xyXG4wLjQ6dGhpcy5vcHRpb25zLmludGVydmFsLGcrPWMsZS09Yyk7SW5maW5pdHkhPT10aGlzLmRhdGFJbmZvLm1pbkRpZmY/aD10aGlzLmRhdGFJbmZvLm1pbkRpZmY6MTxnLWU/aD0wLjUqTWF0aC5hYnMoZy1lKTooaD0xLGImJihmPSEwKSl9ZWxzZVwiYXhpc1lcIj09PXRoaXMudHlwZSYmKGU9bnVsbCE9PXRoaXMudmlld3BvcnRNaW5pbXVtP3RoaXMudmlld3BvcnRNaW5pbXVtOnRoaXMuZGF0YUluZm8udmlld1BvcnRNaW4sZz1udWxsIT09dGhpcy52aWV3cG9ydE1heGltdW0/dGhpcy52aWV3cG9ydE1heGltdW06dGhpcy5kYXRhSW5mby52aWV3UG9ydE1heCxpc0Zpbml0ZShlKXx8aXNGaW5pdGUoZyk/aXNGaW5pdGUoZSk/aXNGaW5pdGUoZyl8fChnPWUpOmU9ZzooZz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5pbnRlcnZhbD8tSW5maW5pdHk6dGhpcy5vcHRpb25zLmludGVydmFsLGU9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB0aGlzLm9wdGlvbnMuaW50ZXJ2YWx8fGlzRmluaXRlKHRoaXMuZGF0YUluZm8ubWluRGlmZik/XHJcbjA6SW5maW5pdHkpLDA9PT1lJiYwPT09Zz8oZys9OSxlPTApOjA9PT1nLWU/KGM9TWF0aC5taW4oTWF0aC5hYnMoMC4wMSpNYXRoLmFicyhnKSksNSksZys9YyxlLT1jKTplPmc/KGM9TWF0aC5taW4oMC4wMSpNYXRoLmFicyh0aGlzLmdldEFwcGFyZW50RGlmZmVyZW5jZShnLGUsbnVsbCwhMCkpLDUpLDA8PWc/ZT1nLWM6Zz1pc0Zpbml0ZShlKT9lK2M6MCk6KGM9TWF0aC5taW4oMC4wMSpNYXRoLmFicyh0aGlzLmdldEFwcGFyZW50RGlmZmVyZW5jZShlLGcsbnVsbCwhMCkpLDAuMDUpLDAhPT1nJiYoZys9YyksMCE9PWUmJihlLT1jKSksaD1JbmZpbml0eSE9PXRoaXMuZGF0YUluZm8ubWluRGlmZj90aGlzLmRhdGFJbmZvLm1pbkRpZmY6MTxnLWU/MC41Kk1hdGguYWJzKGctZSk6MSx0aGlzLmluY2x1ZGVaZXJvJiYobnVsbD09PXRoaXMudmlld3BvcnRNaW5pbXVtfHxpc05hTih0aGlzLnZpZXdwb3J0TWluaW11bSkpJiYwPGUmJihlPTApLHRoaXMuaW5jbHVkZVplcm8mJihudWxsPT09XHJcbnRoaXMudmlld3BvcnRNYXhpbXVtfHxpc05hTih0aGlzLnZpZXdwb3J0TWF4aW11bSkpJiYwPmcmJihnPTApKTtjPXRoaXMuZ2V0QXBwYXJlbnREaWZmZXJlbmNlKGlzTmFOKHRoaXMudmlld3BvcnRNaW5pbXVtKXx8bnVsbD09PXRoaXMudmlld3BvcnRNaW5pbXVtP2U6dGhpcy52aWV3cG9ydE1pbmltdW0saXNOYU4odGhpcy52aWV3cG9ydE1heGltdW0pfHxudWxsPT09dGhpcy52aWV3cG9ydE1heGltdW0/Zzp0aGlzLnZpZXdwb3J0TWF4aW11bSxudWxsLCEwKTtpZihcImF4aXNYXCI9PT10aGlzLnR5cGUmJmIpe3RoaXMuaW50ZXJ2YWxUeXBlfHwoYy8xPD1hPyh0aGlzLmludGVydmFsPTEsdGhpcy5pbnRlcnZhbFR5cGU9XCJtaWxsaXNlY29uZFwiKTpjLzI8PWE/KHRoaXMuaW50ZXJ2YWw9Mix0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmMvNTw9YT8odGhpcy5pbnRlcnZhbD01LHRoaXMuaW50ZXJ2YWxUeXBlPVwibWlsbGlzZWNvbmRcIik6Yy8xMDw9YT8odGhpcy5pbnRlcnZhbD1cclxuMTAsdGhpcy5pbnRlcnZhbFR5cGU9XCJtaWxsaXNlY29uZFwiKTpjLzIwPD1hPyh0aGlzLmludGVydmFsPTIwLHRoaXMuaW50ZXJ2YWxUeXBlPVwibWlsbGlzZWNvbmRcIik6Yy81MDw9YT8odGhpcy5pbnRlcnZhbD01MCx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmMvMTAwPD1hPyh0aGlzLmludGVydmFsPTEwMCx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmMvMjAwPD1hPyh0aGlzLmludGVydmFsPTIwMCx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmMvMjUwPD1hPyh0aGlzLmludGVydmFsPTI1MCx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmMvMzAwPD1hPyh0aGlzLmludGVydmFsPTMwMCx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmMvNDAwPD1hPyh0aGlzLmludGVydmFsPTQwMCx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmMvNTAwPD1hPyh0aGlzLmludGVydmFsPTUwMCx0aGlzLmludGVydmFsVHlwZT1cclxuXCJtaWxsaXNlY29uZFwiKTpjLygxKlUuc2Vjb25kRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTEsdGhpcy5pbnRlcnZhbFR5cGU9XCJzZWNvbmRcIik6Yy8oMipVLnNlY29uZER1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0yLHRoaXMuaW50ZXJ2YWxUeXBlPVwic2Vjb25kXCIpOmMvKDUqVS5zZWNvbmREdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9NSx0aGlzLmludGVydmFsVHlwZT1cInNlY29uZFwiKTpjLygxMCpVLnNlY29uZER1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0xMCx0aGlzLmludGVydmFsVHlwZT1cInNlY29uZFwiKTpjLygxNSpVLnNlY29uZER1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0xNSx0aGlzLmludGVydmFsVHlwZT1cInNlY29uZFwiKTpjLygyMCpVLnNlY29uZER1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0yMCx0aGlzLmludGVydmFsVHlwZT1cInNlY29uZFwiKTpjLygzMCpVLnNlY29uZER1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0zMCx0aGlzLmludGVydmFsVHlwZT1cclxuXCJzZWNvbmRcIik6Yy8oMSpVLm1pbnV0ZUR1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0xLHRoaXMuaW50ZXJ2YWxUeXBlPVwibWludXRlXCIpOmMvKDIqVS5taW51dGVEdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9Mix0aGlzLmludGVydmFsVHlwZT1cIm1pbnV0ZVwiKTpjLyg1KlUubWludXRlRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTUsdGhpcy5pbnRlcnZhbFR5cGU9XCJtaW51dGVcIik6Yy8oMTAqVS5taW51dGVEdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9MTAsdGhpcy5pbnRlcnZhbFR5cGU9XCJtaW51dGVcIik6Yy8oMTUqVS5taW51dGVEdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9MTUsdGhpcy5pbnRlcnZhbFR5cGU9XCJtaW51dGVcIik6Yy8oMjAqVS5taW51dGVEdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9MjAsdGhpcy5pbnRlcnZhbFR5cGU9XCJtaW51dGVcIik6Yy8oMzAqVS5taW51dGVEdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9MzAsdGhpcy5pbnRlcnZhbFR5cGU9XHJcblwibWludXRlXCIpOmMvKDEqVS5ob3VyRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTEsdGhpcy5pbnRlcnZhbFR5cGU9XCJob3VyXCIpOmMvKDIqVS5ob3VyRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTIsdGhpcy5pbnRlcnZhbFR5cGU9XCJob3VyXCIpOmMvKDMqVS5ob3VyRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTMsdGhpcy5pbnRlcnZhbFR5cGU9XCJob3VyXCIpOmMvKDYqVS5ob3VyRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTYsdGhpcy5pbnRlcnZhbFR5cGU9XCJob3VyXCIpOmMvKDEqVS5kYXlEdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9MSx0aGlzLmludGVydmFsVHlwZT1cImRheVwiKTpjLygyKlUuZGF5RHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTIsdGhpcy5pbnRlcnZhbFR5cGU9XCJkYXlcIik6Yy8oNCpVLmRheUR1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD00LHRoaXMuaW50ZXJ2YWxUeXBlPVwiZGF5XCIpOmMvKDEqVS53ZWVrRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPVxyXG4xLHRoaXMuaW50ZXJ2YWxUeXBlPVwid2Vla1wiKTpjLygyKlUud2Vla0R1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0yLHRoaXMuaW50ZXJ2YWxUeXBlPVwid2Vla1wiKTpjLygzKlUud2Vla0R1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0zLHRoaXMuaW50ZXJ2YWxUeXBlPVwid2Vla1wiKTpjLygxKlUubW9udGhEdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9MSx0aGlzLmludGVydmFsVHlwZT1cIm1vbnRoXCIpOmMvKDIqVS5tb250aER1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0yLHRoaXMuaW50ZXJ2YWxUeXBlPVwibW9udGhcIik6Yy8oMypVLm1vbnRoRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTMsdGhpcy5pbnRlcnZhbFR5cGU9XCJtb250aFwiKTpjLyg2KlUubW9udGhEdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9Nix0aGlzLmludGVydmFsVHlwZT1cIm1vbnRoXCIpOih0aGlzLmludGVydmFsPWMvKDEqVS55ZWFyRHVyYXRpb24pPD1hPzE6Yy8oMipVLnllYXJEdXJhdGlvbik8PVxyXG5hPzI6Yy8oNCpVLnllYXJEdXJhdGlvbik8PWE/NDpNYXRoLmZsb29yKEMuZ2V0TmljZU51bWJlcihjLyhhLTEpLCEwKS9VLnllYXJEdXJhdGlvbiksdGhpcy5pbnRlcnZhbFR5cGU9XCJ5ZWFyXCIpKTtpZihudWxsPT09dGhpcy52aWV3cG9ydE1pbmltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNaW5pbXVtKSl0aGlzLnZpZXdwb3J0TWluaW11bT1lLWgvMjtpZihudWxsPT09dGhpcy52aWV3cG9ydE1heGltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNYXhpbXVtKSl0aGlzLnZpZXdwb3J0TWF4aW11bT1nK2gvMjtmP3RoaXMuYXV0b1ZhbHVlRm9ybWF0U3RyaW5nPVwiTU1NIEREIFlZWVkgSEg6bW1cIjpcInllYXJcIj09PXRoaXMuaW50ZXJ2YWxUeXBlP3RoaXMuYXV0b1ZhbHVlRm9ybWF0U3RyaW5nPVwiWVlZWVwiOlwibW9udGhcIj09PXRoaXMuaW50ZXJ2YWxUeXBlP3RoaXMuYXV0b1ZhbHVlRm9ybWF0U3RyaW5nPVwiTU1NIFlZWVlcIjpcIndlZWtcIj09PXRoaXMuaW50ZXJ2YWxUeXBlP3RoaXMuYXV0b1ZhbHVlRm9ybWF0U3RyaW5nPVxyXG5cIk1NTSBERCBZWVlZXCI6XCJkYXlcIj09PXRoaXMuaW50ZXJ2YWxUeXBlP3RoaXMuYXV0b1ZhbHVlRm9ybWF0U3RyaW5nPVwiTU1NIEREIFlZWVlcIjpcImhvdXJcIj09PXRoaXMuaW50ZXJ2YWxUeXBlP3RoaXMuYXV0b1ZhbHVlRm9ybWF0U3RyaW5nPVwiaGg6bW0gVFRcIjpcIm1pbnV0ZVwiPT09dGhpcy5pbnRlcnZhbFR5cGU/dGhpcy5hdXRvVmFsdWVGb3JtYXRTdHJpbmc9XCJoaDptbSBUVFwiOlwic2Vjb25kXCI9PT10aGlzLmludGVydmFsVHlwZT90aGlzLmF1dG9WYWx1ZUZvcm1hdFN0cmluZz1cImhoOm1tOnNzIFRUXCI6XCJtaWxsaXNlY29uZFwiPT09dGhpcy5pbnRlcnZhbFR5cGUmJih0aGlzLmF1dG9WYWx1ZUZvcm1hdFN0cmluZz1cImZmZidtcydcIik7dGhpcy52YWx1ZUZvcm1hdFN0cmluZ3x8KHRoaXMudmFsdWVGb3JtYXRTdHJpbmc9dGhpcy5hdXRvVmFsdWVGb3JtYXRTdHJpbmcpfWVsc2V7dGhpcy5pbnRlcnZhbFR5cGU9XCJudW1iZXJcIjtjPUMuZ2V0TmljZU51bWJlcihjLCExKTt0aGlzLmludGVydmFsPVxyXG50aGlzLm9wdGlvbnMmJjA8dGhpcy5vcHRpb25zLmludGVydmFsP3RoaXMub3B0aW9ucy5pbnRlcnZhbDpDLmdldE5pY2VOdW1iZXIoYy8oYS0xKSwhMCk7aWYobnVsbD09PXRoaXMudmlld3BvcnRNaW5pbXVtfHxpc05hTih0aGlzLnZpZXdwb3J0TWluaW11bSkpdGhpcy52aWV3cG9ydE1pbmltdW09XCJheGlzWFwiPT09dGhpcy50eXBlP2UtaC8yOk1hdGguZmxvb3IoZS90aGlzLmludGVydmFsKSp0aGlzLmludGVydmFsO2lmKG51bGw9PT10aGlzLnZpZXdwb3J0TWF4aW11bXx8aXNOYU4odGhpcy52aWV3cG9ydE1heGltdW0pKXRoaXMudmlld3BvcnRNYXhpbXVtPVwiYXhpc1hcIj09PXRoaXMudHlwZT9nK2gvMjpNYXRoLmNlaWwoZy90aGlzLmludGVydmFsKSp0aGlzLmludGVydmFsOzA9PT10aGlzLnZpZXdwb3J0TWF4aW11bSYmMD09PXRoaXMudmlld3BvcnRNaW5pbXVtJiYoMD09PXRoaXMub3B0aW9ucy52aWV3cG9ydE1pbmltdW0/dGhpcy52aWV3cG9ydE1heGltdW0rPTEwOjA9PT10aGlzLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtJiZcclxuKHRoaXMudmlld3BvcnRNaW5pbXVtLT0xMCksdGhpcy5vcHRpb25zJiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5pbnRlcnZhbCYmKHRoaXMuaW50ZXJ2YWw9Qy5nZXROaWNlTnVtYmVyKCh0aGlzLnZpZXdwb3J0TWF4aW11bS10aGlzLnZpZXdwb3J0TWluaW11bSkvKGEtMSksITApKSl9aWYobnVsbD09PXRoaXMubWluaW11bXx8bnVsbD09PXRoaXMubWF4aW11bSlpZihcImF4aXNYXCI9PT10aGlzLnR5cGU/KGU9bnVsbCE9PXRoaXMubWluaW11bT90aGlzLm1pbmltdW06dGhpcy5kYXRhSW5mby5taW4sZz1udWxsIT09dGhpcy5tYXhpbXVtP3RoaXMubWF4aW11bTp0aGlzLmRhdGFJbmZvLm1heCwwPT09Zy1lJiYoYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5pbnRlcnZhbD8wLjQ6dGhpcy5vcHRpb25zLmludGVydmFsLGcrPWMsZS09YyksaD1JbmZpbml0eSE9PXRoaXMuZGF0YUluZm8ubWluRGlmZj90aGlzLmRhdGFJbmZvLm1pbkRpZmY6MTxnLWU/XHJcbjAuNSpNYXRoLmFicyhnLWUpOjEpOlwiYXhpc1lcIj09PXRoaXMudHlwZSYmKGU9bnVsbCE9PXRoaXMubWluaW11bT90aGlzLm1pbmltdW06dGhpcy5kYXRhSW5mby5taW4sZz1udWxsIT09dGhpcy5tYXhpbXVtP3RoaXMubWF4aW11bTp0aGlzLmRhdGFJbmZvLm1heCxpc0Zpbml0ZShlKXx8aXNGaW5pdGUoZyk/MD09PWUmJjA9PT1nPyhnKz05LGU9MCk6MD09PWctZT8oYz1NYXRoLm1pbihNYXRoLmFicygwLjAxKk1hdGguYWJzKGcpKSw1KSxnKz1jLGUtPWMpOmU+Zz8oYz1NYXRoLm1pbigwLjAxKk1hdGguYWJzKHRoaXMuZ2V0QXBwYXJlbnREaWZmZXJlbmNlKGcsZSxudWxsLCEwKSksNSksMDw9Zz9lPWctYzpnPWlzRmluaXRlKGUpP2UrYzowKTooYz1NYXRoLm1pbigwLjAxKk1hdGguYWJzKHRoaXMuZ2V0QXBwYXJlbnREaWZmZXJlbmNlKGUsZyxudWxsLCEwKSksMC4wNSksMCE9PWcmJihnKz1jKSwwIT09ZSYmKGUtPWMpKTooZz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5pbnRlcnZhbD9cclxuLUluZmluaXR5OnRoaXMub3B0aW9ucy5pbnRlcnZhbCxlPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgdGhpcy5vcHRpb25zLmludGVydmFsfHxpc0Zpbml0ZSh0aGlzLmRhdGFJbmZvLm1pbkRpZmYpPzA6SW5maW5pdHkpLGg9SW5maW5pdHkhPT10aGlzLmRhdGFJbmZvLm1pbkRpZmY/dGhpcy5kYXRhSW5mby5taW5EaWZmOjE8Zy1lPzAuNSpNYXRoLmFicyhnLWUpOjEsdGhpcy5pbmNsdWRlWmVybyYmKG51bGw9PT10aGlzLm1pbmltdW18fGlzTmFOKHRoaXMubWluaW11bSkpJiYwPGUmJihlPTApLHRoaXMuaW5jbHVkZVplcm8mJihudWxsPT09dGhpcy5tYXhpbXVtfHxpc05hTih0aGlzLm1heGltdW0pKSYmMD5nJiYoZz0wKSksTWF0aC5hYnModGhpcy5nZXRBcHBhcmVudERpZmZlcmVuY2UoZSxnLG51bGwsITApKSxcImF4aXNYXCI9PT10aGlzLnR5cGUmJmIpe3RoaXMudmFsdWVUeXBlPVwiZGF0ZVRpbWVcIjtpZihudWxsPT09dGhpcy5taW5pbXVtfHxpc05hTih0aGlzLm1pbmltdW0pKXRoaXMubWluaW11bT1cclxuZS1oLzI7aWYobnVsbD09PXRoaXMubWF4aW11bXx8aXNOYU4odGhpcy5tYXhpbXVtKSl0aGlzLm1heGltdW09ZytoLzJ9ZWxzZSB0aGlzLmludGVydmFsVHlwZT10aGlzLnZhbHVlVHlwZT1cIm51bWJlclwiLG51bGw9PT10aGlzLm1pbmltdW0mJih0aGlzLm1pbmltdW09XCJheGlzWFwiPT09dGhpcy50eXBlP2UtaC8yOk1hdGguZmxvb3IoZS90aGlzLmludGVydmFsKSp0aGlzLmludGVydmFsLHRoaXMubWluaW11bT1NYXRoLm1pbih0aGlzLm1pbmltdW0sbnVsbD09PXRoaXMuc2Vzc2lvblZhcmlhYmxlcy52aWV3cG9ydE1pbmltdW18fGlzTmFOKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy52aWV3cG9ydE1pbmltdW0pP0luZmluaXR5OnRoaXMuc2Vzc2lvblZhcmlhYmxlcy52aWV3cG9ydE1pbmltdW0pKSxudWxsPT09dGhpcy5tYXhpbXVtJiYodGhpcy5tYXhpbXVtPVwiYXhpc1hcIj09PXRoaXMudHlwZT9nK2gvMjpNYXRoLmNlaWwoZy90aGlzLmludGVydmFsKSp0aGlzLmludGVydmFsLHRoaXMubWF4aW11bT1cclxuTWF0aC5tYXgodGhpcy5tYXhpbXVtLG51bGw9PT10aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNYXhpbXVtfHxpc05hTih0aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNYXhpbXVtKT8tSW5maW5pdHk6dGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWF4aW11bSkpLDA9PT10aGlzLm1heGltdW0mJjA9PT10aGlzLm1pbmltdW0mJigwPT09dGhpcy5vcHRpb25zLm1pbmltdW0/dGhpcy5tYXhpbXVtKz0xMDowPT09dGhpcy5vcHRpb25zLm1heGltdW0mJih0aGlzLm1pbmltdW0tPTEwKSk7eSh0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtKSYmKHRoaXMudmlld3BvcnRNaW5pbXVtPU1hdGgubWF4KHRoaXMudmlld3BvcnRNaW5pbXVtLHRoaXMubWluaW11bSkpO3kodGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bSkmJih0aGlzLnZpZXdwb3J0TWF4aW11bT1NYXRoLm1pbih0aGlzLnZpZXdwb3J0TWF4aW11bSx0aGlzLm1heGltdW0pKTtcclxudGhpcy5yYW5nZT10aGlzLnZpZXdwb3J0TWF4aW11bS10aGlzLnZpZXdwb3J0TWluaW11bTt0aGlzLmludGVydmFsU3RhcnRQb3NpdGlvbj1cImF4aXNYXCI9PT10aGlzLnR5cGUmJmI/dGhpcy5nZXRMYWJlbFN0YXJ0UG9pbnQobmV3IERhdGUodGhpcy52aWV3cG9ydE1pbmltdW0pLHRoaXMuaW50ZXJ2YWxUeXBlLHRoaXMuaW50ZXJ2YWwpOk1hdGguZmxvb3IoKHRoaXMudmlld3BvcnRNaW5pbXVtKzAuMip0aGlzLmludGVydmFsKS90aGlzLmludGVydmFsKSp0aGlzLmludGVydmFsO3RoaXMudmFsdWVGb3JtYXRTdHJpbmd8fCh0aGlzLnZhbHVlRm9ybWF0U3RyaW5nPUMuZ2VuZXJhdGVWYWx1ZUZvcm1hdFN0cmluZyh0aGlzLnJhbmdlLDIpKX19O0MucHJvdG90eXBlLmNhbGN1bGF0ZUxvZ2FyaXRobWljQXhpc1BhcmFtZXRlcnM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LmxheW91dE1hbmFnZXIuZ2V0RnJlZVNwYWNlKCksZj1NYXRoLmxvZyh0aGlzLmxvZ2FyaXRobUJhc2UpLGI7XHJcblwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uPyh0aGlzLm1heFdpZHRoPWEud2lkdGgsdGhpcy5tYXhIZWlnaHQ9YS5oZWlnaHQpOih0aGlzLm1heFdpZHRoPWEuaGVpZ2h0LHRoaXMubWF4SGVpZ2h0PWEud2lkdGgpO3ZhciBhPVwiYXhpc1hcIj09PXRoaXMudHlwZT81MDA+dGhpcy5tYXhXaWR0aD83Ok1hdGgubWF4KDcsTWF0aC5mbG9vcih0aGlzLm1heFdpZHRoLzEwMCkpOk1hdGgubWF4KE1hdGguZmxvb3IodGhpcy5tYXhXaWR0aC81MCksMyksYyxlLGcsaDtoPTE7aWYobnVsbD09PXRoaXMudmlld3BvcnRNaW5pbXVtfHxpc05hTih0aGlzLnZpZXdwb3J0TWluaW11bSkpdGhpcy52aWV3cG9ydE1pbmltdW09dGhpcy5taW5pbXVtO2lmKG51bGw9PT10aGlzLnZpZXdwb3J0TWF4aW11bXx8aXNOYU4odGhpcy52aWV3cG9ydE1heGltdW0pKXRoaXMudmlld3BvcnRNYXhpbXVtPXRoaXMubWF4aW11bTtpZih0aGlzLnNjYWxlQnJlYWtzKWZvcihoPVxyXG4wO2g8dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGg7aCsrKWlmKCgheSh0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtKSYmdGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bT49dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrc1toXS5zdGFydFZhbHVlfHwheSh0aGlzLm9wdGlvbnMubWluaW11bSkmJnRoaXMub3B0aW9ucy5taW5pbXVtPj10aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW2hdLnN0YXJ0VmFsdWV8fCF5KHRoaXMub3B0aW9ucy52aWV3cG9ydE1pbmltdW0pJiZ0aGlzLnZpZXdwb3J0TWluaW11bT49dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrc1toXS5zdGFydFZhbHVlKSYmKCF5KHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW0pJiZ0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtPD10aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW2hdLmVuZFZhbHVlfHxcclxuIXkodGhpcy5vcHRpb25zLm1heGltdW0pJiZ0aGlzLm9wdGlvbnMubWF4aW11bTw9dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrc1toXS5lbmRWYWx1ZXx8IXkodGhpcy5vcHRpb25zLnZpZXdwb3J0TWF4aW11bSkmJnRoaXMudmlld3BvcnRNYXhpbXVtPD10aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW2hdLmVuZFZhbHVlKSl7dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5zcGxpY2UoaCwxKTticmVha31cImF4aXNYXCI9PT10aGlzLnR5cGU/KGM9bnVsbCE9PXRoaXMudmlld3BvcnRNaW5pbXVtP3RoaXMudmlld3BvcnRNaW5pbXVtOnRoaXMuZGF0YUluZm8udmlld1BvcnRNaW4sZT1udWxsIT09dGhpcy52aWV3cG9ydE1heGltdW0/dGhpcy52aWV3cG9ydE1heGltdW06dGhpcy5kYXRhSW5mby52aWV3UG9ydE1heCwxPT09ZS9jJiYoaD1NYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLm9wdGlvbnMuaW50ZXJ2YWw/XHJcbjAuNDp0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpLGUqPWgsYy89aCksZz1JbmZpbml0eSE9PXRoaXMuZGF0YUluZm8ubWluRGlmZj90aGlzLmRhdGFJbmZvLm1pbkRpZmY6ZS9jPnRoaXMubG9nYXJpdGhtQmFzZT9lL2MqTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDAuNSk6dGhpcy5sb2dhcml0aG1CYXNlKTpcImF4aXNZXCI9PT10aGlzLnR5cGUmJihjPW51bGwhPT10aGlzLnZpZXdwb3J0TWluaW11bT90aGlzLnZpZXdwb3J0TWluaW11bTp0aGlzLmRhdGFJbmZvLnZpZXdQb3J0TWluLGU9bnVsbCE9PXRoaXMudmlld3BvcnRNYXhpbXVtP3RoaXMudmlld3BvcnRNYXhpbXVtOnRoaXMuZGF0YUluZm8udmlld1BvcnRNYXgsMD49YyYmIWlzRmluaXRlKGUpPyhlPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmludGVydmFsPzA6dGhpcy5vcHRpb25zLmludGVydmFsLGM9MSk6MD49Yz9jPWU6aXNGaW5pdGUoZSl8fChlPWMpLDE9PT1jJiYxPT09ZT8oZSo9dGhpcy5sb2dhcml0aG1CYXNlLVxyXG4xL3RoaXMubG9nYXJpdGhtQmFzZSxjPTEpOjE9PT1lL2M/KGg9TWF0aC5taW4oZSpNYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsMC4wMSksTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDUpKSxlKj1oLGMvPWgpOmM+ZT8oaD1NYXRoLm1pbihjL2UqTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDAuMDEpLE1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSw1KSksMTw9ZT9jPWUvaDplPWMqaCk6KGg9TWF0aC5taW4oZS9jKk1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSwwLjAxKSxNYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsMC4wNCkpLDEhPT1lJiYoZSo9aCksMSE9PWMmJihjLz1oKSksZz1JbmZpbml0eSE9PXRoaXMuZGF0YUluZm8ubWluRGlmZj90aGlzLmRhdGFJbmZvLm1pbkRpZmY6ZS9jPnRoaXMubG9nYXJpdGhtQmFzZT9lL2MqTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDAuNSk6dGhpcy5sb2dhcml0aG1CYXNlLHRoaXMuaW5jbHVkZVplcm8mJihudWxsPT09XHJcbnRoaXMudmlld3BvcnRNaW5pbXVtfHxpc05hTih0aGlzLnZpZXdwb3J0TWluaW11bSkpJiYxPGMmJihjPTEpLHRoaXMuaW5jbHVkZVplcm8mJihudWxsPT09dGhpcy52aWV3cG9ydE1heGltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNYXhpbXVtKSkmJjE+ZSYmKGU9MSkpO2g9KGlzTmFOKHRoaXMudmlld3BvcnRNYXhpbXVtKXx8bnVsbD09PXRoaXMudmlld3BvcnRNYXhpbXVtP2U6dGhpcy52aWV3cG9ydE1heGltdW0pLyhpc05hTih0aGlzLnZpZXdwb3J0TWluaW11bSl8fG51bGw9PT10aGlzLnZpZXdwb3J0TWluaW11bT9jOnRoaXMudmlld3BvcnRNaW5pbXVtKTtsaW5lYXJSYW5nZT0oaXNOYU4odGhpcy52aWV3cG9ydE1heGltdW0pfHxudWxsPT09dGhpcy52aWV3cG9ydE1heGltdW0/ZTp0aGlzLnZpZXdwb3J0TWF4aW11bSktKGlzTmFOKHRoaXMudmlld3BvcnRNaW5pbXVtKXx8bnVsbD09PXRoaXMudmlld3BvcnRNaW5pbXVtP2M6dGhpcy52aWV3cG9ydE1pbmltdW0pO3RoaXMuaW50ZXJ2YWxUeXBlPVxyXG5cIm51bWJlclwiO2g9TWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLEMuZ2V0TmljZU51bWJlcihNYXRoLmFicyhNYXRoLmxvZyhoKS9mKSwhMSkpO3RoaXMub3B0aW9ucyYmMDx0aGlzLm9wdGlvbnMuaW50ZXJ2YWw/dGhpcy5pbnRlcnZhbD10aGlzLm9wdGlvbnMuaW50ZXJ2YWw6KHRoaXMuaW50ZXJ2YWw9Qy5nZXROaWNlRXhwb25lbnQoTWF0aC5sb2coaCkvZi8oYS0xKSwhMCksYj1DLmdldE5pY2VOdW1iZXIobGluZWFyUmFuZ2UvKGEtMSksITApKTtpZihudWxsPT09dGhpcy52aWV3cG9ydE1pbmltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNaW5pbXVtKSl0aGlzLnZpZXdwb3J0TWluaW11bT1cImF4aXNYXCI9PT10aGlzLnR5cGU/Yy9NYXRoLnNxcnQoZyk6TWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLHRoaXMuaW50ZXJ2YWwqTWF0aC5mbG9vcihNYXRoLmxvZyhjKS9mL3RoaXMuaW50ZXJ2YWwpKTtpZihudWxsPT09dGhpcy52aWV3cG9ydE1heGltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNYXhpbXVtKSl0aGlzLnZpZXdwb3J0TWF4aW11bT1cclxuXCJheGlzWFwiPT09dGhpcy50eXBlP2UqTWF0aC5zcXJ0KGcpOk1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSx0aGlzLmludGVydmFsKk1hdGguY2VpbChNYXRoLmxvZyhlKS9mL3RoaXMuaW50ZXJ2YWwpKTsxPT09dGhpcy52aWV3cG9ydE1heGltdW0mJjE9PT10aGlzLnZpZXdwb3J0TWluaW11bSYmKDE9PT10aGlzLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtP3RoaXMudmlld3BvcnRNYXhpbXVtKj10aGlzLmxvZ2FyaXRobUJhc2UtMS90aGlzLmxvZ2FyaXRobUJhc2U6MT09PXRoaXMub3B0aW9ucy52aWV3cG9ydE1heGltdW0mJih0aGlzLnZpZXdwb3J0TWluaW11bS89dGhpcy5sb2dhcml0aG1CYXNlLTEvdGhpcy5sb2dhcml0aG1CYXNlKSx0aGlzLm9wdGlvbnMmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmludGVydmFsJiYodGhpcy5pbnRlcnZhbD1DLmdldE5pY2VFeHBvbmVudChNYXRoLmNlaWwoTWF0aC5sb2coaCkvZikvKGEtMSkpLGI9Qy5nZXROaWNlTnVtYmVyKCh0aGlzLnZpZXdwb3J0TWF4aW11bS1cclxudGhpcy52aWV3cG9ydE1pbmltdW0pLyhhLTEpLCEwKSkpO2lmKG51bGw9PT10aGlzLm1pbmltdW18fG51bGw9PT10aGlzLm1heGltdW0pXCJheGlzWFwiPT09dGhpcy50eXBlPyhjPW51bGwhPT10aGlzLm1pbmltdW0/dGhpcy5taW5pbXVtOnRoaXMuZGF0YUluZm8ubWluLGU9bnVsbCE9PXRoaXMubWF4aW11bT90aGlzLm1heGltdW06dGhpcy5kYXRhSW5mby5tYXgsMT09PWUvYyYmKGg9TWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLFwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmludGVydmFsPzAuNDp0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpLGUqPWgsYy89aCksZz1JbmZpbml0eSE9PXRoaXMuZGF0YUluZm8ubWluRGlmZj90aGlzLmRhdGFJbmZvLm1pbkRpZmY6ZS9jPnRoaXMubG9nYXJpdGhtQmFzZT9lL2MqTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDAuNSk6dGhpcy5sb2dhcml0aG1CYXNlKTpcImF4aXNZXCI9PT10aGlzLnR5cGUmJihjPW51bGwhPT10aGlzLm1pbmltdW0/XHJcbnRoaXMubWluaW11bTp0aGlzLmRhdGFJbmZvLm1pbixlPW51bGwhPT10aGlzLm1heGltdW0/dGhpcy5tYXhpbXVtOnRoaXMuZGF0YUluZm8ubWF4LGlzRmluaXRlKGMpfHxpc0Zpbml0ZShlKT8xPT09YyYmMT09PWU/KGUqPXRoaXMubG9nYXJpdGhtQmFzZSxjLz10aGlzLmxvZ2FyaXRobUJhc2UpOjE9PT1lL2M/KGg9TWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLHRoaXMuaW50ZXJ2YWwpLGUqPWgsYy89aCk6Yz5lPyhoPU1hdGgubWluKDAuMDEqKGMvZSksNSksMTw9ZT9jPWUvaDplPWMqaCk6KGg9TWF0aC5taW4oZS9jKk1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSwwLjAxKSxNYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsMC4wNCkpLDEhPT1lJiYoZSo9aCksMSE9PWMmJihjLz1oKSk6KGU9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLm9wdGlvbnMuaW50ZXJ2YWw/MDp0aGlzLm9wdGlvbnMuaW50ZXJ2YWwsYz0xKSxnPUluZmluaXR5IT09dGhpcy5kYXRhSW5mby5taW5EaWZmP1xyXG50aGlzLmRhdGFJbmZvLm1pbkRpZmY6ZS9jPnRoaXMubG9nYXJpdGhtQmFzZT9lL2MqTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDAuNSk6dGhpcy5sb2dhcml0aG1CYXNlLHRoaXMuaW5jbHVkZVplcm8mJihudWxsPT09dGhpcy5taW5pbXVtfHxpc05hTih0aGlzLm1pbmltdW0pKSYmMTxjJiYoYz0xKSx0aGlzLmluY2x1ZGVaZXJvJiYobnVsbD09PXRoaXMubWF4aW11bXx8aXNOYU4odGhpcy5tYXhpbXVtKSkmJjE+ZSYmKGU9MSkpLHRoaXMuaW50ZXJ2YWxUeXBlPVwibnVtYmVyXCIsbnVsbD09PXRoaXMubWluaW11bSYmKHRoaXMubWluaW11bT1cImF4aXNYXCI9PT10aGlzLnR5cGU/Yy9NYXRoLnNxcnQoZyk6TWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLHRoaXMuaW50ZXJ2YWwqTWF0aC5mbG9vcihNYXRoLmxvZyhjKS9mL3RoaXMuaW50ZXJ2YWwpKSx0aGlzLm1pbmltdW09TWF0aC5taW4odGhpcy5taW5pbXVtLG51bGw9PT10aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNaW5pbXVtfHxcclxuaXNOYU4odGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWluaW11bSk/XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtP0luZmluaXR5OnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW06dGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWluaW11bSkpLG51bGw9PT10aGlzLm1heGltdW0mJih0aGlzLm1heGltdW09XCJheGlzWFwiPT09dGhpcy50eXBlP2UqTWF0aC5zcXJ0KGcpOk1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSx0aGlzLmludGVydmFsKk1hdGguY2VpbChNYXRoLmxvZyhlKS9mL3RoaXMuaW50ZXJ2YWwpKSx0aGlzLm1heGltdW09TWF0aC5tYXgodGhpcy5tYXhpbXVtLG51bGw9PT10aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNYXhpbXVtfHxpc05hTih0aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNYXhpbXVtKT9cInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW0/XHJcbjA6dGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bTp0aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNYXhpbXVtKSksMT09PXRoaXMubWF4aW11bSYmMT09PXRoaXMubWluaW11bSYmKDE9PT10aGlzLm9wdGlvbnMubWluaW11bT90aGlzLm1heGltdW0qPXRoaXMubG9nYXJpdGhtQmFzZS0xL3RoaXMubG9nYXJpdGhtQmFzZToxPT09dGhpcy5vcHRpb25zLm1heGltdW0mJih0aGlzLm1pbmltdW0vPXRoaXMubG9nYXJpdGhtQmFzZS0xL3RoaXMubG9nYXJpdGhtQmFzZSkpO3RoaXMudmlld3BvcnRNaW5pbXVtPU1hdGgubWF4KHRoaXMudmlld3BvcnRNaW5pbXVtLHRoaXMubWluaW11bSk7dGhpcy52aWV3cG9ydE1heGltdW09TWF0aC5taW4odGhpcy52aWV3cG9ydE1heGltdW0sdGhpcy5tYXhpbXVtKTt0aGlzLnZpZXdwb3J0TWluaW11bT50aGlzLnZpZXdwb3J0TWF4aW11bSYmKCF0aGlzLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtJiYhdGhpcy5vcHRpb25zLm1pbmltdW18fFxyXG50aGlzLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtfHx0aGlzLm9wdGlvbnMubWF4aW11bT90aGlzLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtfHx0aGlzLm9wdGlvbnMubWluaW11bXx8IXRoaXMub3B0aW9ucy52aWV3cG9ydE1heGltdW0mJiF0aGlzLm9wdGlvbnMubWF4aW11bXx8KHRoaXMudmlld3BvcnRNaW5pbXVtPXRoaXMubWluaW11bT0odGhpcy5vcHRpb25zLnZpZXdwb3J0TWF4aW11bXx8dGhpcy5vcHRpb25zLm1heGltdW0pL01hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSwyKk1hdGguY2VpbCh0aGlzLmludGVydmFsKSkpOnRoaXMudmlld3BvcnRNYXhpbXVtPXRoaXMubWF4aW11bT10aGlzLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtfHx0aGlzLm9wdGlvbnMubWluaW11bSk7Yz1NYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsTWF0aC5mbG9vcihNYXRoLmxvZyh0aGlzLnZpZXdwb3J0TWluaW11bSkvKGYqdGhpcy5pbnRlcnZhbCkrMC4yKSp0aGlzLmludGVydmFsKTt0aGlzLnJhbmdlPVxyXG50aGlzLnZpZXdwb3J0TWF4aW11bS90aGlzLnZpZXdwb3J0TWluaW11bTt0aGlzLm5vVGlja3M9YTtpZighdGhpcy5vcHRpb25zLmludGVydmFsJiZ0aGlzLnJhbmdlPE1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSw4PnRoaXMudmlld3BvcnRNYXhpbXVtfHwzPmE/MjozKSl7Zm9yKGY9TWF0aC5mbG9vcih0aGlzLnZpZXdwb3J0TWluaW11bS9iKzAuNSkqYjtmPHRoaXMudmlld3BvcnRNaW5pbXVtOylmKz1iO3RoaXMuZXF1aWRpc3RhbnRJbnRlcnZhbD0hMTt0aGlzLmludGVydmFsU3RhcnRQb3NpdGlvbj1mO3RoaXMuaW50ZXJ2YWw9Yn1lbHNlIHRoaXMub3B0aW9ucy5pbnRlcnZhbHx8KGI9TWF0aC5jZWlsKHRoaXMuaW50ZXJ2YWwpLHRoaXMucmFuZ2U+dGhpcy5pbnRlcnZhbCYmKHRoaXMuaW50ZXJ2YWw9YixjPU1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSxNYXRoLmZsb29yKE1hdGgubG9nKHRoaXMudmlld3BvcnRNaW5pbXVtKS8oZip0aGlzLmludGVydmFsKSswLjIpKnRoaXMuaW50ZXJ2YWwpKSksXHJcbnRoaXMuZXF1aWRpc3RhbnRJbnRlcnZhbD0hMCx0aGlzLmludGVydmFsU3RhcnRQb3NpdGlvbj1jO2lmKCF0aGlzLnZhbHVlRm9ybWF0U3RyaW5nJiYodGhpcy52YWx1ZUZvcm1hdFN0cmluZz1cIiMsIyMwLiMjXCIsMT50aGlzLnZpZXdwb3J0TWluaW11bSkpe2Y9TWF0aC5mbG9vcihNYXRoLmFicyhNYXRoLmxvZyh0aGlzLnZpZXdwb3J0TWluaW11bSkvTWF0aC5MTjEwKSkrMjtpZihpc05hTihmKXx8IWlzRmluaXRlKGYpKWY9MjtpZigyPGYpZm9yKGg9MDtoPGYtMjtoKyspdGhpcy52YWx1ZUZvcm1hdFN0cmluZys9XCIjXCJ9fTtDLmdlbmVyYXRlVmFsdWVGb3JtYXRTdHJpbmc9ZnVuY3Rpb24oYSxmKXt2YXIgYj1cIiMsIyMwLlwiLGM9ZjsxPmEmJihjKz1NYXRoLmZsb29yKE1hdGguYWJzKE1hdGgubG9nKGEpL01hdGguTE4xMCkpLGlzTmFOKGMpfHwhaXNGaW5pdGUoYykpJiYoYz1mKTtmb3IodmFyIGU9MDtlPGM7ZSsrKWIrPVwiI1wiO3JldHVybiBifTtDLmdldE5pY2VFeHBvbmVudD1mdW5jdGlvbihhLFxyXG5mKXt2YXIgYj1NYXRoLmZsb29yKE1hdGgubG9nKGEpL01hdGguTE4xMCksYz1hL01hdGgucG93KDEwLGIpLGM9MD5iPzE+PWM/MTo1Pj1jPzU6MTA6TWF0aC5tYXgoTWF0aC5mbG9vcihjKSwxKTtyZXR1cm4gTnVtYmVyKChjKk1hdGgucG93KDEwLGIpKS50b0ZpeGVkKDIwKSl9O0MuZ2V0TmljZU51bWJlcj1mdW5jdGlvbihhLGYpe3ZhciBiPU1hdGguZmxvb3IoTWF0aC5sb2coYSkvTWF0aC5MTjEwKSxjPWEvTWF0aC5wb3coMTAsYik7cmV0dXJuIE51bWJlcigoKGY/MS41PmM/MTozPmM/Mjo3PmM/NToxMDoxPj1jPzE6Mj49Yz8yOjU+PWM/NToxMCkqTWF0aC5wb3coMTAsYikpLnRvRml4ZWQoMjApKX07Qy5wcm90b3R5cGUuZ2V0TGFiZWxTdGFydFBvaW50PWZ1bmN0aW9uKCl7dmFyIGE9VVt0aGlzLmludGVydmFsVHlwZStcIkR1cmF0aW9uXCJdKnRoaXMuaW50ZXJ2YWwsYT1uZXcgRGF0ZShNYXRoLmZsb29yKHRoaXMudmlld3BvcnRNaW5pbXVtL2EpKmEpO2lmKFwibWlsbGlzZWNvbmRcIiE9PVxyXG50aGlzLmludGVydmFsVHlwZSlpZihcInNlY29uZFwiPT09dGhpcy5pbnRlcnZhbFR5cGUpMDxhLmdldE1pbGxpc2Vjb25kcygpJiYoYS5zZXRTZWNvbmRzKGEuZ2V0U2Vjb25kcygpKzEpLGEuc2V0TWlsbGlzZWNvbmRzKDApKTtlbHNlIGlmKFwibWludXRlXCI9PT10aGlzLmludGVydmFsVHlwZSl7aWYoMDxhLmdldFNlY29uZHMoKXx8MDxhLmdldE1pbGxpc2Vjb25kcygpKWEuc2V0TWludXRlcyhhLmdldE1pbnV0ZXMoKSsxKSxhLnNldFNlY29uZHMoMCksYS5zZXRNaWxsaXNlY29uZHMoMCl9ZWxzZSBpZihcImhvdXJcIj09PXRoaXMuaW50ZXJ2YWxUeXBlKXtpZigwPGEuZ2V0TWludXRlcygpfHwwPGEuZ2V0U2Vjb25kcygpfHwwPGEuZ2V0TWlsbGlzZWNvbmRzKCkpYS5zZXRIb3VycyhhLmdldEhvdXJzKCkrMSksYS5zZXRNaW51dGVzKDApLGEuc2V0U2Vjb25kcygwKSxhLnNldE1pbGxpc2Vjb25kcygwKX1lbHNlIGlmKFwiZGF5XCI9PT10aGlzLmludGVydmFsVHlwZSl7aWYoMDxhLmdldEhvdXJzKCl8fFxyXG4wPGEuZ2V0TWludXRlcygpfHwwPGEuZ2V0U2Vjb25kcygpfHwwPGEuZ2V0TWlsbGlzZWNvbmRzKCkpYS5zZXREYXRlKGEuZ2V0RGF0ZSgpKzEpLGEuc2V0SG91cnMoMCksYS5zZXRNaW51dGVzKDApLGEuc2V0U2Vjb25kcygwKSxhLnNldE1pbGxpc2Vjb25kcygwKX1lbHNlIGlmKFwid2Vla1wiPT09dGhpcy5pbnRlcnZhbFR5cGUpe2lmKDA8YS5nZXREYXkoKXx8MDxhLmdldEhvdXJzKCl8fDA8YS5nZXRNaW51dGVzKCl8fDA8YS5nZXRTZWNvbmRzKCl8fDA8YS5nZXRNaWxsaXNlY29uZHMoKSlhLnNldERhdGUoYS5nZXREYXRlKCkrKDctYS5nZXREYXkoKSkpLGEuc2V0SG91cnMoMCksYS5zZXRNaW51dGVzKDApLGEuc2V0U2Vjb25kcygwKSxhLnNldE1pbGxpc2Vjb25kcygwKX1lbHNlIGlmKFwibW9udGhcIj09PXRoaXMuaW50ZXJ2YWxUeXBlKXtpZigxPGEuZ2V0RGF0ZSgpfHwwPGEuZ2V0SG91cnMoKXx8MDxhLmdldE1pbnV0ZXMoKXx8MDxhLmdldFNlY29uZHMoKXx8MDxhLmdldE1pbGxpc2Vjb25kcygpKWEuc2V0TW9udGgoYS5nZXRNb250aCgpK1xyXG4xKSxhLnNldERhdGUoMSksYS5zZXRIb3VycygwKSxhLnNldE1pbnV0ZXMoMCksYS5zZXRTZWNvbmRzKDApLGEuc2V0TWlsbGlzZWNvbmRzKDApfWVsc2VcInllYXJcIj09PXRoaXMuaW50ZXJ2YWxUeXBlJiYoMDxhLmdldE1vbnRoKCl8fDE8YS5nZXREYXRlKCl8fDA8YS5nZXRIb3VycygpfHwwPGEuZ2V0TWludXRlcygpfHwwPGEuZ2V0U2Vjb25kcygpfHwwPGEuZ2V0TWlsbGlzZWNvbmRzKCkpJiYoYS5zZXRGdWxsWWVhcihhLmdldEZ1bGxZZWFyKCkrMSksYS5zZXRNb250aCgwKSxhLnNldERhdGUoMSksYS5zZXRIb3VycygwKSxhLnNldE1pbnV0ZXMoMCksYS5zZXRTZWNvbmRzKDApLGEuc2V0TWlsbGlzZWNvbmRzKDApKTtyZXR1cm4gYX07cGEoUCxYKTtwYShhYSxYKTthYS5wcm90b3R5cGUuY3JlYXRlVXNlck9wdGlvbnM9ZnVuY3Rpb24oYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhfHx0aGlzLm9wdGlvbnMuX2lzUGxhY2Vob2xkZXIpe3ZhciBmPTA7dGhpcy5wYXJlbnQub3B0aW9ucy5faXNQbGFjZWhvbGRlciYmXHJcbnRoaXMucGFyZW50LmNyZWF0ZVVzZXJPcHRpb25zKCk7dGhpcy5vcHRpb25zLl9pc1BsYWNlaG9sZGVyfHwoRGEodGhpcy5wYXJlbnRbdGhpcy5vcHRpb25zTmFtZV0pLGY9dGhpcy5wYXJlbnQub3B0aW9uc1t0aGlzLm9wdGlvbnNOYW1lXS5pbmRleE9mKHRoaXMub3B0aW9ucykpO3RoaXMub3B0aW9ucz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/e306YTt0aGlzLnBhcmVudC5vcHRpb25zW3RoaXMub3B0aW9uc05hbWVdW2ZdPXRoaXMub3B0aW9uc319O2FhLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSl7aWYoMCE9PXRoaXMuc3BhY2luZ3x8MCE9PXRoaXMub3B0aW9ucy5saW5lVGhpY2tuZXNzJiYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB0aGlzLm9wdGlvbnMubGluZVRoaWNrbmVzc3x8MCE9PXRoaXMucGFyZW50LmxpbmVUaGlja25lc3MpKXt2YXIgZj10aGlzLmN0eCxiPXRoaXMuY3R4Lmdsb2JhbEFscGhhO3RoaXMuY3R4PWF8fHRoaXMuY3R4O3RoaXMuY3R4LnNhdmUoKTt0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxudGhpcy5jdHgucmVjdCh0aGlzLmNoYXJ0LnBsb3RBcmVhLngxLHRoaXMuY2hhcnQucGxvdEFyZWEueTEsdGhpcy5jaGFydC5wbG90QXJlYS53aWR0aCx0aGlzLmNoYXJ0LnBsb3RBcmVhLmhlaWdodCk7dGhpcy5jdHguY2xpcCgpO3ZhciBjPXRoaXMuc2NhbGVCcmVha3MucGFyZW50LmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXModGhpcy5zdGFydFZhbHVlKSxlPXRoaXMuc2NhbGVCcmVha3MucGFyZW50LmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXModGhpcy5lbmRWYWx1ZSk7dGhpcy5jdHguc3Ryb2tlU3R5bGU9dGhpcy5saW5lQ29sb3I7dGhpcy5jdHguZmlsbFN0eWxlPXRoaXMuY29sb3I7dGhpcy5jdHguYmVnaW5QYXRoKCk7dGhpcy5jdHguZ2xvYmFsQWxwaGE9MTtSKHRoaXMuaWQpO3ZhciBnLGgsbCxtLGsscjthPU1hdGgubWF4KHRoaXMuc3BhY2luZywzKTt2YXIgcD1NYXRoLm1heCgwLHRoaXMubGluZVRoaWNrbmVzcyk7dGhpcy5jdHgubGluZVdpZHRoPXA7dGhpcy5jdHguc2V0TGluZURhc2gmJlxyXG50aGlzLmN0eC5zZXRMaW5lRGFzaChHKHRoaXMubGluZURhc2hUeXBlLHApKTtpZihcImJvdHRvbVwiPT09dGhpcy5zY2FsZUJyZWFrcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5zY2FsZUJyZWFrcy5wYXJlbnQuX3Bvc2l0aW9uKWlmKGM9MT09PXAlMj8oYy54PDwwKSswLjU6Yy54PDwwLGg9MT09PXAlMj8oZS54PDwwKSswLjU6ZS54PDwwLFwidG9wXCI9PT10aGlzLnNjYWxlQnJlYWtzLnBhcmVudC5fcG9zaXRpb24/KGU9dGhpcy5jaGFydC5wbG90QXJlYS55MSxsPXRoaXMuY2hhcnQucGxvdEFyZWEueTIrcC8yKzAuNTw8MCk6KGU9dGhpcy5jaGFydC5wbG90QXJlYS55MixsPXRoaXMuY2hhcnQucGxvdEFyZWEueTEtcC8yKzAuNTw8MCxhKj0tMSksdGhpcy5ib3VuZHM9e3gxOmMtcC8yLHkxOmUseDI6aCtwLzIseTI6bH0sdGhpcy5jdHgubW92ZVRvKGMsZSksXCJzdHJhaWdodFwiPT09dGhpcy50eXBlfHxcInRvcFwiPT09dGhpcy5zY2FsZUJyZWFrcy5wYXJlbnQuX3Bvc2l0aW9uJiZcclxuMD49YXx8XCJib3R0b21cIj09PXRoaXMuc2NhbGVCcmVha3MucGFyZW50Ll9wb3NpdGlvbiYmMDw9YSl0aGlzLmN0eC5saW5lVG8oYyxsKSx0aGlzLmN0eC5saW5lVG8oaCxsKSx0aGlzLmN0eC5saW5lVG8oaCxlKTtlbHNlIGlmKFwid2F2eVwiPT09dGhpcy50eXBlKXttPWM7az1lO2c9MC41O3I9KGwtaykvYS8zO2Zvcih2YXIgbj0wO248cjtuKyspdGhpcy5jdHguYmV6aWVyQ3VydmVUbyhtK2cqYSxrK2EsbStnKmEsaysyKmEsbSxrKzMqYSksays9MyphLGcqPS0xO3RoaXMuY3R4LmJlemllckN1cnZlVG8obStnKmEsaythLG0rZyphLGsrMiphLG0sayszKmEpO209aDtnKj0tMTt0aGlzLmN0eC5saW5lVG8obSxrKTtmb3Iobj0wO248cjtuKyspdGhpcy5jdHguYmV6aWVyQ3VydmVUbyhtK2cqYSxrLWEsbStnKmEsay0yKmEsbSxrLTMqYSksay09MyphLGcqPS0xfWVsc2V7aWYoXCJ6aWd6YWdcIj09PXRoaXMudHlwZSl7Zz0tMTtrPWUrYTttPWMrYTtyPShsLWspL2EvMjtmb3Iobj0wO248cjtuKyspdGhpcy5jdHgubGluZVRvKG0sXHJcbmspLG0rPTIqZyphLGsrPTIqYSxnKj0tMTt0aGlzLmN0eC5saW5lVG8obSxrKTttKz1oLWM7Zm9yKG49MDtuPHIrMTtuKyspdGhpcy5jdHgubGluZVRvKG0sayksbSs9MipnKmEsay09MiphLGcqPS0xO3RoaXMuY3R4LmxpbmVUbyhtK2cqYSxrK2EpfX1lbHNlIGlmKFwibGVmdFwiPT09dGhpcy5zY2FsZUJyZWFrcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLnNjYWxlQnJlYWtzLnBhcmVudC5fcG9zaXRpb24paWYoZT0xPT09cCUyPyhlLnk8PDApKzAuNTplLnk8PDAsbD0xPT09cCUyPyhjLnk8PDApKzAuNTpjLnk8PDAsXCJsZWZ0XCI9PT10aGlzLnNjYWxlQnJlYWtzLnBhcmVudC5fcG9zaXRpb24/KGM9dGhpcy5jaGFydC5wbG90QXJlYS54MSxoPXRoaXMuY2hhcnQucGxvdEFyZWEueDIrcC8yKzAuNTw8MCk6KGM9dGhpcy5jaGFydC5wbG90QXJlYS54MixoPXRoaXMuY2hhcnQucGxvdEFyZWEueDEtcC8yKzAuNTw8MCxhKj0tMSksdGhpcy5ib3VuZHM9e3gxOmMseTE6ZS1wL1xyXG4yLHgyOmgseTI6bCtwLzJ9LHRoaXMuY3R4Lm1vdmVUbyhjLGUpLFwic3RyYWlnaHRcIj09PXRoaXMudHlwZXx8XCJsZWZ0XCI9PT10aGlzLnNjYWxlQnJlYWtzLnBhcmVudC5fcG9zaXRpb24mJjA+PWF8fFwicmlnaHRcIj09PXRoaXMuc2NhbGVCcmVha3MucGFyZW50Ll9wb3NpdGlvbiYmMDw9YSl0aGlzLmN0eC5saW5lVG8oaCxlKSx0aGlzLmN0eC5saW5lVG8oaCxsKSx0aGlzLmN0eC5saW5lVG8oYyxsKTtlbHNlIGlmKFwid2F2eVwiPT09dGhpcy50eXBlKXttPWM7az1lO2c9MC41O3I9KGgtbSkvYS8zO2ZvcihuPTA7bjxyO24rKyl0aGlzLmN0eC5iZXppZXJDdXJ2ZVRvKG0rYSxrK2cqYSxtKzIqYSxrK2cqYSxtKzMqYSxrKSxtKz0zKmEsZyo9LTE7dGhpcy5jdHguYmV6aWVyQ3VydmVUbyhtK2EsaytnKmEsbSsyKmEsaytnKmEsbSszKmEsayk7az1sO2cqPS0xO3RoaXMuY3R4LmxpbmVUbyhtLGspO2ZvcihuPTA7bjxyO24rKyl0aGlzLmN0eC5iZXppZXJDdXJ2ZVRvKG0tYSxrK2cqYSxtLTIqYSxcclxuaytnKmEsbS0zKmEsayksbS09MyphLGcqPS0xfWVsc2UgaWYoXCJ6aWd6YWdcIj09PXRoaXMudHlwZSl7Zz0xO2s9ZS1hO209YythO3I9KGgtbSkvYS8yO2ZvcihuPTA7bjxyO24rKyl0aGlzLmN0eC5saW5lVG8obSxrKSxrKz0yKmcqYSxtKz0yKmEsZyo9LTE7dGhpcy5jdHgubGluZVRvKG0sayk7ays9bC1lO2ZvcihuPTA7bjxyKzE7bisrKXRoaXMuY3R4LmxpbmVUbyhtLGspLGsrPTIqZyphLG0tPTIqYSxnKj0tMTt0aGlzLmN0eC5saW5lVG8obSthLGsrZyphKX0wPHAmJnRoaXMuY3R4LnN0cm9rZSgpO3RoaXMuY3R4LmNsb3NlUGF0aCgpO3RoaXMuY3R4Lmdsb2JhbEFscGhhPXRoaXMuZmlsbE9wYWNpdHk7dGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwiZGVzdGluYXRpb24tb3ZlclwiO3RoaXMuY3R4LmZpbGwoKTt0aGlzLmN0eC5yZXN0b3JlKCk7dGhpcy5jdHguZ2xvYmFsQWxwaGE9Yjt0aGlzLmN0eD1mfX07cGEoZ2EsWCk7Z2EucHJvdG90eXBlLmNyZWF0ZVVzZXJPcHRpb25zPVxyXG5mdW5jdGlvbihhKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGF8fHRoaXMub3B0aW9ucy5faXNQbGFjZWhvbGRlcil7dmFyIGY9MDt0aGlzLnBhcmVudC5vcHRpb25zLl9pc1BsYWNlaG9sZGVyJiZ0aGlzLnBhcmVudC5jcmVhdGVVc2VyT3B0aW9ucygpO3RoaXMub3B0aW9ucy5faXNQbGFjZWhvbGRlcnx8KERhKHRoaXMucGFyZW50LnN0cmlwTGluZXMpLGY9dGhpcy5wYXJlbnQub3B0aW9ucy5zdHJpcExpbmVzLmluZGV4T2YodGhpcy5vcHRpb25zKSk7dGhpcy5vcHRpb25zPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYT97fTphO3RoaXMucGFyZW50Lm9wdGlvbnMuc3RyaXBMaW5lc1tmXT10aGlzLm9wdGlvbnN9fTtnYS5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKCl7dGhpcy5jdHguc2F2ZSgpO3ZhciBhPXRoaXMucGFyZW50LmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXModGhpcy52YWx1ZSksZj1NYXRoLmFicyhcInBpeGVsXCI9PT10aGlzLl90aGlja25lc3NUeXBlP3RoaXMudGhpY2tuZXNzOlxyXG50aGlzLnBhcmVudC5jb252ZXJzaW9uUGFyYW1ldGVycy5waXhlbFBlclVuaXQqdGhpcy50aGlja25lc3MpO2lmKDA8Zil7dmFyIGI9bnVsbD09PXRoaXMub3BhY2l0eT8xOnRoaXMub3BhY2l0eTt0aGlzLmN0eC5zdHJva2VTdHlsZT10aGlzLmNvbG9yO3RoaXMuY3R4LmJlZ2luUGF0aCgpO3ZhciBjPXRoaXMuY3R4Lmdsb2JhbEFscGhhO3RoaXMuY3R4Lmdsb2JhbEFscGhhPWI7Uih0aGlzLmlkKTt2YXIgZSxnLGgsbDt0aGlzLmN0eC5saW5lV2lkdGg9Zjt0aGlzLmN0eC5zZXRMaW5lRGFzaCYmdGhpcy5jdHguc2V0TGluZURhc2goRyh0aGlzLmxpbmVEYXNoVHlwZSxmKSk7aWYoXCJib3R0b21cIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbillPWc9MT09PXRoaXMuY3R4LmxpbmVXaWR0aCUyPyhhLng8PDApKzAuNTphLng8PDAsaD10aGlzLmNoYXJ0LnBsb3RBcmVhLnkxLGw9dGhpcy5jaGFydC5wbG90QXJlYS55Mix0aGlzLmJvdW5kcz1cclxue3gxOmUtZi8yLHkxOmgseDI6ZytmLzIseTI6bH07ZWxzZSBpZihcImxlZnRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKWg9bD0xPT09dGhpcy5jdHgubGluZVdpZHRoJTI/KGEueTw8MCkrMC41OmEueTw8MCxlPXRoaXMuY2hhcnQucGxvdEFyZWEueDEsZz10aGlzLmNoYXJ0LnBsb3RBcmVhLngyLHRoaXMuYm91bmRzPXt4MTplLHkxOmgtZi8yLHgyOmcseTI6bCtmLzJ9O3RoaXMuY3R4Lm1vdmVUbyhlLGgpO3RoaXMuY3R4LmxpbmVUbyhnLGwpO3RoaXMuY3R4LnN0cm9rZSgpO3RoaXMuY3R4Lmdsb2JhbEFscGhhPWN9dGhpcy5jdHgucmVzdG9yZSgpfTtwYShpYSxYKTtpYS5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGEsZil7dmFyIGIsYyxlLGcsaD1udWxsLGw9aD1udWxsLG09XCJcIjtpZighdGhpcy52YWx1ZUZvcm1hdFN0cmluZylpZihcImRhdGVUaW1lXCI9PT10aGlzLnBhcmVudC52YWx1ZVR5cGUpdGhpcy52YWx1ZUZvcm1hdFN0cmluZz1cclxudGhpcy5wYXJlbnQudmFsdWVGb3JtYXRTdHJpbmc7ZWxzZXt2YXIgaz0wLGs9XCJ4eVN3YXBwZWRcIj09PXRoaXMuY2hhcnQucGxvdEluZm8uYXhpc1BsYWNlbWVudD81MDx0aGlzLnBhcmVudC5yYW5nZT8wOjUwMDx0aGlzLmNoYXJ0LndpZHRoJiYyNT50aGlzLnBhcmVudC5yYW5nZT8yOk1hdGguZmxvb3IoTWF0aC5hYnMoTWF0aC5sb2codGhpcy5wYXJlbnQucmFuZ2UpL01hdGguTE4xMCkpKyg1PnRoaXMucGFyZW50LnJhbmdlPzI6MTA+dGhpcy5wYXJlbnQucmFuZ2U/MTowKTo1MDx0aGlzLnBhcmVudC5yYW5nZT8wOk1hdGguZmxvb3IoTWF0aC5hYnMoTWF0aC5sb2codGhpcy5wYXJlbnQucmFuZ2UpL01hdGguTE4xMCkpKyg1PnRoaXMucGFyZW50LnJhbmdlPzI6MTA+dGhpcy5wYXJlbnQucmFuZ2U/MTowKTt0aGlzLnZhbHVlRm9ybWF0U3RyaW5nPUMuZ2VuZXJhdGVWYWx1ZUZvcm1hdFN0cmluZyh0aGlzLnBhcmVudC5yYW5nZSxrKX12YXIgbD1udWxsPT09dGhpcy5vcGFjaXR5PzE6XHJcbnRoaXMub3BhY2l0eSxrPU1hdGguYWJzKFwicGl4ZWxcIj09PXRoaXMuX3RoaWNrbmVzc1R5cGU/dGhpcy50aGlja25lc3M6dGhpcy5wYXJlbnQuY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0KnRoaXMudGhpY2tuZXNzKSxyPXRoaXMuY2hhcnQub3ZlcmxhaWRDYW52YXNDdHgscD1yLmdsb2JhbEFscGhhO3IuZ2xvYmFsQWxwaGE9bDtyLmJlZ2luUGF0aCgpO3Iuc3Ryb2tlU3R5bGU9dGhpcy5jb2xvcjtyLmxpbmVXaWR0aD1rO3Iuc2F2ZSgpO3RoaXMubGFiZWxGb250U2l6ZT15KHRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKT90aGlzLnBhcmVudC5sYWJlbEZvbnRTaXplOnRoaXMubGFiZWxGb250U2l6ZTtpZihcImxlZnRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKXRoaXMubGFiZWxNYXhXaWR0aD15KHRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoKT90aGlzLnBhcmVudC5ib3VuZHMueDItdGhpcy5wYXJlbnQuYm91bmRzLngxOlxyXG50aGlzLmxhYmVsTWF4V2lkdGgsdGhpcy5sYWJlbE1heEhlaWdodD15KHRoaXMub3B0aW9ucy5sYWJlbFdyYXApfHx0aGlzLmxhYmVsV3JhcD8zKnRoaXMuY2hhcnQuaGVpZ2h0OjIqdGhpcy5sYWJlbEZvbnRTaXplO2Vsc2UgaWYoXCJ0b3BcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJib3R0b21cIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbil0aGlzLmxhYmVsTWF4V2lkdGg9eSh0aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCk/Myp0aGlzLmNoYXJ0LndpZHRoOnRoaXMubGFiZWxNYXhXaWR0aCx0aGlzLmxhYmVsTWF4SGVpZ2h0PXkodGhpcy5vcHRpb25zLmxhYmVsV3JhcCl8fHRoaXMubGFiZWxXcmFwP3RoaXMucGFyZW50LmJvdW5kcy5oZWlnaHQ6Mip0aGlzLmxhYmVsRm9udFNpemU7MDxrJiZyLnNldExpbmVEYXNoJiZyLnNldExpbmVEYXNoKEcodGhpcy5saW5lRGFzaFR5cGUsaykpO2w9bmV3IGxhKHIse3g6MCx5OjAscGFkZGluZzp7dG9wOjIscmlnaHQ6Myxib3R0b206MixsZWZ0OjR9LFxyXG5iYWNrZ3JvdW5kQ29sb3I6dGhpcy5sYWJlbEJhY2tncm91bmRDb2xvcixib3JkZXJDb2xvcjp0aGlzLmxhYmVsQm9yZGVyQ29sb3IsYm9yZGVyVGhpY2tuZXNzOnRoaXMubGFiZWxCb3JkZXJUaGlja25lc3MsY29ybmVyUmFkaXVzOnRoaXMubGFiZWxDb3JuZXJSYWRpdXMsbWF4V2lkdGg6dGhpcy5sYWJlbE1heFdpZHRoLG1heEhlaWdodDp0aGlzLmxhYmVsTWF4SGVpZ2h0LGFuZ2xlOnRoaXMubGFiZWxBbmdsZSx0ZXh0Om0saG9yaXpvbnRhbEFsaWduOlwibGVmdFwiLGZvbnRTaXplOnRoaXMubGFiZWxGb250U2l6ZSxmb250RmFtaWx5OnRoaXMubGFiZWxGb250RmFtaWx5LGZvbnRXZWlnaHQ6dGhpcy5sYWJlbEZvbnRXZWlnaHQsZm9udENvbG9yOnRoaXMubGFiZWxGb250Q29sb3IsZm9udFN0eWxlOnRoaXMubGFiZWxGb250U3R5bGUsdGV4dEJhc2VsaW5lOlwibWlkZGxlXCJ9KTtpZih0aGlzLnNuYXBUb0RhdGFQb2ludCl7dmFyIG49MCxoPVtdO2lmKFwieHlTd2FwcGVkXCI9PT10aGlzLmNoYXJ0LnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQpe3ZhciBkPVxyXG5udWxsO2lmKFwiYm90dG9tXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb258fFwidG9wXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pbj10aGlzLnBhcmVudC5kYXRhU2VyaWVzWzBdLmF4aXNYLmNvbnZlcnRQaXhlbFRvVmFsdWUoe3k6Zn0pO2Vsc2UgaWYoXCJsZWZ0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb258fFwicmlnaHRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbiluPXRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoe3k6Zn0pO2Zvcih2YXIgcT0wO3E8dGhpcy5wYXJlbnQuZGF0YVNlcmllcy5sZW5ndGg7cSsrKShkPXRoaXMucGFyZW50LmRhdGFTZXJpZXNbcV0uZ2V0RGF0YVBvaW50QXRYKG4sITApKSYmMDw9ZC5pbmRleCYmKGQuZGF0YVNlcmllcz10aGlzLnBhcmVudC5kYXRhU2VyaWVzW3FdLG51bGwhPT1kLmRhdGFQb2ludC55JiZoLnB1c2goZCkpO2Q9bnVsbDtpZigwPT09aC5sZW5ndGgpcmV0dXJuO2guc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLmRpc3RhbmNlLVxyXG5iLmRpc3RhbmNlfSk7ZD1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoaFswXS5kYXRhUG9pbnQueSkpO3E9MDtpZihcInJhbmdlQmFyXCI9PT1oWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJlcnJvclwiPT09aFswXS5kYXRhU2VyaWVzLnR5cGUpZm9yKHZhciBkPU1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChoW3FdLmRhdGFQb2ludC55WzBdKSkscz0wLG49MDtuPGgubGVuZ3RoO24rKylpZihoW25dLmRhdGFQb2ludC55JiZoW25dLmRhdGFQb2ludC55Lmxlbmd0aClmb3IobT0wO208aFtuXS5kYXRhUG9pbnQueS5sZW5ndGg7bSsrKXM9TWF0aC5hYnMoYS10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKGhbbl0uZGF0YVBvaW50LnlbbV0pKSxzPGQmJihkPXMscT1uKTtlbHNlIHM9TWF0aC5hYnMoYS10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKGhbbl0uZGF0YVBvaW50LnkpKSxzPGQmJihkPXMscT1uKTtlbHNlIGlmKFwic3RhY2tlZEJhclwiPT09XHJcbmhbMF0uZGF0YVNlcmllcy50eXBlKWZvcih2YXIgZD1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoaFswXS5kYXRhUG9pbnQueSkpLHY9cz0wLG49cT0wO248aC5sZW5ndGg7bisrKWlmKGhbbl0uZGF0YVBvaW50LnkmJmhbbl0uZGF0YVBvaW50LnkubGVuZ3RoKWZvcihtPTA7bTxoW25dLmRhdGFQb2ludC55Lmxlbmd0aDttKyspcz1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoaFtuXS5kYXRhUG9pbnQueVttXSkpLHM8ZCYmKGQ9cyxxPW4pO2Vsc2Ugdis9aFtuXS5kYXRhUG9pbnQueSxzPU1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh2KSksczxkJiYoZD1zLHE9bik7ZWxzZSBpZihcInN0YWNrZWRCYXIxMDBcIj09PWhbMF0uZGF0YVNlcmllcy50eXBlKWZvcih2YXIgZD1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoaFswXS5kYXRhUG9pbnQueSkpLHU9dj1zPTAsXHJcbm49MDtuPGgubGVuZ3RoO24rKylpZihoW25dLmRhdGFQb2ludC55JiZoW25dLmRhdGFQb2ludC55Lmxlbmd0aClmb3IobT0wO208aFtuXS5kYXRhUG9pbnQueS5sZW5ndGg7bSsrKXM9TWF0aC5hYnMoYS10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKGhbbl0uZGF0YVBvaW50LnlbbV0pKSxzPGQmJihkPXMscT1uKTtlbHNlIHYrPWhbbl0uZGF0YVBvaW50LnksdT1oW25dLmRhdGFQb2ludC54LmdldFRpbWU/aFtuXS5kYXRhUG9pbnQueC5nZXRUaW1lKCk6aFtuXS5kYXRhUG9pbnQueCx1PTEwMCoodi9oW25dLmRhdGFTZXJpZXMucGxvdFVuaXQuZGF0YVBvaW50WVN1bXNbdV0pLHM9TWF0aC5hYnMoYS10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHUpKSxzPGQmJihkPXMscT1uKTtlbHNlIGZvcihkPU1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChoWzBdLmRhdGFQb2ludC55KSksbj1xPXM9MDtuPGgubGVuZ3RoO24rKylpZihoW25dLmRhdGFQb2ludC55JiZcclxuaFtuXS5kYXRhUG9pbnQueS5sZW5ndGgpZm9yKG09MDttPGhbbl0uZGF0YVBvaW50LnkubGVuZ3RoO20rKylzPU1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChoW25dLmRhdGFQb2ludC55W21dKSksczxkJiYoZD1zLHE9bik7ZWxzZSBzPU1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChoW25dLmRhdGFQb2ludC55KSksczxkJiYoZD1zLHE9bik7bT1oW3FdO2lmKFwiYm90dG9tXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb258fFwidG9wXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pe2I9MDtpZihcInJhbmdlQmFyXCI9PT10aGlzLnBhcmVudC5kYXRhU2VyaWVzW3FdLnR5cGV8fFwiZXJyb3JcIj09PXRoaXMucGFyZW50LmRhdGFTZXJpZXNbcV0udHlwZSl7ZD1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobS5kYXRhUG9pbnQueVswXSkpO2ZvcihuPXM9MDtuPG0uZGF0YVBvaW50LnkubGVuZ3RoO24rKylzPU1hdGguYWJzKGEtXHJcbnRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobS5kYXRhUG9pbnQueVtuXSkpLHM8ZCYmKGQ9cyxiPW4pO2g9MT09PXIubGluZVdpZHRoJTI/KHRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobS5kYXRhUG9pbnQueVtiXSk8PDApKzAuNTp0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG0uZGF0YVBvaW50LnlbYl0pPDwwO2wudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6bS5kYXRhUG9pbnQueVtiXX0pOnkodGhpcy5vcHRpb25zLmxhYmVsKT9XKG0uZGF0YVBvaW50LnlbYl0sdGhpcy52YWx1ZUZvcm1hdFN0cmluZyx0aGlzLmNoYXJ0Ll9jdWx0dXJlSW5mbyk6dGhpcy5sYWJlbH1lbHNlIGlmKFwic3RhY2tlZEJhclwiPT09dGhpcy5wYXJlbnQuZGF0YVNlcmllc1txXS50eXBlKXtkPU1hdGguYWJzKGEtXHJcbnRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoaFswXS5kYXRhUG9pbnQueSkpO3Y9cz0wO2ZvcihuPXE7MDw9bjtuLS0pdis9aFtuXS5kYXRhUG9pbnQueSxzPU1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh2KSksczxkJiYoZD1zLGI9bik7aD0xPT09ci5saW5lV2lkdGglMj8odGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh2KTw8MCkrMC41OnRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwodik8PDA7bC50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTptLmRhdGFQb2ludC55fSk6eSh0aGlzLm9wdGlvbnMubGFiZWwpP1cobS5kYXRhUG9pbnQueSx0aGlzLnZhbHVlRm9ybWF0U3RyaW5nLHRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsfWVsc2UgaWYoXCJzdGFja2VkQmFyMTAwXCI9PT1cclxudGhpcy5wYXJlbnQuZGF0YVNlcmllc1txXS50eXBlKXtkPU1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChoWzBdLmRhdGFQb2ludC55KSk7dT12PXM9MDtmb3Iobj1xOzA8PW47bi0tKXYrPWhbbl0uZGF0YVBvaW50LnksdT1oW25dLmRhdGFQb2ludC54LmdldFRpbWU/aFtuXS5kYXRhUG9pbnQueC5nZXRUaW1lKCk6aFtuXS5kYXRhUG9pbnQueCx1PTEwMCoodi9oW25dLmRhdGFTZXJpZXMucGxvdFVuaXQuZGF0YVBvaW50WVN1bXNbdV0pLHM9TWF0aC5hYnMoYS10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHUpKSxzPGQmJihkPXMsYj1uKTtoPTE9PT1yLmxpbmVXaWR0aCUyPyh0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHUpPDwwKSswLjU6dGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh1KTw8MDtsLnRleHQ9dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxcclxuY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTp1fSk6eSh0aGlzLm9wdGlvbnMubGFiZWwpP1codSx0aGlzLnZhbHVlRm9ybWF0U3RyaW5nLHRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsfWVsc2UgaD0xPT09ci5saW5lV2lkdGglMj8odGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChtLmRhdGFQb2ludC55KTw8MCkrMC41OnRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobS5kYXRhUG9pbnQueSk8PDAsbC50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTptLmRhdGFQb2ludC55fSk6eSh0aGlzLm9wdGlvbnMubGFiZWwpP1cobS5kYXRhUG9pbnQueSx0aGlzLnZhbHVlRm9ybWF0U3RyaW5nLHRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsO2I9Yz1oO2U9dGhpcy5jaGFydC5wbG90QXJlYS55MTtcclxuZz10aGlzLmNoYXJ0LnBsb3RBcmVhLnkyO3RoaXMuYm91bmRzPXt4MTpiLWsvMix5MTplLHgyOmMray8yLHkyOmd9O2wueD1iLWwubWVhc3VyZVRleHQoKS53aWR0aC8yO2wueCtsLndpZHRoPnRoaXMuY2hhcnQuYm91bmRzLngyP2wueD10aGlzLmNoYXJ0LmJvdW5kcy54Mi1sLndpZHRoOmwueDx0aGlzLmNoYXJ0LmJvdW5kcy54MSYmKGwueD10aGlzLmNoYXJ0LmJvdW5kcy54MSk7bC55PXRoaXMucGFyZW50LmxpbmVDb29yZGluYXRlcy55MitsLmZvbnRTaXplLzIrMn1lbHNlIGlmKFwibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pe2U9Zz1oPTE9PT1yLmxpbmVXaWR0aCUyPyh0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG0uZGF0YVBvaW50LngpPDwwKSswLjU6dGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChtLmRhdGFQb2ludC54KTw8MDtiPXRoaXMuY2hhcnQucGxvdEFyZWEueDE7Yz10aGlzLmNoYXJ0LnBsb3RBcmVhLngyO1xyXG50aGlzLmJvdW5kcz17eDE6Yix5MTplLWsvMix4MjpjLHkyOmcray8yfTt1PSExO2lmKHRoaXMucGFyZW50LmxhYmVscylmb3IoaD1NYXRoLmNlaWwodGhpcy5wYXJlbnQuaW50ZXJ2YWwpLG49MDtuPHRoaXMucGFyZW50LnZpZXdwb3J0TWF4aW11bTtuKz1oKWlmKHRoaXMucGFyZW50LmxhYmVsc1tuXSl1PSEwO2Vsc2V7dT0hMTticmVha31pZih1KXtpZihcImF4aXNYXCI9PT10aGlzLnBhcmVudC50eXBlKWZvcihuPXRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoe3k6Zn0pLGQ9bnVsbCxxPTA7cTx0aGlzLnBhcmVudC5kYXRhU2VyaWVzLmxlbmd0aDtxKyspKGQ9dGhpcy5wYXJlbnQuZGF0YVNlcmllc1txXS5nZXREYXRhUG9pbnRBdFgobiwhMCkpJiYwPD1kLmluZGV4JiYobC50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTptLmRhdGFQb2ludC54fSk6XHJcbnkodGhpcy5vcHRpb25zLmxhYmVsKT9kLmRhdGFQb2ludC5sYWJlbDp0aGlzLmxhYmVsKX1lbHNlXCJkYXRlVGltZVwiPT09dGhpcy5wYXJlbnQudmFsdWVUeXBlP2wudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6bS5kYXRhUG9pbnQueH0pOnkodGhpcy5vcHRpb25zLmxhYmVsKT9CYShtLmRhdGFQb2ludC54LHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWw6XCJudW1iZXJcIj09PXRoaXMucGFyZW50LnZhbHVlVHlwZSYmKGwudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6bS5kYXRhUG9pbnQueH0pOnkodGhpcy5vcHRpb25zLmxhYmVsKT9cclxuVyhtLmRhdGFQb2ludC54LHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWwpO2wueT1nK2wuZm9udFNpemUvMi1sLm1lYXN1cmVUZXh0KCkuaGVpZ2h0LzIrMjtsLnktbC5mb250U2l6ZS8yPHRoaXMuY2hhcnQuYm91bmRzLnkxP2wueT10aGlzLmNoYXJ0LmJvdW5kcy55MStsLmZvbnRTaXplLzIrMjpsLnkrbC5tZWFzdXJlVGV4dCgpLmhlaWdodC1sLmZvbnRTaXplLzI+dGhpcy5jaGFydC5ib3VuZHMueTImJihsLnk9dGhpcy5jaGFydC5ib3VuZHMueTItbC5tZWFzdXJlVGV4dCgpLmhlaWdodCtsLmZvbnRTaXplLzIpO1wibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uP2wueD10aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueDItbC5tZWFzdXJlVGV4dCgpLndpZHRoOlwicmlnaHRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbiYmKGwueD10aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueDIpfX1lbHNlIGlmKFwiYm90dG9tXCI9PT1cclxudGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKXtuPXRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoe3g6YX0pO2ZvcihxPTA7cTx0aGlzLnBhcmVudC5kYXRhU2VyaWVzLmxlbmd0aDtxKyspKGQ9dGhpcy5wYXJlbnQuZGF0YVNlcmllc1txXS5nZXREYXRhUG9pbnRBdFgobiwhMCkpJiYwPD1kLmluZGV4JiYoZC5kYXRhU2VyaWVzPXRoaXMucGFyZW50LmRhdGFTZXJpZXNbcV0sbnVsbCE9PWQuZGF0YVBvaW50LnkmJmgucHVzaChkKSk7aWYoMD09PWgubGVuZ3RoKXJldHVybjtoLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5kaXN0YW5jZS1iLmRpc3RhbmNlfSk7bT1oWzBdO2I9Yz1oPTE9PT1yLmxpbmVXaWR0aCUyPyh0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG0uZGF0YVBvaW50LngpPDwwKSswLjU6dGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChtLmRhdGFQb2ludC54KTw8MDtlPXRoaXMuY2hhcnQucGxvdEFyZWEueTE7XHJcbmc9dGhpcy5jaGFydC5wbG90QXJlYS55Mjt0aGlzLmJvdW5kcz17eDE6Yi1rLzIseTE6ZSx4MjpjK2svMix5MjpnfTt1PSExO2lmKHRoaXMucGFyZW50LmxhYmVscylmb3IoaD1NYXRoLmNlaWwodGhpcy5wYXJlbnQuaW50ZXJ2YWwpLG49MDtuPHRoaXMucGFyZW50LnZpZXdwb3J0TWF4aW11bTtuKz1oKWlmKHRoaXMucGFyZW50LmxhYmVsc1tuXSl1PSEwO2Vsc2V7dT0hMTticmVha31pZih1KXtpZihcImF4aXNYXCI9PT10aGlzLnBhcmVudC50eXBlKWZvcihuPXRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoe3g6YX0pLGQ9bnVsbCxxPTA7cTx0aGlzLnBhcmVudC5kYXRhU2VyaWVzLmxlbmd0aDtxKyspKGQ9dGhpcy5wYXJlbnQuZGF0YVNlcmllc1txXS5nZXREYXRhUG9pbnRBdFgobiwhMCkpJiYwPD1kLmluZGV4JiYobC50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsXHJcbmNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6bS5kYXRhUG9pbnQueH0pOnkodGhpcy5vcHRpb25zLmxhYmVsKT9kLmRhdGFQb2ludC5sYWJlbDp0aGlzLmxhYmVsKX1lbHNlXCJkYXRlVGltZVwiPT09dGhpcy5wYXJlbnQudmFsdWVUeXBlP2wudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6bS5kYXRhUG9pbnQueH0pOnkodGhpcy5vcHRpb25zLmxhYmVsKT9CYShtLmRhdGFQb2ludC54LHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWw6XCJudW1iZXJcIj09PXRoaXMucGFyZW50LnZhbHVlVHlwZSYmKGwudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsXHJcbnZhbHVlOm0uZGF0YVBvaW50Lnh9KTp5KHRoaXMub3B0aW9ucy5sYWJlbCk/VyhtLmRhdGFQb2ludC54LHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWwpO2wueD1iLWwubWVhc3VyZVRleHQoKS53aWR0aC8yO2wueCtsLndpZHRoPnRoaXMuY2hhcnQuYm91bmRzLngyJiYobC54PXRoaXMuY2hhcnQuYm91bmRzLngyLWwud2lkdGgpO2wueDx0aGlzLmNoYXJ0LmJvdW5kcy54MSYmKGwueD10aGlzLmNoYXJ0LmJvdW5kcy54MSk7XCJib3R0b21cIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbj9sLnk9dGhpcy5wYXJlbnQubGluZUNvb3JkaW5hdGVzLnkyK2wuZm9udFNpemUvMisyOlwidG9wXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24mJihsLnk9dGhpcy5wYXJlbnQubGluZUNvb3JkaW5hdGVzLnkxLWwuaGVpZ2h0K2wuZm9udFNpemUvMisyKX1lbHNlIGlmKFwibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24peyF5KHRoaXMucGFyZW50LmRhdGFTZXJpZXMpJiZcclxuMDx0aGlzLnBhcmVudC5kYXRhU2VyaWVzLmxlbmd0aCYmKG49dGhpcy5wYXJlbnQuZGF0YVNlcmllc1swXS5heGlzWC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKHt4OmF9KSk7Zm9yKHE9MDtxPHRoaXMucGFyZW50LmRhdGFTZXJpZXMubGVuZ3RoO3ErKykoZD10aGlzLnBhcmVudC5kYXRhU2VyaWVzW3FdLmdldERhdGFQb2ludEF0WChuLCEwKSkmJjA8PWQuaW5kZXgmJihkLmRhdGFTZXJpZXM9dGhpcy5wYXJlbnQuZGF0YVNlcmllc1txXSxudWxsIT09ZC5kYXRhUG9pbnQueSYmaC5wdXNoKGQpKTtpZigwPT09aC5sZW5ndGgpcmV0dXJuO2guc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLmRpc3RhbmNlLWIuZGlzdGFuY2V9KTtxPTA7aWYoXCJyYW5nZUNvbHVtblwiPT09aFswXS5kYXRhU2VyaWVzLnR5cGV8fFwicmFuZ2VBcmVhXCI9PT1oWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJlcnJvclwiPT09aFswXS5kYXRhU2VyaWVzLnR5cGV8fFwicmFuZ2VTcGxpbmVBcmVhXCI9PT1oWzBdLmRhdGFTZXJpZXMudHlwZXx8XHJcblwiY2FuZGxlc3RpY2tcIj09PWhbMF0uZGF0YVNlcmllcy50eXBlfHxcIm9obGNcIj09PWhbMF0uZGF0YVNlcmllcy50eXBlfHxcImJveEFuZFdoaXNrZXJcIj09PWhbMF0uZGF0YVNlcmllcy50eXBlKWZvcihkPU1hdGguYWJzKGYtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChoWzBdLmRhdGFQb2ludC55WzBdKSksbj1zPTA7bjxoLmxlbmd0aDtuKyspaWYoaFtuXS5kYXRhUG9pbnQueSYmaFtuXS5kYXRhUG9pbnQueS5sZW5ndGgpZm9yKG09MDttPGhbbl0uZGF0YVBvaW50LnkubGVuZ3RoO20rKylzPU1hdGguYWJzKGYtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChoW25dLmRhdGFQb2ludC55W21dKSksczxkJiYoZD1zLHE9bik7ZWxzZSBzPU1hdGguYWJzKGYtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChoW25dLmRhdGFQb2ludC55KSksczxkJiYoZD1zLHE9bik7ZWxzZSBpZihcInN0YWNrZWRDb2x1bW5cIj09PWhbMF0uZGF0YVNlcmllcy50eXBlfHxcInN0YWNrZWRBcmVhXCI9PT1cclxuaFswXS5kYXRhU2VyaWVzLnR5cGUpZm9yKGQ9TWF0aC5hYnMoZi10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKGhbMF0uZGF0YVBvaW50LnkpKSxuPXY9cz0wO248aC5sZW5ndGg7bisrKWlmKGhbbl0uZGF0YVBvaW50LnkmJmhbbl0uZGF0YVBvaW50LnkubGVuZ3RoKWZvcihtPTA7bTxoW25dLmRhdGFQb2ludC55Lmxlbmd0aDttKyspcz1NYXRoLmFicyhmLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoaFtuXS5kYXRhUG9pbnQueVttXSkpLHM8ZCYmKGQ9cyxxPW4pO2Vsc2Ugdis9aFtuXS5kYXRhUG9pbnQueSxzPU1hdGguYWJzKGYtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh2KSksczxkJiYoZD1zLHE9bik7ZWxzZSBpZihcInN0YWNrZWRDb2x1bW4xMDBcIj09PWhbMF0uZGF0YVNlcmllcy50eXBlfHxcInN0YWNrZWRBcmVhMTAwXCI9PT1oWzBdLmRhdGFTZXJpZXMudHlwZSlmb3IoZD1NYXRoLmFicyhmLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoaFswXS5kYXRhUG9pbnQueSkpLFxyXG5uPXU9dj1zPTA7bjxoLmxlbmd0aDtuKyspaWYoaFtuXS5kYXRhUG9pbnQueSYmaFtuXS5kYXRhUG9pbnQueS5sZW5ndGgpZm9yKG09MDttPGhbbl0uZGF0YVBvaW50LnkubGVuZ3RoO20rKylzPU1hdGguYWJzKGYtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChoW25dLmRhdGFQb2ludC55W21dKSksczxkJiYoZD1zLHE9bik7ZWxzZSB2Kz1oW25dLmRhdGFQb2ludC55LHU9aFtuXS5kYXRhUG9pbnQueC5nZXRUaW1lP2hbbl0uZGF0YVBvaW50LnguZ2V0VGltZSgpOmhbbl0uZGF0YVBvaW50LngsdT0xMDAqKHYvaFtuXS5kYXRhU2VyaWVzLnBsb3RVbml0LmRhdGFQb2ludFlTdW1zW3VdKSxzPU1hdGguYWJzKGYtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh1KSksczxkJiYoZD1zLHE9bik7ZWxzZSBmb3IoZD1NYXRoLmFicyhmLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoaFswXS5kYXRhUG9pbnQueSkpLG49cz0wO248aC5sZW5ndGg7bisrKWlmKGhbbl0uZGF0YVBvaW50LnkmJlxyXG5oW25dLmRhdGFQb2ludC55Lmxlbmd0aClmb3IobT0wO208aFtuXS5kYXRhUG9pbnQueS5sZW5ndGg7bSsrKXM9TWF0aC5hYnMoZi10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKGhbbl0uZGF0YVBvaW50LnlbbV0pKSxzPGQmJihkPXMscT1uKTtlbHNlIHM9TWF0aC5hYnMoZi10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKGhbbl0uZGF0YVBvaW50LnkpKSxzPGQmJihkPXMscT1uKTttPWhbcV07Yj0wO2lmKFwicmFuZ2VDb2x1bW5cIj09PXRoaXMucGFyZW50LmRhdGFTZXJpZXNbcV0udHlwZXx8XCJyYW5nZUFyZWFcIj09PXRoaXMucGFyZW50LmRhdGFTZXJpZXNbcV0udHlwZXx8XCJlcnJvclwiPT09dGhpcy5wYXJlbnQuZGF0YVNlcmllc1txXS50eXBlfHxcInJhbmdlU3BsaW5lQXJlYVwiPT09dGhpcy5wYXJlbnQuZGF0YVNlcmllc1txXS50eXBlfHxcImNhbmRsZXN0aWNrXCI9PT10aGlzLnBhcmVudC5kYXRhU2VyaWVzW3FdLnR5cGV8fFwib2hsY1wiPT09dGhpcy5wYXJlbnQuZGF0YVNlcmllc1txXS50eXBlfHxcclxuXCJib3hBbmRXaGlza2VyXCI9PT10aGlzLnBhcmVudC5kYXRhU2VyaWVzW3FdLnR5cGUpe2Q9TWF0aC5hYnMoZi10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG0uZGF0YVBvaW50LnlbMF0pKTtmb3Iobj1zPTA7bjxtLmRhdGFQb2ludC55Lmxlbmd0aDtuKyspcz1NYXRoLmFicyhmLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobS5kYXRhUG9pbnQueVtuXSkpLHM8ZCYmKGQ9cyxiPW4pO2g9MT09PXIubGluZVdpZHRoJTI/KHRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobS5kYXRhUG9pbnQueVtiXSk8PDApKzAuNTp0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG0uZGF0YVBvaW50LnlbYl0pPDwwO2wudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6bS5kYXRhUG9pbnQueVtiXX0pOnkodGhpcy5vcHRpb25zLmxhYmVsKT9cclxuVyhtLmRhdGFQb2ludC55W2JdLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWx9ZWxzZSBpZihcInN0YWNrZWRDb2x1bW5cIj09PXRoaXMucGFyZW50LmRhdGFTZXJpZXNbcV0udHlwZXx8XCJzdGFja2VkQXJlYVwiPT09dGhpcy5wYXJlbnQuZGF0YVNlcmllc1txXS50eXBlKXtkPU1hdGguYWJzKGYtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChoWzBdLmRhdGFQb2ludC55KSk7dj1zPTA7Zm9yKG49cTswPD1uO24tLSl2Kz1oW25dLmRhdGFQb2ludC55LHM9TWF0aC5hYnMoZi10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHYpKSxzPGQmJihkPXMsYj1uKTtoPTE9PT1yLmxpbmVXaWR0aCUyPyh0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHYpPDwwKSswLjU6dGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh2KTw8MDtsLnRleHQ9dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LFxyXG5heGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTptLmRhdGFQb2ludC55fSk6eSh0aGlzLm9wdGlvbnMubGFiZWwpP1cobS5kYXRhUG9pbnQueSx0aGlzLnZhbHVlRm9ybWF0U3RyaW5nLHRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsfWVsc2UgaWYoXCJzdGFja2VkQ29sdW1uMTAwXCI9PT10aGlzLnBhcmVudC5kYXRhU2VyaWVzW3FdLnR5cGV8fFwic3RhY2tlZEFyZWExMDBcIj09PXRoaXMucGFyZW50LmRhdGFTZXJpZXNbcV0udHlwZSl7ZD1NYXRoLmFicyhmLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoaFswXS5kYXRhUG9pbnQueSkpO3Y9cz0wO2ZvcihuPXE7MDw9bjtuLS0pdis9aFtuXS5kYXRhUG9pbnQueSx1PWhbbl0uZGF0YVBvaW50LnguZ2V0VGltZT9oW25dLmRhdGFQb2ludC54LmdldFRpbWUoKTpoW25dLmRhdGFQb2ludC54LHU9MTAwKih2L2hbbl0uZGF0YVNlcmllcy5wbG90VW5pdC5kYXRhUG9pbnRZU3Vtc1t1XSksXHJcbnM9TWF0aC5hYnMoZi10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHUpKSxzPGQmJihkPXMsYj1uKTtoPTE9PT1yLmxpbmVXaWR0aCUyPyh0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHUpPDwwKSswLjU6dGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh1KTw8MDtsLnRleHQ9dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOnV9KTp5KHRoaXMub3B0aW9ucy5sYWJlbCk/Vyh1LHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWx9ZWxzZVwid2F0ZXJmYWxsXCI9PT10aGlzLnBhcmVudC5kYXRhU2VyaWVzW3FdLnR5cGU/KGg9MT09PXIubGluZVdpZHRoJTI/KHRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobS5kYXRhU2VyaWVzLmRhdGFQb2ludEVPc1ttLmluZGV4XS5jdW11bGF0aXZlU3VtKTw8XHJcbjApKzAuNTp0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG0uZGF0YVNlcmllcy5kYXRhUG9pbnRFT3NbbS5pbmRleF0uY3VtdWxhdGl2ZVN1bSk8PDAsbC50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTptLmRhdGFTZXJpZXMuZGF0YVBvaW50RU9zW20uaW5kZXhdLmN1bXVsYXRpdmVTdW19KTp5KHRoaXMub3B0aW9ucy5sYWJlbCk/VyhtLmRhdGFTZXJpZXMuZGF0YVBvaW50RU9zW20uaW5kZXhdLmN1bXVsYXRpdmVTdW0sdGhpcy52YWx1ZUZvcm1hdFN0cmluZyx0aGlzLmNoYXJ0Ll9jdWx0dXJlSW5mbyk6dGhpcy5sYWJlbCk6KGg9MT09PXIubGluZVdpZHRoJTI/KHRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobS5kYXRhUG9pbnQueSk8PDApKzAuNTp0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG0uZGF0YVBvaW50LnkpPDxcclxuMCxsLnRleHQ9dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOm0uZGF0YVBvaW50Lnl9KTp5KHRoaXMub3B0aW9ucy5sYWJlbCk/VyhtLmRhdGFQb2ludC55LHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWwpO2U9Zz1oO2I9dGhpcy5jaGFydC5wbG90QXJlYS54MTtjPXRoaXMuY2hhcnQucGxvdEFyZWEueDI7dGhpcy5ib3VuZHM9e3gxOmIseTE6ZS1rLzIseDI6Yyx5MjpnK2svMn07bC55PWcrbC5mb250U2l6ZS8yLWwubWVhc3VyZVRleHQoKS5oZWlnaHQvMisyO2wueS1sLmZvbnRTaXplLzI8dGhpcy5jaGFydC5ib3VuZHMueTE/bC55PXRoaXMuY2hhcnQuYm91bmRzLnkxK2wuZm9udFNpemUvMisyOmwueStsLm1lYXN1cmVUZXh0KCkuaGVpZ2h0LWwuZm9udFNpemUvMj50aGlzLmNoYXJ0LmJvdW5kcy55MiYmXHJcbihsLnk9dGhpcy5jaGFydC5ib3VuZHMueTItbC5tZWFzdXJlVGV4dCgpLmhlaWdodCtsLmZvbnRTaXplLzIpO1wibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uP2wueD10aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueDItbC5tZWFzdXJlVGV4dCgpLndpZHRoOlwicmlnaHRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbiYmKGwueD10aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueDIpfWg9bnVsbDsoXCJib3R0b21cIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbikmJihiPj10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHRoaXMucGFyZW50LnZpZXdwb3J0TWluaW11bSkmJmM8PXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwodGhpcy5wYXJlbnQudmlld3BvcnRNYXhpbXVtKSkmJigwPGsmJihyLm1vdmVUbyhiLGUpLHIubGluZVRvKGMsZyksci5zdHJva2UoKSksci5yZXN0b3JlKCksIXkobC50ZXh0KSYmKFwibnVtYmVyXCI9PT1cclxudHlwZW9mIGwudGV4dC52YWx1ZU9mKCl8fDA8bC50ZXh0Lmxlbmd0aCkmJmwucmVuZGVyKCEwKSk7KFwibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pJiYoZz49dGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh0aGlzLnBhcmVudC52aWV3cG9ydE1heGltdW0pJiZlPD10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHRoaXMucGFyZW50LnZpZXdwb3J0TWluaW11bSkpJiYoMDxrJiYoci5tb3ZlVG8oYixlKSxyLmxpbmVUbyhjLGcpLHIuc3Ryb2tlKCkpLHIucmVzdG9yZSgpLCF5KGwudGV4dCkmJihcIm51bWJlclwiPT09dHlwZW9mIGwudGV4dC52YWx1ZU9mKCl8fDA8bC50ZXh0Lmxlbmd0aCkmJmwucmVuZGVyKCEwKSl9ZWxzZXtpZihcImJvdHRvbVwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKWI9Yz1oPTE9PT1yLmxpbmVXaWR0aCUyPyhhPDwwKSswLjU6XHJcbmE8PDAsZT10aGlzLmNoYXJ0LnBsb3RBcmVhLnkxLGc9dGhpcy5jaGFydC5wbG90QXJlYS55Mix0aGlzLmJvdW5kcz17eDE6Yi1rLzIseTE6ZSx4MjpjK2svMix5MjpnfTtlbHNlIGlmKFwibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pZT1nPWg9MT09PXIubGluZVdpZHRoJTI/KGY8PDApKzAuNTpmPDwwLGI9dGhpcy5jaGFydC5wbG90QXJlYS54MSxjPXRoaXMuY2hhcnQucGxvdEFyZWEueDIsdGhpcy5ib3VuZHM9e3gxOmIseTE6ZS1rLzIseDI6Yyx5MjpnK2svMn07aWYoXCJ4eVN3YXBwZWRcIj09PXRoaXMuY2hhcnQucGxvdEluZm8uYXhpc1BsYWNlbWVudClpZihcImxlZnRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKXt1PSExO2lmKHRoaXMucGFyZW50LmxhYmVscylmb3IoaD1NYXRoLmNlaWwodGhpcy5wYXJlbnQuaW50ZXJ2YWwpLG49MDtuPHRoaXMucGFyZW50LnZpZXdwb3J0TWF4aW11bTtuKz1cclxuaClpZih0aGlzLnBhcmVudC5sYWJlbHNbbl0pdT0hMDtlbHNle3U9ITE7YnJlYWt9aWYodSl7aWYoXCJheGlzWFwiPT09dGhpcy5wYXJlbnQudHlwZSlmb3Iobj10aGlzLnBhcmVudC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKHt5OmZ9KSxkPW51bGwscT0wO3E8dGhpcy5wYXJlbnQuZGF0YVNlcmllcy5sZW5ndGg7cSsrKShkPXRoaXMucGFyZW50LmRhdGFTZXJpZXNbcV0uZ2V0RGF0YVBvaW50QXRYKG4sITApKSYmMDw9ZC5pbmRleCYmKGwudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShhKX0pOnkodGhpcy5vcHRpb25zLmxhYmVsKT9kLmRhdGFQb2ludC5sYWJlbDp0aGlzLmxhYmVsKX1lbHNlXCJkYXRlVGltZVwiPT09dGhpcy5wYXJlbnQudmFsdWVUeXBlP2wudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP1xyXG50aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOnRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoZil9KTp5KHRoaXMub3B0aW9ucy5sYWJlbCk/QmEodGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShmKSx0aGlzLnZhbHVlRm9ybWF0U3RyaW5nLHRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsOlwibnVtYmVyXCI9PT10aGlzLnBhcmVudC52YWx1ZVR5cGUmJihsLnRleHQ9dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOnRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoZil9KTp5KHRoaXMub3B0aW9ucy5sYWJlbCk/Vyh0aGlzLnBhcmVudC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKGYpLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsXHJcbnRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsKTtsLnk9ZitsLmZvbnRTaXplLzItbC5tZWFzdXJlVGV4dCgpLmhlaWdodC8yKzI7bC55LWwuZm9udFNpemUvMjx0aGlzLmNoYXJ0LmJvdW5kcy55MT9sLnk9dGhpcy5jaGFydC5ib3VuZHMueTErbC5mb250U2l6ZS8yKzI6bC55K2wubWVhc3VyZVRleHQoKS5oZWlnaHQtbC5mb250U2l6ZS8yPnRoaXMuY2hhcnQuYm91bmRzLnkyJiYobC55PXRoaXMuY2hhcnQuYm91bmRzLnkyLWwubWVhc3VyZVRleHQoKS5oZWlnaHQrbC5mb250U2l6ZS8yKTtcImxlZnRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbj9sLng9dGhpcy5wYXJlbnQubGluZUNvb3JkaW5hdGVzLngxLWwubWVhc3VyZVRleHQoKS53aWR0aDpcInJpZ2h0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24mJihsLng9dGhpcy5wYXJlbnQubGluZUNvb3JkaW5hdGVzLngyKX1lbHNle2lmKFwiYm90dG9tXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb258fFwidG9wXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pbC50ZXh0PVxyXG50aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShhKX0pOnkodGhpcy5vcHRpb25zLmxhYmVsKT9XKHRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoYSksdGhpcy52YWx1ZUZvcm1hdFN0cmluZyx0aGlzLmNoYXJ0Ll9jdWx0dXJlSW5mbyk6dGhpcy5sYWJlbCxsLng9Yi1sLm1lYXN1cmVUZXh0KCkud2lkdGgvMixsLngrbC53aWR0aD50aGlzLmNoYXJ0LmJvdW5kcy54MiYmKGwueD10aGlzLmNoYXJ0LmJvdW5kcy54Mi1sLndpZHRoKSxsLng8dGhpcy5jaGFydC5ib3VuZHMueDEmJihsLng9dGhpcy5jaGFydC5ib3VuZHMueDEpLFwiYm90dG9tXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24mJihsLnk9dGhpcy5wYXJlbnQubGluZUNvb3JkaW5hdGVzLnkyK2wuZm9udFNpemUvMitcclxuMiksXCJ0b3BcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbiYmKGwueT10aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueTEtbC5oZWlnaHQrbC5mb250U2l6ZS8yKzIpfWVsc2UgaWYoXCJib3R0b21cIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbil7dT0hMTttPVwiXCI7aWYodGhpcy5wYXJlbnQubGFiZWxzKWZvcihoPU1hdGguY2VpbCh0aGlzLnBhcmVudC5pbnRlcnZhbCksbj0wO248dGhpcy5wYXJlbnQudmlld3BvcnRNYXhpbXVtO24rPWgpaWYodGhpcy5wYXJlbnQubGFiZWxzW25dKXU9ITA7ZWxzZXt1PSExO2JyZWFrfWlmKHUpe2lmKFwiYXhpc1hcIj09PXRoaXMucGFyZW50LnR5cGUpZm9yKG49dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZSh7eDphfSksZD1udWxsLHE9MDtxPHRoaXMucGFyZW50LmRhdGFTZXJpZXMubGVuZ3RoO3ErKykoZD10aGlzLnBhcmVudC5kYXRhU2VyaWVzW3FdLmdldERhdGFQb2ludEF0WChuLCEwKSkmJlxyXG4wPD1kLmluZGV4JiYobC50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTp0aGlzLnBhcmVudC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKGEpfSk6eSh0aGlzLm9wdGlvbnMubGFiZWwpP2QuZGF0YVBvaW50LmxhYmVsOnRoaXMubGFiZWwpfWVsc2VcImRhdGVUaW1lXCI9PT10aGlzLnBhcmVudC52YWx1ZVR5cGU/bC50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTp0aGlzLnBhcmVudC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKGEpfSk6eSh0aGlzLm9wdGlvbnMubGFiZWwpP0JhKHRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoYSksdGhpcy52YWx1ZUZvcm1hdFN0cmluZyx0aGlzLmNoYXJ0Ll9jdWx0dXJlSW5mbyk6XHJcbnRoaXMubGFiZWw6XCJudW1iZXJcIj09PXRoaXMucGFyZW50LnZhbHVlVHlwZSYmKGwudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6MDx0aGlzLnBhcmVudC5kYXRhU2VyaWVzLmxlbmd0aD90aGlzLnBhcmVudC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKGEpOlwiXCJ9KTp5KHRoaXMub3B0aW9ucy5sYWJlbCk/Vyh0aGlzLnBhcmVudC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKGEpLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWwpO2wueD1iLWwubWVhc3VyZVRleHQoKS53aWR0aC8yO2wueCtsLndpZHRoPnRoaXMuY2hhcnQuYm91bmRzLngyJiYobC54PXRoaXMuY2hhcnQuYm91bmRzLngyLWwud2lkdGgpO2wueDx0aGlzLmNoYXJ0LmJvdW5kcy54MSYmKGwueD10aGlzLmNoYXJ0LmJvdW5kcy54MSk7XHJcblwiYm90dG9tXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24/bC55PXRoaXMucGFyZW50LmxpbmVDb29yZGluYXRlcy55MitsLmZvbnRTaXplLzIrMjpcInRvcFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uJiYobC55PXRoaXMucGFyZW50LmxpbmVDb29yZGluYXRlcy55MS1sLmhlaWdodCtsLmZvbnRTaXplLzIrMil9ZWxzZSBpZihcImxlZnRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKWwudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShmKX0pOnkodGhpcy5vcHRpb25zLmxhYmVsKT9XKHRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoZiksdGhpcy52YWx1ZUZvcm1hdFN0cmluZyx0aGlzLmNoYXJ0Ll9jdWx0dXJlSW5mbyk6XHJcbnRoaXMubGFiZWwsbC55PWYrbC5mb250U2l6ZS8yLWwubWVhc3VyZVRleHQoKS5oZWlnaHQvMisyLGwueS1sLmZvbnRTaXplLzI8dGhpcy5jaGFydC5ib3VuZHMueTE/bC55PXRoaXMuY2hhcnQuYm91bmRzLnkxK2wuZm9udFNpemUvMisyOmwueStsLm1lYXN1cmVUZXh0KCkuaGVpZ2h0LWwuZm9udFNpemUvMj50aGlzLmNoYXJ0LmJvdW5kcy55MiYmKGwueT10aGlzLmNoYXJ0LmJvdW5kcy55Mi1sLm1lYXN1cmVUZXh0KCkuaGVpZ2h0K2wuZm9udFNpemUvMiksXCJsZWZ0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24/bC54PXRoaXMucGFyZW50LmxpbmVDb29yZGluYXRlcy54Mi1sLm1lYXN1cmVUZXh0KCkud2lkdGg6XCJyaWdodFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uJiYobC54PXRoaXMucGFyZW50LmxpbmVDb29yZGluYXRlcy54Mik7MDxrJiYoci5tb3ZlVG8oYixlKSxyLmxpbmVUbyhjLGcpLHIuc3Ryb2tlKCkpO3IucmVzdG9yZSgpOyF5KGwudGV4dCkmJihcIm51bWJlclwiPT09dHlwZW9mIGwudGV4dC52YWx1ZU9mKCl8fFxyXG4wPGwudGV4dC5sZW5ndGgpJiZsLnJlbmRlcighMCl9ci5nbG9iYWxBbHBoYT1wfTtwYShZLFgpO1kucHJvdG90eXBlLl9pbml0aWFsaXplPWZ1bmN0aW9uKCl7aWYodGhpcy5lbmFibGVkKXt0aGlzLmNvbnRhaW5lcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3RoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsXCJjYW52YXNqcy1jaGFydC10b29sdGlwXCIpO3RoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIjt0aGlzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQ9XCJhdXRvXCI7dGhpcy5jb250YWluZXIuc3R5bGUuYm94U2hhZG93PVwiMXB4IDFweCAycHggMnB4IHJnYmEoMCwwLDAsMC4xKVwiO3RoaXMuY29udGFpbmVyLnN0eWxlLnpJbmRleD1cIjEwMDBcIjt0aGlzLmNvbnRhaW5lci5zdHlsZS5wb2ludGVyRXZlbnRzPVwibm9uZVwiO3RoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7dmFyIGE7YT0nPGRpdiBzdHlsZT1cIiB3aWR0aDogYXV0bztoZWlnaHQ6IGF1dG87bWluLXdpZHRoOiA1MHB4Oyc7XHJcbmErPVwibGluZS1oZWlnaHQ6IGF1dG87XCI7YSs9XCJtYXJnaW46IDBweCAwcHggMHB4IDBweDtcIjthKz1cInBhZGRpbmc6IDVweDtcIjthKz1cImZvbnQtZmFtaWx5OiBDYWxpYnJpLCBBcmlhbCwgR2VvcmdpYSwgc2VyaWY7XCI7YSs9XCJmb250LXdlaWdodDogbm9ybWFsO1wiO2ErPVwiZm9udC1zdHlsZTogXCIrKHY/XCJpdGFsaWM7XCI6XCJub3JtYWw7XCIpO2ErPVwiZm9udC1zaXplOiAxNHB4O1wiO2ErPVwiY29sb3I6ICMwMDAwMDA7XCI7YSs9XCJ0ZXh0LXNoYWRvdzogMXB4IDFweCAxcHggcmdiYSgwLCAwLCAwLCAwLjEpO1wiO2ErPVwidGV4dC1hbGlnbjogbGVmdDtcIjthKz1cImJvcmRlcjogMnB4IHNvbGlkIGdyYXk7XCI7YSs9dj9cImJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsLjkpO1wiOlwiYmFja2dyb3VuZDogcmdiKDI1NSwyNTUsMjU1KTtcIjthKz1cInRleHQtaW5kZW50OiAwcHg7XCI7YSs9XCJ3aGl0ZS1zcGFjZTogbm93cmFwO1wiO2ErPVwiYm9yZGVyLXJhZGl1czogNXB4O1wiO2ErPVwiLW1vei11c2VyLXNlbGVjdDpub25lO1wiO1xyXG5hKz1cIi1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcIjthKz1cIi13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XCI7YSs9XCItbXMtdXNlci1zZWxlY3Q6IG5vbmU7XCI7YSs9XCJ1c2VyLXNlbGVjdDogbm9uZTtcIjt2fHwoYSs9XCJmaWx0ZXI6IGFscGhhKG9wYWNpdHkgPSA5MCk7XCIsYSs9XCJmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5TaGFkb3coU3RyZW5ndGg9MywgRGlyZWN0aW9uPTEzNSwgQ29sb3I9JyM2NjY2NjYnKTtcIik7YSs9J30gXCI+IFNhbXBsZSBUb29sdGlwPC9kaXY+Jzt0aGlzLmNvbnRhaW5lci5pbm5lckhUTUw9YTt0aGlzLmNvbnRlbnREaXY9dGhpcy5jb250YWluZXIuZmlyc3RDaGlsZDt0aGlzLmNvbnRhaW5lci5zdHlsZS5ib3JkZXJSYWRpdXM9dGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlclJhZGl1czt0aGlzLmNoYXJ0Ll9jYW52YXNKU0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcil9fTtZLnByb3RvdHlwZS5tb3VzZU1vdmVIYW5kbGVyPVxyXG5mdW5jdGlvbihhLGYpe3RoaXMuX2xhc3RVcGRhdGVkJiY0PihuZXcgRGF0ZSkuZ2V0VGltZSgpLXRoaXMuX2xhc3RVcGRhdGVkfHwodGhpcy5fbGFzdFVwZGF0ZWQ9KG5ldyBEYXRlKS5nZXRUaW1lKCksdGhpcy5jaGFydC5yZXNldE92ZXJsYXllZENhbnZhcygpLHRoaXMuX3VwZGF0ZVRvb2xUaXAoYSxmKSl9O1kucHJvdG90eXBlLl91cGRhdGVUb29sVGlwPWZ1bmN0aW9uKGEsZixiKXtiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYj8hMDpiO3RoaXMuY29udGFpbmVyfHx0aGlzLl9pbml0aWFsaXplKCk7dGhpcy5lbmFibGVkfHx0aGlzLmhpZGUoKTtpZighdGhpcy5jaGFydC5kaXNhYmxlVG9vbFRpcCl7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhfHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGYpe2lmKGlzTmFOKHRoaXMuX3ByZXZYKXx8aXNOYU4odGhpcy5fcHJldlkpKXJldHVybjthPXRoaXMuX3ByZXZYO2Y9dGhpcy5fcHJldll9ZWxzZSB0aGlzLl9wcmV2WD1hLHRoaXMuX3ByZXZZPWY7XHJcbnZhciBjPW51bGwsZT1udWxsLGc9W10saD0wO2lmKHRoaXMuc2hhcmVkJiZ0aGlzLmVuYWJsZWQmJlwibm9uZVwiIT09dGhpcy5jaGFydC5wbG90SW5mby5heGlzUGxhY2VtZW50KXtpZihcInh5U3dhcHBlZFwiPT09dGhpcy5jaGFydC5wbG90SW5mby5heGlzUGxhY2VtZW50KXt2YXIgbD1bXTtpZih0aGlzLmNoYXJ0LmF4aXNYKWZvcih2YXIgbT0wO208dGhpcy5jaGFydC5heGlzWC5sZW5ndGg7bSsrKXtmb3IodmFyIGg9dGhpcy5jaGFydC5heGlzWFttXS5jb252ZXJ0UGl4ZWxUb1ZhbHVlKHt5OmZ9KSxrPW51bGwsYz0wO2M8dGhpcy5jaGFydC5heGlzWFttXS5kYXRhU2VyaWVzLmxlbmd0aDtjKyspKGs9dGhpcy5jaGFydC5heGlzWFttXS5kYXRhU2VyaWVzW2NdLmdldERhdGFQb2ludEF0WChoLGIpKSYmMDw9ay5pbmRleCYmKGsuZGF0YVNlcmllcz10aGlzLmNoYXJ0LmF4aXNYW21dLmRhdGFTZXJpZXNbY10sbnVsbCE9PWsuZGF0YVBvaW50LnkmJmwucHVzaChrKSk7az1udWxsfWlmKHRoaXMuY2hhcnQuYXhpc1gyKWZvcihtPVxyXG4wO208dGhpcy5jaGFydC5heGlzWDIubGVuZ3RoO20rKyl7aD10aGlzLmNoYXJ0LmF4aXNYMlttXS5jb252ZXJ0UGl4ZWxUb1ZhbHVlKHt5OmZ9KTtrPW51bGw7Zm9yKGM9MDtjPHRoaXMuY2hhcnQuYXhpc1gyW21dLmRhdGFTZXJpZXMubGVuZ3RoO2MrKykoaz10aGlzLmNoYXJ0LmF4aXNYMlttXS5kYXRhU2VyaWVzW2NdLmdldERhdGFQb2ludEF0WChoLGIpKSYmMDw9ay5pbmRleCYmKGsuZGF0YVNlcmllcz10aGlzLmNoYXJ0LmF4aXNYMlttXS5kYXRhU2VyaWVzW2NdLG51bGwhPT1rLmRhdGFQb2ludC55JiZsLnB1c2goaykpO2s9bnVsbH19ZWxzZXtsPVtdO2lmKHRoaXMuY2hhcnQuYXhpc1gpZm9yKG09MDttPHRoaXMuY2hhcnQuYXhpc1gubGVuZ3RoO20rKylmb3IoaD10aGlzLmNoYXJ0LmF4aXNYW21dLmNvbnZlcnRQaXhlbFRvVmFsdWUoe3g6YX0pLGs9bnVsbCxjPTA7Yzx0aGlzLmNoYXJ0LmF4aXNYW21dLmRhdGFTZXJpZXMubGVuZ3RoO2MrKykoaz10aGlzLmNoYXJ0LmF4aXNYW21dLmRhdGFTZXJpZXNbY10uZ2V0RGF0YVBvaW50QXRYKGgsXHJcbmIpKSYmMDw9ay5pbmRleCYmKGsuZGF0YVNlcmllcz10aGlzLmNoYXJ0LmF4aXNYW21dLmRhdGFTZXJpZXNbY10sbnVsbCE9PWsuZGF0YVBvaW50LnkmJmwucHVzaChrKSk7aWYodGhpcy5jaGFydC5heGlzWDIpZm9yKG09MDttPHRoaXMuY2hhcnQuYXhpc1gyLmxlbmd0aDttKyspZm9yKGg9dGhpcy5jaGFydC5heGlzWDJbbV0uY29udmVydFBpeGVsVG9WYWx1ZSh7eDphfSksaz1udWxsLGM9MDtjPHRoaXMuY2hhcnQuYXhpc1gyW21dLmRhdGFTZXJpZXMubGVuZ3RoO2MrKykoaz10aGlzLmNoYXJ0LmF4aXNYMlttXS5kYXRhU2VyaWVzW2NdLmdldERhdGFQb2ludEF0WChoLGIpKSYmMDw9ay5pbmRleCYmKGsuZGF0YVNlcmllcz10aGlzLmNoYXJ0LmF4aXNYMlttXS5kYXRhU2VyaWVzW2NdLG51bGwhPT1rLmRhdGFQb2ludC55JiZsLnB1c2goaykpfWlmKDA9PT1sLmxlbmd0aClyZXR1cm47bC5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZGlzdGFuY2UtYi5kaXN0YW5jZX0pO2I9bFswXTtcclxuZm9yKGM9MDtjPGwubGVuZ3RoO2MrKylsW2NdLmRhdGFQb2ludC54LnZhbHVlT2YoKT09PWIuZGF0YVBvaW50LngudmFsdWVPZigpJiZnLnB1c2gobFtjXSk7bD1udWxsfWVsc2V7aWYoaz10aGlzLmNoYXJ0LmdldERhdGFQb2ludEF0WFkoYSxmLGIpKXRoaXMuY3VycmVudERhdGFQb2ludEluZGV4PWsuZGF0YVBvaW50SW5kZXgsdGhpcy5jdXJyZW50U2VyaWVzSW5kZXg9ay5kYXRhU2VyaWVzLmluZGV4O2Vsc2UgaWYodilpZihrPVdhKGEsZix0aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIuZ2hvc3RDdHgpLDA8ayYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB0aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2tdKXtrPXRoaXMuY2hhcnQuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBba107aWYoXCJsZWdlbmRJdGVtXCI9PT1rLm9iamVjdFR5cGUpcmV0dXJuO3RoaXMuY3VycmVudFNlcmllc0luZGV4PWsuZGF0YVNlcmllc0luZGV4O3RoaXMuY3VycmVudERhdGFQb2ludEluZGV4PTA8PVxyXG5rLmRhdGFQb2ludEluZGV4P2suZGF0YVBvaW50SW5kZXg6LTF9ZWxzZSB0aGlzLmN1cnJlbnREYXRhUG9pbnRJbmRleD0tMTtlbHNlIHRoaXMuY3VycmVudERhdGFQb2ludEluZGV4PS0xO2lmKDA8PXRoaXMuY3VycmVudFNlcmllc0luZGV4KXtlPXRoaXMuY2hhcnQuZGF0YVt0aGlzLmN1cnJlbnRTZXJpZXNJbmRleF07az17fTtpZigwPD10aGlzLmN1cnJlbnREYXRhUG9pbnRJbmRleCljPWUuZGF0YVBvaW50c1t0aGlzLmN1cnJlbnREYXRhUG9pbnRJbmRleF0say5kYXRhU2VyaWVzPWUsay5kYXRhUG9pbnQ9YyxrLmluZGV4PXRoaXMuY3VycmVudERhdGFQb2ludEluZGV4LGsuZGlzdGFuY2U9TWF0aC5hYnMoYy54LWgpLFwid2F0ZXJmYWxsXCI9PT1lLnR5cGUmJihrLmN1bXVsYXRpdmVTdW1ZU3RhcnRWYWx1ZT1lLmRhdGFQb2ludEVPc1t0aGlzLmN1cnJlbnREYXRhUG9pbnRJbmRleF0uY3VtdWxhdGl2ZVN1bVlTdGFydFZhbHVlLGsuY3VtdWxhdGl2ZVN1bT1lLmRhdGFQb2ludEVPc1t0aGlzLmN1cnJlbnREYXRhUG9pbnRJbmRleF0uY3VtdWxhdGl2ZVN1bSk7XHJcbmVsc2V7aWYoIXRoaXMuZW5hYmxlZHx8XCJsaW5lXCIhPT1lLnR5cGUmJlwic3RlcExpbmVcIiE9PWUudHlwZSYmXCJzcGxpbmVcIiE9PWUudHlwZSYmXCJhcmVhXCIhPT1lLnR5cGUmJlwic3RlcEFyZWFcIiE9PWUudHlwZSYmXCJzcGxpbmVBcmVhXCIhPT1lLnR5cGUmJlwic3RhY2tlZEFyZWFcIiE9PWUudHlwZSYmXCJzdGFja2VkQXJlYTEwMFwiIT09ZS50eXBlJiZcInJhbmdlQXJlYVwiIT09ZS50eXBlJiZcInJhbmdlU3BsaW5lQXJlYVwiIT09ZS50eXBlJiZcImNhbmRsZXN0aWNrXCIhPT1lLnR5cGUmJlwib2hsY1wiIT09ZS50eXBlJiZcImJveEFuZFdoaXNrZXJcIiE9PWUudHlwZSlyZXR1cm47aD1lLmF4aXNYLmNvbnZlcnRQaXhlbFRvVmFsdWUoe3g6YX0pO2s9ZS5nZXREYXRhUG9pbnRBdFgoaCxiKTtrLmRhdGFTZXJpZXM9ZTt0aGlzLmN1cnJlbnREYXRhUG9pbnRJbmRleD1rLmluZGV4O2M9ay5kYXRhUG9pbnR9aWYoIXkoay5kYXRhUG9pbnQueSkpaWYoay5kYXRhU2VyaWVzLmF4aXNZKWlmKDA8ay5kYXRhUG9pbnQueS5sZW5ndGgpe2ZvcihjPVxyXG5iPTA7YzxrLmRhdGFQb2ludC55Lmxlbmd0aDtjKyspay5kYXRhUG9pbnQueVtjXTxrLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNaW5pbXVtP2ItLTprLmRhdGFQb2ludC55W2NdPmsuZGF0YVNlcmllcy5heGlzWS52aWV3cG9ydE1heGltdW0mJmIrKztiPGsuZGF0YVBvaW50LnkubGVuZ3RoJiZiPi1rLmRhdGFQb2ludC55Lmxlbmd0aCYmZy5wdXNoKGspfWVsc2VcImNvbHVtblwiPT09ZS50eXBlfHxcImJhclwiPT09ZS50eXBlPzA+ay5kYXRhUG9pbnQueT8wPmsuZGF0YVNlcmllcy5heGlzWS52aWV3cG9ydE1pbmltdW0mJmsuZGF0YVNlcmllcy5heGlzWS52aWV3cG9ydE1heGltdW0+PWsuZGF0YVBvaW50LnkmJmcucHVzaChrKTprLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNaW5pbXVtPD1rLmRhdGFQb2ludC55JiYwPD1rLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNYXhpbXVtJiZnLnB1c2goayk6XCJidWJibGVcIj09PWUudHlwZT8oYj10aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2UuZGF0YVBvaW50SWRzW2suaW5kZXhdXS5zaXplL1xyXG4yLGsuZGF0YVBvaW50Lnk+PWsuZGF0YVNlcmllcy5heGlzWS52aWV3cG9ydE1pbmltdW0tYiYmay5kYXRhUG9pbnQueTw9ay5kYXRhU2VyaWVzLmF4aXNZLnZpZXdwb3J0TWF4aW11bStiJiZnLnB1c2goaykpOlwid2F0ZXJmYWxsXCI9PT1lLnR5cGU/KGI9MCxrLmN1bXVsYXRpdmVTdW1ZU3RhcnRWYWx1ZTxrLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNaW5pbXVtP2ItLTprLmN1bXVsYXRpdmVTdW1ZU3RhcnRWYWx1ZT5rLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNYXhpbXVtJiZiKyssay5jdW11bGF0aXZlU3VtPGsuZGF0YVNlcmllcy5heGlzWS52aWV3cG9ydE1pbmltdW0/Yi0tOmsuY3VtdWxhdGl2ZVN1bT5rLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNYXhpbXVtJiZiKyssMj5iJiYtMjxiJiZnLnB1c2goaykpOigwPD1rLmRhdGFTZXJpZXMudHlwZS5pbmRleE9mKFwiMTAwXCIpfHxcInN0YWNrZWRDb2x1bW5cIj09PWUudHlwZXx8XCJzdGFja2VkQmFyXCI9PT1lLnR5cGV8fGsuZGF0YVBvaW50Lnk+PVxyXG5rLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNaW5pbXVtJiZrLmRhdGFQb2ludC55PD1rLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNYXhpbXVtKSYmZy5wdXNoKGspO2Vsc2UgZy5wdXNoKGspfX1pZigwPGcubGVuZ3RoJiYodGhpcy5oaWdobGlnaHRPYmplY3RzKGcpLHRoaXMuZW5hYmxlZCkpaWYoYj1cIlwiLGI9dGhpcy5nZXRUb29sVGlwSW5uZXJIVE1MKHtlbnRyaWVzOmd9KSxudWxsIT09Yil7dGhpcy5jb250ZW50RGl2LmlubmVySFRNTD1iO2I9ITE7XCJub25lXCI9PT10aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5JiYoYj0hMCx0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIik7dHJ5e3RoaXMuY29udGVudERpdi5zdHlsZS5iYWNrZ3JvdW5kPXRoaXMuYmFja2dyb3VuZENvbG9yP3RoaXMuYmFja2dyb3VuZENvbG9yOnY/XCJyZ2JhKDI1NSwyNTUsMjU1LC45KVwiOlwicmdiKDI1NSwyNTUsMjU1KVwiLHRoaXMuYm9yZGVyQ29sb3I9XCJ3YXRlcmZhbGxcIj09PWdbMF0uZGF0YVNlcmllcy50eXBlP1xyXG50aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyUmlnaHRDb2xvcj10aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyTGVmdENvbG9yPXRoaXMuY29udGVudERpdi5zdHlsZS5ib3JkZXJDb2xvcj10aGlzLm9wdGlvbnMuYm9yZGVyQ29sb3I/dGhpcy5vcHRpb25zLmJvcmRlckNvbG9yOmdbMF0uZGF0YVBvaW50LmNvbG9yP2dbMF0uZGF0YVBvaW50LmNvbG9yOi0xPGdbMF0uZGF0YVBvaW50Lnk/Z1swXS5kYXRhU2VyaWVzLnJpc2luZ0NvbG9yOmdbMF0uZGF0YVNlcmllcy5mYWxsaW5nQ29sb3I6XCJlcnJvclwiPT09Z1swXS5kYXRhU2VyaWVzLnR5cGU/dGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlclJpZ2h0Q29sb3I9dGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlckxlZnRDb2xvcj10aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyQ29sb3I9dGhpcy5vcHRpb25zLmJvcmRlckNvbG9yP3RoaXMub3B0aW9ucy5ib3JkZXJDb2xvcjpnWzBdLmRhdGFTZXJpZXMuY29sb3I/Z1swXS5kYXRhU2VyaWVzLmNvbG9yOlxyXG5nWzBdLmRhdGFTZXJpZXMuX2NvbG9yU2V0W2UuaW5kZXglZ1swXS5kYXRhU2VyaWVzLl9jb2xvclNldC5sZW5ndGhdOnRoaXMuY29udGVudERpdi5zdHlsZS5ib3JkZXJSaWdodENvbG9yPXRoaXMuY29udGVudERpdi5zdHlsZS5ib3JkZXJMZWZ0Q29sb3I9dGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlckNvbG9yPXRoaXMub3B0aW9ucy5ib3JkZXJDb2xvcj90aGlzLm9wdGlvbnMuYm9yZGVyQ29sb3I6Z1swXS5kYXRhUG9pbnQuY29sb3I/Z1swXS5kYXRhUG9pbnQuY29sb3I6Z1swXS5kYXRhU2VyaWVzLmNvbG9yP2dbMF0uZGF0YVNlcmllcy5jb2xvcjpnWzBdLmRhdGFTZXJpZXMuX2NvbG9yU2V0W2dbMF0uaW5kZXglZ1swXS5kYXRhU2VyaWVzLl9jb2xvclNldC5sZW5ndGhdLHRoaXMuY29udGVudERpdi5zdHlsZS5ib3JkZXJXaWR0aD10aGlzLmJvcmRlclRoaWNrbmVzc3x8MD09PXRoaXMuYm9yZGVyVGhpY2tuZXNzP3RoaXMuYm9yZGVyVGhpY2tuZXNzK1wicHhcIjpcIjJweFwiLHRoaXMuY29udGVudERpdi5zdHlsZS5ib3JkZXJSYWRpdXM9XHJcbnRoaXMuY29ybmVyUmFkaXVzfHwwPT09dGhpcy5jb3JuZXJSYWRpdXM/dGhpcy5jb3JuZXJSYWRpdXMrXCJweFwiOlwiNXB4XCIsdGhpcy5jb250YWluZXIuc3R5bGUuYm9yZGVyUmFkaXVzPXRoaXMuY29udGVudERpdi5zdHlsZS5ib3JkZXJSYWRpdXMsdGhpcy5jb250ZW50RGl2LnN0eWxlLmZvbnRTaXplPXRoaXMuZm9udFNpemV8fDA9PT10aGlzLmZvbnRTaXplP3RoaXMuZm9udFNpemUrXCJweFwiOlwiMTRweFwiLHRoaXMuY29udGVudERpdi5zdHlsZS5jb2xvcj10aGlzLmZvbnRDb2xvcj90aGlzLmZvbnRDb2xvcjpcIiMwMDAwMDBcIix0aGlzLmNvbnRlbnREaXYuc3R5bGUuZm9udEZhbWlseT10aGlzLmZvbnRGYW1pbHk/dGhpcy5mb250RmFtaWx5OlwiQ2FsaWJyaSwgQXJpYWwsIEdlb3JnaWEsIHNlcmlmO1wiLHRoaXMuY29udGVudERpdi5zdHlsZS5mb250V2VpZ2h0PXRoaXMuZm9udFdlaWdodD90aGlzLmZvbnRXZWlnaHQ6XCJub3JtYWxcIix0aGlzLmNvbnRlbnREaXYuc3R5bGUuZm9udFN0eWxlPVxyXG50aGlzLmZvbnRTdHlsZT90aGlzLmZvbnRTdHlsZTp2P1wiaXRhbGljXCI6XCJub3JtYWxcIn1jYXRjaChxKXt9XCJwaWVcIj09PWdbMF0uZGF0YVNlcmllcy50eXBlfHxcImRvdWdobnV0XCI9PT1nWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJmdW5uZWxcIj09PWdbMF0uZGF0YVNlcmllcy50eXBlfHxcInB5cmFtaWRcIj09PWdbMF0uZGF0YVNlcmllcy50eXBlfHxcImJhclwiPT09Z1swXS5kYXRhU2VyaWVzLnR5cGV8fFwicmFuZ2VCYXJcIj09PWdbMF0uZGF0YVNlcmllcy50eXBlfHxcInN0YWNrZWRCYXJcIj09PWdbMF0uZGF0YVNlcmllcy50eXBlfHxcInN0YWNrZWRCYXIxMDBcIj09PWdbMF0uZGF0YVNlcmllcy50eXBlP2E9YS0xMC10aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDooYT1nWzBdLmRhdGFTZXJpZXMuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChnWzBdLmRhdGFQb2ludC54KS10aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDw8MCxhLT0xMCk7MD5hJiYoYSs9dGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgrXHJcbjIwKTthK3RoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoPk1hdGgubWF4KHRoaXMuY2hhcnQuY29udGFpbmVyLmNsaWVudFdpZHRoLHRoaXMuY2hhcnQud2lkdGgpJiYoYT1NYXRoLm1heCgwLE1hdGgubWF4KHRoaXMuY2hhcnQuY29udGFpbmVyLmNsaWVudFdpZHRoLHRoaXMuY2hhcnQud2lkdGgpLXRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoKSk7Zj0xIT09Zy5sZW5ndGh8fHRoaXMuc2hhcmVkfHxcImxpbmVcIiE9PWdbMF0uZGF0YVNlcmllcy50eXBlJiZcInN0ZXBMaW5lXCIhPT1nWzBdLmRhdGFTZXJpZXMudHlwZSYmXCJzcGxpbmVcIiE9PWdbMF0uZGF0YVNlcmllcy50eXBlJiZcImFyZWFcIiE9PWdbMF0uZGF0YVNlcmllcy50eXBlJiZcInN0ZXBBcmVhXCIhPT1nWzBdLmRhdGFTZXJpZXMudHlwZSYmXCJzcGxpbmVBcmVhXCIhPT1nWzBdLmRhdGFTZXJpZXMudHlwZT9cImJhclwiPT09Z1swXS5kYXRhU2VyaWVzLnR5cGV8fFwicmFuZ2VCYXJcIj09PWdbMF0uZGF0YVNlcmllcy50eXBlfHxcInN0YWNrZWRCYXJcIj09PVxyXG5nWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJzdGFja2VkQmFyMTAwXCI9PT1nWzBdLmRhdGFTZXJpZXMudHlwZT9nWzBdLmRhdGFTZXJpZXMuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChnWzBdLmRhdGFQb2ludC54KTpmOmdbMF0uZGF0YVNlcmllcy5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKGdbMF0uZGF0YVBvaW50LnkpO2Y9LWYrMTA7MDxmK3RoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCs1JiYoZi09Zit0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQrNS0wKTt0aGlzLmZpeE1velRyYW5zaXRpb25EZWxheShhLGYpOyF0aGlzLmFuaW1hdGlvbkVuYWJsZWR8fGI/dGhpcy5kaXNhYmxlQW5pbWF0aW9uKCk6KHRoaXMuZW5hYmxlQW5pbWF0aW9uKCksdGhpcy5jb250YWluZXIuc3R5bGUuTW96VHJhbnNpdGlvbj10aGlzLm1vekNvbnRhaW5lclRyYW5zaXRpb24pO3RoaXMuY29udGFpbmVyLnN0eWxlLmxlZnQ9YStcInB4XCI7dGhpcy5jb250YWluZXIuc3R5bGUuYm90dG9tPWYrXCJweFwifWVsc2UgdGhpcy5oaWRlKCExKX19O1xyXG5ZLnByb3RvdHlwZS5oaWdobGlnaHRPYmplY3RzPWZ1bmN0aW9uKGEpe3ZhciBmPXRoaXMuY2hhcnQub3ZlcmxhaWRDYW52YXNDdHg7dGhpcy5jaGFydC5yZXNldE92ZXJsYXllZENhbnZhcygpO2YuY2xlYXJSZWN0KDAsMCx0aGlzLmNoYXJ0LndpZHRoLHRoaXMuY2hhcnQuaGVpZ2h0KTtmLnNhdmUoKTt2YXIgYj10aGlzLmNoYXJ0LnBsb3RBcmVhLGM9MDtmLmJlZ2luUGF0aCgpO2YucmVjdChiLngxLGIueTEsYi54Mi1iLngxLGIueTItYi55MSk7Zi5jbGlwKCk7Zm9yKGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGU9YVtiXTtpZigoZT10aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2UuZGF0YVNlcmllcy5kYXRhUG9pbnRJZHNbZS5pbmRleF1dKSYmZS5vYmplY3RUeXBlJiZcImRhdGFQb2ludFwiPT09ZS5vYmplY3RUeXBlKXt2YXIgYz10aGlzLmNoYXJ0LmRhdGFbZS5kYXRhU2VyaWVzSW5kZXhdLGc9Yy5kYXRhUG9pbnRzW2UuZGF0YVBvaW50SW5kZXhdLGg9ZS5kYXRhUG9pbnRJbmRleDtcclxuITE9PT1nLmhpZ2hsaWdodEVuYWJsZWR8fCEwIT09Yy5oaWdobGlnaHRFbmFibGVkJiYhMCE9PWcuaGlnaGxpZ2h0RW5hYmxlZHx8KFwibGluZVwiPT09Yy50eXBlfHxcInN0ZXBMaW5lXCI9PT1jLnR5cGV8fFwic3BsaW5lXCI9PT1jLnR5cGV8fFwic2NhdHRlclwiPT09Yy50eXBlfHxcImFyZWFcIj09PWMudHlwZXx8XCJzdGVwQXJlYVwiPT09Yy50eXBlfHxcInNwbGluZUFyZWFcIj09PWMudHlwZXx8XCJzdGFja2VkQXJlYVwiPT09Yy50eXBlfHxcInN0YWNrZWRBcmVhMTAwXCI9PT1jLnR5cGV8fFwicmFuZ2VBcmVhXCI9PT1jLnR5cGV8fFwicmFuZ2VTcGxpbmVBcmVhXCI9PT1jLnR5cGU/KGc9Yy5nZXRNYXJrZXJQcm9wZXJ0aWVzKGgsZS54MSxlLnkxLHRoaXMuY2hhcnQub3ZlcmxhaWRDYW52YXNDdHgpLGcuc2l6ZT1NYXRoLm1heCgxLjUqZy5zaXplPDwwLDEwKSxnLmJvcmRlckNvbG9yPWcuYm9yZGVyQ29sb3J8fFwiI0ZGRkZGRlwiLGcuYm9yZGVyVGhpY2tuZXNzPWcuYm9yZGVyVGhpY2tuZXNzfHxNYXRoLmNlaWwoMC4xKlxyXG5nLnNpemUpLGphLmRyYXdNYXJrZXJzKFtnXSksXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBlLnkyJiYoZz1jLmdldE1hcmtlclByb3BlcnRpZXMoaCxlLngxLGUueTIsdGhpcy5jaGFydC5vdmVybGFpZENhbnZhc0N0eCksZy5zaXplPU1hdGgubWF4KDEuNSpnLnNpemU8PDAsMTApLGcuYm9yZGVyQ29sb3I9Zy5ib3JkZXJDb2xvcnx8XCIjRkZGRkZGXCIsZy5ib3JkZXJUaGlja25lc3M9Zy5ib3JkZXJUaGlja25lc3N8fE1hdGguY2VpbCgwLjEqZy5zaXplKSxqYS5kcmF3TWFya2VycyhbZ10pKSk6XCJidWJibGVcIj09PWMudHlwZT8oZz1jLmdldE1hcmtlclByb3BlcnRpZXMoaCxlLngxLGUueTEsdGhpcy5jaGFydC5vdmVybGFpZENhbnZhc0N0eCksZy5zaXplPWUuc2l6ZSxnLmNvbG9yPVwid2hpdGVcIixnLmJvcmRlckNvbG9yPVwid2hpdGVcIixmLmdsb2JhbEFscGhhPTAuMyxqYS5kcmF3TWFya2VycyhbZ10pLGYuZ2xvYmFsQWxwaGE9MSk6XCJjb2x1bW5cIj09PWMudHlwZXx8XCJzdGFja2VkQ29sdW1uXCI9PT1cclxuYy50eXBlfHxcInN0YWNrZWRDb2x1bW4xMDBcIj09PWMudHlwZXx8XCJiYXJcIj09PWMudHlwZXx8XCJyYW5nZUJhclwiPT09Yy50eXBlfHxcInN0YWNrZWRCYXJcIj09PWMudHlwZXx8XCJzdGFja2VkQmFyMTAwXCI9PT1jLnR5cGV8fFwicmFuZ2VDb2x1bW5cIj09PWMudHlwZXx8XCJ3YXRlcmZhbGxcIj09PWMudHlwZT9WKGYsZS54MSxlLnkxLGUueDIsZS55MixcIndoaXRlXCIsMCxudWxsLCExLCExLCExLCExLDAuMyk6XCJwaWVcIj09PWMudHlwZXx8XCJkb3VnaG51dFwiPT09Yy50eXBlP3JhKGYsZS5jZW50ZXIsZS5yYWRpdXMsXCJ3aGl0ZVwiLGMudHlwZSxlLnN0YXJ0QW5nbGUsZS5lbmRBbmdsZSwwLjMsZS5wZXJjZW50SW5uZXJSYWRpdXMpOlwiZnVubmVsXCI9PT1jLnR5cGV8fFwicHlyYW1pZFwiPT09Yy50eXBlP3NhKGYsZS5mdW5uZWxTZWN0aW9uLDAuMyxcIndoaXRlXCIpOlwiY2FuZGxlc3RpY2tcIj09PWMudHlwZT8oZi5nbG9iYWxBbHBoYT0xLGYuc3Ryb2tlU3R5bGU9ZS5jb2xvcixmLmxpbmVXaWR0aD0yKmUuYm9yZGVyVGhpY2tuZXNzLFxyXG5jPTA9PT1mLmxpbmVXaWR0aCUyPzA6MC41LGYuYmVnaW5QYXRoKCksZi5tb3ZlVG8oZS54My1jLE1hdGgubWluKGUueTIsZS55MykpLGYubGluZVRvKGUueDMtYyxNYXRoLm1pbihlLnkxLGUueTQpKSxmLnN0cm9rZSgpLGYuYmVnaW5QYXRoKCksZi5tb3ZlVG8oZS54My1jLE1hdGgubWF4KGUueTEsZS55NCkpLGYubGluZVRvKGUueDMtYyxNYXRoLm1heChlLnkyLGUueTMpKSxmLnN0cm9rZSgpLFYoZixlLngxLE1hdGgubWluKGUueTEsZS55NCksZS54MixNYXRoLm1heChlLnkxLGUueTQpLFwidHJhbnNwYXJlbnRcIiwyKmUuYm9yZGVyVGhpY2tuZXNzLGUuY29sb3IsITEsITEsITEsITEpLGYuZ2xvYmFsQWxwaGE9MSk6XCJvaGxjXCI9PT1jLnR5cGU/KGYuZ2xvYmFsQWxwaGE9MSxmLnN0cm9rZVN0eWxlPWUuY29sb3IsZi5saW5lV2lkdGg9MiplLmJvcmRlclRoaWNrbmVzcyxjPTA9PT1mLmxpbmVXaWR0aCUyPzA6MC41LGYuYmVnaW5QYXRoKCksZi5tb3ZlVG8oZS54My1jLGUueTIpLGYubGluZVRvKGUueDMtXHJcbmMsZS55MyksZi5zdHJva2UoKSxmLmJlZ2luUGF0aCgpLGYubW92ZVRvKGUueDMsZS55MSksZi5saW5lVG8oZS54MSxlLnkxKSxmLnN0cm9rZSgpLGYuYmVnaW5QYXRoKCksZi5tb3ZlVG8oZS54MyxlLnk0KSxmLmxpbmVUbyhlLngyLGUueTQpLGYuc3Ryb2tlKCksZi5nbG9iYWxBbHBoYT0xKTpcImJveEFuZFdoaXNrZXJcIj09PWMudHlwZT8oZi5zYXZlKCksZi5nbG9iYWxBbHBoYT0xLGYuc3Ryb2tlU3R5bGU9ZS5zdGVtQ29sb3IsZi5saW5lV2lkdGg9MiplLnN0ZW1UaGlja25lc3MsMDxlLnN0ZW1UaGlja25lc3MmJihmLmJlZ2luUGF0aCgpLGYubW92ZVRvKGUueDMsZS55MitlLmJvcmRlclRoaWNrbmVzcy8yKSxmLmxpbmVUbyhlLngzLGUueTErZS53aGlza2VyVGhpY2tuZXNzLzIpLGYuc3Ryb2tlKCksZi5iZWdpblBhdGgoKSxmLm1vdmVUbyhlLngzLGUueTQtZS53aGlza2VyVGhpY2tuZXNzLzIpLGYubGluZVRvKGUueDMsZS55My1lLmJvcmRlclRoaWNrbmVzcy8yKSxmLnN0cm9rZSgpKSxcclxuZi5iZWdpblBhdGgoKSxWKGYsZS54MS1lLmJvcmRlclRoaWNrbmVzcy8yLE1hdGgubWF4KGUueTIrZS5ib3JkZXJUaGlja25lc3MvMixlLnkzK2UuYm9yZGVyVGhpY2tuZXNzLzIpLGUueDIrZS5ib3JkZXJUaGlja25lc3MvMixNYXRoLm1pbihlLnkyLWUuYm9yZGVyVGhpY2tuZXNzLzIsZS55My1lLmJvcmRlclRoaWNrbmVzcy8yKSxcInRyYW5zcGFyZW50XCIsZS5ib3JkZXJUaGlja25lc3MsZS5jb2xvciwhMSwhMSwhMSwhMSksZi5nbG9iYWxBbHBoYT0xLGYuc3Ryb2tlU3R5bGU9ZS53aGlza2VyQ29sb3IsZi5saW5lV2lkdGg9MiplLndoaXNrZXJUaGlja25lc3MsMDxlLndoaXNrZXJUaGlja25lc3MmJihmLmJlZ2luUGF0aCgpLGYubW92ZVRvKE1hdGguZmxvb3IoZS54My1lLndoaXNrZXJMZW5ndGgvMiksZS55NCksZi5saW5lVG8oTWF0aC5jZWlsKGUueDMrZS53aGlza2VyTGVuZ3RoLzIpLGUueTQpLGYuc3Ryb2tlKCksZi5iZWdpblBhdGgoKSxmLm1vdmVUbyhNYXRoLmZsb29yKGUueDMtXHJcbmUud2hpc2tlckxlbmd0aC8yKSxlLnkxKSxmLmxpbmVUbyhNYXRoLmNlaWwoZS54MytlLndoaXNrZXJMZW5ndGgvMiksZS55MSksZi5zdHJva2UoKSksZi5nbG9iYWxBbHBoYT0xLGYuc3Ryb2tlU3R5bGU9ZS5saW5lQ29sb3IsZi5saW5lV2lkdGg9MiplLmxpbmVUaGlja25lc3MsMDxlLmxpbmVUaGlja25lc3MmJihmLmJlZ2luUGF0aCgpLGYubW92ZVRvKGUueDEsZS55NSksZi5saW5lVG8oZS54MixlLnk1KSxmLnN0cm9rZSgpKSxmLnJlc3RvcmUoKSxmLmdsb2JhbEFscGhhPTEpOlwiZXJyb3JcIj09PWMudHlwZSYmeihmLGUueDEsZS55MSxlLngyLGUueTIsXCJ3aGl0ZVwiLGUud2hpc2tlclByb3BlcnRpZXMsZS5zdGVtUHJvcGVydGllcyxlLmlzWFlTd2FwcGVkLDAuMykpfX1mLnJlc3RvcmUoKTtmLmdsb2JhbEFscGhhPTE7Zi5iZWdpblBhdGgoKX07WS5wcm90b3R5cGUuZ2V0VG9vbFRpcElubmVySFRNTD1mdW5jdGlvbihhKXthPWEuZW50cmllcztmb3IodmFyIGY9bnVsbCxiPW51bGwsXHJcbmM9bnVsbCxlPTAsZz1cIlwiLGg9ITAsbD0wO2w8YS5sZW5ndGg7bCsrKWlmKGFbbF0uZGF0YVNlcmllcy50b29sVGlwQ29udGVudHx8YVtsXS5kYXRhUG9pbnQudG9vbFRpcENvbnRlbnQpe2g9ITE7YnJlYWt9aWYoaCYmKHRoaXMuY29udGVudCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIHRoaXMuY29udGVudHx8dGhpcy5jb250ZW50Rm9ybWF0dGVyKSlhPXtjaGFydDp0aGlzLmNoYXJ0LHRvb2xUaXA6dGhpcy5vcHRpb25zLGVudHJpZXM6YX0sZj10aGlzLmNvbnRlbnRGb3JtYXR0ZXI/dGhpcy5jb250ZW50Rm9ybWF0dGVyKGEpOnRoaXMuY29udGVudChhKTtlbHNlIGlmKHRoaXMuc2hhcmVkJiZcIm5vbmVcIiE9PXRoaXMuY2hhcnQucGxvdEluZm8uYXhpc1BsYWNlbWVudCl7Zm9yKHZhciBtPW51bGwsaz1cIlwiLGw9MDtsPGEubGVuZ3RoO2wrKyliPWFbbF0uZGF0YVNlcmllcyxjPWFbbF0uZGF0YVBvaW50LGU9YVtsXS5pbmRleCxnPVwiXCIsMD09PWwmJihoJiYhdGhpcy5jb250ZW50KSYmKHRoaXMuY2hhcnQuYXhpc1gmJlxyXG4wPHRoaXMuY2hhcnQuYXhpc1gubGVuZ3RoP2srPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgdGhpcy5jaGFydC5heGlzWFswXS5sYWJlbHNbYy54XT90aGlzLmNoYXJ0LmF4aXNYWzBdLmxhYmVsc1tjLnhdOlwie3h9XCI6dGhpcy5jaGFydC5heGlzWDImJjA8dGhpcy5jaGFydC5heGlzWDIubGVuZ3RoJiYoays9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB0aGlzLmNoYXJ0LmF4aXNYMlswXS5sYWJlbHNbYy54XT90aGlzLmNoYXJ0LmF4aXNYMlswXS5sYWJlbHNbYy54XTpcInt4fVwiKSxrKz1cIjwvYnI+XCIsaz10aGlzLmNoYXJ0LnJlcGxhY2VLZXl3b3Jkc1dpdGhWYWx1ZShrLGMsYixlKSksbnVsbD09PWMudG9vbFRpcENvbnRlbnR8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYy50b29sVGlwQ29udGVudCYmbnVsbD09PWIub3B0aW9ucy50b29sVGlwQ29udGVudHx8KFwibGluZVwiPT09Yi50eXBlfHxcInN0ZXBMaW5lXCI9PT1iLnR5cGV8fFwic3BsaW5lXCI9PT1iLnR5cGV8fFwiYXJlYVwiPT09Yi50eXBlfHxcInN0ZXBBcmVhXCI9PT1cclxuYi50eXBlfHxcInNwbGluZUFyZWFcIj09PWIudHlwZXx8XCJjb2x1bW5cIj09PWIudHlwZXx8XCJiYXJcIj09PWIudHlwZXx8XCJzY2F0dGVyXCI9PT1iLnR5cGV8fFwic3RhY2tlZENvbHVtblwiPT09Yi50eXBlfHxcInN0YWNrZWRDb2x1bW4xMDBcIj09PWIudHlwZXx8XCJzdGFja2VkQmFyXCI9PT1iLnR5cGV8fFwic3RhY2tlZEJhcjEwMFwiPT09Yi50eXBlfHxcInN0YWNrZWRBcmVhXCI9PT1iLnR5cGV8fFwic3RhY2tlZEFyZWExMDBcIj09PWIudHlwZXx8XCJ3YXRlcmZhbGxcIj09PWIudHlwZT8odGhpcy5jaGFydC5heGlzWCYmMTx0aGlzLmNoYXJ0LmF4aXNYLmxlbmd0aCYmKGcrPW0hPWIuYXhpc1hJbmRleD9iLmF4aXNYLnRpdGxlP2IuYXhpc1gudGl0bGUrXCI8YnIvPlwiOlwiWDp7YXhpc1hJbmRleH08YnIvPlwiOlwiXCIpLGcrPWMudG9vbFRpcENvbnRlbnQ/Yy50b29sVGlwQ29udGVudDpiLnRvb2xUaXBDb250ZW50P2IudG9vbFRpcENvbnRlbnQ6dGhpcy5jb250ZW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgdGhpcy5jb250ZW50P1xyXG50aGlzLmNvbnRlbnQ6XCI8c3BhbiBzdHlsZT0nXFxcIlwiKyh0aGlzLm9wdGlvbnMuZm9udENvbG9yP1wiXCI6XCInY29sb3I6e2NvbG9yfTsnXCIpK1wiXFxcIic+e25hbWV9Ojwvc3Bhbj4mbmJzcDsmbmJzcDt7eX1cIixtPWIuYXhpc1hJbmRleCk6XCJidWJibGVcIj09PWIudHlwZT8odGhpcy5jaGFydC5heGlzWCYmMTx0aGlzLmNoYXJ0LmF4aXNYLmxlbmd0aCYmKGcrPW0hPWIuYXhpc1hJbmRleD9iLmF4aXNYLnRpdGxlP2IuYXhpc1gudGl0bGUrXCI8YnIvPlwiOlwiWDp7YXhpc1hJbmRleH08YnIvPlwiOlwiXCIpLGcrPWMudG9vbFRpcENvbnRlbnQ/Yy50b29sVGlwQ29udGVudDpiLnRvb2xUaXBDb250ZW50P2IudG9vbFRpcENvbnRlbnQ6dGhpcy5jb250ZW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgdGhpcy5jb250ZW50P3RoaXMuY29udGVudDpcIjxzcGFuIHN0eWxlPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIidjb2xvcjp7Y29sb3J9OydcIikrXCJcXFwiJz57bmFtZX06PC9zcGFuPiZuYnNwOyZuYnNwO3t5fSwgJm5ic3A7Jm5ic3A7e3p9XCIpOlxyXG5cInJhbmdlQ29sdW1uXCI9PT1iLnR5cGV8fFwicmFuZ2VCYXJcIj09PWIudHlwZXx8XCJyYW5nZUFyZWFcIj09PWIudHlwZXx8XCJyYW5nZVNwbGluZUFyZWFcIj09PWIudHlwZXx8XCJlcnJvclwiPT09Yi50eXBlPyh0aGlzLmNoYXJ0LmF4aXNYJiYxPHRoaXMuY2hhcnQuYXhpc1gubGVuZ3RoJiYoZys9bSE9Yi5heGlzWEluZGV4P2IuYXhpc1gudGl0bGU/Yi5heGlzWC50aXRsZStcIjxici8+XCI6XCJYOntheGlzWEluZGV4fTxici8+XCI6XCJcIiksZys9Yy50b29sVGlwQ29udGVudD9jLnRvb2xUaXBDb250ZW50OmIudG9vbFRpcENvbnRlbnQ/Yi50b29sVGlwQ29udGVudDp0aGlzLmNvbnRlbnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiB0aGlzLmNvbnRlbnQ/dGhpcy5jb250ZW50OlwiPHNwYW4gc3R5bGU9J1xcXCJcIisodGhpcy5vcHRpb25zLmZvbnRDb2xvcj9cIlwiOlwiJ2NvbG9yOntjb2xvcn07J1wiKStcIlxcXCInPntuYW1lfTo8L3NwYW4+Jm5ic3A7Jm5ic3A7e3lbMF19LCZuYnNwO3t5WzFdfVwiKTpcImNhbmRsZXN0aWNrXCI9PT1cclxuYi50eXBlfHxcIm9obGNcIj09PWIudHlwZT8odGhpcy5jaGFydC5heGlzWCYmMTx0aGlzLmNoYXJ0LmF4aXNYLmxlbmd0aCYmKGcrPW0hPWIuYXhpc1hJbmRleD9iLmF4aXNYLnRpdGxlP2IuYXhpc1gudGl0bGUrXCI8YnIvPlwiOlwiWDp7YXhpc1hJbmRleH08YnIvPlwiOlwiXCIpLGcrPWMudG9vbFRpcENvbnRlbnQ/Yy50b29sVGlwQ29udGVudDpiLnRvb2xUaXBDb250ZW50P2IudG9vbFRpcENvbnRlbnQ6dGhpcy5jb250ZW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgdGhpcy5jb250ZW50P3RoaXMuY29udGVudDpcIjxzcGFuIHN0eWxlPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIidjb2xvcjp7Y29sb3J9OydcIikrXCJcXFwiJz57bmFtZX06PC9zcGFuPjxici8+T3BlbjogJm5ic3A7Jm5ic3A7e3lbMF19PGJyLz5IaWdoOiAmbmJzcDsmbmJzcDsmbmJzcDt7eVsxXX08YnIvPkxvdzombmJzcDsmbmJzcDsmbmJzcDt7eVsyXX08YnIvPkNsb3NlOiAmbmJzcDsmbmJzcDt7eVszXX1cIik6XCJib3hBbmRXaGlza2VyXCI9PT1cclxuYi50eXBlJiYodGhpcy5jaGFydC5heGlzWCYmMTx0aGlzLmNoYXJ0LmF4aXNYLmxlbmd0aCYmKGcrPW0hPWIuYXhpc1hJbmRleD9iLmF4aXNYLnRpdGxlP2IuYXhpc1gudGl0bGUrXCI8YnIvPlwiOlwiWDp7YXhpc1hJbmRleH08YnIvPlwiOlwiXCIpLGcrPWMudG9vbFRpcENvbnRlbnQ/Yy50b29sVGlwQ29udGVudDpiLnRvb2xUaXBDb250ZW50P2IudG9vbFRpcENvbnRlbnQ6dGhpcy5jb250ZW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgdGhpcy5jb250ZW50P3RoaXMuY29udGVudDpcIjxzcGFuIHN0eWxlPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIidjb2xvcjp7Y29sb3J9OydcIikrXCJcXFwiJz57bmFtZX06PC9zcGFuPjxici8+TWluaW11bTogJm5ic3A7Jm5ic3A7e3lbMF19PGJyLz5RMTogJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7e3lbMV19PGJyLz5RMjogJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7e3lbNF19PGJyLz5RMzogJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7e3lbMl19PGJyLz5NYXhpbXVtOiAmbmJzcDt7eVszXX1cIiksXHJcbm51bGw9PT1mJiYoZj1cIlwiKSwhMD09PXRoaXMucmV2ZXJzZWQ/KGY9dGhpcy5jaGFydC5yZXBsYWNlS2V5d29yZHNXaXRoVmFsdWUoZyxjLGIsZSkrZixsPGEubGVuZ3RoLTEmJihmPVwiPC9icj5cIitmKSk6KGYrPXRoaXMuY2hhcnQucmVwbGFjZUtleXdvcmRzV2l0aFZhbHVlKGcsYyxiLGUpLGw8YS5sZW5ndGgtMSYmKGYrPVwiPC9icj5cIikpKTtudWxsIT09ZiYmKGY9aytmKX1lbHNle2I9YVswXS5kYXRhU2VyaWVzO2M9YVswXS5kYXRhUG9pbnQ7ZT1hWzBdLmluZGV4O2lmKG51bGw9PT1jLnRvb2xUaXBDb250ZW50fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGMudG9vbFRpcENvbnRlbnQmJm51bGw9PT1iLm9wdGlvbnMudG9vbFRpcENvbnRlbnQpcmV0dXJuIG51bGw7XCJsaW5lXCI9PT1iLnR5cGV8fFwic3RlcExpbmVcIj09PWIudHlwZXx8XCJzcGxpbmVcIj09PWIudHlwZXx8XCJhcmVhXCI9PT1iLnR5cGV8fFwic3RlcEFyZWFcIj09PWIudHlwZXx8XCJzcGxpbmVBcmVhXCI9PT1iLnR5cGV8fFwiY29sdW1uXCI9PT1cclxuYi50eXBlfHxcImJhclwiPT09Yi50eXBlfHxcInNjYXR0ZXJcIj09PWIudHlwZXx8XCJzdGFja2VkQ29sdW1uXCI9PT1iLnR5cGV8fFwic3RhY2tlZENvbHVtbjEwMFwiPT09Yi50eXBlfHxcInN0YWNrZWRCYXJcIj09PWIudHlwZXx8XCJzdGFja2VkQmFyMTAwXCI9PT1iLnR5cGV8fFwic3RhY2tlZEFyZWFcIj09PWIudHlwZXx8XCJzdGFja2VkQXJlYTEwMFwiPT09Yi50eXBlfHxcIndhdGVyZmFsbFwiPT09Yi50eXBlP2c9Yy50b29sVGlwQ29udGVudD9jLnRvb2xUaXBDb250ZW50OmIudG9vbFRpcENvbnRlbnQ/Yi50b29sVGlwQ29udGVudDp0aGlzLmNvbnRlbnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiB0aGlzLmNvbnRlbnQ/dGhpcy5jb250ZW50OlwiPHNwYW4gc3R5bGU9J1xcXCJcIisodGhpcy5vcHRpb25zLmZvbnRDb2xvcj9cIlwiOlwiJ2NvbG9yOntjb2xvcn07J1wiKStcIlxcXCInPlwiKyhjLmxhYmVsP1wie2xhYmVsfVwiOlwie3h9XCIpK1wiOjwvc3Bhbj4mbmJzcDsmbmJzcDt7eX1cIjpcImJ1YmJsZVwiPT09Yi50eXBlP2c9Yy50b29sVGlwQ29udGVudD9cclxuYy50b29sVGlwQ29udGVudDpiLnRvb2xUaXBDb250ZW50P2IudG9vbFRpcENvbnRlbnQ6dGhpcy5jb250ZW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgdGhpcy5jb250ZW50P3RoaXMuY29udGVudDpcIjxzcGFuIHN0eWxlPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIidjb2xvcjp7Y29sb3J9OydcIikrXCJcXFwiJz5cIisoYy5sYWJlbD9cIntsYWJlbH1cIjpcInt4fVwiKStcIjo8L3NwYW4+Jm5ic3A7Jm5ic3A7e3l9LCAmbmJzcDsmbmJzcDt7en1cIjpcInBpZVwiPT09Yi50eXBlfHxcImRvdWdobnV0XCI9PT1iLnR5cGV8fFwiZnVubmVsXCI9PT1iLnR5cGV8fFwicHlyYW1pZFwiPT09Yi50eXBlP2c9Yy50b29sVGlwQ29udGVudD9jLnRvb2xUaXBDb250ZW50OmIudG9vbFRpcENvbnRlbnQ/Yi50b29sVGlwQ29udGVudDp0aGlzLmNvbnRlbnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiB0aGlzLmNvbnRlbnQ/dGhpcy5jb250ZW50OlwiPHNwYW4gc3R5bGU9J1xcXCJcIisodGhpcy5vcHRpb25zLmZvbnRDb2xvcj9cIlwiOlxyXG5cIidjb2xvcjp7Y29sb3J9OydcIikrXCJcXFwiJz5cIisoYy5uYW1lP1wie25hbWV9Ojwvc3Bhbj4mbmJzcDsmbmJzcDtcIjpjLmxhYmVsP1wie2xhYmVsfTo8L3NwYW4+Jm5ic3A7Jm5ic3A7XCI6XCI8L3NwYW4+XCIpK1wie3l9XCI6XCJyYW5nZUNvbHVtblwiPT09Yi50eXBlfHxcInJhbmdlQmFyXCI9PT1iLnR5cGV8fFwicmFuZ2VBcmVhXCI9PT1iLnR5cGV8fFwicmFuZ2VTcGxpbmVBcmVhXCI9PT1iLnR5cGV8fFwiZXJyb3JcIj09PWIudHlwZT9nPWMudG9vbFRpcENvbnRlbnQ/Yy50b29sVGlwQ29udGVudDpiLnRvb2xUaXBDb250ZW50P2IudG9vbFRpcENvbnRlbnQ6dGhpcy5jb250ZW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgdGhpcy5jb250ZW50P3RoaXMuY29udGVudDpcIjxzcGFuIHN0eWxlPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIidjb2xvcjp7Y29sb3J9OydcIikrXCJcXFwiJz5cIisoYy5sYWJlbD9cIntsYWJlbH1cIjpcInt4fVwiKStcIiA6PC9zcGFuPiZuYnNwOyZuYnNwO3t5WzBdfSwgJm5ic3A7e3lbMV19XCI6XHJcblwiY2FuZGxlc3RpY2tcIj09PWIudHlwZXx8XCJvaGxjXCI9PT1iLnR5cGU/Zz1jLnRvb2xUaXBDb250ZW50P2MudG9vbFRpcENvbnRlbnQ6Yi50b29sVGlwQ29udGVudD9iLnRvb2xUaXBDb250ZW50OnRoaXMuY29udGVudCYmXCJmdW5jdGlvblwiIT09dHlwZW9mIHRoaXMuY29udGVudD90aGlzLmNvbnRlbnQ6XCI8c3BhbiBzdHlsZT0nXFxcIlwiKyh0aGlzLm9wdGlvbnMuZm9udENvbG9yP1wiXCI6XCInY29sb3I6e2NvbG9yfTsnXCIpK1wiXFxcIic+XCIrKGMubGFiZWw/XCJ7bGFiZWx9XCI6XCJ7eH1cIikrXCI8L3NwYW4+PGJyLz5PcGVuOiAmbmJzcDsmbmJzcDt7eVswXX08YnIvPkhpZ2g6ICZuYnNwOyZuYnNwOyZuYnNwO3t5WzFdfTxici8+TG93OiAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDt7eVsyXX08YnIvPkNsb3NlOiAmbmJzcDsmbmJzcDt7eVszXX1cIjpcImJveEFuZFdoaXNrZXJcIj09PWIudHlwZSYmKGc9Yy50b29sVGlwQ29udGVudD9jLnRvb2xUaXBDb250ZW50OmIudG9vbFRpcENvbnRlbnQ/Yi50b29sVGlwQ29udGVudDpcclxudGhpcy5jb250ZW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgdGhpcy5jb250ZW50P3RoaXMuY29udGVudDpcIjxzcGFuIHN0eWxlPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIidjb2xvcjp7Y29sb3J9OydcIikrXCJcXFwiJz5cIisoYy5sYWJlbD9cIntsYWJlbH1cIjpcInt4fVwiKStcIjwvc3Bhbj48YnIvPk1pbmltdW06ICZuYnNwOyZuYnNwO3t5WzBdfTxici8+UTE6ICZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO3t5WzFdfTxici8+UTI6ICZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO3t5WzRdfTxici8+UTM6ICZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO3t5WzJdfTxici8+TWF4aW11bTogJm5ic3A7e3lbM119XCIpO1xyXG5udWxsPT09ZiYmKGY9XCJcIik7Zis9dGhpcy5jaGFydC5yZXBsYWNlS2V5d29yZHNXaXRoVmFsdWUoZyxjLGIsZSl9cmV0dXJuIGZ9O1kucHJvdG90eXBlLmVuYWJsZUFuaW1hdGlvbj1mdW5jdGlvbigpe2lmKCF0aGlzLmNvbnRhaW5lci5zdHlsZS5XZWJraXRUcmFuc2l0aW9uKXt2YXIgYT10aGlzLmdldENvbnRhaW5lclRyYW5zaXRpb24odGhpcy5jb250YWluZXJUcmFuc2l0aW9uRHVyYXRpb24pO3RoaXMuY29udGFpbmVyLnN0eWxlLldlYmtpdFRyYW5zaXRpb249YTt0aGlzLmNvbnRhaW5lci5zdHlsZS5Nc1RyYW5zaXRpb249YTt0aGlzLmNvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uPWE7dGhpcy5jb250YWluZXIuc3R5bGUuTW96VHJhbnNpdGlvbj10aGlzLm1vekNvbnRhaW5lclRyYW5zaXRpb259fTtZLnByb3RvdHlwZS5kaXNhYmxlQW5pbWF0aW9uPWZ1bmN0aW9uKCl7dGhpcy5jb250YWluZXIuc3R5bGUuV2Via2l0VHJhbnNpdGlvbiYmKHRoaXMuY29udGFpbmVyLnN0eWxlLldlYmtpdFRyYW5zaXRpb249XHJcblwiXCIsdGhpcy5jb250YWluZXIuc3R5bGUuTW96VHJhbnNpdGlvbj1cIlwiLHRoaXMuY29udGFpbmVyLnN0eWxlLk1zVHJhbnNpdGlvbj1cIlwiLHRoaXMuY29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb249XCJcIil9O1kucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oYSl7dGhpcy5jb250YWluZXImJih0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLHRoaXMuY3VycmVudFNlcmllc0luZGV4PS0xLHRoaXMuX3ByZXZZPXRoaXMuX3ByZXZYPU5hTiwoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhfHxhKSYmdGhpcy5jaGFydC5yZXNldE92ZXJsYXllZENhbnZhcygpKX07WS5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbihhLGYsYil7dGhpcy5fdXBkYXRlVG9vbFRpcChhLGYsXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiPyExOmIpfTtZLnByb3RvdHlwZS5maXhNb3pUcmFuc2l0aW9uRGVsYXk9ZnVuY3Rpb24oYSxmKXtpZigyMDx0aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIubGFzdE9iamVjdElkKXRoaXMubW96Q29udGFpbmVyVHJhbnNpdGlvbj1cclxudGhpcy5nZXRDb250YWluZXJUcmFuc2l0aW9uKDApO2Vsc2V7dmFyIGI9cGFyc2VGbG9hdCh0aGlzLmNvbnRhaW5lci5zdHlsZS5sZWZ0KSxiPWlzTmFOKGIpPzA6YixjPXBhcnNlRmxvYXQodGhpcy5jb250YWluZXIuc3R5bGUuYm90dG9tKSxjPWlzTmFOKGMpPzA6YzsxMDxNYXRoLnNxcnQoTWF0aC5wb3coYi1hLDIpK01hdGgucG93KGMtZiwyKSk/dGhpcy5tb3pDb250YWluZXJUcmFuc2l0aW9uPXRoaXMuZ2V0Q29udGFpbmVyVHJhbnNpdGlvbigwLjEpOnRoaXMubW96Q29udGFpbmVyVHJhbnNpdGlvbj10aGlzLmdldENvbnRhaW5lclRyYW5zaXRpb24oMCl9fTtZLnByb3RvdHlwZS5nZXRDb250YWluZXJUcmFuc2l0aW9uPWZ1bmN0aW9uKGEpe3JldHVyblwibGVmdCBcIithK1wicyBlYXNlLW91dCAwcywgYm90dG9tIFwiK2ErXCJzIGVhc2Utb3V0IDBzXCJ9O2ZhLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMubGFzdE9iamVjdElkPTA7dGhpcy5vYmplY3RNYXA9W107dGhpcy5yZWN0YW5ndWxhclJlZ2lvbkV2ZW50U3Vic2NyaXB0aW9ucz1cclxuW107dGhpcy5wcmV2aW91c0RhdGFQb2ludEV2ZW50T2JqZWN0PW51bGw7dGhpcy5ldmVudE9iamVjdHM9W107diYmKHRoaXMuZ2hvc3RDdHguY2xlYXJSZWN0KDAsMCx0aGlzLmNoYXJ0LndpZHRoLHRoaXMuY2hhcnQuaGVpZ2h0KSx0aGlzLmdob3N0Q3R4LmJlZ2luUGF0aCgpKX07ZmEucHJvdG90eXBlLmdldE5ld09iamVjdFRyYWNraW5nSWQ9ZnVuY3Rpb24oKXtyZXR1cm4rK3RoaXMubGFzdE9iamVjdElkfTtmYS5wcm90b3R5cGUubW91c2VFdmVudEhhbmRsZXI9ZnVuY3Rpb24oYSl7aWYoXCJtb3VzZW1vdmVcIj09PWEudHlwZXx8XCJjbGlja1wiPT09YS50eXBlKXt2YXIgZj1bXSxiPU9hKGEpLGM9bnVsbDtpZigoYz10aGlzLmNoYXJ0LmdldE9iamVjdEF0WFkoYi54LGIueSwhMSkpJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIHRoaXMub2JqZWN0TWFwW2NdKWlmKGM9dGhpcy5vYmplY3RNYXBbY10sXCJkYXRhUG9pbnRcIj09PWMub2JqZWN0VHlwZSl7dmFyIGU9dGhpcy5jaGFydC5kYXRhW2MuZGF0YVNlcmllc0luZGV4XSxcclxuZz1lLmRhdGFQb2ludHNbYy5kYXRhUG9pbnRJbmRleF0saD1jLmRhdGFQb2ludEluZGV4O2MuZXZlbnRQYXJhbWV0ZXI9e3g6Yi54LHk6Yi55LGRhdGFQb2ludDpnLGRhdGFTZXJpZXM6ZS5vcHRpb25zLGRhdGFQb2ludEluZGV4OmgsZGF0YVNlcmllc0luZGV4OmUuaW5kZXgsY2hhcnQ6dGhpcy5jaGFydH07Yy5ldmVudENvbnRleHQ9e2NvbnRleHQ6Zyx1c2VyQ29udGV4dDpnLG1vdXNlb3ZlcjpcIm1vdXNlb3ZlclwiLG1vdXNlbW92ZTpcIm1vdXNlbW92ZVwiLG1vdXNlb3V0OlwibW91c2VvdXRcIixjbGljazpcImNsaWNrXCJ9O2YucHVzaChjKTtjPXRoaXMub2JqZWN0TWFwW2UuaWRdO2MuZXZlbnRQYXJhbWV0ZXI9e3g6Yi54LHk6Yi55LGRhdGFQb2ludDpnLGRhdGFTZXJpZXM6ZS5vcHRpb25zLGRhdGFQb2ludEluZGV4OmgsZGF0YVNlcmllc0luZGV4OmUuaW5kZXgsY2hhcnQ6dGhpcy5jaGFydH07Yy5ldmVudENvbnRleHQ9e2NvbnRleHQ6ZSx1c2VyQ29udGV4dDplLm9wdGlvbnMsbW91c2VvdmVyOlwibW91c2VvdmVyXCIsXHJcbm1vdXNlbW92ZTpcIm1vdXNlbW92ZVwiLG1vdXNlb3V0OlwibW91c2VvdXRcIixjbGljazpcImNsaWNrXCJ9O2YucHVzaCh0aGlzLm9iamVjdE1hcFtlLmlkXSl9ZWxzZVwibGVnZW5kSXRlbVwiPT09Yy5vYmplY3RUeXBlJiYoZT10aGlzLmNoYXJ0LmRhdGFbYy5kYXRhU2VyaWVzSW5kZXhdLGc9bnVsbCE9PWMuZGF0YVBvaW50SW5kZXg/ZS5kYXRhUG9pbnRzW2MuZGF0YVBvaW50SW5kZXhdOm51bGwsYy5ldmVudFBhcmFtZXRlcj17eDpiLngseTpiLnksZGF0YVNlcmllczplLm9wdGlvbnMsZGF0YVBvaW50OmcsZGF0YVBvaW50SW5kZXg6Yy5kYXRhUG9pbnRJbmRleCxkYXRhU2VyaWVzSW5kZXg6Yy5kYXRhU2VyaWVzSW5kZXgsY2hhcnQ6dGhpcy5jaGFydH0sYy5ldmVudENvbnRleHQ9e2NvbnRleHQ6dGhpcy5jaGFydC5sZWdlbmQsdXNlckNvbnRleHQ6dGhpcy5jaGFydC5sZWdlbmQub3B0aW9ucyxtb3VzZW92ZXI6XCJpdGVtbW91c2VvdmVyXCIsbW91c2Vtb3ZlOlwiaXRlbW1vdXNlbW92ZVwiLG1vdXNlb3V0OlwiaXRlbW1vdXNlb3V0XCIsXHJcbmNsaWNrOlwiaXRlbWNsaWNrXCJ9LGYucHVzaChjKSk7ZT1bXTtmb3IoYj0wO2I8dGhpcy5tb3VzZW92ZXJlZE9iamVjdE1hcHMubGVuZ3RoO2IrKyl7Zz0hMDtmb3IoYz0wO2M8Zi5sZW5ndGg7YysrKWlmKGZbY10uaWQ9PT10aGlzLm1vdXNlb3ZlcmVkT2JqZWN0TWFwc1tiXS5pZCl7Zz0hMTticmVha31nP3RoaXMuZmlyZUV2ZW50KHRoaXMubW91c2VvdmVyZWRPYmplY3RNYXBzW2JdLFwibW91c2VvdXRcIixhKTplLnB1c2godGhpcy5tb3VzZW92ZXJlZE9iamVjdE1hcHNbYl0pfXRoaXMubW91c2VvdmVyZWRPYmplY3RNYXBzPWU7Zm9yKGI9MDtiPGYubGVuZ3RoO2IrKyl7ZT0hMTtmb3IoYz0wO2M8dGhpcy5tb3VzZW92ZXJlZE9iamVjdE1hcHMubGVuZ3RoO2MrKylpZihmW2JdLmlkPT09dGhpcy5tb3VzZW92ZXJlZE9iamVjdE1hcHNbY10uaWQpe2U9ITA7YnJlYWt9ZXx8KHRoaXMuZmlyZUV2ZW50KGZbYl0sXCJtb3VzZW92ZXJcIixhKSx0aGlzLm1vdXNlb3ZlcmVkT2JqZWN0TWFwcy5wdXNoKGZbYl0pKTtcclxuXCJjbGlja1wiPT09YS50eXBlP3RoaXMuZmlyZUV2ZW50KGZbYl0sXCJjbGlja1wiLGEpOlwibW91c2Vtb3ZlXCI9PT1hLnR5cGUmJnRoaXMuZmlyZUV2ZW50KGZbYl0sXCJtb3VzZW1vdmVcIixhKX19fTtmYS5wcm90b3R5cGUuZmlyZUV2ZW50PWZ1bmN0aW9uKGEsZixiKXtpZihhJiZmKXt2YXIgYz1hLmV2ZW50UGFyYW1ldGVyLGU9YS5ldmVudENvbnRleHQsZz1hLmV2ZW50Q29udGV4dC51c2VyQ29udGV4dDtnJiYoZSYmZ1tlW2ZdXSkmJmdbZVtmXV0uY2FsbChnLGMpO1wibW91c2VvdXRcIiE9PWY/Zy5jdXJzb3ImJmcuY3Vyc29yIT09Yi50YXJnZXQuc3R5bGUuY3Vyc29yJiYoYi50YXJnZXQuc3R5bGUuY3Vyc29yPWcuY3Vyc29yKTooYi50YXJnZXQuc3R5bGUuY3Vyc29yPXRoaXMuY2hhcnQuX2RlZmF1bHRDdXJzb3IsZGVsZXRlIGEuZXZlbnRQYXJhbWV0ZXIsZGVsZXRlIGEuZXZlbnRDb250ZXh0KTtcImNsaWNrXCI9PT1mJiYoXCJkYXRhUG9pbnRcIj09PWEub2JqZWN0VHlwZSYmdGhpcy5jaGFydC5waWVEb3VnaG51dENsaWNrSGFuZGxlcikmJlxyXG50aGlzLmNoYXJ0LnBpZURvdWdobnV0Q2xpY2tIYW5kbGVyLmNhbGwodGhpcy5jaGFydC5kYXRhW2EuZGF0YVNlcmllc0luZGV4XSxjKTtcImNsaWNrXCI9PT1mJiYoXCJkYXRhUG9pbnRcIj09PWEub2JqZWN0VHlwZSYmdGhpcy5jaGFydC5mdW5uZWxQeXJhbWlkQ2xpY2tIYW5kbGVyKSYmdGhpcy5jaGFydC5mdW5uZWxQeXJhbWlkQ2xpY2tIYW5kbGVyLmNhbGwodGhpcy5jaGFydC5kYXRhW2EuZGF0YVNlcmllc0luZGV4XSxjKX19O2thLnByb3RvdHlwZS5hbmltYXRlPWZ1bmN0aW9uKGEsZixiLGMsZSl7dmFyIGc9dGhpczt0aGlzLmNoYXJ0LmlzQW5pbWF0aW5nPSEwO2U9ZXx8SC5lYXNpbmcubGluZWFyO2ImJnRoaXMuYW5pbWF0aW9ucy5wdXNoKHtzdGFydFRpbWU6KG5ldyBEYXRlKS5nZXRUaW1lKCkrKGE/YTowKSxkdXJhdGlvbjpmLGFuaW1hdGlvbkNhbGxiYWNrOmIsb25Db21wbGV0ZTpjfSk7Zm9yKGE9W107MDx0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOylpZihmPXRoaXMuYW5pbWF0aW9ucy5zaGlmdCgpLFxyXG5iPShuZXcgRGF0ZSkuZ2V0VGltZSgpLGM9MCxmLnN0YXJ0VGltZTw9YiYmKGM9ZShNYXRoLm1pbihiLWYuc3RhcnRUaW1lLGYuZHVyYXRpb24pLDAsMSxmLmR1cmF0aW9uKSxjPU1hdGgubWluKGMsMSksaXNOYU4oYyl8fCFpc0Zpbml0ZShjKSkmJihjPTEpLDE+YyYmYS5wdXNoKGYpLGYuYW5pbWF0aW9uQ2FsbGJhY2soYyksMTw9YyYmZi5vbkNvbXBsZXRlKWYub25Db21wbGV0ZSgpO3RoaXMuYW5pbWF0aW9ucz1hOzA8dGhpcy5hbmltYXRpb25zLmxlbmd0aD90aGlzLmFuaW1hdGlvblJlcXVlc3RJZD10aGlzLmNoYXJ0LnJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csZnVuY3Rpb24oKXtnLmFuaW1hdGUuY2FsbChnKX0pOnRoaXMuY2hhcnQuaXNBbmltYXRpbmc9ITF9O2thLnByb3RvdHlwZS5jYW5jZWxBbGxBbmltYXRpb25zPWZ1bmN0aW9uKCl7dGhpcy5hbmltYXRpb25zPVtdO3RoaXMuYW5pbWF0aW9uUmVxdWVzdElkJiZ0aGlzLmNoYXJ0LmNhbmNlbFJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csXHJcbnRoaXMuYW5pbWF0aW9uUmVxdWVzdElkKTt0aGlzLmFuaW1hdGlvblJlcXVlc3RJZD1udWxsO3RoaXMuY2hhcnQuaXNBbmltYXRpbmc9ITF9O3ZhciBIPXt5U2NhbGVBbmltYXRpb246ZnVuY3Rpb24oYSxmKXtpZigwIT09YSl7dmFyIGI9Zi5kZXN0LGM9Zi5zb3VyY2UuY2FudmFzLGU9Zi5hbmltYXRpb25CYXNlO2IuZHJhd0ltYWdlKGMsMCwwLGMud2lkdGgsYy5oZWlnaHQsMCxlLWUqYSxiLmNhbnZhcy53aWR0aC9oYSxhKmIuY2FudmFzLmhlaWdodC9oYSl9fSx4U2NhbGVBbmltYXRpb246ZnVuY3Rpb24oYSxmKXtpZigwIT09YSl7dmFyIGI9Zi5kZXN0LGM9Zi5zb3VyY2UuY2FudmFzLGU9Zi5hbmltYXRpb25CYXNlO2IuZHJhd0ltYWdlKGMsMCwwLGMud2lkdGgsYy5oZWlnaHQsZS1lKmEsMCxhKmIuY2FudmFzLndpZHRoL2hhLGIuY2FudmFzLmhlaWdodC9oYSl9fSx4Q2xpcEFuaW1hdGlvbjpmdW5jdGlvbihhLGYpe2lmKDAhPT1hKXt2YXIgYj1mLmRlc3QsYz1mLnNvdXJjZS5jYW52YXM7XHJcbmIuc2F2ZSgpOzA8YSYmYi5kcmF3SW1hZ2UoYywwLDAsYy53aWR0aCphLGMuaGVpZ2h0LDAsMCxjLndpZHRoKmEvaGEsYy5oZWlnaHQvaGEpO2IucmVzdG9yZSgpfX0sZmFkZUluQW5pbWF0aW9uOmZ1bmN0aW9uKGEsZil7aWYoMCE9PWEpe3ZhciBiPWYuZGVzdCxjPWYuc291cmNlLmNhbnZhcztiLnNhdmUoKTtiLmdsb2JhbEFscGhhPWE7Yi5kcmF3SW1hZ2UoYywwLDAsYy53aWR0aCxjLmhlaWdodCwwLDAsYi5jYW52YXMud2lkdGgvaGEsYi5jYW52YXMuaGVpZ2h0L2hhKTtiLnJlc3RvcmUoKX19LGVhc2luZzp7bGluZWFyOmZ1bmN0aW9uKGEsZixiLGMpe3JldHVybiBiKmEvYytmfSxlYXNlT3V0UXVhZDpmdW5jdGlvbihhLGYsYixjKXtyZXR1cm4tYiooYS89YykqKGEtMikrZn0sZWFzZU91dFF1YXJ0OmZ1bmN0aW9uKGEsZixiLGMpe3JldHVybi1iKigoYT1hL2MtMSkqYSphKmEtMSkrZn0sZWFzZUluUXVhZDpmdW5jdGlvbihhLGYsYixjKXtyZXR1cm4gYiooYS89YykqYStmfSxlYXNlSW5RdWFydDpmdW5jdGlvbihhLFxyXG5mLGIsYyl7cmV0dXJuIGIqKGEvPWMpKmEqYSphK2Z9fX0samE9e2RyYXdNYXJrZXI6ZnVuY3Rpb24oYSxmLGIsYyxlLGcsaCxsKXtpZihiKXt2YXIgbT0xO2IuZmlsbFN0eWxlPWc/ZzpcIiMwMDAwMDBcIjtiLnN0cm9rZVN0eWxlPWg/aDpcIiMwMDAwMDBcIjtiLmxpbmVXaWR0aD1sP2w6MDtcImNpcmNsZVwiPT09Yz8oYi5tb3ZlVG8oYSxmKSxiLmJlZ2luUGF0aCgpLGIuYXJjKGEsZixlLzIsMCwyKk1hdGguUEksITEpLGcmJmIuZmlsbCgpLGwmJihoP2Iuc3Ryb2tlKCk6KG09Yi5nbG9iYWxBbHBoYSxiLmdsb2JhbEFscGhhPTAuMTUsYi5zdHJva2VTdHlsZT1cImJsYWNrXCIsYi5zdHJva2UoKSxiLmdsb2JhbEFscGhhPW0pKSk6XCJzcXVhcmVcIj09PWM/KGIuYmVnaW5QYXRoKCksYi5yZWN0KGEtZS8yLGYtZS8yLGUsZSksZyYmYi5maWxsKCksbCYmKGg/Yi5zdHJva2UoKToobT1iLmdsb2JhbEFscGhhLGIuZ2xvYmFsQWxwaGE9MC4xNSxiLnN0cm9rZVN0eWxlPVwiYmxhY2tcIixiLnN0cm9rZSgpLGIuZ2xvYmFsQWxwaGE9XHJcbm0pKSk6XCJ0cmlhbmdsZVwiPT09Yz8oYi5iZWdpblBhdGgoKSxiLm1vdmVUbyhhLWUvMixmK2UvMiksYi5saW5lVG8oYStlLzIsZitlLzIpLGIubGluZVRvKGEsZi1lLzIpLGIuY2xvc2VQYXRoKCksZyYmYi5maWxsKCksbCYmKGg/Yi5zdHJva2UoKToobT1iLmdsb2JhbEFscGhhLGIuZ2xvYmFsQWxwaGE9MC4xNSxiLnN0cm9rZVN0eWxlPVwiYmxhY2tcIixiLnN0cm9rZSgpLGIuZ2xvYmFsQWxwaGE9bSkpLGIuYmVnaW5QYXRoKCkpOlwiY3Jvc3NcIj09PWMmJihiLnN0cm9rZVN0eWxlPWcsYi5saW5lV2lkdGg9ZS80LGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8oYS1lLzIsZi1lLzIpLGIubGluZVRvKGErZS8yLGYrZS8yKSxiLnN0cm9rZSgpLGIubW92ZVRvKGErZS8yLGYtZS8yKSxiLmxpbmVUbyhhLWUvMixmK2UvMiksYi5zdHJva2UoKSl9fSxkcmF3TWFya2VyczpmdW5jdGlvbihhKXtmb3IodmFyIGY9MDtmPGEubGVuZ3RoO2YrKyl7dmFyIGI9YVtmXTtqYS5kcmF3TWFya2VyKGIueCxiLnksYi5jdHgsXHJcbmIudHlwZSxiLnNpemUsYi5jb2xvcixiLmJvcmRlckNvbG9yLGIuYm9yZGVyVGhpY2tuZXNzKX19fTtyZXR1cm4gcX0oKTt4LkNoYXJ0LnZlcnNpb249XCJ2Mi4wLjEgR0FcIn0pKCk7XHJcblxyXG4vKlxyXG4gIGV4Y2FudmFzIGlzIHVzZWQgdG8gc3VwcG9ydCBJRTY3OCB3aGljaCBkbyBub3QgaW1wbGVtZW50IEhUTUw1IENhbnZhcyBFbGVtZW50LiBZb3UgY2FuIHNhZmVseSByZW1vdmUgdGhlIGZvbGxvd2luZyBleGNhbnZhcyBjb2RlIGlmIHlvdSBkb24ndCBuZWVkIHRvIHN1cHBvcnQgb2xkZXIgYnJvd3NlcnMuXHJcblxyXG4gIENvcHlyaWdodCAyMDA2IEdvb2dsZSBJbmMuIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZXhwbG9yZXJjYW52YXMvXHJcbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4qL1xyXG5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHR8fGZ1bmN0aW9uKCl7ZnVuY3Rpb24gVigpe3JldHVybiB0aGlzLmNvbnRleHRffHwodGhpcy5jb250ZXh0Xz1uZXcgQyh0aGlzKSl9ZnVuY3Rpb24gVyhhLGIsYyl7dmFyIGc9TS5jYWxsKGFyZ3VtZW50cywyKTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShiLGcuY29uY2F0KE0uY2FsbChhcmd1bWVudHMpKSl9fWZ1bmN0aW9uIE4oYSl7cmV0dXJuIFN0cmluZyhhKS5yZXBsYWNlKC8mL2csXCImYW1wO1wiKS5yZXBsYWNlKC9cIi9nLFwiJnF1b3Q7XCIpfWZ1bmN0aW9uIE8oYSl7YS5uYW1lc3BhY2VzLmdfdm1sX3x8YS5uYW1lc3BhY2VzLmFkZChcImdfdm1sX1wiLFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWxcIixcIiNkZWZhdWx0I1ZNTFwiKTthLm5hbWVzcGFjZXMuZ19vX3x8YS5uYW1lc3BhY2VzLmFkZChcImdfb19cIixcInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206b2ZmaWNlOm9mZmljZVwiLFwiI2RlZmF1bHQjVk1MXCIpO1xyXG5hLnN0eWxlU2hlZXRzLmV4X2NhbnZhc198fChhPWEuY3JlYXRlU3R5bGVTaGVldCgpLGEub3duaW5nRWxlbWVudC5pZD1cImV4X2NhbnZhc19cIixhLmNzc1RleHQ9XCJjYW52YXN7ZGlzcGxheTppbmxpbmUtYmxvY2s7b3ZlcmZsb3c6aGlkZGVuO3RleHQtYWxpZ246bGVmdDt3aWR0aDozMDBweDtoZWlnaHQ6MTUwcHh9XCIpfWZ1bmN0aW9uIFgoYSl7dmFyIGI9YS5zcmNFbGVtZW50O3N3aXRjaChhLnByb3BlcnR5TmFtZSl7Y2FzZSBcIndpZHRoXCI6Yi5nZXRDb250ZXh0KCkuY2xlYXJSZWN0KCk7Yi5zdHlsZS53aWR0aD1iLmF0dHJpYnV0ZXMud2lkdGgubm9kZVZhbHVlK1wicHhcIjtiLmZpcnN0Q2hpbGQuc3R5bGUud2lkdGg9Yi5jbGllbnRXaWR0aCtcInB4XCI7YnJlYWs7Y2FzZSBcImhlaWdodFwiOmIuZ2V0Q29udGV4dCgpLmNsZWFyUmVjdCgpLGIuc3R5bGUuaGVpZ2h0PWIuYXR0cmlidXRlcy5oZWlnaHQubm9kZVZhbHVlK1wicHhcIixiLmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0PWIuY2xpZW50SGVpZ2h0K1xyXG5cInB4XCJ9fWZ1bmN0aW9uIFkoYSl7YT1hLnNyY0VsZW1lbnQ7YS5maXJzdENoaWxkJiYoYS5maXJzdENoaWxkLnN0eWxlLndpZHRoPWEuY2xpZW50V2lkdGgrXCJweFwiLGEuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQ9YS5jbGllbnRIZWlnaHQrXCJweFwiKX1mdW5jdGlvbiBEKCl7cmV0dXJuW1sxLDAsMF0sWzAsMSwwXSxbMCwwLDFdXX1mdW5jdGlvbiB0KGEsYil7Zm9yKHZhciBjPUQoKSxnPTA7Mz5nO2crKylmb3IodmFyIGU9MDszPmU7ZSsrKXtmb3IodmFyIGY9MCxkPTA7Mz5kO2QrKylmKz1hW2ddW2RdKmJbZF1bZV07Y1tnXVtlXT1mfXJldHVybiBjfWZ1bmN0aW9uIFAoYSxiKXtiLmZpbGxTdHlsZT1hLmZpbGxTdHlsZTtiLmxpbmVDYXA9YS5saW5lQ2FwO2IubGluZUpvaW49YS5saW5lSm9pbjtiLmxpbmVXaWR0aD1hLmxpbmVXaWR0aDtiLm1pdGVyTGltaXQ9YS5taXRlckxpbWl0O2Iuc2hhZG93Qmx1cj1hLnNoYWRvd0JsdXI7Yi5zaGFkb3dDb2xvcj1hLnNoYWRvd0NvbG9yO2Iuc2hhZG93T2Zmc2V0WD1cclxuYS5zaGFkb3dPZmZzZXRYO2Iuc2hhZG93T2Zmc2V0WT1hLnNoYWRvd09mZnNldFk7Yi5zdHJva2VTdHlsZT1hLnN0cm9rZVN0eWxlO2IuZ2xvYmFsQWxwaGE9YS5nbG9iYWxBbHBoYTtiLmZvbnQ9YS5mb250O2IudGV4dEFsaWduPWEudGV4dEFsaWduO2IudGV4dEJhc2VsaW5lPWEudGV4dEJhc2VsaW5lO2IuYXJjU2NhbGVYXz1hLmFyY1NjYWxlWF87Yi5hcmNTY2FsZVlfPWEuYXJjU2NhbGVZXztiLmxpbmVTY2FsZV89YS5saW5lU2NhbGVffWZ1bmN0aW9uIFEoYSl7dmFyIGI9YS5pbmRleE9mKFwiKFwiLDMpLGM9YS5pbmRleE9mKFwiKVwiLGIrMSksYj1hLnN1YnN0cmluZyhiKzEsYykuc3BsaXQoXCIsXCIpO2lmKDQhPWIubGVuZ3RofHxcImFcIiE9YS5jaGFyQXQoMykpYlszXT0xO3JldHVybiBifWZ1bmN0aW9uIEUoYSxiLGMpe3JldHVybiBNYXRoLm1pbihjLE1hdGgubWF4KGIsYSkpfWZ1bmN0aW9uIEYoYSxiLGMpezA+YyYmYysrOzE8YyYmYy0tO3JldHVybiAxPjYqYz9hKzYqKGItYSkqYzpcclxuMT4yKmM/YjoyPjMqYz9hKzYqKGItYSkqKDIvMy1jKTphfWZ1bmN0aW9uIEcoYSl7aWYoYSBpbiBIKXJldHVybiBIW2FdO3ZhciBiLGM9MTthPVN0cmluZyhhKTtpZihcIiNcIj09YS5jaGFyQXQoMCkpYj1hO2Vsc2UgaWYoL15yZ2IvLnRlc3QoYSkpe2M9UShhKTtiPVwiI1wiO2Zvcih2YXIgZyxlPTA7Mz5lO2UrKylnPS0xIT1jW2VdLmluZGV4T2YoXCIlXCIpP01hdGguZmxvb3IoMjU1KihwYXJzZUZsb2F0KGNbZV0pLzEwMCkpOitjW2VdLGIrPXZbRShnLDAsMjU1KV07Yz0rY1szXX1lbHNlIGlmKC9eaHNsLy50ZXN0KGEpKXtlPWM9UShhKTtiPXBhcnNlRmxvYXQoZVswXSkvMzYwJTM2MDswPmImJmIrKztnPUUocGFyc2VGbG9hdChlWzFdKS8xMDAsMCwxKTtlPUUocGFyc2VGbG9hdChlWzJdKS8xMDAsMCwxKTtpZigwPT1nKWc9ZT1iPWU7ZWxzZXt2YXIgZj0wLjU+ZT9lKigxK2cpOmUrZy1lKmcsZD0yKmUtZjtnPUYoZCxmLGIrMS8zKTtlPUYoZCxmLGIpO2I9RihkLGYsYi0xLzMpfWI9XCIjXCIrXHJcbnZbTWF0aC5mbG9vcigyNTUqZyldK3ZbTWF0aC5mbG9vcigyNTUqZSldK3ZbTWF0aC5mbG9vcigyNTUqYildO2M9Y1szXX1lbHNlIGI9WlthXXx8YTtyZXR1cm4gSFthXT17Y29sb3I6YixhbHBoYTpjfX1mdW5jdGlvbiBDKGEpe3RoaXMubV89RCgpO3RoaXMubVN0YWNrXz1bXTt0aGlzLmFTdGFja189W107dGhpcy5jdXJyZW50UGF0aF89W107dGhpcy5maWxsU3R5bGU9dGhpcy5zdHJva2VTdHlsZT1cIiMwMDBcIjt0aGlzLmxpbmVXaWR0aD0xO3RoaXMubGluZUpvaW49XCJtaXRlclwiO3RoaXMubGluZUNhcD1cImJ1dHRcIjt0aGlzLm1pdGVyTGltaXQ9MSpxO3RoaXMuZ2xvYmFsQWxwaGE9MTt0aGlzLmZvbnQ9XCIxMHB4IHNhbnMtc2VyaWZcIjt0aGlzLnRleHRBbGlnbj1cImxlZnRcIjt0aGlzLnRleHRCYXNlbGluZT1cImFscGhhYmV0aWNcIjt0aGlzLmNhbnZhcz1hO3ZhciBiPVwid2lkdGg6XCIrYS5jbGllbnRXaWR0aCtcInB4O2hlaWdodDpcIithLmNsaWVudEhlaWdodCtcInB4O292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjphYnNvbHV0ZVwiLFxyXG5jPWEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2Muc3R5bGUuY3NzVGV4dD1iO2EuYXBwZW5kQ2hpbGQoYyk7Yj1jLmNsb25lTm9kZSghMSk7Yi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9XCJyZWRcIjtiLnN0eWxlLmZpbHRlcj1cImFscGhhKG9wYWNpdHk9MClcIjthLmFwcGVuZENoaWxkKGIpO3RoaXMuZWxlbWVudF89Yzt0aGlzLmxpbmVTY2FsZV89dGhpcy5hcmNTY2FsZVlfPXRoaXMuYXJjU2NhbGVYXz0xfWZ1bmN0aW9uIFIoYSxiLGMsZyl7YS5jdXJyZW50UGF0aF8ucHVzaCh7dHlwZTpcImJlemllckN1cnZlVG9cIixjcDF4OmIueCxjcDF5OmIueSxjcDJ4OmMueCxjcDJ5OmMueSx4OmcueCx5OmcueX0pO2EuY3VycmVudFhfPWcueDthLmN1cnJlbnRZXz1nLnl9ZnVuY3Rpb24gUyhhLGIpe3ZhciBjPUcoYS5zdHJva2VTdHlsZSksZz1jLmNvbG9yLGM9Yy5hbHBoYSphLmdsb2JhbEFscGhhLGU9YS5saW5lU2NhbGVfKmEubGluZVdpZHRoOzE+ZSYmKGMqPWUpO2IucHVzaChcIjxnX3ZtbF86c3Ryb2tlXCIsXHJcbicgb3BhY2l0eT1cIicsYywnXCInLCcgam9pbnN0eWxlPVwiJyxhLmxpbmVKb2luLCdcIicsJyBtaXRlcmxpbWl0PVwiJyxhLm1pdGVyTGltaXQsJ1wiJywnIGVuZGNhcD1cIicsJFthLmxpbmVDYXBdfHxcInNxdWFyZVwiLCdcIicsJyB3ZWlnaHQ9XCInLGUsJ3B4XCInLCcgY29sb3I9XCInLGcsJ1wiIC8+Jyl9ZnVuY3Rpb24gVChhLGIsYyxnKXt2YXIgZT1hLmZpbGxTdHlsZSxmPWEuYXJjU2NhbGVYXyxkPWEuYXJjU2NhbGVZXyxrPWcueC1jLngsbj1nLnktYy55O2lmKGUgaW5zdGFuY2VvZiB3KXt2YXIgaD0wLGw9Zz0wLHU9MCxtPTE7aWYoXCJncmFkaWVudFwiPT1lLnR5cGVfKXtoPWUueDFfL2Y7Yz1lLnkxXy9kO3ZhciBwPXMoYSxlLngwXy9mLGUueTBfL2QpLGg9cyhhLGgsYyksaD0xODAqTWF0aC5hdGFuMihoLngtcC54LGgueS1wLnkpL01hdGguUEk7MD5oJiYoaCs9MzYwKTsxRS02PmgmJihoPTApfWVsc2UgcD1zKGEsZS54MF8sZS55MF8pLGc9KHAueC1jLngpL2ssbD0ocC55LWMueSkvbixrLz1mKnEsXHJcbm4vPWQqcSxtPXgubWF4KGssbiksdT0yKmUucjBfL20sbT0yKmUucjFfL20tdTtmPWUuY29sb3JzXztmLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5vZmZzZXQtYi5vZmZzZXR9KTtkPWYubGVuZ3RoO3A9ZlswXS5jb2xvcjtjPWZbZC0xXS5jb2xvcjtrPWZbMF0uYWxwaGEqYS5nbG9iYWxBbHBoYTthPWZbZC0xXS5hbHBoYSphLmdsb2JhbEFscGhhO2Zvcih2YXIgbj1bXSxyPTA7cjxkO3IrKyl7dmFyIHQ9ZltyXTtuLnB1c2godC5vZmZzZXQqbSt1K1wiIFwiK3QuY29sb3IpfWIucHVzaCgnPGdfdm1sXzpmaWxsIHR5cGU9XCInLGUudHlwZV8sJ1wiJywnIG1ldGhvZD1cIm5vbmVcIiBmb2N1cz1cIjEwMCVcIicsJyBjb2xvcj1cIicscCwnXCInLCcgY29sb3IyPVwiJyxjLCdcIicsJyBjb2xvcnM9XCInLG4uam9pbihcIixcIiksJ1wiJywnIG9wYWNpdHk9XCInLGEsJ1wiJywnIGdfb186b3BhY2l0eTI9XCInLGssJ1wiJywnIGFuZ2xlPVwiJyxoLCdcIicsJyBmb2N1c3Bvc2l0aW9uPVwiJyxnLFwiLFwiLGwsJ1wiIC8+Jyl9ZWxzZSBlIGluc3RhbmNlb2ZcclxuST9rJiZuJiZiLnB1c2goXCI8Z192bWxfOmZpbGxcIiwnIHBvc2l0aW9uPVwiJywtYy54L2sqZipmLFwiLFwiLC1jLnkvbipkKmQsJ1wiJywnIHR5cGU9XCJ0aWxlXCInLCcgc3JjPVwiJyxlLnNyY18sJ1wiIC8+Jyk6KGU9RyhhLmZpbGxTdHlsZSksYi5wdXNoKCc8Z192bWxfOmZpbGwgY29sb3I9XCInLGUuY29sb3IsJ1wiIG9wYWNpdHk9XCInLGUuYWxwaGEqYS5nbG9iYWxBbHBoYSwnXCIgLz4nKSl9ZnVuY3Rpb24gcyhhLGIsYyl7YT1hLm1fO3JldHVybnt4OnEqKGIqYVswXVswXStjKmFbMV1bMF0rYVsyXVswXSktcix5OnEqKGIqYVswXVsxXStjKmFbMV1bMV0rYVsyXVsxXSktcn19ZnVuY3Rpb24geihhLGIsYyl7aXNGaW5pdGUoYlswXVswXSkmJihpc0Zpbml0ZShiWzBdWzFdKSYmaXNGaW5pdGUoYlsxXVswXSkmJmlzRmluaXRlKGJbMV1bMV0pJiZpc0Zpbml0ZShiWzJdWzBdKSYmaXNGaW5pdGUoYlsyXVsxXSkpJiYoYS5tXz1iLGMmJihhLmxpbmVTY2FsZV89YWEoYmEoYlswXVswXSpiWzFdWzFdLWJbMF1bMV0qXHJcbmJbMV1bMF0pKSkpfWZ1bmN0aW9uIHcoYSl7dGhpcy50eXBlXz1hO3RoaXMucjFfPXRoaXMueTFfPXRoaXMueDFfPXRoaXMucjBfPXRoaXMueTBfPXRoaXMueDBfPTA7dGhpcy5jb2xvcnNfPVtdfWZ1bmN0aW9uIEkoYSxiKXtpZighYXx8MSE9YS5ub2RlVHlwZXx8XCJJTUdcIiE9YS50YWdOYW1lKXRocm93IG5ldyBBKFwiVFlQRV9NSVNNQVRDSF9FUlJcIik7aWYoXCJjb21wbGV0ZVwiIT1hLnJlYWR5U3RhdGUpdGhyb3cgbmV3IEEoXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtzd2l0Y2goYil7Y2FzZSBcInJlcGVhdFwiOmNhc2UgbnVsbDpjYXNlIFwiXCI6dGhpcy5yZXBldGl0aW9uXz1cInJlcGVhdFwiO2JyZWFrO2Nhc2UgXCJyZXBlYXQteFwiOmNhc2UgXCJyZXBlYXQteVwiOmNhc2UgXCJuby1yZXBlYXRcIjp0aGlzLnJlcGV0aXRpb25fPWI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgQShcIlNZTlRBWF9FUlJcIik7fXRoaXMuc3JjXz1hLnNyYzt0aGlzLndpZHRoXz1hLndpZHRoO3RoaXMuaGVpZ2h0Xz1hLmhlaWdodH1cclxuZnVuY3Rpb24gQShhKXt0aGlzLmNvZGU9dGhpc1thXTt0aGlzLm1lc3NhZ2U9YStcIjogRE9NIEV4Y2VwdGlvbiBcIit0aGlzLmNvZGV9dmFyIHg9TWF0aCxrPXgucm91bmQsSj14LnNpbixLPXguY29zLGJhPXguYWJzLGFhPXguc3FydCxxPTEwLHI9cS8yO25hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL01TSUUgKFtcXGQuXSspPy8pO3ZhciBNPUFycmF5LnByb3RvdHlwZS5zbGljZTtPKGRvY3VtZW50KTt2YXIgVT17aW5pdDpmdW5jdGlvbihhKXthPWF8fGRvY3VtZW50O2EuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTthLmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsVyh0aGlzLmluaXRfLHRoaXMsYSkpfSxpbml0XzpmdW5jdGlvbihhKXthPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjYW52YXNcIik7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspdGhpcy5pbml0RWxlbWVudChhW2JdKX0saW5pdEVsZW1lbnQ6ZnVuY3Rpb24oYSl7aWYoIWEuZ2V0Q29udGV4dCl7YS5nZXRDb250ZXh0PVxyXG5WO08oYS5vd25lckRvY3VtZW50KTthLmlubmVySFRNTD1cIlwiO2EuYXR0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsWCk7YS5hdHRhY2hFdmVudChcIm9ucmVzaXplXCIsWSk7dmFyIGI9YS5hdHRyaWJ1dGVzO2Iud2lkdGgmJmIud2lkdGguc3BlY2lmaWVkP2Euc3R5bGUud2lkdGg9Yi53aWR0aC5ub2RlVmFsdWUrXCJweFwiOmEud2lkdGg9YS5jbGllbnRXaWR0aDtiLmhlaWdodCYmYi5oZWlnaHQuc3BlY2lmaWVkP2Euc3R5bGUuaGVpZ2h0PWIuaGVpZ2h0Lm5vZGVWYWx1ZStcInB4XCI6YS5oZWlnaHQ9YS5jbGllbnRIZWlnaHR9cmV0dXJuIGF9fTtVLmluaXQoKTtmb3IodmFyIHY9W10sZD0wOzE2PmQ7ZCsrKWZvcih2YXIgQj0wOzE2PkI7QisrKXZbMTYqZCtCXT1kLnRvU3RyaW5nKDE2KStCLnRvU3RyaW5nKDE2KTt2YXIgWj17YWxpY2VibHVlOlwiI0YwRjhGRlwiLGFudGlxdWV3aGl0ZTpcIiNGQUVCRDdcIixhcXVhbWFyaW5lOlwiIzdGRkZENFwiLGF6dXJlOlwiI0YwRkZGRlwiLGJlaWdlOlwiI0Y1RjVEQ1wiLFxyXG5iaXNxdWU6XCIjRkZFNEM0XCIsYmxhY2s6XCIjMDAwMDAwXCIsYmxhbmNoZWRhbG1vbmQ6XCIjRkZFQkNEXCIsYmx1ZXZpb2xldDpcIiM4QTJCRTJcIixicm93bjpcIiNBNTJBMkFcIixidXJseXdvb2Q6XCIjREVCODg3XCIsY2FkZXRibHVlOlwiIzVGOUVBMFwiLGNoYXJ0cmV1c2U6XCIjN0ZGRjAwXCIsY2hvY29sYXRlOlwiI0QyNjkxRVwiLGNvcmFsOlwiI0ZGN0Y1MFwiLGNvcm5mbG93ZXJibHVlOlwiIzY0OTVFRFwiLGNvcm5zaWxrOlwiI0ZGRjhEQ1wiLGNyaW1zb246XCIjREMxNDNDXCIsY3lhbjpcIiMwMEZGRkZcIixkYXJrYmx1ZTpcIiMwMDAwOEJcIixkYXJrY3lhbjpcIiMwMDhCOEJcIixkYXJrZ29sZGVucm9kOlwiI0I4ODYwQlwiLGRhcmtncmF5OlwiI0E5QTlBOVwiLGRhcmtncmVlbjpcIiMwMDY0MDBcIixkYXJrZ3JleTpcIiNBOUE5QTlcIixkYXJra2hha2k6XCIjQkRCNzZCXCIsZGFya21hZ2VudGE6XCIjOEIwMDhCXCIsZGFya29saXZlZ3JlZW46XCIjNTU2QjJGXCIsZGFya29yYW5nZTpcIiNGRjhDMDBcIixkYXJrb3JjaGlkOlwiIzk5MzJDQ1wiLGRhcmtyZWQ6XCIjOEIwMDAwXCIsXHJcbmRhcmtzYWxtb246XCIjRTk5NjdBXCIsZGFya3NlYWdyZWVuOlwiIzhGQkM4RlwiLGRhcmtzbGF0ZWJsdWU6XCIjNDgzRDhCXCIsZGFya3NsYXRlZ3JheTpcIiMyRjRGNEZcIixkYXJrc2xhdGVncmV5OlwiIzJGNEY0RlwiLGRhcmt0dXJxdW9pc2U6XCIjMDBDRUQxXCIsZGFya3Zpb2xldDpcIiM5NDAwRDNcIixkZWVwcGluazpcIiNGRjE0OTNcIixkZWVwc2t5Ymx1ZTpcIiMwMEJGRkZcIixkaW1ncmF5OlwiIzY5Njk2OVwiLGRpbWdyZXk6XCIjNjk2OTY5XCIsZG9kZ2VyYmx1ZTpcIiMxRTkwRkZcIixmaXJlYnJpY2s6XCIjQjIyMjIyXCIsZmxvcmFsd2hpdGU6XCIjRkZGQUYwXCIsZm9yZXN0Z3JlZW46XCIjMjI4QjIyXCIsZ2FpbnNib3JvOlwiI0RDRENEQ1wiLGdob3N0d2hpdGU6XCIjRjhGOEZGXCIsZ29sZDpcIiNGRkQ3MDBcIixnb2xkZW5yb2Q6XCIjREFBNTIwXCIsZ3JleTpcIiM4MDgwODBcIixncmVlbnllbGxvdzpcIiNBREZGMkZcIixob25leWRldzpcIiNGMEZGRjBcIixob3RwaW5rOlwiI0ZGNjlCNFwiLGluZGlhbnJlZDpcIiNDRDVDNUNcIixpbmRpZ286XCIjNEIwMDgyXCIsXHJcbml2b3J5OlwiI0ZGRkZGMFwiLGtoYWtpOlwiI0YwRTY4Q1wiLGxhdmVuZGVyOlwiI0U2RTZGQVwiLGxhdmVuZGVyYmx1c2g6XCIjRkZGMEY1XCIsbGF3bmdyZWVuOlwiIzdDRkMwMFwiLGxlbW9uY2hpZmZvbjpcIiNGRkZBQ0RcIixsaWdodGJsdWU6XCIjQUREOEU2XCIsbGlnaHRjb3JhbDpcIiNGMDgwODBcIixsaWdodGN5YW46XCIjRTBGRkZGXCIsbGlnaHRnb2xkZW5yb2R5ZWxsb3c6XCIjRkFGQUQyXCIsbGlnaHRncmVlbjpcIiM5MEVFOTBcIixsaWdodGdyZXk6XCIjRDNEM0QzXCIsbGlnaHRwaW5rOlwiI0ZGQjZDMVwiLGxpZ2h0c2FsbW9uOlwiI0ZGQTA3QVwiLGxpZ2h0c2VhZ3JlZW46XCIjMjBCMkFBXCIsbGlnaHRza3libHVlOlwiIzg3Q0VGQVwiLGxpZ2h0c2xhdGVncmF5OlwiIzc3ODg5OVwiLGxpZ2h0c2xhdGVncmV5OlwiIzc3ODg5OVwiLGxpZ2h0c3RlZWxibHVlOlwiI0IwQzRERVwiLGxpZ2h0eWVsbG93OlwiI0ZGRkZFMFwiLGxpbWVncmVlbjpcIiMzMkNEMzJcIixsaW5lbjpcIiNGQUYwRTZcIixtYWdlbnRhOlwiI0ZGMDBGRlwiLG1lZGl1bWFxdWFtYXJpbmU6XCIjNjZDREFBXCIsXHJcbm1lZGl1bWJsdWU6XCIjMDAwMENEXCIsbWVkaXVtb3JjaGlkOlwiI0JBNTVEM1wiLG1lZGl1bXB1cnBsZTpcIiM5MzcwREJcIixtZWRpdW1zZWFncmVlbjpcIiMzQ0IzNzFcIixtZWRpdW1zbGF0ZWJsdWU6XCIjN0I2OEVFXCIsbWVkaXVtc3ByaW5nZ3JlZW46XCIjMDBGQTlBXCIsbWVkaXVtdHVycXVvaXNlOlwiIzQ4RDFDQ1wiLG1lZGl1bXZpb2xldHJlZDpcIiNDNzE1ODVcIixtaWRuaWdodGJsdWU6XCIjMTkxOTcwXCIsbWludGNyZWFtOlwiI0Y1RkZGQVwiLG1pc3R5cm9zZTpcIiNGRkU0RTFcIixtb2NjYXNpbjpcIiNGRkU0QjVcIixuYXZham93aGl0ZTpcIiNGRkRFQURcIixvbGRsYWNlOlwiI0ZERjVFNlwiLG9saXZlZHJhYjpcIiM2QjhFMjNcIixvcmFuZ2U6XCIjRkZBNTAwXCIsb3JhbmdlcmVkOlwiI0ZGNDUwMFwiLG9yY2hpZDpcIiNEQTcwRDZcIixwYWxlZ29sZGVucm9kOlwiI0VFRThBQVwiLHBhbGVncmVlbjpcIiM5OEZCOThcIixwYWxldHVycXVvaXNlOlwiI0FGRUVFRVwiLHBhbGV2aW9sZXRyZWQ6XCIjREI3MDkzXCIscGFwYXlhd2hpcDpcIiNGRkVGRDVcIixcclxucGVhY2hwdWZmOlwiI0ZGREFCOVwiLHBlcnU6XCIjQ0Q4NTNGXCIscGluazpcIiNGRkMwQ0JcIixwbHVtOlwiI0REQTBERFwiLHBvd2RlcmJsdWU6XCIjQjBFMEU2XCIscm9zeWJyb3duOlwiI0JDOEY4RlwiLHJveWFsYmx1ZTpcIiM0MTY5RTFcIixzYWRkbGVicm93bjpcIiM4QjQ1MTNcIixzYWxtb246XCIjRkE4MDcyXCIsc2FuZHlicm93bjpcIiNGNEE0NjBcIixzZWFncmVlbjpcIiMyRThCNTdcIixzZWFzaGVsbDpcIiNGRkY1RUVcIixzaWVubmE6XCIjQTA1MjJEXCIsc2t5Ymx1ZTpcIiM4N0NFRUJcIixzbGF0ZWJsdWU6XCIjNkE1QUNEXCIsc2xhdGVncmF5OlwiIzcwODA5MFwiLHNsYXRlZ3JleTpcIiM3MDgwOTBcIixzbm93OlwiI0ZGRkFGQVwiLHNwcmluZ2dyZWVuOlwiIzAwRkY3RlwiLHN0ZWVsYmx1ZTpcIiM0NjgyQjRcIix0YW46XCIjRDJCNDhDXCIsdGhpc3RsZTpcIiNEOEJGRDhcIix0b21hdG86XCIjRkY2MzQ3XCIsdHVycXVvaXNlOlwiIzQwRTBEMFwiLHZpb2xldDpcIiNFRTgyRUVcIix3aGVhdDpcIiNGNURFQjNcIix3aGl0ZXNtb2tlOlwiI0Y1RjVGNVwiLHllbGxvd2dyZWVuOlwiIzlBQ0QzMlwifSxcclxuSD17fSxMPXt9LCQ9e2J1dHQ6XCJmbGF0XCIscm91bmQ6XCJyb3VuZFwifSxkPUMucHJvdG90eXBlO2QuY2xlYXJSZWN0PWZ1bmN0aW9uKCl7dGhpcy50ZXh0TWVhc3VyZUVsXyYmKHRoaXMudGV4dE1lYXN1cmVFbF8ucmVtb3ZlTm9kZSghMCksdGhpcy50ZXh0TWVhc3VyZUVsXz1udWxsKTt0aGlzLmVsZW1lbnRfLmlubmVySFRNTD1cIlwifTtkLmJlZ2luUGF0aD1mdW5jdGlvbigpe3RoaXMuY3VycmVudFBhdGhfPVtdfTtkLm1vdmVUbz1mdW5jdGlvbihhLGIpe3ZhciBjPXModGhpcyxhLGIpO3RoaXMuY3VycmVudFBhdGhfLnB1c2goe3R5cGU6XCJtb3ZlVG9cIix4OmMueCx5OmMueX0pO3RoaXMuY3VycmVudFhfPWMueDt0aGlzLmN1cnJlbnRZXz1jLnl9O2QubGluZVRvPWZ1bmN0aW9uKGEsYil7dmFyIGM9cyh0aGlzLGEsYik7dGhpcy5jdXJyZW50UGF0aF8ucHVzaCh7dHlwZTpcImxpbmVUb1wiLHg6Yy54LHk6Yy55fSk7dGhpcy5jdXJyZW50WF89Yy54O3RoaXMuY3VycmVudFlfPWMueX07ZC5iZXppZXJDdXJ2ZVRvPVxyXG5mdW5jdGlvbihhLGIsYyxnLGUsZil7ZT1zKHRoaXMsZSxmKTthPXModGhpcyxhLGIpO2M9cyh0aGlzLGMsZyk7Uih0aGlzLGEsYyxlKX07ZC5xdWFkcmF0aWNDdXJ2ZVRvPWZ1bmN0aW9uKGEsYixjLGcpe2E9cyh0aGlzLGEsYik7Yz1zKHRoaXMsYyxnKTtnPXt4OnRoaXMuY3VycmVudFhfKzIvMyooYS54LXRoaXMuY3VycmVudFhfKSx5OnRoaXMuY3VycmVudFlfKzIvMyooYS55LXRoaXMuY3VycmVudFlfKX07Uih0aGlzLGcse3g6Zy54KyhjLngtdGhpcy5jdXJyZW50WF8pLzMseTpnLnkrKGMueS10aGlzLmN1cnJlbnRZXykvM30sYyl9O2QuYXJjPWZ1bmN0aW9uKGEsYixjLGcsZSxmKXtjKj1xO3ZhciBkPWY/XCJhdFwiOlwid2FcIixrPWErSyhnKSpjLXIsbj1iK0ooZykqYy1yO2c9YStLKGUpKmMtcjtlPWIrSihlKSpjLXI7ayE9Z3x8Znx8KGsrPTAuMTI1KTthPXModGhpcyxhLGIpO2s9cyh0aGlzLGssbik7Zz1zKHRoaXMsZyxlKTt0aGlzLmN1cnJlbnRQYXRoXy5wdXNoKHt0eXBlOmQsXHJcbng6YS54LHk6YS55LHJhZGl1czpjLHhTdGFydDprLngseVN0YXJ0OmsueSx4RW5kOmcueCx5RW5kOmcueX0pfTtkLnJlY3Q9ZnVuY3Rpb24oYSxiLGMsZyl7dGhpcy5tb3ZlVG8oYSxiKTt0aGlzLmxpbmVUbyhhK2MsYik7dGhpcy5saW5lVG8oYStjLGIrZyk7dGhpcy5saW5lVG8oYSxiK2cpO3RoaXMuY2xvc2VQYXRoKCl9O2Quc3Ryb2tlUmVjdD1mdW5jdGlvbihhLGIsYyxnKXt2YXIgZT10aGlzLmN1cnJlbnRQYXRoXzt0aGlzLmJlZ2luUGF0aCgpO3RoaXMubW92ZVRvKGEsYik7dGhpcy5saW5lVG8oYStjLGIpO3RoaXMubGluZVRvKGErYyxiK2cpO3RoaXMubGluZVRvKGEsYitnKTt0aGlzLmNsb3NlUGF0aCgpO3RoaXMuc3Ryb2tlKCk7dGhpcy5jdXJyZW50UGF0aF89ZX07ZC5maWxsUmVjdD1mdW5jdGlvbihhLGIsYyxnKXt2YXIgZT10aGlzLmN1cnJlbnRQYXRoXzt0aGlzLmJlZ2luUGF0aCgpO3RoaXMubW92ZVRvKGEsYik7dGhpcy5saW5lVG8oYStjLGIpO3RoaXMubGluZVRvKGErXHJcbmMsYitnKTt0aGlzLmxpbmVUbyhhLGIrZyk7dGhpcy5jbG9zZVBhdGgoKTt0aGlzLmZpbGwoKTt0aGlzLmN1cnJlbnRQYXRoXz1lfTtkLmNyZWF0ZUxpbmVhckdyYWRpZW50PWZ1bmN0aW9uKGEsYixjLGcpe3ZhciBlPW5ldyB3KFwiZ3JhZGllbnRcIik7ZS54MF89YTtlLnkwXz1iO2UueDFfPWM7ZS55MV89ZztyZXR1cm4gZX07ZC5jcmVhdGVSYWRpYWxHcmFkaWVudD1mdW5jdGlvbihhLGIsYyxnLGUsZil7dmFyIGQ9bmV3IHcoXCJncmFkaWVudHJhZGlhbFwiKTtkLngwXz1hO2QueTBfPWI7ZC5yMF89YztkLngxXz1nO2QueTFfPWU7ZC5yMV89ZjtyZXR1cm4gZH07ZC5kcmF3SW1hZ2U9ZnVuY3Rpb24oYSxiKXt2YXIgYyxnLGUsZCxyLHksbixoO2U9YS5ydW50aW1lU3R5bGUud2lkdGg7ZD1hLnJ1bnRpbWVTdHlsZS5oZWlnaHQ7YS5ydW50aW1lU3R5bGUud2lkdGg9XCJhdXRvXCI7YS5ydW50aW1lU3R5bGUuaGVpZ2h0PVwiYXV0b1wiO3ZhciBsPWEud2lkdGgsdT1hLmhlaWdodDthLnJ1bnRpbWVTdHlsZS53aWR0aD1cclxuZTthLnJ1bnRpbWVTdHlsZS5oZWlnaHQ9ZDtpZigzPT1hcmd1bWVudHMubGVuZ3RoKWM9YXJndW1lbnRzWzFdLGc9YXJndW1lbnRzWzJdLHI9eT0wLG49ZT1sLGg9ZD11O2Vsc2UgaWYoNT09YXJndW1lbnRzLmxlbmd0aCljPWFyZ3VtZW50c1sxXSxnPWFyZ3VtZW50c1syXSxlPWFyZ3VtZW50c1szXSxkPWFyZ3VtZW50c1s0XSxyPXk9MCxuPWwsaD11O2Vsc2UgaWYoOT09YXJndW1lbnRzLmxlbmd0aClyPWFyZ3VtZW50c1sxXSx5PWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1szXSxoPWFyZ3VtZW50c1s0XSxjPWFyZ3VtZW50c1s1XSxnPWFyZ3VtZW50c1s2XSxlPWFyZ3VtZW50c1s3XSxkPWFyZ3VtZW50c1s4XTtlbHNlIHRocm93IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzXCIpO3ZhciBtPXModGhpcyxjLGcpLHA9W107cC5wdXNoKFwiIDxnX3ZtbF86Z3JvdXBcIiwnIGNvb3Jkc2l6ZT1cIicsMTAqcSxcIixcIiwxMCpxLCdcIicsJyBjb29yZG9yaWdpbj1cIjAsMFwiJywnIHN0eWxlPVwid2lkdGg6JyxcclxuMTAsXCJweDtoZWlnaHQ6XCIsMTAsXCJweDtwb3NpdGlvbjphYnNvbHV0ZTtcIik7aWYoMSE9dGhpcy5tX1swXVswXXx8dGhpcy5tX1swXVsxXXx8MSE9dGhpcy5tX1sxXVsxXXx8dGhpcy5tX1sxXVswXSl7dmFyIHQ9W107dC5wdXNoKFwiTTExPVwiLHRoaXMubV9bMF1bMF0sXCIsXCIsXCJNMTI9XCIsdGhpcy5tX1sxXVswXSxcIixcIixcIk0yMT1cIix0aGlzLm1fWzBdWzFdLFwiLFwiLFwiTTIyPVwiLHRoaXMubV9bMV1bMV0sXCIsXCIsXCJEeD1cIixrKG0ueC9xKSxcIixcIixcIkR5PVwiLGsobS55L3EpLFwiXCIpO3ZhciB2PXModGhpcyxjK2UsZyksdz1zKHRoaXMsYyxnK2QpO2M9cyh0aGlzLGMrZSxnK2QpO20ueD14Lm1heChtLngsdi54LHcueCxjLngpO20ueT14Lm1heChtLnksdi55LHcueSxjLnkpO3AucHVzaChcInBhZGRpbmc6MCBcIixrKG0ueC9xKSxcInB4IFwiLGsobS55L3EpLFwicHggMDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChcIix0LmpvaW4oXCJcIiksXCIsIHNpemluZ21ldGhvZD0nY2xpcCcpO1wiKX1lbHNlIHAucHVzaChcInRvcDpcIixcclxuayhtLnkvcSksXCJweDtsZWZ0OlwiLGsobS54L3EpLFwicHg7XCIpO3AucHVzaCgnIFwiPicsJzxnX3ZtbF86aW1hZ2Ugc3JjPVwiJyxhLnNyYywnXCInLCcgc3R5bGU9XCJ3aWR0aDonLHEqZSxcInB4O1wiLFwiIGhlaWdodDpcIixxKmQsJ3B4XCInLCcgY3JvcGxlZnQ9XCInLHIvbCwnXCInLCcgY3JvcHRvcD1cIicseS91LCdcIicsJyBjcm9wcmlnaHQ9XCInLChsLXItbikvbCwnXCInLCcgY3JvcGJvdHRvbT1cIicsKHUteS1oKS91LCdcIicsXCIgLz5cIixcIjwvZ192bWxfOmdyb3VwPlwiKTt0aGlzLmVsZW1lbnRfLmluc2VydEFkamFjZW50SFRNTChcIkJlZm9yZUVuZFwiLHAuam9pbihcIlwiKSl9O2Quc3Ryb2tlPWZ1bmN0aW9uKGEpe3ZhciBiPVtdO2IucHVzaChcIjxnX3ZtbF86c2hhcGVcIiwnIGZpbGxlZD1cIicsISFhLCdcIicsJyBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3dpZHRoOicsMTAsXCJweDtoZWlnaHQ6XCIsMTAsJ3B4O1wiJywnIGNvb3Jkb3JpZ2luPVwiMCwwXCInLCcgY29vcmRzaXplPVwiJywxMCpxLFwiLFwiLDEwKnEsJ1wiJyxcclxuJyBzdHJva2VkPVwiJywhYSwnXCInLCcgcGF0aD1cIicpO2Zvcih2YXIgYz17eDpudWxsLHk6bnVsbH0sZD17eDpudWxsLHk6bnVsbH0sZT0wO2U8dGhpcy5jdXJyZW50UGF0aF8ubGVuZ3RoO2UrKyl7dmFyIGY9dGhpcy5jdXJyZW50UGF0aF9bZV07c3dpdGNoKGYudHlwZSl7Y2FzZSBcIm1vdmVUb1wiOmIucHVzaChcIiBtIFwiLGsoZi54KSxcIixcIixrKGYueSkpO2JyZWFrO2Nhc2UgXCJsaW5lVG9cIjpiLnB1c2goXCIgbCBcIixrKGYueCksXCIsXCIsayhmLnkpKTticmVhaztjYXNlIFwiY2xvc2VcIjpiLnB1c2goXCIgeCBcIik7Zj1udWxsO2JyZWFrO2Nhc2UgXCJiZXppZXJDdXJ2ZVRvXCI6Yi5wdXNoKFwiIGMgXCIsayhmLmNwMXgpLFwiLFwiLGsoZi5jcDF5KSxcIixcIixrKGYuY3AyeCksXCIsXCIsayhmLmNwMnkpLFwiLFwiLGsoZi54KSxcIixcIixrKGYueSkpO2JyZWFrO2Nhc2UgXCJhdFwiOmNhc2UgXCJ3YVwiOmIucHVzaChcIiBcIixmLnR5cGUsXCIgXCIsayhmLngtdGhpcy5hcmNTY2FsZVhfKmYucmFkaXVzKSxcIixcIixrKGYueS10aGlzLmFyY1NjYWxlWV8qXHJcbmYucmFkaXVzKSxcIiBcIixrKGYueCt0aGlzLmFyY1NjYWxlWF8qZi5yYWRpdXMpLFwiLFwiLGsoZi55K3RoaXMuYXJjU2NhbGVZXypmLnJhZGl1cyksXCIgXCIsayhmLnhTdGFydCksXCIsXCIsayhmLnlTdGFydCksXCIgXCIsayhmLnhFbmQpLFwiLFwiLGsoZi55RW5kKSl9aWYoZil7aWYobnVsbD09Yy54fHxmLng8Yy54KWMueD1mLng7aWYobnVsbD09ZC54fHxmLng+ZC54KWQueD1mLng7aWYobnVsbD09Yy55fHxmLnk8Yy55KWMueT1mLnk7aWYobnVsbD09ZC55fHxmLnk+ZC55KWQueT1mLnl9fWIucHVzaCgnIFwiPicpO2E/VCh0aGlzLGIsYyxkKTpTKHRoaXMsYik7Yi5wdXNoKFwiPC9nX3ZtbF86c2hhcGU+XCIpO3RoaXMuZWxlbWVudF8uaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlRW5kXCIsYi5qb2luKFwiXCIpKX07ZC5maWxsPWZ1bmN0aW9uKCl7dGhpcy5zdHJva2UoITApfTtkLmNsb3NlUGF0aD1mdW5jdGlvbigpe3RoaXMuY3VycmVudFBhdGhfLnB1c2goe3R5cGU6XCJjbG9zZVwifSl9O2Quc2F2ZT1mdW5jdGlvbigpe3ZhciBhPVxyXG57fTtQKHRoaXMsYSk7dGhpcy5hU3RhY2tfLnB1c2goYSk7dGhpcy5tU3RhY2tfLnB1c2godGhpcy5tXyk7dGhpcy5tXz10KEQoKSx0aGlzLm1fKX07ZC5yZXN0b3JlPWZ1bmN0aW9uKCl7dGhpcy5hU3RhY2tfLmxlbmd0aCYmKFAodGhpcy5hU3RhY2tfLnBvcCgpLHRoaXMpLHRoaXMubV89dGhpcy5tU3RhY2tfLnBvcCgpKX07ZC50cmFuc2xhdGU9ZnVuY3Rpb24oYSxiKXt6KHRoaXMsdChbWzEsMCwwXSxbMCwxLDBdLFthLGIsMV1dLHRoaXMubV8pLCExKX07ZC5yb3RhdGU9ZnVuY3Rpb24oYSl7dmFyIGI9SyhhKTthPUooYSk7eih0aGlzLHQoW1tiLGEsMF0sWy1hLGIsMF0sWzAsMCwxXV0sdGhpcy5tXyksITEpfTtkLnNjYWxlPWZ1bmN0aW9uKGEsYil7dGhpcy5hcmNTY2FsZVhfKj1hO3RoaXMuYXJjU2NhbGVZXyo9Yjt6KHRoaXMsdChbW2EsMCwwXSxbMCxiLDBdLFswLDAsMV1dLHRoaXMubV8pLCEwKX07ZC50cmFuc2Zvcm09ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3oodGhpcyx0KFtbYSxcclxuYiwwXSxbYyxkLDBdLFtlLGYsMV1dLHRoaXMubV8pLCEwKX07ZC5zZXRUcmFuc2Zvcm09ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3oodGhpcyxbW2EsYiwwXSxbYyxkLDBdLFtlLGYsMV1dLCEwKX07ZC5kcmF3VGV4dF89ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzLm1fO2Q9MDt2YXIgcj0xRTMsdD0wLG49W10saDtoPXRoaXMuZm9udDtpZihMW2hdKWg9TFtoXTtlbHNle3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGU7dHJ5e2wuZm9udD1ofWNhdGNoKHUpe31oPUxbaF09e3N0eWxlOmwuZm9udFN0eWxlfHxcIm5vcm1hbFwiLHZhcmlhbnQ6bC5mb250VmFyaWFudHx8XCJub3JtYWxcIix3ZWlnaHQ6bC5mb250V2VpZ2h0fHxcIm5vcm1hbFwiLHNpemU6bC5mb250U2l6ZXx8MTAsZmFtaWx5OmwuZm9udEZhbWlseXx8XCJzYW5zLXNlcmlmXCJ9fXZhciBsPWgsbT10aGlzLmVsZW1lbnRfO2g9e307Zm9yKHZhciBwIGluIGwpaFtwXT1sW3BdO3A9cGFyc2VGbG9hdChtLmN1cnJlbnRTdHlsZS5mb250U2l6ZSk7XHJcbm09cGFyc2VGbG9hdChsLnNpemUpO1wibnVtYmVyXCI9PXR5cGVvZiBsLnNpemU/aC5zaXplPWwuc2l6ZTotMSE9bC5zaXplLmluZGV4T2YoXCJweFwiKT9oLnNpemU9bTotMSE9bC5zaXplLmluZGV4T2YoXCJlbVwiKT9oLnNpemU9cCptOi0xIT1sLnNpemUuaW5kZXhPZihcIiVcIik/aC5zaXplPXAvMTAwKm06LTEhPWwuc2l6ZS5pbmRleE9mKFwicHRcIik/aC5zaXplPW0vMC43NTpoLnNpemU9cDtoLnNpemUqPTAuOTgxO3A9aC5zdHlsZStcIiBcIitoLnZhcmlhbnQrXCIgXCIraC53ZWlnaHQrXCIgXCIraC5zaXplK1wicHggXCIraC5mYW1pbHk7bT10aGlzLmVsZW1lbnRfLmN1cnJlbnRTdHlsZTtsPXRoaXMudGV4dEFsaWduLnRvTG93ZXJDYXNlKCk7c3dpdGNoKGwpe2Nhc2UgXCJsZWZ0XCI6Y2FzZSBcImNlbnRlclwiOmNhc2UgXCJyaWdodFwiOmJyZWFrO2Nhc2UgXCJlbmRcIjpsPVwibHRyXCI9PW0uZGlyZWN0aW9uP1wicmlnaHRcIjpcImxlZnRcIjticmVhaztjYXNlIFwic3RhcnRcIjpsPVwicnRsXCI9PW0uZGlyZWN0aW9uP1wicmlnaHRcIjpcclxuXCJsZWZ0XCI7YnJlYWs7ZGVmYXVsdDpsPVwibGVmdFwifXN3aXRjaCh0aGlzLnRleHRCYXNlbGluZSl7Y2FzZSBcImhhbmdpbmdcIjpjYXNlIFwidG9wXCI6dD1oLnNpemUvMS43NTticmVhaztjYXNlIFwibWlkZGxlXCI6YnJlYWs7ZGVmYXVsdDpjYXNlIG51bGw6Y2FzZSBcImFscGhhYmV0aWNcIjpjYXNlIFwiaWRlb2dyYXBoaWNcIjpjYXNlIFwiYm90dG9tXCI6dD0taC5zaXplLzIuMjV9c3dpdGNoKGwpe2Nhc2UgXCJyaWdodFwiOmQ9MUUzO3I9MC4wNTticmVhaztjYXNlIFwiY2VudGVyXCI6ZD1yPTUwMH1iPXModGhpcyxiKzAsYyt0KTtuLnB1c2goJzxnX3ZtbF86bGluZSBmcm9tPVwiJywtZCwnIDBcIiB0bz1cIicsciwnIDAuMDVcIiAnLCcgY29vcmRzaXplPVwiMTAwIDEwMFwiIGNvb3Jkb3JpZ2luPVwiMCAwXCInLCcgZmlsbGVkPVwiJywhZSwnXCIgc3Ryb2tlZD1cIicsISFlLCdcIiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3dpZHRoOjFweDtoZWlnaHQ6MXB4O1wiPicpO2U/Uyh0aGlzLG4pOlQodGhpcyxuLHt4Oi1kLHk6MH0sXHJcbnt4OnIseTpoLnNpemV9KTtlPWZbMF1bMF0udG9GaXhlZCgzKStcIixcIitmWzFdWzBdLnRvRml4ZWQoMykrXCIsXCIrZlswXVsxXS50b0ZpeGVkKDMpK1wiLFwiK2ZbMV1bMV0udG9GaXhlZCgzKStcIiwwLDBcIjtiPWsoYi54L3EpK1wiLFwiK2soYi55L3EpO24ucHVzaCgnPGdfdm1sXzpza2V3IG9uPVwidFwiIG1hdHJpeD1cIicsZSwnXCIgJywnIG9mZnNldD1cIicsYiwnXCIgb3JpZ2luPVwiJyxkLCcgMFwiIC8+JywnPGdfdm1sXzpwYXRoIHRleHRwYXRob2s9XCJ0cnVlXCIgLz4nLCc8Z192bWxfOnRleHRwYXRoIG9uPVwidHJ1ZVwiIHN0cmluZz1cIicsTihhKSwnXCIgc3R5bGU9XCJ2LXRleHQtYWxpZ246JyxsLFwiO2ZvbnQ6XCIsTihwKSwnXCIgLz48L2dfdm1sXzpsaW5lPicpO3RoaXMuZWxlbWVudF8uaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlRW5kXCIsbi5qb2luKFwiXCIpKX07ZC5maWxsVGV4dD1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLmRyYXdUZXh0XyhhLGIsYyxkLCExKX07ZC5zdHJva2VUZXh0PWZ1bmN0aW9uKGEsXHJcbmIsYyxkKXt0aGlzLmRyYXdUZXh0XyhhLGIsYyxkLCEwKX07ZC5tZWFzdXJlVGV4dD1mdW5jdGlvbihhKXt0aGlzLnRleHRNZWFzdXJlRWxffHwodGhpcy5lbGVtZW50Xy5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVFbmRcIiwnPHNwYW4gc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTIwMDAwcHg7bGVmdDowO3BhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6bm9uZTt3aGl0ZS1zcGFjZTpwcmU7XCI+PC9zcGFuPicpLHRoaXMudGV4dE1lYXN1cmVFbF89dGhpcy5lbGVtZW50Xy5sYXN0Q2hpbGQpO3ZhciBiPXRoaXMuZWxlbWVudF8ub3duZXJEb2N1bWVudDt0aGlzLnRleHRNZWFzdXJlRWxfLmlubmVySFRNTD1cIlwiO3RoaXMudGV4dE1lYXN1cmVFbF8uc3R5bGUuZm9udD10aGlzLmZvbnQ7dGhpcy50ZXh0TWVhc3VyZUVsXy5hcHBlbmRDaGlsZChiLmNyZWF0ZVRleHROb2RlKGEpKTtyZXR1cm57d2lkdGg6dGhpcy50ZXh0TWVhc3VyZUVsXy5vZmZzZXRXaWR0aH19O2QuY2xpcD1mdW5jdGlvbigpe307XHJcbmQuYXJjVG89ZnVuY3Rpb24oKXt9O2QuY3JlYXRlUGF0dGVybj1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgSShhLGIpfTt3LnByb3RvdHlwZS5hZGRDb2xvclN0b3A9ZnVuY3Rpb24oYSxiKXtiPUcoYik7dGhpcy5jb2xvcnNfLnB1c2goe29mZnNldDphLGNvbG9yOmIuY29sb3IsYWxwaGE6Yi5hbHBoYX0pfTtkPUEucHJvdG90eXBlPUVycm9yKCk7ZC5JTkRFWF9TSVpFX0VSUj0xO2QuRE9NU1RSSU5HX1NJWkVfRVJSPTI7ZC5ISUVSQVJDSFlfUkVRVUVTVF9FUlI9MztkLldST05HX0RPQ1VNRU5UX0VSUj00O2QuSU5WQUxJRF9DSEFSQUNURVJfRVJSPTU7ZC5OT19EQVRBX0FMTE9XRURfRVJSPTY7ZC5OT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlI9NztkLk5PVF9GT1VORF9FUlI9ODtkLk5PVF9TVVBQT1JURURfRVJSPTk7ZC5JTlVTRV9BVFRSSUJVVEVfRVJSPTEwO2QuSU5WQUxJRF9TVEFURV9FUlI9MTE7ZC5TWU5UQVhfRVJSPTEyO2QuSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSPVxyXG4xMztkLk5BTUVTUEFDRV9FUlI9MTQ7ZC5JTlZBTElEX0FDQ0VTU19FUlI9MTU7ZC5WQUxJREFUSU9OX0VSUj0xNjtkLlRZUEVfTUlTTUFUQ0hfRVJSPTE3O0dfdm1sQ2FudmFzTWFuYWdlcj1VO0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRD1DO0NhbnZhc0dyYWRpZW50PXc7Q2FudmFzUGF0dGVybj1JO0RPTUV4Y2VwdGlvbj1BfSgpO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NsaWVudC9hcHAvQ2FudmFzSlMuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7QUFTQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBQUE7QUFBQTtBQUFBO0FBZ0JBO0FBaEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFnQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFKQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBREE7QUFDQTtBQVJBO0FBUUE7QUFBQTtBQUNBO0FBVEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVNBO0FBQUE7QUFBQTtBQUFBO0FBVEE7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFMQTtBQUtBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBUkE7QUFRQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBSkE7QUFLQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBRUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBTEE7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBSEE7QUFHQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQUE7QUFKQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUhBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBRkE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUhBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFIQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRkE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSEE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRkE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBSEE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFIQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBSEE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUZBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBSkE7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVJBO0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUdBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBRkE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFKQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFIQTtBQUdBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUpBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUZBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBRkE7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBS0E7QUFBQTtBQUNBO0FBVEE7QUFZQTtBQWJBO0FBYUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWRBO0FBZ0JBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQVRBO0FBU0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBRUE7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFXQTtBQVhBO0FBV0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRkE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRkE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBRkE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBT0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFGQTtBQWNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRkE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBREE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBTEE7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQU9BO0FBQUE7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRkE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }

/******/ });